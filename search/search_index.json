{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"api/Classes/","text":"Classes class BufferUtil class Camera class CommandBuffer struct DebugUtil class DrawOp class Fence struct VertexFormatInfo namespace glm namespace ngfx class BaseApplication class Buffer class Camera class CommandBuffer class ComputeApplication class ComputeOp class ComputePass class ComputePipeline class ComputeShaderModule class Device class DrawColorOp class DrawMeshOp struct LightData struct UBO_FS_Data struct UBO_VS_Data class DrawOp class DrawTextureOp class FPSCounter class Fence class File class FileUtil struct Lock class FilterOp class FragmentShaderModule class Framebuffer struct Attachment class Graphics class GraphicsContext struct AttachmentDescription struct RenderPassConfig class GraphicsPipeline struct Descriptor struct State class InputListener class MatrixMultiplyCPUOp class MatrixMultiplyGPUOp struct UboData class MatrixMultiplyOp struct MatrixParam struct MeshData struct MeshUtil class Pipeline class PipelineCache class ProcessUtil class Queue struct Rect2D class RegexUtil struct Match class RenderPass class Semaphore class ShaderModule struct BufferInfo struct BufferMemberInfo struct DescriptorInfo class ShaderTools struct HLSLReflectData struct MacroDefinition struct MetalReflectData class StringUtil class Surface class Swapchain class Texture class Timer class Util class VertexShaderModule struct AttributeDescription class Window namespace std namespace std::chrono namespace std::placeholders Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Classes"},{"location":"api/Classes/#classes","text":"class BufferUtil class Camera class CommandBuffer struct DebugUtil class DrawOp class Fence struct VertexFormatInfo namespace glm namespace ngfx class BaseApplication class Buffer class Camera class CommandBuffer class ComputeApplication class ComputeOp class ComputePass class ComputePipeline class ComputeShaderModule class Device class DrawColorOp class DrawMeshOp struct LightData struct UBO_FS_Data struct UBO_VS_Data class DrawOp class DrawTextureOp class FPSCounter class Fence class File class FileUtil struct Lock class FilterOp class FragmentShaderModule class Framebuffer struct Attachment class Graphics class GraphicsContext struct AttachmentDescription struct RenderPassConfig class GraphicsPipeline struct Descriptor struct State class InputListener class MatrixMultiplyCPUOp class MatrixMultiplyGPUOp struct UboData class MatrixMultiplyOp struct MatrixParam struct MeshData struct MeshUtil class Pipeline class PipelineCache class ProcessUtil class Queue struct Rect2D class RegexUtil struct Match class RenderPass class Semaphore class ShaderModule struct BufferInfo struct BufferMemberInfo struct DescriptorInfo class ShaderTools struct HLSLReflectData struct MacroDefinition struct MetalReflectData class StringUtil class Surface class Swapchain class Texture class Timer class Util class VertexShaderModule struct AttributeDescription class Window namespace std namespace std::chrono namespace std::placeholders Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Classes"},{"location":"api/Classes/classBufferUtil/","text":"BufferUtil More... #include <BufferUtil.h> Detailed Description class BufferUtil; This utility module provides helper functions for creating various types of specialized GPU buffers Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"BufferUtil"},{"location":"api/Classes/classBufferUtil/#bufferutil","text":"More... #include <BufferUtil.h>","title":"BufferUtil"},{"location":"api/Classes/classBufferUtil/#detailed-description","text":"class BufferUtil; This utility module provides helper functions for creating various types of specialized GPU buffers Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"Detailed Description"},{"location":"api/Classes/classCamera/","text":"Camera More... #include <Camera.h> Detailed Description class Camera; This class supports 2D and 3D camera operations. It supports, panning, zooming, and rotation. It also supports user input via keyboard, mouse, and touch events. Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"Camera"},{"location":"api/Classes/classCamera/#camera","text":"More... #include <Camera.h>","title":"Camera"},{"location":"api/Classes/classCamera/#detailed-description","text":"class Camera; This class supports 2D and 3D camera operations. It supports, panning, zooming, and rotation. It also supports user input via keyboard, mouse, and touch events. Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"Detailed Description"},{"location":"api/Classes/classCommandBuffer/","text":"CommandBuffer More... #include <CommandBuffer.h> Detailed Description class CommandBuffer; This class supports GPU command buffer operations, including recording draw commands and submitting them to the GPU. It supports primary and secondary command buffers. Secondary command buffers can be recorded in parallel, using multiple threads, and can be added to a primary command buffer. Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"CommandBuffer"},{"location":"api/Classes/classCommandBuffer/#commandbuffer","text":"More... #include <CommandBuffer.h>","title":"CommandBuffer"},{"location":"api/Classes/classCommandBuffer/#detailed-description","text":"class CommandBuffer; This class supports GPU command buffer operations, including recording draw commands and submitting them to the GPU. It supports primary and secondary command buffers. Secondary command buffers can be recorded in parallel, using multiple threads, and can be added to a primary command buffer. Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"Detailed Description"},{"location":"api/Classes/classDrawOp/","text":"DrawOp More... #include <DrawOp.h> Detailed Description class DrawOp; This class defines the interface for draw operations. Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"DrawOp"},{"location":"api/Classes/classDrawOp/#drawop","text":"More... #include <DrawOp.h>","title":"DrawOp"},{"location":"api/Classes/classDrawOp/#detailed-description","text":"class DrawOp; This class defines the interface for draw operations. Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"Detailed Description"},{"location":"api/Classes/classFence/","text":"Fence More... #include <Fence.h> Detailed Description class Fence; This class implements a fence synchronization mechanism. The CPU waits for the fence to be signaled by the GPU when an operation is completed. Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"Fence"},{"location":"api/Classes/classFence/#fence","text":"More... #include <Fence.h>","title":"Fence"},{"location":"api/Classes/classFence/#detailed-description","text":"class Fence; This class implements a fence synchronization mechanism. The CPU waits for the fence to be signaled by the GPU when an operation is completed. Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"Detailed Description"},{"location":"api/Classes/classngfx_1_1BaseApplication/","text":"ngfx::BaseApplication Inherits from ngfx::InputListener Public Functions Name BaseApplication (const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false) virtual ~BaseApplication () virtual void init () virtual void createWindow () virtual void paint () virtual void recordCommandBuffers () virtual void close () virtual void onInit () virtual void onRecordCommandBuffer ( CommandBuffer * commandBuffer) =0 virtual void onUpdate () virtual void onPaint () virtual void run () virtual void drawFrame () Public Attributes Name std::unique_ptr< Graphics > graphics std::unique_ptr< Window > window std::unique_ptr< GraphicsContext > graphicsContext std::string appName int w int h bool enableDepthStencil bool offscreen bool persistentCommandBuffers Protected Attributes Name bool initOnce std::unique_ptr< ngfx::Texture > outputTexture std::unique_ptr< ngfx::Texture > depthTexture std::unique_ptr< Framebuffer > outputFramebuffer Additional inherited members Public Functions inherited from ngfx::InputListener Name virtual void onKey (KeyCode code, InputAction action) virtual void onScroll (double xoffset, double yoffset) virtual void onCursorPos (double x, double y) virtual void onMouseButton (MouseButton button, InputAction action) Public Functions Documentation function BaseApplication BaseApplication( const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false ) function ~BaseApplication inline virtual ~BaseApplication() function init virtual void init() function createWindow virtual void createWindow() function paint virtual void paint() function recordCommandBuffers virtual void recordCommandBuffers() function close virtual void close() function onInit inline virtual void onInit() function onRecordCommandBuffer virtual void onRecordCommandBuffer( CommandBuffer * commandBuffer ) =0 function onUpdate inline virtual void onUpdate() function onPaint virtual void onPaint() function run virtual void run() function drawFrame virtual void drawFrame() Public Attributes Documentation variable graphics std::unique_ptr< Graphics > graphics; variable window std::unique_ptr< Window > window; variable graphicsContext std::unique_ptr< GraphicsContext > graphicsContext; variable appName std::string appName; variable w int w; variable h int h; variable enableDepthStencil bool enableDepthStencil = false; variable offscreen bool offscreen = false; variable persistentCommandBuffers bool persistentCommandBuffers = true; Protected Attributes Documentation variable initOnce bool initOnce = true; variable outputTexture std::unique_ptr< ngfx::Texture > outputTexture; variable depthTexture std::unique_ptr< ngfx::Texture > depthTexture; variable outputFramebuffer std::unique_ptr< Framebuffer > outputFramebuffer; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::BaseApplication"},{"location":"api/Classes/classngfx_1_1BaseApplication/#ngfxbaseapplication","text":"Inherits from ngfx::InputListener","title":"ngfx::BaseApplication"},{"location":"api/Classes/classngfx_1_1BaseApplication/#public-functions","text":"Name BaseApplication (const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false) virtual ~BaseApplication () virtual void init () virtual void createWindow () virtual void paint () virtual void recordCommandBuffers () virtual void close () virtual void onInit () virtual void onRecordCommandBuffer ( CommandBuffer * commandBuffer) =0 virtual void onUpdate () virtual void onPaint () virtual void run () virtual void drawFrame ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1BaseApplication/#public-attributes","text":"Name std::unique_ptr< Graphics > graphics std::unique_ptr< Window > window std::unique_ptr< GraphicsContext > graphicsContext std::string appName int w int h bool enableDepthStencil bool offscreen bool persistentCommandBuffers","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1BaseApplication/#protected-attributes","text":"Name bool initOnce std::unique_ptr< ngfx::Texture > outputTexture std::unique_ptr< ngfx::Texture > depthTexture std::unique_ptr< Framebuffer > outputFramebuffer","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1BaseApplication/#additional-inherited-members","text":"Public Functions inherited from ngfx::InputListener Name virtual void onKey (KeyCode code, InputAction action) virtual void onScroll (double xoffset, double yoffset) virtual void onCursorPos (double x, double y) virtual void onMouseButton (MouseButton button, InputAction action)","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1BaseApplication/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-baseapplication","text":"BaseApplication( const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false )","title":"function BaseApplication"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-baseapplication_1","text":"inline virtual ~BaseApplication()","title":"function ~BaseApplication"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-init","text":"virtual void init()","title":"function init"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-createwindow","text":"virtual void createWindow()","title":"function createWindow"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-paint","text":"virtual void paint()","title":"function paint"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-recordcommandbuffers","text":"virtual void recordCommandBuffers()","title":"function recordCommandBuffers"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-close","text":"virtual void close()","title":"function close"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-oninit","text":"inline virtual void onInit()","title":"function onInit"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-onrecordcommandbuffer","text":"virtual void onRecordCommandBuffer( CommandBuffer * commandBuffer ) =0","title":"function onRecordCommandBuffer"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-onupdate","text":"inline virtual void onUpdate()","title":"function onUpdate"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-onpaint","text":"virtual void onPaint()","title":"function onPaint"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-run","text":"virtual void run()","title":"function run"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-drawframe","text":"virtual void drawFrame()","title":"function drawFrame"},{"location":"api/Classes/classngfx_1_1BaseApplication/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-graphics","text":"std::unique_ptr< Graphics > graphics;","title":"variable graphics"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-window","text":"std::unique_ptr< Window > window;","title":"variable window"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-graphicscontext","text":"std::unique_ptr< GraphicsContext > graphicsContext;","title":"variable graphicsContext"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-appname","text":"std::string appName;","title":"variable appName"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-w","text":"int w;","title":"variable w"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-h","text":"int h;","title":"variable h"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-enabledepthstencil","text":"bool enableDepthStencil = false;","title":"variable enableDepthStencil"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-offscreen","text":"bool offscreen = false;","title":"variable offscreen"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-persistentcommandbuffers","text":"bool persistentCommandBuffers = true;","title":"variable persistentCommandBuffers"},{"location":"api/Classes/classngfx_1_1BaseApplication/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-initonce","text":"bool initOnce = true;","title":"variable initOnce"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-outputtexture","text":"std::unique_ptr< ngfx::Texture > outputTexture;","title":"variable outputTexture"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-depthtexture","text":"std::unique_ptr< ngfx::Texture > depthTexture;","title":"variable depthTexture"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-outputframebuffer","text":"std::unique_ptr< Framebuffer > outputFramebuffer; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable outputFramebuffer"},{"location":"api/Classes/classngfx_1_1Buffer/","text":"ngfx::Buffer More... #include <Buffer.h> Public Functions Name Buffer * create ( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags) template <typename T > Buffer * create ( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags) virtual ~Buffer () virtual void * map () =0 virtual void unmap () =0 virtual void upload (const void * data, uint32_t size, uint32_t offset =0) =0 virtual void download (void * data, uint32_t size, uint32_t offset =0) =0 Detailed Description class ngfx::Buffer; This class defines the interface for a graphics buffer. Each backend is responsible for implementing this interface via a subclass. The same buffer object can support multiple usage scenarios, including storing uniform data, vertex buffer data, index buffer data, etc. In addition, on shared memory architectures, it supports shared CPU/GPU access. Public Functions Documentation function create static Buffer * create( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) usageFlags The buffer usage flags Create a graphics buffer function create template <typename T > static inline Buffer * create( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags ) function ~Buffer inline virtual ~Buffer() Destroy the buffer function map virtual void * map() =0 Map the buffer contents for CPU read/write access function unmap virtual void unmap() =0 Unmap the buffer function upload virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Upload the CPU data to the GPU buffer function download virtual void download( void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Download the GPU data to CPU-accessible memory Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Buffer"},{"location":"api/Classes/classngfx_1_1Buffer/#ngfxbuffer","text":"More... #include <Buffer.h>","title":"ngfx::Buffer"},{"location":"api/Classes/classngfx_1_1Buffer/#public-functions","text":"Name Buffer * create ( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags) template <typename T > Buffer * create ( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags) virtual ~Buffer () virtual void * map () =0 virtual void unmap () =0 virtual void upload (const void * data, uint32_t size, uint32_t offset =0) =0 virtual void download (void * data, uint32_t size, uint32_t offset =0) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Buffer/#detailed-description","text":"class ngfx::Buffer; This class defines the interface for a graphics buffer. Each backend is responsible for implementing this interface via a subclass. The same buffer object can support multiple usage scenarios, including storing uniform data, vertex buffer data, index buffer data, etc. In addition, on shared memory architectures, it supports shared CPU/GPU access.","title":"Detailed Description"},{"location":"api/Classes/classngfx_1_1Buffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Buffer/#function-create","text":"static Buffer * create( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) usageFlags The buffer usage flags Create a graphics buffer","title":"function create"},{"location":"api/Classes/classngfx_1_1Buffer/#function-create_1","text":"template <typename T > static inline Buffer * create( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags )","title":"function create"},{"location":"api/Classes/classngfx_1_1Buffer/#function-buffer","text":"inline virtual ~Buffer() Destroy the buffer","title":"function ~Buffer"},{"location":"api/Classes/classngfx_1_1Buffer/#function-map","text":"virtual void * map() =0 Map the buffer contents for CPU read/write access","title":"function map"},{"location":"api/Classes/classngfx_1_1Buffer/#function-unmap","text":"virtual void unmap() =0 Unmap the buffer","title":"function unmap"},{"location":"api/Classes/classngfx_1_1Buffer/#function-upload","text":"virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Upload the CPU data to the GPU buffer","title":"function upload"},{"location":"api/Classes/classngfx_1_1Buffer/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Download the GPU data to CPU-accessible memory Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function download"},{"location":"api/Classes/classngfx_1_1Camera/","text":"ngfx::Camera Inherits from ngfx::InputListener Public Functions Name virtual ~Camera () virtual void onKey (KeyCode keyCode, InputAction keyAction) override virtual void onScroll (double xoffset, double yoffset) override virtual void onCursorPos (double x, double y) override virtual void onMouseButton (MouseButton button, InputAction action) override void update () Public Attributes Name float panX float panY float zoom float yaw float pitch float roll mat4 viewMat uint32_t state double x double y Public Functions Documentation function ~Camera inline virtual ~Camera() Destroy the camera function onKey virtual void onKey( KeyCode keyCode, InputAction keyAction ) override Parameters : keyCode The key code keyAction The key action Reimplements : ngfx::InputListener::onKey Handle key press input event function onScroll virtual void onScroll( double xoffset, double yoffset ) override Parameters : xoffset The relative x offset yoffset The relative y offset Reimplements : ngfx::InputListener::onScroll Handle scroll input event function onCursorPos virtual void onCursorPos( double x, double y ) override Parameters : x The relative x movement y The relative y movement Reimplements : ngfx::InputListener::onCursorPos Handle cursor move event function onMouseButton virtual void onMouseButton( MouseButton button, InputAction action ) override Parameters : button The mouse button action The mouse button event Reimplements : ngfx::InputListener::onMouseButton Handle mouse button event function update void update() Update camera parameters This function is called once per frame Public Attributes Documentation variable panX float panX = 0.0f; The camera pan along the x axis variable panY float panY = 0.0f; The camera pan along the y axis variable zoom float zoom = 0.0f; The camera zoom variable yaw float yaw = 0.0f; The camera yaw (radians) variable pitch float pitch = 0.0f; The camera pitch (radians) variable roll float roll = 0.0f; The camera roll (radians) The camera view matrix variable viewMat mat4 viewMat; variable state uint32_t state = 0; variable x double x = -1.0; variable y double y = -1.0; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Camera"},{"location":"api/Classes/classngfx_1_1Camera/#ngfxcamera","text":"Inherits from ngfx::InputListener","title":"ngfx::Camera"},{"location":"api/Classes/classngfx_1_1Camera/#public-functions","text":"Name virtual ~Camera () virtual void onKey (KeyCode keyCode, InputAction keyAction) override virtual void onScroll (double xoffset, double yoffset) override virtual void onCursorPos (double x, double y) override virtual void onMouseButton (MouseButton button, InputAction action) override void update ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Camera/#public-attributes","text":"Name float panX float panY float zoom float yaw float pitch float roll mat4 viewMat uint32_t state double x double y","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Camera/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Camera/#function-camera","text":"inline virtual ~Camera() Destroy the camera","title":"function ~Camera"},{"location":"api/Classes/classngfx_1_1Camera/#function-onkey","text":"virtual void onKey( KeyCode keyCode, InputAction keyAction ) override Parameters : keyCode The key code keyAction The key action Reimplements : ngfx::InputListener::onKey Handle key press input event","title":"function onKey"},{"location":"api/Classes/classngfx_1_1Camera/#function-onscroll","text":"virtual void onScroll( double xoffset, double yoffset ) override Parameters : xoffset The relative x offset yoffset The relative y offset Reimplements : ngfx::InputListener::onScroll Handle scroll input event","title":"function onScroll"},{"location":"api/Classes/classngfx_1_1Camera/#function-oncursorpos","text":"virtual void onCursorPos( double x, double y ) override Parameters : x The relative x movement y The relative y movement Reimplements : ngfx::InputListener::onCursorPos Handle cursor move event","title":"function onCursorPos"},{"location":"api/Classes/classngfx_1_1Camera/#function-onmousebutton","text":"virtual void onMouseButton( MouseButton button, InputAction action ) override Parameters : button The mouse button action The mouse button event Reimplements : ngfx::InputListener::onMouseButton Handle mouse button event","title":"function onMouseButton"},{"location":"api/Classes/classngfx_1_1Camera/#function-update","text":"void update() Update camera parameters This function is called once per frame","title":"function update"},{"location":"api/Classes/classngfx_1_1Camera/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Camera/#variable-panx","text":"float panX = 0.0f; The camera pan along the x axis","title":"variable panX"},{"location":"api/Classes/classngfx_1_1Camera/#variable-pany","text":"float panY = 0.0f; The camera pan along the y axis","title":"variable panY"},{"location":"api/Classes/classngfx_1_1Camera/#variable-zoom","text":"float zoom = 0.0f; The camera zoom","title":"variable zoom"},{"location":"api/Classes/classngfx_1_1Camera/#variable-yaw","text":"float yaw = 0.0f; The camera yaw (radians)","title":"variable yaw"},{"location":"api/Classes/classngfx_1_1Camera/#variable-pitch","text":"float pitch = 0.0f; The camera pitch (radians)","title":"variable pitch"},{"location":"api/Classes/classngfx_1_1Camera/#variable-roll","text":"float roll = 0.0f; The camera roll (radians) The camera view matrix","title":"variable roll"},{"location":"api/Classes/classngfx_1_1Camera/#variable-viewmat","text":"mat4 viewMat;","title":"variable viewMat"},{"location":"api/Classes/classngfx_1_1Camera/#variable-state","text":"uint32_t state = 0;","title":"variable state"},{"location":"api/Classes/classngfx_1_1Camera/#variable-x","text":"double x = -1.0;","title":"variable x"},{"location":"api/Classes/classngfx_1_1Camera/#variable-y","text":"double y = -1.0; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable y"},{"location":"api/Classes/classngfx_1_1CommandBuffer/","text":"ngfx::CommandBuffer Public Functions Name CommandBuffer * create ( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY) virtual ~CommandBuffer () virtual void begin () =0 virtual void end () =0 Public Functions Documentation function create static CommandBuffer * create( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY ) Parameters : ctx The graphics context level The command buffer level Create the command buffer function ~CommandBuffer inline virtual ~CommandBuffer() Destroy the command buffer function begin virtual void begin() =0 Begin recording function end virtual void end() =0 End recording Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::CommandBuffer"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#ngfxcommandbuffer","text":"","title":"ngfx::CommandBuffer"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#public-functions","text":"Name CommandBuffer * create ( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY) virtual ~CommandBuffer () virtual void begin () =0 virtual void end () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-create","text":"static CommandBuffer * create( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY ) Parameters : ctx The graphics context level The command buffer level Create the command buffer","title":"function create"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-commandbuffer","text":"inline virtual ~CommandBuffer() Destroy the command buffer","title":"function ~CommandBuffer"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-begin","text":"virtual void begin() =0 Begin recording","title":"function begin"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-end","text":"virtual void end() =0 End recording Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function end"},{"location":"api/Classes/classngfx_1_1ComputeApplication/","text":"ngfx::ComputeApplication Public Functions Name ComputeApplication (const std::string & name, int w =0, int h =0) virtual ~ComputeApplication () virtual void onInit () virtual void onRecordCommandBuffer ( CommandBuffer * commandBuffer) virtual void onUpdate () virtual void run () Protected Functions Name virtual void init () virtual void close () virtual void doCompute ( CommandBuffer * commandBuffer) virtual void onComputeFinished () virtual void recordCommandBuffer ( CommandBuffer * commandBuffer) Protected Attributes Name std::unique_ptr< Graphics > graphics std::unique_ptr< Window > window std::unique_ptr< GraphicsContext > graphicsContext std::string appName int w int h Public Functions Documentation function ComputeApplication ComputeApplication( const std::string & name, int w =0, int h =0 ) function ~ComputeApplication inline virtual ~ComputeApplication() function onInit inline virtual void onInit() function onRecordCommandBuffer inline virtual void onRecordCommandBuffer( CommandBuffer * commandBuffer ) function onUpdate inline virtual void onUpdate() function run virtual void run() Protected Functions Documentation function init virtual void init() function close virtual void close() function doCompute virtual void doCompute( CommandBuffer * commandBuffer ) function onComputeFinished inline virtual void onComputeFinished() function recordCommandBuffer virtual void recordCommandBuffer( CommandBuffer * commandBuffer ) Protected Attributes Documentation variable graphics std::unique_ptr< Graphics > graphics; variable window std::unique_ptr< Window > window; variable graphicsContext std::unique_ptr< GraphicsContext > graphicsContext; variable appName std::string appName; variable w int w; variable h int h; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ComputeApplication"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#ngfxcomputeapplication","text":"","title":"ngfx::ComputeApplication"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#public-functions","text":"Name ComputeApplication (const std::string & name, int w =0, int h =0) virtual ~ComputeApplication () virtual void onInit () virtual void onRecordCommandBuffer ( CommandBuffer * commandBuffer) virtual void onUpdate () virtual void run ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#protected-functions","text":"Name virtual void init () virtual void close () virtual void doCompute ( CommandBuffer * commandBuffer) virtual void onComputeFinished () virtual void recordCommandBuffer ( CommandBuffer * commandBuffer)","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#protected-attributes","text":"Name std::unique_ptr< Graphics > graphics std::unique_ptr< Window > window std::unique_ptr< GraphicsContext > graphicsContext std::string appName int w int h","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-computeapplication","text":"ComputeApplication( const std::string & name, int w =0, int h =0 )","title":"function ComputeApplication"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-computeapplication_1","text":"inline virtual ~ComputeApplication()","title":"function ~ComputeApplication"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-oninit","text":"inline virtual void onInit()","title":"function onInit"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-onrecordcommandbuffer","text":"inline virtual void onRecordCommandBuffer( CommandBuffer * commandBuffer )","title":"function onRecordCommandBuffer"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-onupdate","text":"inline virtual void onUpdate()","title":"function onUpdate"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-run","text":"virtual void run()","title":"function run"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-init","text":"virtual void init()","title":"function init"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-close","text":"virtual void close()","title":"function close"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-docompute","text":"virtual void doCompute( CommandBuffer * commandBuffer )","title":"function doCompute"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-oncomputefinished","text":"inline virtual void onComputeFinished()","title":"function onComputeFinished"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-recordcommandbuffer","text":"virtual void recordCommandBuffer( CommandBuffer * commandBuffer )","title":"function recordCommandBuffer"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-graphics","text":"std::unique_ptr< Graphics > graphics;","title":"variable graphics"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-window","text":"std::unique_ptr< Window > window;","title":"variable window"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-graphicscontext","text":"std::unique_ptr< GraphicsContext > graphicsContext;","title":"variable graphicsContext"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-appname","text":"std::string appName;","title":"variable appName"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-w","text":"int w;","title":"variable w"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-h","text":"int h; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable h"},{"location":"api/Classes/classngfx_1_1ComputeOp/","text":"ngfx::ComputeOp Inherited by ngfx::MatrixMultiplyOp Public Functions Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) =0 Protected Attributes Name GraphicsContext * ctx Public Functions Documentation function ComputeOp inline ComputeOp( GraphicsContext * ctx ) function ~ComputeOp inline virtual ~ComputeOp() function apply virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) =0 Reimplemented by : ngfx::MatrixMultiplyGPUOp::apply , ngfx::MatrixMultiplyCPUOp::apply , ngfx::MatrixMultiplyOp::apply Protected Attributes Documentation variable ctx GraphicsContext * ctx; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ComputeOp"},{"location":"api/Classes/classngfx_1_1ComputeOp/#ngfxcomputeop","text":"Inherited by ngfx::MatrixMultiplyOp","title":"ngfx::ComputeOp"},{"location":"api/Classes/classngfx_1_1ComputeOp/#public-functions","text":"Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputeOp/#protected-attributes","text":"Name GraphicsContext * ctx","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1ComputeOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputeOp/#function-computeop","text":"inline ComputeOp( GraphicsContext * ctx )","title":"function ComputeOp"},{"location":"api/Classes/classngfx_1_1ComputeOp/#function-computeop_1","text":"inline virtual ~ComputeOp()","title":"function ~ComputeOp"},{"location":"api/Classes/classngfx_1_1ComputeOp/#function-apply","text":"virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) =0 Reimplemented by : ngfx::MatrixMultiplyGPUOp::apply , ngfx::MatrixMultiplyCPUOp::apply , ngfx::MatrixMultiplyOp::apply","title":"function apply"},{"location":"api/Classes/classngfx_1_1ComputeOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1ComputeOp/#variable-ctx","text":"GraphicsContext * ctx; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1ComputePass/","text":"ngfx::ComputePass Public Functions Name virtual ~ComputePass () virtual void begin ( GraphicsContext * ctx, CommandBuffer * commandBuffer) virtual void end ( CommandBuffer * commandBuffer) Public Functions Documentation function ~ComputePass inline virtual ~ComputePass() function begin inline virtual void begin( GraphicsContext * ctx, CommandBuffer * commandBuffer ) function end inline virtual void end( CommandBuffer * commandBuffer ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ComputePass"},{"location":"api/Classes/classngfx_1_1ComputePass/#ngfxcomputepass","text":"","title":"ngfx::ComputePass"},{"location":"api/Classes/classngfx_1_1ComputePass/#public-functions","text":"Name virtual ~ComputePass () virtual void begin ( GraphicsContext * ctx, CommandBuffer * commandBuffer) virtual void end ( CommandBuffer * commandBuffer)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputePass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputePass/#function-computepass","text":"inline virtual ~ComputePass()","title":"function ~ComputePass"},{"location":"api/Classes/classngfx_1_1ComputePass/#function-begin","text":"inline virtual void begin( GraphicsContext * ctx, CommandBuffer * commandBuffer )","title":"function begin"},{"location":"api/Classes/classngfx_1_1ComputePass/#function-end","text":"inline virtual void end( CommandBuffer * commandBuffer ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function end"},{"location":"api/Classes/classngfx_1_1ComputePipeline/","text":"ngfx::ComputePipeline Inherits from ngfx::Pipeline Public Functions Name ComputePipeline * create ( GraphicsContext * graphicsContext, ComputeShaderModule * cs) virtual ~ComputePipeline () Public Attributes Name std::vector< uint32_t > descriptorBindings Additional inherited members Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create static ComputePipeline * create( GraphicsContext * graphicsContext, ComputeShaderModule * cs ) function ~ComputePipeline inline virtual ~ComputePipeline() Public Attributes Documentation variable descriptorBindings std::vector< uint32_t > descriptorBindings; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ComputePipeline"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#ngfxcomputepipeline","text":"Inherits from ngfx::Pipeline","title":"ngfx::ComputePipeline"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#public-functions","text":"Name ComputePipeline * create ( GraphicsContext * graphicsContext, ComputeShaderModule * cs) virtual ~ComputePipeline ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#public-attributes","text":"Name std::vector< uint32_t > descriptorBindings","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#additional-inherited-members","text":"Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#function-create","text":"static ComputePipeline * create( GraphicsContext * graphicsContext, ComputeShaderModule * cs )","title":"function create"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#function-computepipeline","text":"inline virtual ~ComputePipeline()","title":"function ~ComputePipeline"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#variable-descriptorbindings","text":"std::vector< uint32_t > descriptorBindings; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable descriptorBindings"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/","text":"ngfx::ComputeShaderModule Inherits from ngfx::ShaderModule Public Functions Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename) Additional inherited members Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function create static std::unique_ptr< ComputeShaderModule > create( Device * device, const std::string & filename ) function ~ComputeShaderModule inline virtual ~ComputeShaderModule() function initBindings inline void initBindings( const std::string & filename ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ComputeShaderModule"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#ngfxcomputeshadermodule","text":"Inherits from ngfx::ShaderModule","title":"ngfx::ComputeShaderModule"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#public-functions","text":"Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#function-create","text":"static std::unique_ptr< ComputeShaderModule > create( Device * device, const std::string & filename )","title":"function create"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#function-computeshadermodule","text":"inline virtual ~ComputeShaderModule()","title":"function ~ComputeShaderModule"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#function-initbindings","text":"inline void initBindings( const std::string & filename ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1Device/","text":"ngfx::Device Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Device"},{"location":"api/Classes/classngfx_1_1Device/#ngfxdevice","text":"Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Device"},{"location":"api/Classes/classngfx_1_1DrawColorOp/","text":"ngfx::DrawColorOp Inherits from ngfx::DrawOp Public Functions Name DrawColorOp ( GraphicsContext * ctx, const std::vector< glm::vec2 > & pos, const glm::vec4 & color) virtual ~DrawColorOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override Protected Functions Name virtual void createPipeline () Public Attributes Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bUbo Protected Attributes Name GraphicsPipeline * graphicsPipeline uint32_t B_POS uint32_t U_UBO uint32_t numVerts Additional inherited members Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx Public Functions Documentation function DrawColorOp DrawColorOp( GraphicsContext * ctx, const std::vector< glm::vec2 > & pos, const glm::vec4 & color ) function ~DrawColorOp inline virtual ~DrawColorOp() function draw virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer. Protected Functions Documentation function createPipeline virtual void createPipeline() Public Attributes Documentation variable bPos std::unique_ptr< Buffer > bPos; variable bUbo std::unique_ptr< Buffer > bUbo; Protected Attributes Documentation variable graphicsPipeline GraphicsPipeline * graphicsPipeline; variable B_POS uint32_t B_POS; variable U_UBO uint32_t U_UBO; variable numVerts uint32_t numVerts; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::DrawColorOp"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#ngfxdrawcolorop","text":"Inherits from ngfx::DrawOp","title":"ngfx::DrawColorOp"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#public-functions","text":"Name DrawColorOp ( GraphicsContext * ctx, const std::vector< glm::vec2 > & pos, const glm::vec4 & color) virtual ~DrawColorOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#protected-functions","text":"Name virtual void createPipeline ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#public-attributes","text":"Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bUbo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#protected-attributes","text":"Name GraphicsPipeline * graphicsPipeline uint32_t B_POS uint32_t U_UBO uint32_t numVerts","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#function-drawcolorop","text":"DrawColorOp( GraphicsContext * ctx, const std::vector< glm::vec2 > & pos, const glm::vec4 & color )","title":"function DrawColorOp"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#function-drawcolorop_1","text":"inline virtual ~DrawColorOp()","title":"function ~DrawColorOp"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#function-draw","text":"virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer.","title":"function draw"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#function-createpipeline","text":"virtual void createPipeline()","title":"function createPipeline"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-bpos","text":"std::unique_ptr< Buffer > bPos;","title":"variable bPos"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-bubo","text":"std::unique_ptr< Buffer > bUbo;","title":"variable bUbo"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-graphicspipeline","text":"GraphicsPipeline * graphicsPipeline;","title":"variable graphicsPipeline"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-b_pos","text":"uint32_t B_POS;","title":"variable B_POS"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-u_ubo","text":"uint32_t U_UBO;","title":"variable U_UBO"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-numverts","text":"uint32_t numVerts; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable numVerts"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/","text":"ngfx::DrawMeshOp Inherits from ngfx::DrawOp Public Classes Name struct LightData Protected Classes Name struct UBO_FS_Data struct UBO_VS_Data Public Functions Name DrawMeshOp ( GraphicsContext * ctx, MeshData & meshData) virtual ~DrawMeshOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override virtual void update (mat4 & modelView, mat4 & modelViewInverseTranspose, mat4 & modelViewProj, LightData & lightData) Protected Functions Name virtual void createPipeline () Public Attributes Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bNormals std::unique_ptr< Buffer > bFaces std::unique_ptr< Buffer > bUboVS std::unique_ptr< Buffer > bUboFS Protected Attributes Name GraphicsPipeline * graphicsPipeline uint32_t B_POS uint32_t B_NORMALS uint32_t U_UBO_VS uint32_t U_UBO_FS uint32_t numVerts uint32_t numNormals uint32_t numFaces Additional inherited members Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx Public Functions Documentation function DrawMeshOp DrawMeshOp( GraphicsContext * ctx, MeshData & meshData ) function ~DrawMeshOp inline virtual ~DrawMeshOp() function draw virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer. function update virtual void update( mat4 & modelView, mat4 & modelViewInverseTranspose, mat4 & modelViewProj, LightData & lightData ) Protected Functions Documentation function createPipeline virtual void createPipeline() Public Attributes Documentation variable bPos std::unique_ptr< Buffer > bPos; variable bNormals std::unique_ptr< Buffer > bNormals; variable bFaces std::unique_ptr< Buffer > bFaces; variable bUboVS std::unique_ptr< Buffer > bUboVS; variable bUboFS std::unique_ptr< Buffer > bUboFS; Protected Attributes Documentation variable graphicsPipeline GraphicsPipeline * graphicsPipeline; variable B_POS uint32_t B_POS; variable B_NORMALS uint32_t B_NORMALS; variable U_UBO_VS uint32_t U_UBO_VS; variable U_UBO_FS uint32_t U_UBO_FS; variable numVerts uint32_t numVerts; variable numNormals uint32_t numNormals; variable numFaces uint32_t numFaces; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::DrawMeshOp"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#ngfxdrawmeshop","text":"Inherits from ngfx::DrawOp","title":"ngfx::DrawMeshOp"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#public-classes","text":"Name struct LightData","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#protected-classes","text":"Name struct UBO_FS_Data struct UBO_VS_Data","title":"Protected Classes"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#public-functions","text":"Name DrawMeshOp ( GraphicsContext * ctx, MeshData & meshData) virtual ~DrawMeshOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override virtual void update (mat4 & modelView, mat4 & modelViewInverseTranspose, mat4 & modelViewProj, LightData & lightData)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#protected-functions","text":"Name virtual void createPipeline ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#public-attributes","text":"Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bNormals std::unique_ptr< Buffer > bFaces std::unique_ptr< Buffer > bUboVS std::unique_ptr< Buffer > bUboFS","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#protected-attributes","text":"Name GraphicsPipeline * graphicsPipeline uint32_t B_POS uint32_t B_NORMALS uint32_t U_UBO_VS uint32_t U_UBO_FS uint32_t numVerts uint32_t numNormals uint32_t numFaces","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#function-drawmeshop","text":"DrawMeshOp( GraphicsContext * ctx, MeshData & meshData )","title":"function DrawMeshOp"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#function-drawmeshop_1","text":"inline virtual ~DrawMeshOp()","title":"function ~DrawMeshOp"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#function-draw","text":"virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer.","title":"function draw"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#function-update","text":"virtual void update( mat4 & modelView, mat4 & modelViewInverseTranspose, mat4 & modelViewProj, LightData & lightData )","title":"function update"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#function-createpipeline","text":"virtual void createPipeline()","title":"function createPipeline"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-bpos","text":"std::unique_ptr< Buffer > bPos;","title":"variable bPos"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-bnormals","text":"std::unique_ptr< Buffer > bNormals;","title":"variable bNormals"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-bfaces","text":"std::unique_ptr< Buffer > bFaces;","title":"variable bFaces"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-bubovs","text":"std::unique_ptr< Buffer > bUboVS;","title":"variable bUboVS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-bubofs","text":"std::unique_ptr< Buffer > bUboFS;","title":"variable bUboFS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-graphicspipeline","text":"GraphicsPipeline * graphicsPipeline;","title":"variable graphicsPipeline"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-b_pos","text":"uint32_t B_POS;","title":"variable B_POS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-b_normals","text":"uint32_t B_NORMALS;","title":"variable B_NORMALS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-u_ubo_vs","text":"uint32_t U_UBO_VS;","title":"variable U_UBO_VS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-u_ubo_fs","text":"uint32_t U_UBO_FS;","title":"variable U_UBO_FS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-numverts","text":"uint32_t numVerts;","title":"variable numVerts"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-numnormals","text":"uint32_t numNormals;","title":"variable numNormals"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-numfaces","text":"uint32_t numFaces; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable numFaces"},{"location":"api/Classes/classngfx_1_1DrawOp/","text":"ngfx::DrawOp Inherited by ngfx::DrawColorOp , ngfx::DrawMeshOp , ngfx::DrawTextureOp , ngfx::FilterOp Public Functions Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0 Protected Attributes Name GraphicsContext * ctx Public Functions Documentation function DrawOp inline DrawOp( GraphicsContext * ctx ) Parameters : ctx The graphics context Create the draw operation function ~DrawOp inline virtual ~DrawOp() Destroy the draw op function draw virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) =0 Parameters : commandBuffer The command buffer graphics The graphics object Reimplemented by : ngfx::DrawMeshOp::draw , ngfx::DrawColorOp::draw , ngfx::DrawTextureOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer. Protected Attributes Documentation variable ctx GraphicsContext * ctx; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#ngfxdrawop","text":"Inherited by ngfx::DrawColorOp , ngfx::DrawMeshOp , ngfx::DrawTextureOp , ngfx::FilterOp","title":"ngfx::DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#public-functions","text":"Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1DrawOp/#protected-attributes","text":"Name GraphicsContext * ctx","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1DrawOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawOp/#function-drawop","text":"inline DrawOp( GraphicsContext * ctx ) Parameters : ctx The graphics context Create the draw operation","title":"function DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#function-drawop_1","text":"inline virtual ~DrawOp() Destroy the draw op","title":"function ~DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#function-draw","text":"virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) =0 Parameters : commandBuffer The command buffer graphics The graphics object Reimplemented by : ngfx::DrawMeshOp::draw , ngfx::DrawColorOp::draw , ngfx::DrawTextureOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer.","title":"function draw"},{"location":"api/Classes/classngfx_1_1DrawOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawOp/#variable-ctx","text":"GraphicsContext * ctx; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/","text":"ngfx::DrawTextureOp Inherits from ngfx::DrawOp Public Functions Name DrawTextureOp ( GraphicsContext * ctx, Texture * texture) DrawTextureOp ( GraphicsContext * ctx, Texture * texture, const std::vector< glm::vec2 > & pos, const std::vector< glm::vec2 > & texCoord) virtual ~DrawTextureOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override Protected Functions Name virtual void createPipeline () Public Attributes Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bTexCoord Texture * texture Protected Attributes Name GraphicsPipeline * graphicsPipeline uint32_t numVerts uint32_t B_POS uint32_t B_TEXCOORD uint32_t U_TEXTURE Additional inherited members Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx Public Functions Documentation function DrawTextureOp inline DrawTextureOp( GraphicsContext * ctx, Texture * texture ) function DrawTextureOp DrawTextureOp( GraphicsContext * ctx, Texture * texture, const std::vector< glm::vec2 > & pos, const std::vector< glm::vec2 > & texCoord ) function ~DrawTextureOp inline virtual ~DrawTextureOp() function draw virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer. Protected Functions Documentation function createPipeline virtual void createPipeline() Public Attributes Documentation variable bPos std::unique_ptr< Buffer > bPos; variable bTexCoord std::unique_ptr< Buffer > bTexCoord; variable texture Texture * texture; Protected Attributes Documentation variable graphicsPipeline GraphicsPipeline * graphicsPipeline; variable numVerts uint32_t numVerts; variable B_POS uint32_t B_POS; variable B_TEXCOORD uint32_t B_TEXCOORD; variable U_TEXTURE uint32_t U_TEXTURE; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::DrawTextureOp"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#ngfxdrawtextureop","text":"Inherits from ngfx::DrawOp","title":"ngfx::DrawTextureOp"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#public-functions","text":"Name DrawTextureOp ( GraphicsContext * ctx, Texture * texture) DrawTextureOp ( GraphicsContext * ctx, Texture * texture, const std::vector< glm::vec2 > & pos, const std::vector< glm::vec2 > & texCoord) virtual ~DrawTextureOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#protected-functions","text":"Name virtual void createPipeline ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#public-attributes","text":"Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bTexCoord Texture * texture","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#protected-attributes","text":"Name GraphicsPipeline * graphicsPipeline uint32_t numVerts uint32_t B_POS uint32_t B_TEXCOORD uint32_t U_TEXTURE","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#function-drawtextureop","text":"inline DrawTextureOp( GraphicsContext * ctx, Texture * texture )","title":"function DrawTextureOp"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#function-drawtextureop_1","text":"DrawTextureOp( GraphicsContext * ctx, Texture * texture, const std::vector< glm::vec2 > & pos, const std::vector< glm::vec2 > & texCoord )","title":"function DrawTextureOp"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#function-drawtextureop_2","text":"inline virtual ~DrawTextureOp()","title":"function ~DrawTextureOp"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#function-draw","text":"virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer.","title":"function draw"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#function-createpipeline","text":"virtual void createPipeline()","title":"function createPipeline"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-bpos","text":"std::unique_ptr< Buffer > bPos;","title":"variable bPos"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-btexcoord","text":"std::unique_ptr< Buffer > bTexCoord;","title":"variable bTexCoord"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-texture","text":"Texture * texture;","title":"variable texture"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-graphicspipeline","text":"GraphicsPipeline * graphicsPipeline;","title":"variable graphicsPipeline"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-numverts","text":"uint32_t numVerts;","title":"variable numVerts"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-b_pos","text":"uint32_t B_POS;","title":"variable B_POS"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-b_texcoord","text":"uint32_t B_TEXCOORD;","title":"variable B_TEXCOORD"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-u_texture","text":"uint32_t U_TEXTURE; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable U_TEXTURE"},{"location":"api/Classes/classngfx_1_1FPSCounter/","text":"ngfx::FPSCounter Public Functions Name FPSCounter () void update () Public Attributes Name float fps Public Functions Documentation function FPSCounter inline FPSCounter() function update void update() Public Attributes Documentation variable fps float fps = 0.0f; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::FPSCounter"},{"location":"api/Classes/classngfx_1_1FPSCounter/#ngfxfpscounter","text":"","title":"ngfx::FPSCounter"},{"location":"api/Classes/classngfx_1_1FPSCounter/#public-functions","text":"Name FPSCounter () void update ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1FPSCounter/#public-attributes","text":"Name float fps","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1FPSCounter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1FPSCounter/#function-fpscounter","text":"inline FPSCounter()","title":"function FPSCounter"},{"location":"api/Classes/classngfx_1_1FPSCounter/#function-update","text":"void update()","title":"function update"},{"location":"api/Classes/classngfx_1_1FPSCounter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1FPSCounter/#variable-fps","text":"float fps = 0.0f; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable fps"},{"location":"api/Classes/classngfx_1_1Fence/","text":"ngfx::Fence Public Functions Name Fence * create ( Device * device, FenceCreateFlags flags =0) virtual ~Fence () virtual void wait () =0 virtual void reset () =0 Public Functions Documentation function create static Fence * create( Device * device, FenceCreateFlags flags =0 ) Parameters : device The GPU device handle flags Additional fence create flags (optional) Create the fence object function ~Fence inline virtual ~Fence() Destroy the fence object function wait virtual void wait() =0 Wait for the fence to be signaled by the GPU function reset virtual void reset() =0 Reset the fence Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Fence"},{"location":"api/Classes/classngfx_1_1Fence/#ngfxfence","text":"","title":"ngfx::Fence"},{"location":"api/Classes/classngfx_1_1Fence/#public-functions","text":"Name Fence * create ( Device * device, FenceCreateFlags flags =0) virtual ~Fence () virtual void wait () =0 virtual void reset () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Fence/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Fence/#function-create","text":"static Fence * create( Device * device, FenceCreateFlags flags =0 ) Parameters : device The GPU device handle flags Additional fence create flags (optional) Create the fence object","title":"function create"},{"location":"api/Classes/classngfx_1_1Fence/#function-fence","text":"inline virtual ~Fence() Destroy the fence object","title":"function ~Fence"},{"location":"api/Classes/classngfx_1_1Fence/#function-wait","text":"virtual void wait() =0 Wait for the fence to be signaled by the GPU","title":"function wait"},{"location":"api/Classes/classngfx_1_1Fence/#function-reset","text":"virtual void reset() =0 Reset the fence Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function reset"},{"location":"api/Classes/classngfx_1_1File/","text":"ngfx::File Public Functions Name void read (const std::string & filename) Public Attributes Name std::unique_ptr< char[]> data int size Public Functions Documentation function read void read( const std::string & filename ) Public Attributes Documentation variable data std::unique_ptr< char[]> data; variable size int size; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::File"},{"location":"api/Classes/classngfx_1_1File/#ngfxfile","text":"","title":"ngfx::File"},{"location":"api/Classes/classngfx_1_1File/#public-functions","text":"Name void read (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1File/#public-attributes","text":"Name std::unique_ptr< char[]> data int size","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1File/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1File/#function-read","text":"void read( const std::string & filename )","title":"function read"},{"location":"api/Classes/classngfx_1_1File/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1File/#variable-data","text":"std::unique_ptr< char[]> data;","title":"variable data"},{"location":"api/Classes/classngfx_1_1File/#variable-size","text":"int size; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable size"},{"location":"api/Classes/classngfx_1_1FileUtil/","text":"ngfx::FileUtil Public Classes Name struct Lock Public Functions Name bool getmtime (const std::string & filename, std::filesystem::file_time_type & mtime) bool srcFileNewerThanOutFile (const std::string & srcFileName, const std::string & targetFileName) std::string tempDir () std::string readFile (const std::string & path) void writeFile (const std::string & path, const std::string & contents) std::vector< std::string > splitExt (const std::string & filename) std::vector< std::string > findFiles (const std::string & path) std::vector< std::string > findFiles (const std::string & path, const std::string & ext) std::vector< std::string > filterFiles (const std::vector< std::string > & files, const std::string & fileFilter) std::vector< std::string > findFiles (const std::vector< std::string > & paths, const std::vector< std::string > & extensions) Public Functions Documentation function getmtime static bool getmtime( const std::string & filename, std::filesystem::file_time_type & mtime ) function srcFileNewerThanOutFile static bool srcFileNewerThanOutFile( const std::string & srcFileName, const std::string & targetFileName ) function tempDir static std::string tempDir() function readFile static std::string readFile( const std::string & path ) function writeFile static void writeFile( const std::string & path, const std::string & contents ) function splitExt static std::vector< std::string > splitExt( const std::string & filename ) function findFiles static std::vector< std::string > findFiles( const std::string & path ) function findFiles static std::vector< std::string > findFiles( const std::string & path, const std::string & ext ) function filterFiles static std::vector< std::string > filterFiles( const std::vector< std::string > & files, const std::string & fileFilter ) function findFiles static std::vector< std::string > findFiles( const std::vector< std::string > & paths, const std::vector< std::string > & extensions ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::FileUtil"},{"location":"api/Classes/classngfx_1_1FileUtil/#ngfxfileutil","text":"","title":"ngfx::FileUtil"},{"location":"api/Classes/classngfx_1_1FileUtil/#public-classes","text":"Name struct Lock","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1FileUtil/#public-functions","text":"Name bool getmtime (const std::string & filename, std::filesystem::file_time_type & mtime) bool srcFileNewerThanOutFile (const std::string & srcFileName, const std::string & targetFileName) std::string tempDir () std::string readFile (const std::string & path) void writeFile (const std::string & path, const std::string & contents) std::vector< std::string > splitExt (const std::string & filename) std::vector< std::string > findFiles (const std::string & path) std::vector< std::string > findFiles (const std::string & path, const std::string & ext) std::vector< std::string > filterFiles (const std::vector< std::string > & files, const std::string & fileFilter) std::vector< std::string > findFiles (const std::vector< std::string > & paths, const std::vector< std::string > & extensions)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1FileUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-getmtime","text":"static bool getmtime( const std::string & filename, std::filesystem::file_time_type & mtime )","title":"function getmtime"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-srcfilenewerthanoutfile","text":"static bool srcFileNewerThanOutFile( const std::string & srcFileName, const std::string & targetFileName )","title":"function srcFileNewerThanOutFile"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-tempdir","text":"static std::string tempDir()","title":"function tempDir"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-readfile","text":"static std::string readFile( const std::string & path )","title":"function readFile"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-writefile","text":"static void writeFile( const std::string & path, const std::string & contents )","title":"function writeFile"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-splitext","text":"static std::vector< std::string > splitExt( const std::string & filename )","title":"function splitExt"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-findfiles","text":"static std::vector< std::string > findFiles( const std::string & path )","title":"function findFiles"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-findfiles_1","text":"static std::vector< std::string > findFiles( const std::string & path, const std::string & ext )","title":"function findFiles"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-filterfiles","text":"static std::vector< std::string > filterFiles( const std::vector< std::string > & files, const std::string & fileFilter )","title":"function filterFiles"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-findfiles_2","text":"static std::vector< std::string > findFiles( const std::vector< std::string > & paths, const std::vector< std::string > & extensions ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function findFiles"},{"location":"api/Classes/classngfx_1_1FilterOp/","text":"ngfx::FilterOp Inherits from ngfx::DrawOp Public Functions Name FilterOp ( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight) virtual ~FilterOp () void apply ( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics) Public Attributes Name std::unique_ptr< Texture > outputTexture std::unique_ptr< Framebuffer > outputFramebuffer Additional inherited members Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0 Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx Public Functions Documentation function FilterOp FilterOp( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight ) function ~FilterOp inline virtual ~FilterOp() function apply void apply( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics ) Public Attributes Documentation variable outputTexture std::unique_ptr< Texture > outputTexture; variable outputFramebuffer std::unique_ptr< Framebuffer > outputFramebuffer; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#ngfxfilterop","text":"Inherits from ngfx::DrawOp","title":"ngfx::FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-functions","text":"Name FilterOp ( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight) virtual ~FilterOp () void apply ( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-attributes","text":"Name std::unique_ptr< Texture > outputTexture std::unique_ptr< Framebuffer > outputFramebuffer","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1FilterOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0 Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1FilterOp/#function-filterop","text":"FilterOp( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight )","title":"function FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#function-filterop_1","text":"inline virtual ~FilterOp()","title":"function ~FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#function-apply","text":"void apply( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics )","title":"function apply"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1FilterOp/#variable-outputtexture","text":"std::unique_ptr< Texture > outputTexture;","title":"variable outputTexture"},{"location":"api/Classes/classngfx_1_1FilterOp/#variable-outputframebuffer","text":"std::unique_ptr< Framebuffer > outputFramebuffer; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable outputFramebuffer"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/","text":"ngfx::FragmentShaderModule Inherits from ngfx::ShaderModule Public Functions Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename) Additional inherited members Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function create static std::unique_ptr< FragmentShaderModule > create( Device * device, const std::string & filename ) function ~FragmentShaderModule inline virtual ~FragmentShaderModule() function initBindings inline void initBindings( const std::string & filename ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::FragmentShaderModule"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#ngfxfragmentshadermodule","text":"Inherits from ngfx::ShaderModule","title":"ngfx::FragmentShaderModule"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#public-functions","text":"Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#function-create","text":"static std::unique_ptr< FragmentShaderModule > create( Device * device, const std::string & filename )","title":"function create"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#function-fragmentshadermodule","text":"inline virtual ~FragmentShaderModule()","title":"function ~FragmentShaderModule"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#function-initbindings","text":"inline void initBindings( const std::string & filename ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1Framebuffer/","text":"ngfx::Framebuffer Public Classes Name struct Attachment Public Functions Name Framebuffer * create ( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1) virtual ~Framebuffer () Public Attributes Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments Public Functions Documentation function create static Framebuffer * create( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1 ) function ~Framebuffer inline virtual ~Framebuffer() Public Attributes Documentation variable w uint32_t w; variable h uint32_t h; variable layers uint32_t layers; variable numAttachments uint32_t numAttachments; variable attachments std::vector< Attachment > attachments; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Framebuffer"},{"location":"api/Classes/classngfx_1_1Framebuffer/#ngfxframebuffer","text":"","title":"ngfx::Framebuffer"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-classes","text":"Name struct Attachment","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-functions","text":"Name Framebuffer * create ( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1) virtual ~Framebuffer ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-attributes","text":"Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Framebuffer/#function-create","text":"static Framebuffer * create( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1Framebuffer/#function-framebuffer","text":"inline virtual ~Framebuffer()","title":"function ~Framebuffer"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-w","text":"uint32_t w;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-h","text":"uint32_t h;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-layers","text":"uint32_t layers;","title":"variable layers"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-numattachments","text":"uint32_t numAttachments;","title":"variable numAttachments"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-attachments","text":"std::vector< Attachment > attachments; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable attachments"},{"location":"api/Classes/classngfx_1_1Graphics/","text":"ngfx::Graphics Public Functions Name Graphics * create ( GraphicsContext * ctx) virtual ~Graphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) =0 virtual void endComputePass ( CommandBuffer * commandBuffer) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) =0 virtual void endRenderPass ( CommandBuffer * commandBuffer) =0 virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) =0 virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32) =0 virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) =0 virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) =0 virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) =0 virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) =0 virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) =0 virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) =0 virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void waitIdle ( CommandBuffer * cmdBuffer) =0 Public Attributes Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer Protected Attributes Name GraphicsContext * ctx Public Functions Documentation function create static Graphics * create( GraphicsContext * ctx ) function ~Graphics inline virtual ~Graphics() function beginComputePass virtual void beginComputePass( CommandBuffer * commandBuffer ) =0 function endComputePass virtual void endComputePass( CommandBuffer * commandBuffer ) =0 function beginRenderPass virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) =0 function endRenderPass virtual void endRenderPass( CommandBuffer * commandBuffer ) =0 function bindVertexBuffer virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) =0 function bindIndexBuffer virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32 ) =0 function bindUniformBuffer virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0 function bindStorageBuffer virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0 function bindComputePipeline virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) =0 function bindGraphicsPipeline virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) =0 function bindTexture virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) =0 function draw virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) =0 function drawIndexed virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) =0 function dispatch virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) =0 function setViewport virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) =0 function setScissor virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) =0 function waitIdle virtual void waitIdle( CommandBuffer * cmdBuffer ) =0 Public Attributes Documentation variable scissorRect Rect2D scissorRect; variable viewport Rect2D viewport; variable currentPipeline Pipeline * currentPipeline = nullptr; variable currentRenderPass RenderPass * currentRenderPass = nullptr; variable currentFramebuffer Framebuffer * currentFramebuffer = nullptr; Protected Attributes Documentation variable ctx GraphicsContext * ctx; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Graphics"},{"location":"api/Classes/classngfx_1_1Graphics/#ngfxgraphics","text":"","title":"ngfx::Graphics"},{"location":"api/Classes/classngfx_1_1Graphics/#public-functions","text":"Name Graphics * create ( GraphicsContext * ctx) virtual ~Graphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) =0 virtual void endComputePass ( CommandBuffer * commandBuffer) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) =0 virtual void endRenderPass ( CommandBuffer * commandBuffer) =0 virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) =0 virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32) =0 virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) =0 virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) =0 virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) =0 virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) =0 virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) =0 virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) =0 virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void waitIdle ( CommandBuffer * cmdBuffer) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Graphics/#public-attributes","text":"Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Graphics/#protected-attributes","text":"Name GraphicsContext * ctx","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1Graphics/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Graphics/#function-create","text":"static Graphics * create( GraphicsContext * ctx )","title":"function create"},{"location":"api/Classes/classngfx_1_1Graphics/#function-graphics","text":"inline virtual ~Graphics()","title":"function ~Graphics"},{"location":"api/Classes/classngfx_1_1Graphics/#function-begincomputepass","text":"virtual void beginComputePass( CommandBuffer * commandBuffer ) =0","title":"function beginComputePass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-endcomputepass","text":"virtual void endComputePass( CommandBuffer * commandBuffer ) =0","title":"function endComputePass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-beginrenderpass","text":"virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) =0","title":"function beginRenderPass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-endrenderpass","text":"virtual void endRenderPass( CommandBuffer * commandBuffer ) =0","title":"function endRenderPass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindvertexbuffer","text":"virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) =0","title":"function bindVertexBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindindexbuffer","text":"virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32 ) =0","title":"function bindIndexBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-binduniformbuffer","text":"virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0","title":"function bindUniformBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindstoragebuffer","text":"virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0","title":"function bindStorageBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindcomputepipeline","text":"virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) =0","title":"function bindComputePipeline"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindgraphicspipeline","text":"virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) =0","title":"function bindGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindtexture","text":"virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) =0","title":"function bindTexture"},{"location":"api/Classes/classngfx_1_1Graphics/#function-draw","text":"virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) =0","title":"function draw"},{"location":"api/Classes/classngfx_1_1Graphics/#function-drawindexed","text":"virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) =0","title":"function drawIndexed"},{"location":"api/Classes/classngfx_1_1Graphics/#function-dispatch","text":"virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) =0","title":"function dispatch"},{"location":"api/Classes/classngfx_1_1Graphics/#function-setviewport","text":"virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) =0","title":"function setViewport"},{"location":"api/Classes/classngfx_1_1Graphics/#function-setscissor","text":"virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) =0","title":"function setScissor"},{"location":"api/Classes/classngfx_1_1Graphics/#function-waitidle","text":"virtual void waitIdle( CommandBuffer * cmdBuffer ) =0","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1Graphics/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-scissorrect","text":"Rect2D scissorRect;","title":"variable scissorRect"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-viewport","text":"Rect2D viewport;","title":"variable viewport"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-currentpipeline","text":"Pipeline * currentPipeline = nullptr;","title":"variable currentPipeline"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-currentrenderpass","text":"RenderPass * currentRenderPass = nullptr;","title":"variable currentRenderPass"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-currentframebuffer","text":"Framebuffer * currentFramebuffer = nullptr;","title":"variable currentFramebuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-ctx","text":"GraphicsContext * ctx; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1GraphicsContext/","text":"ngfx::GraphicsContext Public Classes Name struct AttachmentDescription struct RenderPassConfig Public Functions Name GraphicsContext * create (const char * appName, bool enableDepthStencil =false, bool debug =true) virtual ~GraphicsContext () virtual void setSurface ( Surface * surface) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void submit ( CommandBuffer * commandBuffer) virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) =0 virtual CommandBuffer * copyCommandBuffer () =0 virtual CommandBuffer * computeCommandBuffer () =0 virtual RenderPass * getRenderPass ( RenderPassConfig config) =0 Public Attributes Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor Protected Attributes Name bool debug bool enableDepthStencil Public Functions Documentation function create static GraphicsContext * create( const char * appName, bool enableDepthStencil =false, bool debug =true ) function ~GraphicsContext inline virtual ~GraphicsContext() function setSurface virtual void setSurface( Surface * surface ) =0 function beginRenderPass inline virtual void beginRenderPass( CommandBuffer * commandBuffer, Graphics * graphics ) function beginOffscreenRenderPass inline virtual void beginOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer ) function endRenderPass inline virtual void endRenderPass( CommandBuffer * commandBuffer, Graphics * graphics ) function endOffscreenRenderPass inline virtual void endOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics ) function submit inline virtual void submit( CommandBuffer * commandBuffer ) function drawCommandBuffer virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) =0 function copyCommandBuffer virtual CommandBuffer * copyCommandBuffer() =0 function computeCommandBuffer virtual CommandBuffer * computeCommandBuffer() =0 function getRenderPass virtual RenderPass * getRenderPass( RenderPassConfig config ) =0 Public Attributes Documentation variable device Device * device; variable numDrawCommandBuffers uint32_t numDrawCommandBuffers = 0; variable swapchainFramebuffers std::vector< Framebuffer * > swapchainFramebuffers; variable queue Queue * queue = nullptr; variable defaultRenderPass RenderPass * defaultRenderPass = nullptr; variable defaultOffscreenRenderPass RenderPass * defaultOffscreenRenderPass = nullptr; variable swapchain Swapchain * swapchain = nullptr; variable surface Surface * surface = nullptr; variable currentImageIndex uint32_t currentImageIndex = 0; variable frameFences std::vector< Fence * > frameFences; variable computeFence Fence * computeFence = nullptr; variable presentCompleteSemaphore Semaphore * presentCompleteSemaphore = nullptr; variable renderCompleteSemaphore Semaphore * renderCompleteSemaphore = nullptr; variable pipelineCache PipelineCache * pipelineCache = nullptr; variable surfaceFormat PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED; variable defaultOffscreenSurfaceFormat PixelFormat defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED; variable depthFormat PixelFormat depthFormat = PIXELFORMAT_UNDEFINED; variable clearColor glm::vec4 clearColor = glm::vec4(0.0f); Protected Attributes Documentation variable debug bool debug = false; variable enableDepthStencil bool enableDepthStencil = false; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::GraphicsContext"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#ngfxgraphicscontext","text":"","title":"ngfx::GraphicsContext"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-classes","text":"Name struct AttachmentDescription struct RenderPassConfig","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-functions","text":"Name GraphicsContext * create (const char * appName, bool enableDepthStencil =false, bool debug =true) virtual ~GraphicsContext () virtual void setSurface ( Surface * surface) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void submit ( CommandBuffer * commandBuffer) virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) =0 virtual CommandBuffer * copyCommandBuffer () =0 virtual CommandBuffer * computeCommandBuffer () =0 virtual RenderPass * getRenderPass ( RenderPassConfig config) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-attributes","text":"Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#protected-attributes","text":"Name bool debug bool enableDepthStencil","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-create","text":"static GraphicsContext * create( const char * appName, bool enableDepthStencil =false, bool debug =true )","title":"function create"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-graphicscontext","text":"inline virtual ~GraphicsContext()","title":"function ~GraphicsContext"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-setsurface","text":"virtual void setSurface( Surface * surface ) =0","title":"function setSurface"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-beginrenderpass","text":"inline virtual void beginRenderPass( CommandBuffer * commandBuffer, Graphics * graphics )","title":"function beginRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-beginoffscreenrenderpass","text":"inline virtual void beginOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer )","title":"function beginOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-endrenderpass","text":"inline virtual void endRenderPass( CommandBuffer * commandBuffer, Graphics * graphics )","title":"function endRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-endoffscreenrenderpass","text":"inline virtual void endOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics )","title":"function endOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-submit","text":"inline virtual void submit( CommandBuffer * commandBuffer )","title":"function submit"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-drawcommandbuffer","text":"virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) =0","title":"function drawCommandBuffer"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-copycommandbuffer","text":"virtual CommandBuffer * copyCommandBuffer() =0","title":"function copyCommandBuffer"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-computecommandbuffer","text":"virtual CommandBuffer * computeCommandBuffer() =0","title":"function computeCommandBuffer"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-getrenderpass","text":"virtual RenderPass * getRenderPass( RenderPassConfig config ) =0","title":"function getRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-device","text":"Device * device;","title":"variable device"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-numdrawcommandbuffers","text":"uint32_t numDrawCommandBuffers = 0;","title":"variable numDrawCommandBuffers"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-swapchainframebuffers","text":"std::vector< Framebuffer * > swapchainFramebuffers;","title":"variable swapchainFramebuffers"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-queue","text":"Queue * queue = nullptr;","title":"variable queue"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-defaultrenderpass","text":"RenderPass * defaultRenderPass = nullptr;","title":"variable defaultRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-defaultoffscreenrenderpass","text":"RenderPass * defaultOffscreenRenderPass = nullptr;","title":"variable defaultOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-swapchain","text":"Swapchain * swapchain = nullptr;","title":"variable swapchain"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-surface","text":"Surface * surface = nullptr;","title":"variable surface"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-currentimageindex","text":"uint32_t currentImageIndex = 0;","title":"variable currentImageIndex"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-framefences","text":"std::vector< Fence * > frameFences;","title":"variable frameFences"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-computefence","text":"Fence * computeFence = nullptr;","title":"variable computeFence"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-presentcompletesemaphore","text":"Semaphore * presentCompleteSemaphore = nullptr;","title":"variable presentCompleteSemaphore"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-rendercompletesemaphore","text":"Semaphore * renderCompleteSemaphore = nullptr;","title":"variable renderCompleteSemaphore"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-pipelinecache","text":"PipelineCache * pipelineCache = nullptr;","title":"variable pipelineCache"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-surfaceformat","text":"PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED;","title":"variable surfaceFormat"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-defaultoffscreensurfaceformat","text":"PixelFormat defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED;","title":"variable defaultOffscreenSurfaceFormat"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-depthformat","text":"PixelFormat depthFormat = PIXELFORMAT_UNDEFINED;","title":"variable depthFormat"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-clearcolor","text":"glm::vec4 clearColor = glm::vec4(0.0f);","title":"variable clearColor"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-debug","text":"bool debug = false;","title":"variable debug"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-enabledepthstencil","text":"bool enableDepthStencil = false; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable enableDepthStencil"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/","text":"ngfx::GraphicsPipeline Inherits from ngfx::Pipeline Public Classes Name struct Descriptor struct State Public Functions Name GraphicsPipeline * create ( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={}) virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings) Public Attributes Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings Additional inherited members Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create static GraphicsPipeline * create( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={} ) function ~GraphicsPipeline inline virtual ~GraphicsPipeline() function getBindings void getBindings( std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings ) Public Attributes Documentation variable descriptorBindings std::vector< uint32_t > descriptorBindings; variable vertexAttributeBindings std::vector< uint32_t > vertexAttributeBindings; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::GraphicsPipeline"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#ngfxgraphicspipeline","text":"Inherits from ngfx::Pipeline","title":"ngfx::GraphicsPipeline"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-classes","text":"Name struct Descriptor struct State","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-functions","text":"Name GraphicsPipeline * create ( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={}) virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-attributes","text":"Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#additional-inherited-members","text":"Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#function-create","text":"static GraphicsPipeline * create( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={} )","title":"function create"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#function-graphicspipeline","text":"inline virtual ~GraphicsPipeline()","title":"function ~GraphicsPipeline"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#function-getbindings","text":"void getBindings( std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings )","title":"function getBindings"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#variable-descriptorbindings","text":"std::vector< uint32_t > descriptorBindings;","title":"variable descriptorBindings"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#variable-vertexattributebindings","text":"std::vector< uint32_t > vertexAttributeBindings; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable vertexAttributeBindings"},{"location":"api/Classes/classngfx_1_1InputListener/","text":"ngfx::InputListener Inherited by ngfx::BaseApplication , ngfx::Camera Public Functions Name virtual void onKey (KeyCode code, InputAction action) virtual void onScroll (double xoffset, double yoffset) virtual void onCursorPos (double x, double y) virtual void onMouseButton (MouseButton button, InputAction action) Public Functions Documentation function onKey inline virtual void onKey( KeyCode code, InputAction action ) Reimplemented by : ngfx::Camera::onKey function onScroll inline virtual void onScroll( double xoffset, double yoffset ) Reimplemented by : ngfx::Camera::onScroll function onCursorPos inline virtual void onCursorPos( double x, double y ) Reimplemented by : ngfx::Camera::onCursorPos function onMouseButton inline virtual void onMouseButton( MouseButton button, InputAction action ) Reimplemented by : ngfx::Camera::onMouseButton Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::InputListener"},{"location":"api/Classes/classngfx_1_1InputListener/#ngfxinputlistener","text":"Inherited by ngfx::BaseApplication , ngfx::Camera","title":"ngfx::InputListener"},{"location":"api/Classes/classngfx_1_1InputListener/#public-functions","text":"Name virtual void onKey (KeyCode code, InputAction action) virtual void onScroll (double xoffset, double yoffset) virtual void onCursorPos (double x, double y) virtual void onMouseButton (MouseButton button, InputAction action)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1InputListener/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1InputListener/#function-onkey","text":"inline virtual void onKey( KeyCode code, InputAction action ) Reimplemented by : ngfx::Camera::onKey","title":"function onKey"},{"location":"api/Classes/classngfx_1_1InputListener/#function-onscroll","text":"inline virtual void onScroll( double xoffset, double yoffset ) Reimplemented by : ngfx::Camera::onScroll","title":"function onScroll"},{"location":"api/Classes/classngfx_1_1InputListener/#function-oncursorpos","text":"inline virtual void onCursorPos( double x, double y ) Reimplemented by : ngfx::Camera::onCursorPos","title":"function onCursorPos"},{"location":"api/Classes/classngfx_1_1InputListener/#function-onmousebutton","text":"inline virtual void onMouseButton( MouseButton button, InputAction action ) Reimplemented by : ngfx::Camera::onMouseButton Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function onMouseButton"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/","text":"ngfx::MatrixMultiplyCPUOp Inherits from ngfx::MatrixMultiplyOp , ngfx::ComputeOp Public Functions Name MatrixMultiplyCPUOp ( MatrixParam src0, MatrixParam src1, MatrixParam dst) virtual ~MatrixMultiplyCPUOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) override virtual void update ( MatrixParam src0, MatrixParam src1) override void transpose ( MatrixParam & src, MatrixParam & dst) Protected Functions Name void matrixMultiply () Protected Attributes Name std::vector< float > src1t_data MatrixParam src0 MatrixParam src1 MatrixParam src1t MatrixParam dst Additional inherited members Public Classes inherited from ngfx::MatrixMultiplyOp Name struct MatrixParam Public Functions inherited from ngfx::MatrixMultiplyOp Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx Public Functions Documentation function MatrixMultiplyCPUOp MatrixMultiplyCPUOp( MatrixParam src0, MatrixParam src1, MatrixParam dst ) function ~MatrixMultiplyCPUOp virtual ~MatrixMultiplyCPUOp() function apply virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) override Reimplements : ngfx::MatrixMultiplyOp::apply function update virtual void update( MatrixParam src0, MatrixParam src1 ) override Reimplements : ngfx::MatrixMultiplyOp::update function transpose static void transpose( MatrixParam & src, MatrixParam & dst ) Protected Functions Documentation function matrixMultiply void matrixMultiply() Protected Attributes Documentation variable src1t_data std::vector< float > src1t_data; variable src0 MatrixParam src0; variable src1 MatrixParam src1; variable src1t MatrixParam src1t; variable dst MatrixParam dst; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::MatrixMultiplyCPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#ngfxmatrixmultiplycpuop","text":"Inherits from ngfx::MatrixMultiplyOp , ngfx::ComputeOp","title":"ngfx::MatrixMultiplyCPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#public-functions","text":"Name MatrixMultiplyCPUOp ( MatrixParam src0, MatrixParam src1, MatrixParam dst) virtual ~MatrixMultiplyCPUOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) override virtual void update ( MatrixParam src0, MatrixParam src1) override void transpose ( MatrixParam & src, MatrixParam & dst)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#protected-functions","text":"Name void matrixMultiply ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#protected-attributes","text":"Name std::vector< float > src1t_data MatrixParam src0 MatrixParam src1 MatrixParam src1t MatrixParam dst","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#additional-inherited-members","text":"Public Classes inherited from ngfx::MatrixMultiplyOp Name struct MatrixParam Public Functions inherited from ngfx::MatrixMultiplyOp Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-matrixmultiplycpuop","text":"MatrixMultiplyCPUOp( MatrixParam src0, MatrixParam src1, MatrixParam dst )","title":"function MatrixMultiplyCPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-matrixmultiplycpuop_1","text":"virtual ~MatrixMultiplyCPUOp()","title":"function ~MatrixMultiplyCPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-apply","text":"virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) override Reimplements : ngfx::MatrixMultiplyOp::apply","title":"function apply"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-update","text":"virtual void update( MatrixParam src0, MatrixParam src1 ) override Reimplements : ngfx::MatrixMultiplyOp::update","title":"function update"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-transpose","text":"static void transpose( MatrixParam & src, MatrixParam & dst )","title":"function transpose"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-matrixmultiply","text":"void matrixMultiply()","title":"function matrixMultiply"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#variable-src1t_data","text":"std::vector< float > src1t_data;","title":"variable src1t_data"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#variable-src0","text":"MatrixParam src0;","title":"variable src0"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#variable-src1","text":"MatrixParam src1;","title":"variable src1"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#variable-src1t","text":"MatrixParam src1t;","title":"variable src1t"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#variable-dst","text":"MatrixParam dst; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable dst"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/","text":"ngfx::MatrixMultiplyGPUOp Inherits from ngfx::MatrixMultiplyOp , ngfx::ComputeOp Protected Classes Name struct UboData Public Functions Name MatrixMultiplyGPUOp ( GraphicsContext * ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst) virtual ~MatrixMultiplyGPUOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) virtual void update ( MatrixParam src0, MatrixParam src1) Protected Functions Name void createPipeline () Public Attributes Name std::unique_ptr< Buffer > bUbo std::unique_ptr< Buffer > bSrc0 std::unique_ptr< Buffer > bSrc1 std::unique_ptr< Buffer > bDst Protected Attributes Name ComputePipeline * computePipeline uint32_t U_UBO uint32_t SSBO_SRC0 uint32_t SSBO_SRC1 uint32_t SSBO_DST MatrixParam dst Additional inherited members Public Classes inherited from ngfx::MatrixMultiplyOp Name struct MatrixParam Public Functions inherited from ngfx::MatrixMultiplyOp Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx Public Functions Documentation function MatrixMultiplyGPUOp MatrixMultiplyGPUOp( GraphicsContext * ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst ) function ~MatrixMultiplyGPUOp virtual ~MatrixMultiplyGPUOp() function apply virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) Reimplements : ngfx::MatrixMultiplyOp::apply function update virtual void update( MatrixParam src0, MatrixParam src1 ) Protected Functions Documentation function createPipeline void createPipeline() Public Attributes Documentation variable bUbo std::unique_ptr< Buffer > bUbo; variable bSrc0 std::unique_ptr< Buffer > bSrc0; variable bSrc1 std::unique_ptr< Buffer > bSrc1; variable bDst std::unique_ptr< Buffer > bDst; Protected Attributes Documentation variable computePipeline ComputePipeline * computePipeline; variable U_UBO uint32_t U_UBO = 0; variable SSBO_SRC0 uint32_t SSBO_SRC0 = 1; variable SSBO_SRC1 uint32_t SSBO_SRC1 = 2; variable SSBO_DST uint32_t SSBO_DST = 3; variable dst MatrixParam dst; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::MatrixMultiplyGPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#ngfxmatrixmultiplygpuop","text":"Inherits from ngfx::MatrixMultiplyOp , ngfx::ComputeOp","title":"ngfx::MatrixMultiplyGPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#protected-classes","text":"Name struct UboData","title":"Protected Classes"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#public-functions","text":"Name MatrixMultiplyGPUOp ( GraphicsContext * ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst) virtual ~MatrixMultiplyGPUOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) virtual void update ( MatrixParam src0, MatrixParam src1)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#protected-functions","text":"Name void createPipeline ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#public-attributes","text":"Name std::unique_ptr< Buffer > bUbo std::unique_ptr< Buffer > bSrc0 std::unique_ptr< Buffer > bSrc1 std::unique_ptr< Buffer > bDst","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#protected-attributes","text":"Name ComputePipeline * computePipeline uint32_t U_UBO uint32_t SSBO_SRC0 uint32_t SSBO_SRC1 uint32_t SSBO_DST MatrixParam dst","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#additional-inherited-members","text":"Public Classes inherited from ngfx::MatrixMultiplyOp Name struct MatrixParam Public Functions inherited from ngfx::MatrixMultiplyOp Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#function-matrixmultiplygpuop","text":"MatrixMultiplyGPUOp( GraphicsContext * ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst )","title":"function MatrixMultiplyGPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#function-matrixmultiplygpuop_1","text":"virtual ~MatrixMultiplyGPUOp()","title":"function ~MatrixMultiplyGPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#function-apply","text":"virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) Reimplements : ngfx::MatrixMultiplyOp::apply","title":"function apply"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#function-update","text":"virtual void update( MatrixParam src0, MatrixParam src1 )","title":"function update"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#function-createpipeline","text":"void createPipeline()","title":"function createPipeline"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-bubo","text":"std::unique_ptr< Buffer > bUbo;","title":"variable bUbo"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-bsrc0","text":"std::unique_ptr< Buffer > bSrc0;","title":"variable bSrc0"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-bsrc1","text":"std::unique_ptr< Buffer > bSrc1;","title":"variable bSrc1"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-bdst","text":"std::unique_ptr< Buffer > bDst;","title":"variable bDst"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-computepipeline","text":"ComputePipeline * computePipeline;","title":"variable computePipeline"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-u_ubo","text":"uint32_t U_UBO = 0;","title":"variable U_UBO"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-ssbo_src0","text":"uint32_t SSBO_SRC0 = 1;","title":"variable SSBO_SRC0"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-ssbo_src1","text":"uint32_t SSBO_SRC1 = 2;","title":"variable SSBO_SRC1"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-ssbo_dst","text":"uint32_t SSBO_DST = 3;","title":"variable SSBO_DST"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-dst","text":"MatrixParam dst; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable dst"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/","text":"ngfx::MatrixMultiplyOp Inherits from ngfx::ComputeOp Inherited by ngfx::MatrixMultiplyCPUOp , ngfx::MatrixMultiplyGPUOp Public Classes Name struct MatrixParam Public Functions Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) override =0 virtual void update ( MatrixParam src0, MatrixParam src1) =0 Additional inherited members Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx Public Functions Documentation function MatrixMultiplyOp inline MatrixMultiplyOp( GraphicsContext * ctx ) function ~MatrixMultiplyOp inline virtual ~MatrixMultiplyOp() function apply virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) override =0 Reimplements : ngfx::ComputeOp::apply Reimplemented by : ngfx::MatrixMultiplyGPUOp::apply , ngfx::MatrixMultiplyCPUOp::apply function update virtual void update( MatrixParam src0, MatrixParam src1 ) =0 Reimplemented by : ngfx::MatrixMultiplyCPUOp::update Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::MatrixMultiplyOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#ngfxmatrixmultiplyop","text":"Inherits from ngfx::ComputeOp Inherited by ngfx::MatrixMultiplyCPUOp , ngfx::MatrixMultiplyGPUOp","title":"ngfx::MatrixMultiplyOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#public-classes","text":"Name struct MatrixParam","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#public-functions","text":"Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) override =0 virtual void update ( MatrixParam src0, MatrixParam src1) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#function-matrixmultiplyop","text":"inline MatrixMultiplyOp( GraphicsContext * ctx )","title":"function MatrixMultiplyOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#function-matrixmultiplyop_1","text":"inline virtual ~MatrixMultiplyOp()","title":"function ~MatrixMultiplyOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#function-apply","text":"virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) override =0 Reimplements : ngfx::ComputeOp::apply Reimplemented by : ngfx::MatrixMultiplyGPUOp::apply , ngfx::MatrixMultiplyCPUOp::apply","title":"function apply"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#function-update","text":"virtual void update( MatrixParam src0, MatrixParam src1 ) =0 Reimplemented by : ngfx::MatrixMultiplyCPUOp::update Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function update"},{"location":"api/Classes/classngfx_1_1Pipeline/","text":"ngfx::Pipeline Inherited by ngfx::ComputePipeline , ngfx::GraphicsPipeline Public Functions Name virtual ~Pipeline () Public Functions Documentation function ~Pipeline inline virtual ~Pipeline() Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Pipeline"},{"location":"api/Classes/classngfx_1_1Pipeline/#ngfxpipeline","text":"Inherited by ngfx::ComputePipeline , ngfx::GraphicsPipeline","title":"ngfx::Pipeline"},{"location":"api/Classes/classngfx_1_1Pipeline/#public-functions","text":"Name virtual ~Pipeline ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Pipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Pipeline/#function-pipeline","text":"inline virtual ~Pipeline() Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function ~Pipeline"},{"location":"api/Classes/classngfx_1_1PipelineCache/","text":"ngfx::PipelineCache Public Functions Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value) Public Functions Documentation function ~PipelineCache inline virtual ~PipelineCache() function get virtual Pipeline * get( const std::string & key ) function add virtual void add( const std::string & key, Pipeline * value ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::PipelineCache"},{"location":"api/Classes/classngfx_1_1PipelineCache/#ngfxpipelinecache","text":"","title":"ngfx::PipelineCache"},{"location":"api/Classes/classngfx_1_1PipelineCache/#public-functions","text":"Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1PipelineCache/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1PipelineCache/#function-pipelinecache","text":"inline virtual ~PipelineCache()","title":"function ~PipelineCache"},{"location":"api/Classes/classngfx_1_1PipelineCache/#function-get","text":"virtual Pipeline * get( const std::string & key )","title":"function get"},{"location":"api/Classes/classngfx_1_1PipelineCache/#function-add","text":"virtual void add( const std::string & key, Pipeline * value ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function add"},{"location":"api/Classes/classngfx_1_1ProcessUtil/","text":"ngfx::ProcessUtil Public Functions Name int getPID () Public Functions Documentation function getPID static int getPID() Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ProcessUtil"},{"location":"api/Classes/classngfx_1_1ProcessUtil/#ngfxprocessutil","text":"","title":"ngfx::ProcessUtil"},{"location":"api/Classes/classngfx_1_1ProcessUtil/#public-functions","text":"Name int getPID ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ProcessUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ProcessUtil/#function-getpid","text":"static int getPID() Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function getPID"},{"location":"api/Classes/classngfx_1_1Queue/","text":"ngfx::Queue Public Functions Name virtual ~Queue () virtual void present () =0 virtual void submit ( CommandBuffer * commandBuffer) =0 virtual void waitIdle () =0 Public Functions Documentation function ~Queue inline virtual ~Queue() function present virtual void present() =0 function submit virtual void submit( CommandBuffer * commandBuffer ) =0 function waitIdle virtual void waitIdle() =0 Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Queue"},{"location":"api/Classes/classngfx_1_1Queue/#ngfxqueue","text":"","title":"ngfx::Queue"},{"location":"api/Classes/classngfx_1_1Queue/#public-functions","text":"Name virtual ~Queue () virtual void present () =0 virtual void submit ( CommandBuffer * commandBuffer) =0 virtual void waitIdle () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Queue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Queue/#function-queue","text":"inline virtual ~Queue()","title":"function ~Queue"},{"location":"api/Classes/classngfx_1_1Queue/#function-present","text":"virtual void present() =0","title":"function present"},{"location":"api/Classes/classngfx_1_1Queue/#function-submit","text":"virtual void submit( CommandBuffer * commandBuffer ) =0","title":"function submit"},{"location":"api/Classes/classngfx_1_1Queue/#function-waitidle","text":"virtual void waitIdle() =0 Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1RegexUtil/","text":"ngfx::RegexUtil Public Classes Name struct Match Public Functions Name std::vector< Match > findAll (const std::regex & p, std::string contents) Public Functions Documentation function findAll static std::vector< Match > findAll( const std::regex & p, std::string contents ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::RegexUtil"},{"location":"api/Classes/classngfx_1_1RegexUtil/#ngfxregexutil","text":"","title":"ngfx::RegexUtil"},{"location":"api/Classes/classngfx_1_1RegexUtil/#public-classes","text":"Name struct Match","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1RegexUtil/#public-functions","text":"Name std::vector< Match > findAll (const std::regex & p, std::string contents)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1RegexUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1RegexUtil/#function-findall","text":"static std::vector< Match > findAll( const std::regex & p, std::string contents ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function findAll"},{"location":"api/Classes/classngfx_1_1RenderPass/","text":"ngfx::RenderPass Public Functions Name virtual ~RenderPass () Public Attributes Name Framebuffer * currentFramebuffer Public Functions Documentation function ~RenderPass inline virtual ~RenderPass() Public Attributes Documentation variable currentFramebuffer Framebuffer * currentFramebuffer = nullptr; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::RenderPass"},{"location":"api/Classes/classngfx_1_1RenderPass/#ngfxrenderpass","text":"","title":"ngfx::RenderPass"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-functions","text":"Name virtual ~RenderPass ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-attributes","text":"Name Framebuffer * currentFramebuffer","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1RenderPass/#function-renderpass","text":"inline virtual ~RenderPass()","title":"function ~RenderPass"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1RenderPass/#variable-currentframebuffer","text":"Framebuffer * currentFramebuffer = nullptr; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable currentFramebuffer"},{"location":"api/Classes/classngfx_1_1Semaphore/","text":"ngfx::Semaphore Public Functions Name Semaphore * create ( Device * device) virtual ~Semaphore () virtual uint64_t wait () =0 virtual void signal (uint64_t value =1) =0 Public Functions Documentation function create static Semaphore * create( Device * device ) function ~Semaphore inline virtual ~Semaphore() function wait virtual uint64_t wait() =0 function signal virtual void signal( uint64_t value =1 ) =0 Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Semaphore"},{"location":"api/Classes/classngfx_1_1Semaphore/#ngfxsemaphore","text":"","title":"ngfx::Semaphore"},{"location":"api/Classes/classngfx_1_1Semaphore/#public-functions","text":"Name Semaphore * create ( Device * device) virtual ~Semaphore () virtual uint64_t wait () =0 virtual void signal (uint64_t value =1) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Semaphore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-create","text":"static Semaphore * create( Device * device )","title":"function create"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-semaphore","text":"inline virtual ~Semaphore()","title":"function ~Semaphore"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-wait","text":"virtual uint64_t wait() =0","title":"function wait"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-signal","text":"virtual void signal( uint64_t value =1 ) =0 Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function signal"},{"location":"api/Classes/classngfx_1_1ShaderModule/","text":"ngfx::ShaderModule Inherited by ngfx::ComputeShaderModule , ngfx::FragmentShaderModule , ngfx::VertexShaderModule Public Classes Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Types Documentation typedef DescriptorInfos typedef std::vector<DescriptorInfo> ngfx::ShaderModule::DescriptorInfos; typedef BufferMemberInfos typedef std::map<std::string, BufferMemberInfo> ngfx::ShaderModule::BufferMemberInfos; typedef BufferInfos typedef std::map<std::string, BufferInfo> ngfx::ShaderModule::BufferInfos; Public Functions Documentation function ~ShaderModule inline virtual ~ShaderModule() function findDescriptorInfo inline DescriptorInfo * findDescriptorInfo( const std::string & name ) function findUniformBufferInfo inline BufferInfo * findUniformBufferInfo( const std::string & name ) function findStorageBufferInfo inline BufferInfo * findStorageBufferInfo( const std::string & name ) function initBindings void initBindings( std::ifstream & in, ShaderStageFlags shaderStages ) function initBindings void initBindings( const std::string & filename, ShaderStageFlags shaderStages ) Public Attributes Documentation variable descriptors DescriptorInfos descriptors; variable uniformBufferInfos BufferInfos uniformBufferInfos; variable shaderStorageBufferInfos BufferInfos shaderStorageBufferInfos; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ShaderModule"},{"location":"api/Classes/classngfx_1_1ShaderModule/#ngfxshadermodule","text":"Inherited by ngfx::ComputeShaderModule , ngfx::FragmentShaderModule , ngfx::VertexShaderModule","title":"ngfx::ShaderModule"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-classes","text":"Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-types","text":"Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos","title":"Public Types"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-functions","text":"Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-attributes","text":"Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1ShaderModule/#typedef-descriptorinfos","text":"typedef std::vector<DescriptorInfo> ngfx::ShaderModule::DescriptorInfos;","title":"typedef DescriptorInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#typedef-buffermemberinfos","text":"typedef std::map<std::string, BufferMemberInfo> ngfx::ShaderModule::BufferMemberInfos;","title":"typedef BufferMemberInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#typedef-bufferinfos","text":"typedef std::map<std::string, BufferInfo> ngfx::ShaderModule::BufferInfos;","title":"typedef BufferInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-shadermodule","text":"inline virtual ~ShaderModule()","title":"function ~ShaderModule"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-finddescriptorinfo","text":"inline DescriptorInfo * findDescriptorInfo( const std::string & name )","title":"function findDescriptorInfo"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-finduniformbufferinfo","text":"inline BufferInfo * findUniformBufferInfo( const std::string & name )","title":"function findUniformBufferInfo"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-findstoragebufferinfo","text":"inline BufferInfo * findStorageBufferInfo( const std::string & name )","title":"function findStorageBufferInfo"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-initbindings","text":"void initBindings( std::ifstream & in, ShaderStageFlags shaderStages )","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-initbindings_1","text":"void initBindings( const std::string & filename, ShaderStageFlags shaderStages )","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1ShaderModule/#variable-descriptors","text":"DescriptorInfos descriptors;","title":"variable descriptors"},{"location":"api/Classes/classngfx_1_1ShaderModule/#variable-uniformbufferinfos","text":"BufferInfos uniformBufferInfos;","title":"variable uniformBufferInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#variable-shaderstoragebufferinfos","text":"BufferInfos shaderStorageBufferInfos; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable shaderStorageBufferInfos"},{"location":"api/Classes/classngfx_1_1ShaderTools/","text":"ngfx::ShaderTools Public Classes Name struct MacroDefinition Public Types Name enum @1 { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2} enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL} typedef std::vector< MacroDefinition > MacroDefinitions Public Functions Name ShaderTools (bool verbose =false) std::vector< std::string > compileShaders (const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0) std::vector< std::string > convertShaders (const std::vector< std::string > & files, std::string outDir, Format fmt) std::vector< std::string > generateShaderMaps (const std::vector< std::string > & files, std::string outDir, Format fmt) Public Types Documentation enum @1 Enumerator Value Description PATCH_SHADER_LAYOUTS_GLSL 1 REMOVE_UNUSED_VARIABLES 2 enum Format Enumerator Value Description FORMAT_GLSL FORMAT_HLSL FORMAT_MSL typedef MacroDefinitions typedef std::vector<MacroDefinition> ngfx::ShaderTools::MacroDefinitions; Public Functions Documentation function ShaderTools ShaderTools( bool verbose =false ) function compileShaders std::vector< std::string > compileShaders( const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0 ) function convertShaders std::vector< std::string > convertShaders( const std::vector< std::string > & files, std::string outDir, Format fmt ) function generateShaderMaps std::vector< std::string > generateShaderMaps( const std::vector< std::string > & files, std::string outDir, Format fmt ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ShaderTools"},{"location":"api/Classes/classngfx_1_1ShaderTools/#ngfxshadertools","text":"","title":"ngfx::ShaderTools"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-classes","text":"Name struct MacroDefinition","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-types","text":"Name enum @1 { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2} enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL} typedef std::vector< MacroDefinition > MacroDefinitions","title":"Public Types"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-functions","text":"Name ShaderTools (bool verbose =false) std::vector< std::string > compileShaders (const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0) std::vector< std::string > convertShaders (const std::vector< std::string > & files, std::string outDir, Format fmt) std::vector< std::string > generateShaderMaps (const std::vector< std::string > & files, std::string outDir, Format fmt)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1ShaderTools/#enum-1","text":"Enumerator Value Description PATCH_SHADER_LAYOUTS_GLSL 1 REMOVE_UNUSED_VARIABLES 2","title":"enum @1"},{"location":"api/Classes/classngfx_1_1ShaderTools/#enum-format","text":"Enumerator Value Description FORMAT_GLSL FORMAT_HLSL FORMAT_MSL","title":"enum Format"},{"location":"api/Classes/classngfx_1_1ShaderTools/#typedef-macrodefinitions","text":"typedef std::vector<MacroDefinition> ngfx::ShaderTools::MacroDefinitions;","title":"typedef MacroDefinitions"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-shadertools","text":"ShaderTools( bool verbose =false )","title":"function ShaderTools"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-compileshaders","text":"std::vector< std::string > compileShaders( const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0 )","title":"function compileShaders"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-convertshaders","text":"std::vector< std::string > convertShaders( const std::vector< std::string > & files, std::string outDir, Format fmt )","title":"function convertShaders"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-generateshadermaps","text":"std::vector< std::string > generateShaderMaps( const std::vector< std::string > & files, std::string outDir, Format fmt ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function generateShaderMaps"},{"location":"api/Classes/classngfx_1_1StringUtil/","text":"ngfx::StringUtil Public Functions Name std::string toLower (const std::string & str) std::wstring toWString (const std::string & str) Public Functions Documentation function toLower static std::string toLower( const std::string & str ) function toWString static std::wstring toWString( const std::string & str ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::StringUtil"},{"location":"api/Classes/classngfx_1_1StringUtil/#ngfxstringutil","text":"","title":"ngfx::StringUtil"},{"location":"api/Classes/classngfx_1_1StringUtil/#public-functions","text":"Name std::string toLower (const std::string & str) std::wstring toWString (const std::string & str)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1StringUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1StringUtil/#function-tolower","text":"static std::string toLower( const std::string & str )","title":"function toLower"},{"location":"api/Classes/classngfx_1_1StringUtil/#function-towstring","text":"static std::wstring toWString( const std::string & str ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function toWString"},{"location":"api/Classes/classngfx_1_1Surface/","text":"ngfx::Surface Public Functions Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface () Public Attributes Name uint32_t w uint32_t h bool offscreen Public Functions Documentation function Surface inline Surface() function Surface inline Surface( uint32_t w, uint32_t h, bool offscreen =false ) function ~Surface inline virtual ~Surface() Public Attributes Documentation variable w uint32_t w = 0; variable h uint32_t h = 0; variable offscreen bool offscreen = false; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Surface"},{"location":"api/Classes/classngfx_1_1Surface/#ngfxsurface","text":"","title":"ngfx::Surface"},{"location":"api/Classes/classngfx_1_1Surface/#public-functions","text":"Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Surface/#public-attributes","text":"Name uint32_t w uint32_t h bool offscreen","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Surface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Surface/#function-surface","text":"inline Surface()","title":"function Surface"},{"location":"api/Classes/classngfx_1_1Surface/#function-surface_1","text":"inline Surface( uint32_t w, uint32_t h, bool offscreen =false )","title":"function Surface"},{"location":"api/Classes/classngfx_1_1Surface/#function-surface_2","text":"inline virtual ~Surface()","title":"function ~Surface"},{"location":"api/Classes/classngfx_1_1Surface/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Surface/#variable-w","text":"uint32_t w = 0;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Surface/#variable-h","text":"uint32_t h = 0;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Surface/#variable-offscreen","text":"bool offscreen = false; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable offscreen"},{"location":"api/Classes/classngfx_1_1Swapchain/","text":"ngfx::Swapchain Public Functions Name virtual ~Swapchain () virtual void acquireNextImage () =0 Public Attributes Name uint32_t numImages Public Functions Documentation function ~Swapchain inline virtual ~Swapchain() function acquireNextImage virtual void acquireNextImage() =0 Public Attributes Documentation variable numImages uint32_t numImages; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Swapchain"},{"location":"api/Classes/classngfx_1_1Swapchain/#ngfxswapchain","text":"","title":"ngfx::Swapchain"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-functions","text":"Name virtual ~Swapchain () virtual void acquireNextImage () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-attributes","text":"Name uint32_t numImages","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Swapchain/#function-swapchain","text":"inline virtual ~Swapchain()","title":"function ~Swapchain"},{"location":"api/Classes/classngfx_1_1Swapchain/#function-acquirenextimage","text":"virtual void acquireNextImage() =0","title":"function acquireNextImage"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Swapchain/#variable-numimages","text":"uint32_t numImages; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable numImages"},{"location":"api/Classes/classngfx_1_1Texture/","text":"ngfx::Texture Public Functions Name Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT virtual ~Texture () virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) =0 virtual void generateMipmaps ( CommandBuffer * commandBuffer) =0 Public Attributes Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType Public Functions Documentation function create static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 ) function create static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 ) function ~Texture inline virtual ~Texture() function upload virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0 function download virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0 function changeLayout virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) =0 function generateMipmaps virtual void generateMipmaps( CommandBuffer * commandBuffer ) =0 Public Attributes Documentation variable format PixelFormat format; variable w uint32_t w = 0; variable h uint32_t h = 0; variable d uint32_t d = 1; variable arrayLayers uint32_t arrayLayers = 1; variable mipLevels uint32_t mipLevels = 1; variable numSamples uint32_t numSamples = 1; variable imageUsageFlags ImageUsageFlags imageUsageFlags; variable textureType TextureType textureType; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Texture"},{"location":"api/Classes/classngfx_1_1Texture/#ngfxtexture","text":"","title":"ngfx::Texture"},{"location":"api/Classes/classngfx_1_1Texture/#public-functions","text":"Name Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT virtual ~Texture () virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) =0 virtual void generateMipmaps ( CommandBuffer * commandBuffer) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Texture/#public-attributes","text":"Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Texture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Texture/#function-create","text":"static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1Texture/#function-create_1","text":"static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1Texture/#function-texture","text":"inline virtual ~Texture()","title":"function ~Texture"},{"location":"api/Classes/classngfx_1_1Texture/#function-upload","text":"virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0","title":"function upload"},{"location":"api/Classes/classngfx_1_1Texture/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0","title":"function download"},{"location":"api/Classes/classngfx_1_1Texture/#function-changelayout","text":"virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) =0","title":"function changeLayout"},{"location":"api/Classes/classngfx_1_1Texture/#function-generatemipmaps","text":"virtual void generateMipmaps( CommandBuffer * commandBuffer ) =0","title":"function generateMipmaps"},{"location":"api/Classes/classngfx_1_1Texture/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Texture/#variable-format","text":"PixelFormat format;","title":"variable format"},{"location":"api/Classes/classngfx_1_1Texture/#variable-w","text":"uint32_t w = 0;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Texture/#variable-h","text":"uint32_t h = 0;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Texture/#variable-d","text":"uint32_t d = 1;","title":"variable d"},{"location":"api/Classes/classngfx_1_1Texture/#variable-arraylayers","text":"uint32_t arrayLayers = 1;","title":"variable arrayLayers"},{"location":"api/Classes/classngfx_1_1Texture/#variable-miplevels","text":"uint32_t mipLevels = 1;","title":"variable mipLevels"},{"location":"api/Classes/classngfx_1_1Texture/#variable-numsamples","text":"uint32_t numSamples = 1;","title":"variable numSamples"},{"location":"api/Classes/classngfx_1_1Texture/#variable-imageusageflags","text":"ImageUsageFlags imageUsageFlags;","title":"variable imageUsageFlags"},{"location":"api/Classes/classngfx_1_1Texture/#variable-texturetype","text":"TextureType textureType; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable textureType"},{"location":"api/Classes/classngfx_1_1Timer/","text":"ngfx::Timer Public Functions Name Timer () void update () Public Attributes Name float elapsed std::chrono::system_clock::time_point t0 Public Functions Documentation function Timer Timer() function update void update() Public Attributes Documentation variable elapsed float elapsed; variable t0 std::chrono::system_clock::time_point t0; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Timer"},{"location":"api/Classes/classngfx_1_1Timer/#ngfxtimer","text":"","title":"ngfx::Timer"},{"location":"api/Classes/classngfx_1_1Timer/#public-functions","text":"Name Timer () void update ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Timer/#public-attributes","text":"Name float elapsed std::chrono::system_clock::time_point t0","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Timer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Timer/#function-timer","text":"Timer()","title":"function Timer"},{"location":"api/Classes/classngfx_1_1Timer/#function-update","text":"void update()","title":"function update"},{"location":"api/Classes/classngfx_1_1Timer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Timer/#variable-elapsed","text":"float elapsed;","title":"variable elapsed"},{"location":"api/Classes/classngfx_1_1Timer/#variable-t0","text":"std::chrono::system_clock::time_point t0; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable t0"},{"location":"api/Classes/classngfx_1_1Util/","text":"ngfx::Util Public Functions Name template <typename T > bool contains (std::vector< T > & v, T item) uint64_t hash (const std::string & s) Public Functions Documentation function contains template <typename T > static inline bool contains( std::vector< T > & v, T item ) function hash static uint64_t hash( const std::string & s ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Util"},{"location":"api/Classes/classngfx_1_1Util/#ngfxutil","text":"","title":"ngfx::Util"},{"location":"api/Classes/classngfx_1_1Util/#public-functions","text":"Name template <typename T > bool contains (std::vector< T > & v, T item) uint64_t hash (const std::string & s)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Util/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Util/#function-contains","text":"template <typename T > static inline bool contains( std::vector< T > & v, T item )","title":"function contains"},{"location":"api/Classes/classngfx_1_1Util/#function-hash","text":"static uint64_t hash( const std::string & s ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function hash"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/","text":"ngfx::VertexShaderModule Inherits from ngfx::ShaderModule Public Classes Name struct AttributeDescription Public Functions Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename) Public Attributes Name std::vector< AttributeDescription > attributes Additional inherited members Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function create static std::unique_ptr< VertexShaderModule > create( Device * device, const std::string & filename ) function ~VertexShaderModule inline virtual ~VertexShaderModule() function findAttribute inline AttributeDescription * findAttribute( const std::string & name ) function initBindings void initBindings( const std::string & filename ) Public Attributes Documentation variable attributes std::vector< AttributeDescription > attributes; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::VertexShaderModule"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#ngfxvertexshadermodule","text":"Inherits from ngfx::ShaderModule","title":"ngfx::VertexShaderModule"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-classes","text":"Name struct AttributeDescription","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-functions","text":"Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-attributes","text":"Name std::vector< AttributeDescription > attributes","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-create","text":"static std::unique_ptr< VertexShaderModule > create( Device * device, const std::string & filename )","title":"function create"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-vertexshadermodule","text":"inline virtual ~VertexShaderModule()","title":"function ~VertexShaderModule"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-findattribute","text":"inline AttributeDescription * findAttribute( const std::string & name )","title":"function findAttribute"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-initbindings","text":"void initBindings( const std::string & filename )","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#variable-attributes","text":"std::vector< AttributeDescription > attributes; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable attributes"},{"location":"api/Classes/classngfx_1_1Window/","text":"ngfx::Window Public Types Name enum @2 { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1} Public Functions Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () virtual bool shouldClose () =0 virtual void pollEvents () =0 Public Attributes Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton Public Types Documentation enum @2 Enumerator Value Description DISPLAY_WIDTH -1 DISPLAY_HEIGHT -1 Public Functions Documentation function create static Window * create( GraphicsContext * graphicsContext, const char * title, std::function< void(Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT ) function ~Window inline virtual ~Window() function shouldClose virtual bool shouldClose() =0 function pollEvents virtual void pollEvents() =0 Public Attributes Documentation variable w int w; variable h int h; variable surface Surface * surface = nullptr; variable onUpdate std::function< void()> onUpdate = nullptr; variable onPaint std::function< void()> onPaint = nullptr; variable onKey std::function< void(KeyCode code, InputAction action)> onKey = nullptr; variable onScroll std::function< void(double xoffset, double yoffset)> onScroll = nullptr; variable onCursorPos std::function< void(double x, double y)> onCursorPos = nullptr; variable onMouseButton std::function< void(MouseButton button, InputAction action)> onMouseButton = nullptr; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Window"},{"location":"api/Classes/classngfx_1_1Window/#ngfxwindow","text":"","title":"ngfx::Window"},{"location":"api/Classes/classngfx_1_1Window/#public-types","text":"Name enum @2 { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1}","title":"Public Types"},{"location":"api/Classes/classngfx_1_1Window/#public-functions","text":"Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () virtual bool shouldClose () =0 virtual void pollEvents () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Window/#public-attributes","text":"Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Window/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1Window/#enum-2","text":"Enumerator Value Description DISPLAY_WIDTH -1 DISPLAY_HEIGHT -1","title":"enum @2"},{"location":"api/Classes/classngfx_1_1Window/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Window/#function-create","text":"static Window * create( GraphicsContext * graphicsContext, const char * title, std::function< void(Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT )","title":"function create"},{"location":"api/Classes/classngfx_1_1Window/#function-window","text":"inline virtual ~Window()","title":"function ~Window"},{"location":"api/Classes/classngfx_1_1Window/#function-shouldclose","text":"virtual bool shouldClose() =0","title":"function shouldClose"},{"location":"api/Classes/classngfx_1_1Window/#function-pollevents","text":"virtual void pollEvents() =0","title":"function pollEvents"},{"location":"api/Classes/classngfx_1_1Window/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Window/#variable-w","text":"int w;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Window/#variable-h","text":"int h;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Window/#variable-surface","text":"Surface * surface = nullptr;","title":"variable surface"},{"location":"api/Classes/classngfx_1_1Window/#variable-onupdate","text":"std::function< void()> onUpdate = nullptr;","title":"variable onUpdate"},{"location":"api/Classes/classngfx_1_1Window/#variable-onpaint","text":"std::function< void()> onPaint = nullptr;","title":"variable onPaint"},{"location":"api/Classes/classngfx_1_1Window/#variable-onkey","text":"std::function< void(KeyCode code, InputAction action)> onKey = nullptr;","title":"variable onKey"},{"location":"api/Classes/classngfx_1_1Window/#variable-onscroll","text":"std::function< void(double xoffset, double yoffset)> onScroll = nullptr;","title":"variable onScroll"},{"location":"api/Classes/classngfx_1_1Window/#variable-oncursorpos","text":"std::function< void(double x, double y)> onCursorPos = nullptr;","title":"variable onCursorPos"},{"location":"api/Classes/classngfx_1_1Window/#variable-onmousebutton","text":"std::function< void(MouseButton button, InputAction action)> onMouseButton = nullptr; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable onMouseButton"},{"location":"api/Classes/structDebugUtil/","text":"DebugUtil Public Functions Name void Exit (uint32_t code) Public Functions Documentation function Exit static inline void Exit( uint32_t code ) Updated on 14 March 2021 at 11:29:16 Pacific Daylight Time","title":"DebugUtil"},{"location":"api/Classes/structDebugUtil/#debugutil","text":"","title":"DebugUtil"},{"location":"api/Classes/structDebugUtil/#public-functions","text":"Name void Exit (uint32_t code)","title":"Public Functions"},{"location":"api/Classes/structDebugUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structDebugUtil/#function-exit","text":"static inline void Exit( uint32_t code ) Updated on 14 March 2021 at 11:29:16 Pacific Daylight Time","title":"function Exit"},{"location":"api/Classes/structVertexFormatInfo/","text":"VertexFormatInfo Public Attributes Name VertexFormat format uint32_t count uint32_t elementSize Public Attributes Documentation variable format VertexFormat format; variable count uint32_t count; variable elementSize uint32_t elementSize; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"VertexFormatInfo"},{"location":"api/Classes/structVertexFormatInfo/#vertexformatinfo","text":"","title":"VertexFormatInfo"},{"location":"api/Classes/structVertexFormatInfo/#public-attributes","text":"Name VertexFormat format uint32_t count uint32_t elementSize","title":"Public Attributes"},{"location":"api/Classes/structVertexFormatInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structVertexFormatInfo/#variable-format","text":"VertexFormat format;","title":"variable format"},{"location":"api/Classes/structVertexFormatInfo/#variable-count","text":"uint32_t count;","title":"variable count"},{"location":"api/Classes/structVertexFormatInfo/#variable-elementsize","text":"uint32_t elementSize; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable elementSize"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/","text":"ngfx::DrawMeshOp::LightData Public Attributes Name vec4 ambient vec4 diffuse vec4 specular vec4 lightViewPos vec2 shininess vec2 padding Public Attributes Documentation variable ambient vec4 ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f); variable diffuse vec4 diffuse = vec4(1.0f); variable specular vec4 specular = vec4(1.0f); variable lightViewPos vec4 lightViewPos = vec4(0.0f, 0.0f, 1.0f, 1.0f); variable shininess vec2 shininess = vec2(10.0f, 0.0f); variable padding vec2 padding; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::DrawMeshOp::LightData"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#ngfxdrawmeshoplightdata","text":"","title":"ngfx::DrawMeshOp::LightData"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#public-attributes","text":"Name vec4 ambient vec4 diffuse vec4 specular vec4 lightViewPos vec2 shininess vec2 padding","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-ambient","text":"vec4 ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f);","title":"variable ambient"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-diffuse","text":"vec4 diffuse = vec4(1.0f);","title":"variable diffuse"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-specular","text":"vec4 specular = vec4(1.0f);","title":"variable specular"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-lightviewpos","text":"vec4 lightViewPos = vec4(0.0f, 0.0f, 1.0f, 1.0f);","title":"variable lightViewPos"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-shininess","text":"vec2 shininess = vec2(10.0f, 0.0f);","title":"variable shininess"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-padding","text":"vec2 padding; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable padding"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__FS__Data/","text":"ngfx::DrawMeshOp::UBO_FS_Data Public Attributes Name LightData light0 Public Attributes Documentation variable light0 LightData light0; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::DrawMeshOp::UBO_FS_Data"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__FS__Data/#ngfxdrawmeshopubo_fs_data","text":"","title":"ngfx::DrawMeshOp::UBO_FS_Data"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__FS__Data/#public-attributes","text":"Name LightData light0","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__FS__Data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__FS__Data/#variable-light0","text":"LightData light0; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable light0"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/","text":"ngfx::DrawMeshOp::UBO_VS_Data Public Attributes Name mat4 modelView mat4 modelViewInverseTranspose mat4 modelViewProj Public Attributes Documentation variable modelView mat4 modelView; variable modelViewInverseTranspose mat4 modelViewInverseTranspose; variable modelViewProj mat4 modelViewProj; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::DrawMeshOp::UBO_VS_Data"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#ngfxdrawmeshopubo_vs_data","text":"","title":"ngfx::DrawMeshOp::UBO_VS_Data"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#public-attributes","text":"Name mat4 modelView mat4 modelViewInverseTranspose mat4 modelViewProj","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#variable-modelview","text":"mat4 modelView;","title":"variable modelView"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#variable-modelviewinversetranspose","text":"mat4 modelViewInverseTranspose;","title":"variable modelViewInverseTranspose"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#variable-modelviewproj","text":"mat4 modelViewProj; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable modelViewProj"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/","text":"ngfx::FileUtil::Lock Public Functions Name Lock (const std::string & path, uint32_t timeoutMs =3000) ~Lock () Public Attributes Name std::string lockPath uint32_t timeoutMs Public Functions Documentation function Lock Lock( const std::string & path, uint32_t timeoutMs =3000 ) function ~Lock ~Lock() Public Attributes Documentation variable lockPath std::string lockPath; variable timeoutMs uint32_t timeoutMs; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::FileUtil::Lock"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#ngfxfileutillock","text":"","title":"ngfx::FileUtil::Lock"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#public-functions","text":"Name Lock (const std::string & path, uint32_t timeoutMs =3000) ~Lock ()","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#public-attributes","text":"Name std::string lockPath uint32_t timeoutMs","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#function-lock","text":"Lock( const std::string & path, uint32_t timeoutMs =3000 )","title":"function Lock"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#function-lock_1","text":"~Lock()","title":"function ~Lock"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#variable-lockpath","text":"std::string lockPath;","title":"variable lockPath"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#variable-timeoutms","text":"uint32_t timeoutMs; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable timeoutMs"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/","text":"ngfx::Framebuffer::Attachment Public Attributes Name Texture * texture uint32_t level uint32_t layer Public Attributes Documentation variable texture Texture * texture = nullptr; variable level uint32_t level = 0; variable layer uint32_t layer = 0; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Framebuffer::Attachment"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#ngfxframebufferattachment","text":"","title":"ngfx::Framebuffer::Attachment"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#public-attributes","text":"Name Texture * texture uint32_t level uint32_t layer","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#variable-texture","text":"Texture * texture = nullptr;","title":"variable texture"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#variable-level","text":"uint32_t level = 0;","title":"variable level"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#variable-layer","text":"uint32_t layer = 0; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable layer"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/","text":"ngfx::GraphicsContext::AttachmentDescription Public Functions Name bool operator== (const AttachmentDescription & rhs) const Public Attributes Name PixelFormat format std::optional< ImageLayout > initialLayout std::optional< ImageLayout > finalLayout Public Functions Documentation function operator== inline bool operator==( const AttachmentDescription & rhs ) const Public Attributes Documentation variable format PixelFormat format; variable initialLayout std::optional< ImageLayout > initialLayout; variable finalLayout std::optional< ImageLayout > finalLayout; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::GraphicsContext::AttachmentDescription"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#ngfxgraphicscontextattachmentdescription","text":"","title":"ngfx::GraphicsContext::AttachmentDescription"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-functions","text":"Name bool operator== (const AttachmentDescription & rhs) const","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-attributes","text":"Name PixelFormat format std::optional< ImageLayout > initialLayout std::optional< ImageLayout > finalLayout","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#function-operator","text":"inline bool operator==( const AttachmentDescription & rhs ) const","title":"function operator=="},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#variable-format","text":"PixelFormat format;","title":"variable format"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#variable-initiallayout","text":"std::optional< ImageLayout > initialLayout;","title":"variable initialLayout"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#variable-finallayout","text":"std::optional< ImageLayout > finalLayout; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable finalLayout"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/","text":"ngfx::GraphicsContext::RenderPassConfig Public Functions Name bool operator== (const RenderPassConfig & rhs) const uint32_t numColorAttachments () const Public Attributes Name std::vector< AttachmentDescription > colorAttachmentDescriptions std::optional< AttachmentDescription > depthStencilAttachmentDescription bool enableDepthStencilResolve uint32_t numSamples Public Functions Documentation function operator== inline bool operator==( const RenderPassConfig & rhs ) const function numColorAttachments inline uint32_t numColorAttachments() const Public Attributes Documentation variable colorAttachmentDescriptions std::vector< AttachmentDescription > colorAttachmentDescriptions; variable depthStencilAttachmentDescription std::optional< AttachmentDescription > depthStencilAttachmentDescription; variable enableDepthStencilResolve bool enableDepthStencilResolve = false; variable numSamples uint32_t numSamples = 1; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::GraphicsContext::RenderPassConfig"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#ngfxgraphicscontextrenderpassconfig","text":"","title":"ngfx::GraphicsContext::RenderPassConfig"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-functions","text":"Name bool operator== (const RenderPassConfig & rhs) const uint32_t numColorAttachments () const","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-attributes","text":"Name std::vector< AttachmentDescription > colorAttachmentDescriptions std::optional< AttachmentDescription > depthStencilAttachmentDescription bool enableDepthStencilResolve uint32_t numSamples","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#function-operator","text":"inline bool operator==( const RenderPassConfig & rhs ) const","title":"function operator=="},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#function-numcolorattachments","text":"inline uint32_t numColorAttachments() const","title":"function numColorAttachments"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-colorattachmentdescriptions","text":"std::vector< AttachmentDescription > colorAttachmentDescriptions;","title":"variable colorAttachmentDescriptions"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-depthstencilattachmentdescription","text":"std::optional< AttachmentDescription > depthStencilAttachmentDescription;","title":"variable depthStencilAttachmentDescription"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-enabledepthstencilresolve","text":"bool enableDepthStencilResolve = false;","title":"variable enableDepthStencilResolve"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-numsamples","text":"uint32_t numSamples = 1; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable numSamples"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/","text":"ngfx::GraphicsPipeline::Descriptor Public Attributes Name DescriptorType type ShaderStageFlags stageFlags Public Attributes Documentation variable type DescriptorType type; variable stageFlags ShaderStageFlags stageFlags = SHADER_STAGE_ALL; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::GraphicsPipeline::Descriptor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#ngfxgraphicspipelinedescriptor","text":"","title":"ngfx::GraphicsPipeline::Descriptor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#public-attributes","text":"Name DescriptorType type ShaderStageFlags stageFlags","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#variable-type","text":"DescriptorType type;","title":"variable type"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#variable-stageflags","text":"ShaderStageFlags stageFlags = SHADER_STAGE_ALL; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable stageFlags"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/","text":"ngfx::GraphicsPipeline::State Public Attributes Name PrimitiveTopology primitiveTopology PolygonMode polygonMode bool blendEnable BlendFactor srcColorBlendFactor BlendFactor dstColorBlendFactor BlendFactor srcAlphaBlendFactor BlendFactor dstAlphaBlendFactor BlendOp colorBlendOp BlendOp alphaBlendOp uint8_t colorWriteMask CullModeFlags cullModeFlags FrontFace frontFace float lineWidth bool depthTestEnable bool depthWriteEnable RenderPass * renderPass uint32_t numSamples uint32_t numColorAttachments Public Attributes Documentation variable primitiveTopology PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; variable polygonMode PolygonMode polygonMode = POLYGON_MODE_FILL; variable blendEnable bool blendEnable = false; variable srcColorBlendFactor BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA; variable dstColorBlendFactor BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; variable srcAlphaBlendFactor BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA; variable dstAlphaBlendFactor BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; variable colorBlendOp BlendOp colorBlendOp = BLEND_OP_ADD; variable alphaBlendOp BlendOp alphaBlendOp = BLEND_OP_ADD; variable colorWriteMask uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT; variable cullModeFlags CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT; variable frontFace FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE; variable lineWidth float lineWidth = 1.0f; variable depthTestEnable bool depthTestEnable = false; variable depthWriteEnable bool depthWriteEnable = false; variable renderPass RenderPass * renderPass = nullptr; variable numSamples uint32_t numSamples = 1; variable numColorAttachments uint32_t numColorAttachments = 1; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::GraphicsPipeline::State"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#ngfxgraphicspipelinestate","text":"","title":"ngfx::GraphicsPipeline::State"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#public-attributes","text":"Name PrimitiveTopology primitiveTopology PolygonMode polygonMode bool blendEnable BlendFactor srcColorBlendFactor BlendFactor dstColorBlendFactor BlendFactor srcAlphaBlendFactor BlendFactor dstAlphaBlendFactor BlendOp colorBlendOp BlendOp alphaBlendOp uint8_t colorWriteMask CullModeFlags cullModeFlags FrontFace frontFace float lineWidth bool depthTestEnable bool depthWriteEnable RenderPass * renderPass uint32_t numSamples uint32_t numColorAttachments","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-primitivetopology","text":"PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;","title":"variable primitiveTopology"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-polygonmode","text":"PolygonMode polygonMode = POLYGON_MODE_FILL;","title":"variable polygonMode"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-blendenable","text":"bool blendEnable = false;","title":"variable blendEnable"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-srccolorblendfactor","text":"BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA;","title":"variable srcColorBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-dstcolorblendfactor","text":"BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;","title":"variable dstColorBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-srcalphablendfactor","text":"BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA;","title":"variable srcAlphaBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-dstalphablendfactor","text":"BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;","title":"variable dstAlphaBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-colorblendop","text":"BlendOp colorBlendOp = BLEND_OP_ADD;","title":"variable colorBlendOp"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-alphablendop","text":"BlendOp alphaBlendOp = BLEND_OP_ADD;","title":"variable alphaBlendOp"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-colorwritemask","text":"uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT;","title":"variable colorWriteMask"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-cullmodeflags","text":"CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT;","title":"variable cullModeFlags"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-frontface","text":"FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE;","title":"variable frontFace"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-linewidth","text":"float lineWidth = 1.0f;","title":"variable lineWidth"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-depthtestenable","text":"bool depthTestEnable = false;","title":"variable depthTestEnable"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-depthwriteenable","text":"bool depthWriteEnable = false;","title":"variable depthWriteEnable"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-renderpass","text":"RenderPass * renderPass = nullptr;","title":"variable renderPass"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-numsamples","text":"uint32_t numSamples = 1;","title":"variable numSamples"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-numcolorattachments","text":"uint32_t numColorAttachments = 1; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable numColorAttachments"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/","text":"ngfx::MatrixMultiplyGPUOp::UboData Public Attributes Name int32_t src0_w int32_t src0_h int32_t src1t_w int32_t src1t_h int32_t dst_w int32_t dst_h Public Attributes Documentation variable src0_w int32_t src0_w; variable src0_h int32_t src0_h; variable src1t_w int32_t src1t_w; variable src1t_h int32_t src1t_h; variable dst_w int32_t dst_w; variable dst_h int32_t dst_h; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::MatrixMultiplyGPUOp::UboData"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#ngfxmatrixmultiplygpuopubodata","text":"","title":"ngfx::MatrixMultiplyGPUOp::UboData"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#public-attributes","text":"Name int32_t src0_w int32_t src0_h int32_t src1t_w int32_t src1t_h int32_t dst_w int32_t dst_h","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-src0_w","text":"int32_t src0_w;","title":"variable src0_w"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-src0_h","text":"int32_t src0_h;","title":"variable src0_h"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-src1t_w","text":"int32_t src1t_w;","title":"variable src1t_w"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-src1t_h","text":"int32_t src1t_h;","title":"variable src1t_h"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-dst_w","text":"int32_t dst_w;","title":"variable dst_w"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-dst_h","text":"int32_t dst_h; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable dst_h"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/","text":"ngfx::MatrixMultiplyOp::MatrixParam Public Attributes Name uint32_t w uint32_t h float * data Public Attributes Documentation variable w uint32_t w; variable h uint32_t h; variable data float * data; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::MatrixMultiplyOp::MatrixParam"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#ngfxmatrixmultiplyopmatrixparam","text":"","title":"ngfx::MatrixMultiplyOp::MatrixParam"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#public-attributes","text":"Name uint32_t w uint32_t h float * data","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#variable-w","text":"uint32_t w;","title":"variable w"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#variable-h","text":"uint32_t h;","title":"variable h"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#variable-data","text":"float * data; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable data"},{"location":"api/Classes/structngfx_1_1MeshData/","text":"ngfx::MeshData Public Attributes Name std::vector< vec3 > pos std::vector< vec3 > normal std::vector< ivec3 > faces vec3 bounds Public Attributes Documentation variable pos std::vector< vec3 > pos; variable normal std::vector< vec3 > normal; variable faces std::vector< ivec3 > faces; variable bounds vec3 bounds = {vec3(FLT_MAX), vec3(FLT_MIN)}; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::MeshData"},{"location":"api/Classes/structngfx_1_1MeshData/#ngfxmeshdata","text":"","title":"ngfx::MeshData"},{"location":"api/Classes/structngfx_1_1MeshData/#public-attributes","text":"Name std::vector< vec3 > pos std::vector< vec3 > normal std::vector< ivec3 > faces vec3 bounds","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1MeshData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-pos","text":"std::vector< vec3 > pos;","title":"variable pos"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-normal","text":"std::vector< vec3 > normal;","title":"variable normal"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-faces","text":"std::vector< ivec3 > faces;","title":"variable faces"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-bounds","text":"vec3 bounds = {vec3(FLT_MAX), vec3(FLT_MIN)}; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable bounds"},{"location":"api/Classes/structngfx_1_1MeshUtil/","text":"ngfx::MeshUtil Public Functions Name void importMesh (const std::string & file, MeshData & meshData) void exportMesh (const std::string & file, MeshData & meshData) Public Functions Documentation function importMesh static void importMesh( const std::string & file, MeshData & meshData ) function exportMesh static void exportMesh( const std::string & file, MeshData & meshData ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::MeshUtil"},{"location":"api/Classes/structngfx_1_1MeshUtil/#ngfxmeshutil","text":"","title":"ngfx::MeshUtil"},{"location":"api/Classes/structngfx_1_1MeshUtil/#public-functions","text":"Name void importMesh (const std::string & file, MeshData & meshData) void exportMesh (const std::string & file, MeshData & meshData)","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1MeshUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1MeshUtil/#function-importmesh","text":"static void importMesh( const std::string & file, MeshData & meshData )","title":"function importMesh"},{"location":"api/Classes/structngfx_1_1MeshUtil/#function-exportmesh","text":"static void exportMesh( const std::string & file, MeshData & meshData ) Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function exportMesh"},{"location":"api/Classes/structngfx_1_1Rect2D/","text":"ngfx::Rect2D Public Attributes Name int32_t x int32_t y uint32_t w uint32_t h Public Attributes Documentation variable x int32_t x; variable y int32_t y; variable w uint32_t w; variable h uint32_t h; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::Rect2D"},{"location":"api/Classes/structngfx_1_1Rect2D/#ngfxrect2d","text":"","title":"ngfx::Rect2D"},{"location":"api/Classes/structngfx_1_1Rect2D/#public-attributes","text":"Name int32_t x int32_t y uint32_t w uint32_t h","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1Rect2D/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-x","text":"int32_t x;","title":"variable x"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-y","text":"int32_t y;","title":"variable y"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-w","text":"uint32_t w;","title":"variable w"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-h","text":"uint32_t h; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable h"},{"location":"api/Classes/structngfx_1_1RegexUtil_1_1Match/","text":"ngfx::RegexUtil::Match Public Attributes Name std::vector< std::string > s Public Attributes Documentation variable s std::vector< std::string > s; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::RegexUtil::Match"},{"location":"api/Classes/structngfx_1_1RegexUtil_1_1Match/#ngfxregexutilmatch","text":"","title":"ngfx::RegexUtil::Match"},{"location":"api/Classes/structngfx_1_1RegexUtil_1_1Match/#public-attributes","text":"Name std::vector< std::string > s","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1RegexUtil_1_1Match/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1RegexUtil_1_1Match/#variable-s","text":"std::vector< std::string > s; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable s"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/","text":"ngfx::ShaderModule::BufferInfo Public Attributes Name std::string name uint32_t set ShaderStageFlags shaderStages BufferMemberInfos memberInfos Public Attributes Documentation variable name std::string name; variable set uint32_t set; variable shaderStages ShaderStageFlags shaderStages; variable memberInfos BufferMemberInfos memberInfos; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ShaderModule::BufferInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#ngfxshadermodulebufferinfo","text":"","title":"ngfx::ShaderModule::BufferInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#public-attributes","text":"Name std::string name uint32_t set ShaderStageFlags shaderStages BufferMemberInfos memberInfos","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-set","text":"uint32_t set;","title":"variable set"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-shaderstages","text":"ShaderStageFlags shaderStages;","title":"variable shaderStages"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-memberinfos","text":"BufferMemberInfos memberInfos; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable memberInfos"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/","text":"ngfx::ShaderModule::BufferMemberInfo Public Attributes Name uint32_t offset uint32_t size uint32_t arrayCount uint32_t arrayStride Public Attributes Documentation variable offset uint32_t offset; variable size uint32_t size; variable arrayCount uint32_t arrayCount; variable arrayStride uint32_t arrayStride; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ShaderModule::BufferMemberInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#ngfxshadermodulebuffermemberinfo","text":"","title":"ngfx::ShaderModule::BufferMemberInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#public-attributes","text":"Name uint32_t offset uint32_t size uint32_t arrayCount uint32_t arrayStride","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-offset","text":"uint32_t offset;","title":"variable offset"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-size","text":"uint32_t size;","title":"variable size"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-arraycount","text":"uint32_t arrayCount;","title":"variable arrayCount"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-arraystride","text":"uint32_t arrayStride; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable arrayStride"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/","text":"ngfx::ShaderModule::DescriptorInfo Public Attributes Name std::string name uint32_t set DescriptorType type Public Attributes Documentation variable name std::string name; variable set uint32_t set; variable type DescriptorType type; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ShaderModule::DescriptorInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#ngfxshadermoduledescriptorinfo","text":"","title":"ngfx::ShaderModule::DescriptorInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#public-attributes","text":"Name std::string name uint32_t set DescriptorType type","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#variable-set","text":"uint32_t set;","title":"variable set"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#variable-type","text":"DescriptorType type; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable type"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/","text":"ngfx::ShaderTools::HLSLReflectData Public Attributes Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures Public Attributes Documentation variable attributes std::vector< RegexUtil::Match > attributes; variable buffers std::vector< RegexUtil::Match > buffers; variable textures std::vector< RegexUtil::Match > textures; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ShaderTools::HLSLReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#ngfxshadertoolshlslreflectdata","text":"","title":"ngfx::ShaderTools::HLSLReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#public-attributes","text":"Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#variable-attributes","text":"std::vector< RegexUtil::Match > attributes;","title":"variable attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#variable-buffers","text":"std::vector< RegexUtil::Match > buffers;","title":"variable buffers"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#variable-textures","text":"std::vector< RegexUtil::Match > textures; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable textures"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/","text":"ngfx::ShaderTools::MacroDefinition Public Attributes Name std::string name std::string value Public Attributes Documentation variable name std::string name; variable value std::string value; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ShaderTools::MacroDefinition"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#ngfxshadertoolsmacrodefinition","text":"","title":"ngfx::ShaderTools::MacroDefinition"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#public-attributes","text":"Name std::string name std::string value","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#variable-value","text":"std::string value; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable value"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/","text":"ngfx::ShaderTools::MetalReflectData Public Attributes Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures Public Attributes Documentation variable attributes std::vector< RegexUtil::Match > attributes; variable buffers std::vector< RegexUtil::Match > buffers; variable textures std::vector< RegexUtil::Match > textures; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::ShaderTools::MetalReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#ngfxshadertoolsmetalreflectdata","text":"","title":"ngfx::ShaderTools::MetalReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#public-attributes","text":"Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#variable-attributes","text":"std::vector< RegexUtil::Match > attributes;","title":"variable attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#variable-buffers","text":"std::vector< RegexUtil::Match > buffers;","title":"variable buffers"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#variable-textures","text":"std::vector< RegexUtil::Match > textures; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable textures"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/","text":"ngfx::VertexShaderModule::AttributeDescription Public Attributes Name std::string semantic uint32_t location VertexFormat format std::string name uint32_t count uint32_t elementSize Public Attributes Documentation variable semantic std::string semantic; variable location uint32_t location; variable format VertexFormat format; variable name std::string name; variable count uint32_t count; variable elementSize uint32_t elementSize; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx::VertexShaderModule::AttributeDescription"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#ngfxvertexshadermoduleattributedescription","text":"","title":"ngfx::VertexShaderModule::AttributeDescription"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#public-attributes","text":"Name std::string semantic uint32_t location VertexFormat format std::string name uint32_t count uint32_t elementSize","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-semantic","text":"std::string semantic;","title":"variable semantic"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-location","text":"uint32_t location;","title":"variable location"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-format","text":"VertexFormat format;","title":"variable format"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-count","text":"uint32_t count;","title":"variable count"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-elementsize","text":"uint32_t elementSize; Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"variable elementSize"},{"location":"api/Examples/","text":"Examples Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Examples"},{"location":"api/Examples/#examples","text":"Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Examples"},{"location":"api/Files/","text":"Files dir src dir src/ngfx dir src/ngfx/compute file src/ngfx/compute/ComputeApplication.cpp file src/ngfx/compute/ComputeApplication.h file src/ngfx/compute/ComputeOp.h file src/ngfx/compute/ComputePass.h file src/ngfx/compute/ComputePipeline.h dir src/ngfx/computeOps file src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp file src/ngfx/computeOps/MatrixMultiplyCPUOp.h file src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp file src/ngfx/computeOps/MatrixMultiplyGPUOp.h file src/ngfx/computeOps/MatrixMultiplyOp.h dir src/ngfx/core file src/ngfx/core/Application.h file src/ngfx/core/BaseApplication.cpp file src/ngfx/core/BaseApplication.h file src/ngfx/core/DebugUtil.h file src/ngfx/core/FPSCounter.cpp file src/ngfx/core/FPSCounter.h file src/ngfx/core/File.cpp file src/ngfx/core/File.h file src/ngfx/core/FileUtil.cpp file src/ngfx/core/FileUtil.h file src/ngfx/core/ProcessUtil.cpp file src/ngfx/core/ProcessUtil.h file src/ngfx/core/StringUtil.cpp file src/ngfx/core/StringUtil.h file src/ngfx/core/Timer.cpp file src/ngfx/core/Timer.h file src/ngfx/core/Util.cpp file src/ngfx/core/Util.h dir src/ngfx/drawOps file src/ngfx/drawOps/DrawColorOp.cpp file src/ngfx/drawOps/DrawColorOp.h file src/ngfx/drawOps/DrawMeshOp.cpp file src/ngfx/drawOps/DrawMeshOp.h file src/ngfx/drawOps/DrawTextureOp.cpp file src/ngfx/drawOps/DrawTextureOp.h dir src/ngfx/graphics file src/ngfx/graphics/Buffer.h file src/ngfx/graphics/BufferUtil.h file src/ngfx/graphics/Camera.cpp file src/ngfx/graphics/Camera.h file src/ngfx/graphics/CommandBuffer.h file src/ngfx/graphics/Config.h file src/ngfx/graphics/Device.h file src/ngfx/graphics/DrawOp.h file src/ngfx/graphics/Fence.h file src/ngfx/graphics/FilterOp.cpp file src/ngfx/graphics/FilterOp.h file src/ngfx/graphics/Framebuffer.h file src/ngfx/graphics/Graphics.h file src/ngfx/graphics/GraphicsContext.h file src/ngfx/graphics/GraphicsCore.h file src/ngfx/graphics/GraphicsPipeline.cpp file src/ngfx/graphics/GraphicsPipeline.h file src/ngfx/graphics/MeshData.h file src/ngfx/graphics/MeshUtil.cpp file src/ngfx/graphics/MeshUtil.h file src/ngfx/graphics/Pipeline.h file src/ngfx/graphics/PipelineCache.cpp file src/ngfx/graphics/PipelineCache.h file src/ngfx/graphics/Queue.h file src/ngfx/graphics/RenderPass.h file src/ngfx/graphics/Semaphore.h file src/ngfx/graphics/ShaderModule.cpp file src/ngfx/graphics/ShaderModule.h file src/ngfx/graphics/ShaderTools.cpp file src/ngfx/graphics/ShaderTools.h file src/ngfx/graphics/Surface.h file src/ngfx/graphics/Swapchain.h file src/ngfx/graphics/Texture.cpp file src/ngfx/graphics/Texture.h file src/ngfx/graphics/Window.h dir src/ngfx/input file src/ngfx/input/InputListener.h file src/ngfx/input/InputMap.h dir src/ngfx/regex file src/ngfx/regex/RegexUtil.cpp file src/ngfx/regex/RegexUtil.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Files"},{"location":"api/Files/#files","text":"dir src dir src/ngfx dir src/ngfx/compute file src/ngfx/compute/ComputeApplication.cpp file src/ngfx/compute/ComputeApplication.h file src/ngfx/compute/ComputeOp.h file src/ngfx/compute/ComputePass.h file src/ngfx/compute/ComputePipeline.h dir src/ngfx/computeOps file src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp file src/ngfx/computeOps/MatrixMultiplyCPUOp.h file src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp file src/ngfx/computeOps/MatrixMultiplyGPUOp.h file src/ngfx/computeOps/MatrixMultiplyOp.h dir src/ngfx/core file src/ngfx/core/Application.h file src/ngfx/core/BaseApplication.cpp file src/ngfx/core/BaseApplication.h file src/ngfx/core/DebugUtil.h file src/ngfx/core/FPSCounter.cpp file src/ngfx/core/FPSCounter.h file src/ngfx/core/File.cpp file src/ngfx/core/File.h file src/ngfx/core/FileUtil.cpp file src/ngfx/core/FileUtil.h file src/ngfx/core/ProcessUtil.cpp file src/ngfx/core/ProcessUtil.h file src/ngfx/core/StringUtil.cpp file src/ngfx/core/StringUtil.h file src/ngfx/core/Timer.cpp file src/ngfx/core/Timer.h file src/ngfx/core/Util.cpp file src/ngfx/core/Util.h dir src/ngfx/drawOps file src/ngfx/drawOps/DrawColorOp.cpp file src/ngfx/drawOps/DrawColorOp.h file src/ngfx/drawOps/DrawMeshOp.cpp file src/ngfx/drawOps/DrawMeshOp.h file src/ngfx/drawOps/DrawTextureOp.cpp file src/ngfx/drawOps/DrawTextureOp.h dir src/ngfx/graphics file src/ngfx/graphics/Buffer.h file src/ngfx/graphics/BufferUtil.h file src/ngfx/graphics/Camera.cpp file src/ngfx/graphics/Camera.h file src/ngfx/graphics/CommandBuffer.h file src/ngfx/graphics/Config.h file src/ngfx/graphics/Device.h file src/ngfx/graphics/DrawOp.h file src/ngfx/graphics/Fence.h file src/ngfx/graphics/FilterOp.cpp file src/ngfx/graphics/FilterOp.h file src/ngfx/graphics/Framebuffer.h file src/ngfx/graphics/Graphics.h file src/ngfx/graphics/GraphicsContext.h file src/ngfx/graphics/GraphicsCore.h file src/ngfx/graphics/GraphicsPipeline.cpp file src/ngfx/graphics/GraphicsPipeline.h file src/ngfx/graphics/MeshData.h file src/ngfx/graphics/MeshUtil.cpp file src/ngfx/graphics/MeshUtil.h file src/ngfx/graphics/Pipeline.h file src/ngfx/graphics/PipelineCache.cpp file src/ngfx/graphics/PipelineCache.h file src/ngfx/graphics/Queue.h file src/ngfx/graphics/RenderPass.h file src/ngfx/graphics/Semaphore.h file src/ngfx/graphics/ShaderModule.cpp file src/ngfx/graphics/ShaderModule.h file src/ngfx/graphics/ShaderTools.cpp file src/ngfx/graphics/ShaderTools.h file src/ngfx/graphics/Surface.h file src/ngfx/graphics/Swapchain.h file src/ngfx/graphics/Texture.cpp file src/ngfx/graphics/Texture.h file src/ngfx/graphics/Window.h dir src/ngfx/input file src/ngfx/input/InputListener.h file src/ngfx/input/InputMap.h dir src/ngfx/regex file src/ngfx/regex/RegexUtil.cpp file src/ngfx/regex/RegexUtil.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Files"},{"location":"api/Files/Application_8h/","text":"src/ngfx/core/Application.h Defines Name Application Macro Documentation define Application #define Application BaseApplication Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #if defined(NGFX_GRAPHICS_BACKEND_METAL) #include \"ngfx/porting/metal/MTLApplication.h\" #define Application MTLApplication #else #include \"ngfx/BaseApplication.h\" #define Application BaseApplication #endif Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/Application.h"},{"location":"api/Files/Application_8h/#srcngfxcoreapplicationh","text":"","title":"src/ngfx/core/Application.h"},{"location":"api/Files/Application_8h/#defines","text":"Name Application","title":"Defines"},{"location":"api/Files/Application_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/Application_8h/#define-application","text":"#define Application BaseApplication","title":"define Application"},{"location":"api/Files/Application_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #if defined(NGFX_GRAPHICS_BACKEND_METAL) #include \"ngfx/porting/metal/MTLApplication.h\" #define Application MTLApplication #else #include \"ngfx/BaseApplication.h\" #define Application BaseApplication #endif Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/BaseApplication_8cpp/","text":"src/ngfx/core/BaseApplication.cpp Namespaces Name std::placeholders Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/BaseApplication.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/FPSCounter.h\" #include <cstdio> using namespace ngfx; using namespace std::placeholders; BaseApplication::BaseApplication(const std::string &appName, int w, int h, bool enableDepthStencil, bool offscreen) : appName(appName), w(w), h(h), enableDepthStencil(enableDepthStencil), offscreen(offscreen) {} void BaseApplication::init() { auto &ctx = graphicsContext; ctx.reset(GraphicsContext::create(appName.c_str(), enableDepthStencil)); if (offscreen) { Surface surface(w, h, true); graphicsContext->setSurface(&surface); } else { createWindow(); } graphics.reset(Graphics::create(ctx.get())); if (window) { window->onUpdate = std::bind(&BaseApplication::onUpdate, this); window->onPaint = std::bind(&BaseApplication::onPaint, this); window->onKey = std::bind(&BaseApplication::onKey, this, _1, _2); window->onScroll = std::bind(&BaseApplication::onScroll, this, _1, _2); window->onCursorPos = std::bind(&BaseApplication::onCursorPos, this, _1, _2); window->onMouseButton = std::bind(&BaseApplication::onMouseButton, this, _1, _2); } else if (offscreen) { uint32_t size = w * h * 4; outputTexture.reset(ngfx::Texture::create( ctx.get(), graphics.get(), nullptr, PIXELFORMAT_RGBA8_UNORM, size, w, h, 1, 1, ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT | IMAGE_USAGE_COLOR_ATTACHMENT_BIT))); std::vector<ngfx::Framebuffer::Attachment> attachments = { {outputTexture.get()}}; if (enableDepthStencil) { depthTexture.reset(ngfx::Texture::create( ctx.get(), graphics.get(), nullptr, ctx->depthFormat, size, w, h, 1, 1, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)); attachments.push_back({depthTexture.get()}); } outputFramebuffer.reset(Framebuffer::create( ctx->device, ctx->defaultOffscreenRenderPass, attachments, w, h)); } onInit(); if (persistentCommandBuffers) recordCommandBuffers(); } void BaseApplication::createWindow() { auto &ctx = graphicsContext; window.reset(Window::create( ctx.get(), appName.c_str(), [&](Window *thiz) { ctx->setSurface(thiz->surface); }, w, h)); } void BaseApplication::run() { if (initOnce) { init(); initOnce = false; } FPSCounter fpsCounter; while (!window->shouldClose()) { drawFrame(); fpsCounter.update(); } close(); } void BaseApplication::drawFrame() { if (initOnce) { init(); initOnce = false; } if (window) window->pollEvents(); else if (offscreen) { onUpdate(); onPaint(); } } void BaseApplication::close() { auto commandBuffer = graphicsContext->drawCommandBuffer(); graphics->waitIdle(commandBuffer); } void BaseApplication::recordCommandBuffers() { auto &ctx = graphicsContext; for (uint32_t j = 0; j < ctx->numDrawCommandBuffers; j++) { auto commandBuffer = ctx->drawCommandBuffer(j); commandBuffer->begin(); ctx->currentImageIndex = j; onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } } void BaseApplication::onPaint() { paint(); } void BaseApplication::paint() { auto &ctx = graphicsContext; if (!offscreen) ctx->swapchain->acquireNextImage(); auto commandBuffer = ctx->drawCommandBuffer(); if (!persistentCommandBuffers) { commandBuffer->begin(); onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } ctx->queue->submit(commandBuffer); if (!offscreen) ctx->queue->present(); else { graphics->waitIdle(commandBuffer); } } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/BaseApplication.cpp"},{"location":"api/Files/BaseApplication_8cpp/#srcngfxcorebaseapplicationcpp","text":"","title":"src/ngfx/core/BaseApplication.cpp"},{"location":"api/Files/BaseApplication_8cpp/#namespaces","text":"Name std::placeholders","title":"Namespaces"},{"location":"api/Files/BaseApplication_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/BaseApplication.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/FPSCounter.h\" #include <cstdio> using namespace ngfx; using namespace std::placeholders; BaseApplication::BaseApplication(const std::string &appName, int w, int h, bool enableDepthStencil, bool offscreen) : appName(appName), w(w), h(h), enableDepthStencil(enableDepthStencil), offscreen(offscreen) {} void BaseApplication::init() { auto &ctx = graphicsContext; ctx.reset(GraphicsContext::create(appName.c_str(), enableDepthStencil)); if (offscreen) { Surface surface(w, h, true); graphicsContext->setSurface(&surface); } else { createWindow(); } graphics.reset(Graphics::create(ctx.get())); if (window) { window->onUpdate = std::bind(&BaseApplication::onUpdate, this); window->onPaint = std::bind(&BaseApplication::onPaint, this); window->onKey = std::bind(&BaseApplication::onKey, this, _1, _2); window->onScroll = std::bind(&BaseApplication::onScroll, this, _1, _2); window->onCursorPos = std::bind(&BaseApplication::onCursorPos, this, _1, _2); window->onMouseButton = std::bind(&BaseApplication::onMouseButton, this, _1, _2); } else if (offscreen) { uint32_t size = w * h * 4; outputTexture.reset(ngfx::Texture::create( ctx.get(), graphics.get(), nullptr, PIXELFORMAT_RGBA8_UNORM, size, w, h, 1, 1, ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT | IMAGE_USAGE_COLOR_ATTACHMENT_BIT))); std::vector<ngfx::Framebuffer::Attachment> attachments = { {outputTexture.get()}}; if (enableDepthStencil) { depthTexture.reset(ngfx::Texture::create( ctx.get(), graphics.get(), nullptr, ctx->depthFormat, size, w, h, 1, 1, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)); attachments.push_back({depthTexture.get()}); } outputFramebuffer.reset(Framebuffer::create( ctx->device, ctx->defaultOffscreenRenderPass, attachments, w, h)); } onInit(); if (persistentCommandBuffers) recordCommandBuffers(); } void BaseApplication::createWindow() { auto &ctx = graphicsContext; window.reset(Window::create( ctx.get(), appName.c_str(), [&](Window *thiz) { ctx->setSurface(thiz->surface); }, w, h)); } void BaseApplication::run() { if (initOnce) { init(); initOnce = false; } FPSCounter fpsCounter; while (!window->shouldClose()) { drawFrame(); fpsCounter.update(); } close(); } void BaseApplication::drawFrame() { if (initOnce) { init(); initOnce = false; } if (window) window->pollEvents(); else if (offscreen) { onUpdate(); onPaint(); } } void BaseApplication::close() { auto commandBuffer = graphicsContext->drawCommandBuffer(); graphics->waitIdle(commandBuffer); } void BaseApplication::recordCommandBuffers() { auto &ctx = graphicsContext; for (uint32_t j = 0; j < ctx->numDrawCommandBuffers; j++) { auto commandBuffer = ctx->drawCommandBuffer(j); commandBuffer->begin(); ctx->currentImageIndex = j; onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } } void BaseApplication::onPaint() { paint(); } void BaseApplication::paint() { auto &ctx = graphicsContext; if (!offscreen) ctx->swapchain->acquireNextImage(); auto commandBuffer = ctx->drawCommandBuffer(); if (!persistentCommandBuffers) { commandBuffer->begin(); onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } ctx->queue->submit(commandBuffer); if (!offscreen) ctx->queue->present(); else { graphics->waitIdle(commandBuffer); } } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/BaseApplication_8h/","text":"src/ngfx/core/BaseApplication.h Namespaces Name ngfx Classes Name class ngfx::BaseApplication Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/graphics/Window.h\" #include \"ngfx/input/InputListener.h\" #include <memory> #include <string> namespace ngfx { class BaseApplication : public InputListener { public: BaseApplication(const std::string &appName, int w = Window::DISPLAY_WIDTH, int h = Window::DISPLAY_HEIGHT, bool enableDepthStencil = false, bool offscreen = false); virtual ~BaseApplication() {} virtual void init(); virtual void createWindow(); virtual void paint(); virtual void recordCommandBuffers(); virtual void close(); virtual void onInit() {} virtual void onRecordCommandBuffer(CommandBuffer *commandBuffer) = 0; virtual void onUpdate() {} virtual void onPaint(); virtual void run(); virtual void drawFrame(); std::unique_ptr<Graphics> graphics; std::unique_ptr<Window> window; std::unique_ptr<GraphicsContext> graphicsContext; std::string appName; int w, h; bool enableDepthStencil = false; bool offscreen = false; bool persistentCommandBuffers = true; protected: bool initOnce = true; std::unique_ptr<ngfx::Texture> outputTexture, depthTexture; std::unique_ptr<Framebuffer> outputFramebuffer; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/BaseApplication.h"},{"location":"api/Files/BaseApplication_8h/#srcngfxcorebaseapplicationh","text":"","title":"src/ngfx/core/BaseApplication.h"},{"location":"api/Files/BaseApplication_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/BaseApplication_8h/#classes","text":"Name class ngfx::BaseApplication","title":"Classes"},{"location":"api/Files/BaseApplication_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/graphics/Window.h\" #include \"ngfx/input/InputListener.h\" #include <memory> #include <string> namespace ngfx { class BaseApplication : public InputListener { public: BaseApplication(const std::string &appName, int w = Window::DISPLAY_WIDTH, int h = Window::DISPLAY_HEIGHT, bool enableDepthStencil = false, bool offscreen = false); virtual ~BaseApplication() {} virtual void init(); virtual void createWindow(); virtual void paint(); virtual void recordCommandBuffers(); virtual void close(); virtual void onInit() {} virtual void onRecordCommandBuffer(CommandBuffer *commandBuffer) = 0; virtual void onUpdate() {} virtual void onPaint(); virtual void run(); virtual void drawFrame(); std::unique_ptr<Graphics> graphics; std::unique_ptr<Window> window; std::unique_ptr<GraphicsContext> graphicsContext; std::string appName; int w, h; bool enableDepthStencil = false; bool offscreen = false; bool persistentCommandBuffers = true; protected: bool initOnce = true; std::unique_ptr<ngfx::Texture> outputTexture, depthTexture; std::unique_ptr<Framebuffer> outputFramebuffer; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/BufferUtil_8h/","text":"src/ngfx/graphics/BufferUtil.h Namespaces Name ngfx Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" namespace ngfx { static Buffer *createVertexBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_VERTEX_BUFFER_BIT); } template <typename T> static inline Buffer *createVertexBuffer(GraphicsContext *ctx, const std::vector<T> &v) { return createVertexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createIndexBuffer(GraphicsContext *ctx, const void *data, uint32_t size, uint32_t stride = sizeof(uint32_t)) { return Buffer::create(ctx, data, size, BUFFER_USAGE_INDEX_BUFFER_BIT); } template <typename T> static inline Buffer *createIndexBuffer(GraphicsContext *ctx, const std::vector<T> &v, uint32_t stride = sizeof(uint32_t)) { return createIndexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createUniformBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_UNIFORM_BUFFER_BIT); } static Buffer *createStorageBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_STORAGE_BUFFER_BIT); } }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/BufferUtil.h"},{"location":"api/Files/BufferUtil_8h/#srcngfxgraphicsbufferutilh","text":"","title":"src/ngfx/graphics/BufferUtil.h"},{"location":"api/Files/BufferUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/BufferUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" namespace ngfx { static Buffer *createVertexBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_VERTEX_BUFFER_BIT); } template <typename T> static inline Buffer *createVertexBuffer(GraphicsContext *ctx, const std::vector<T> &v) { return createVertexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createIndexBuffer(GraphicsContext *ctx, const void *data, uint32_t size, uint32_t stride = sizeof(uint32_t)) { return Buffer::create(ctx, data, size, BUFFER_USAGE_INDEX_BUFFER_BIT); } template <typename T> static inline Buffer *createIndexBuffer(GraphicsContext *ctx, const std::vector<T> &v, uint32_t stride = sizeof(uint32_t)) { return createIndexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createUniformBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_UNIFORM_BUFFER_BIT); } static Buffer *createStorageBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_STORAGE_BUFFER_BIT); } }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Buffer_8h/","text":"src/ngfx/graphics/Buffer.h Namespaces Name ngfx Classes Name class ngfx::Buffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <vector> namespace ngfx { class GraphicsContext; class Buffer { public: static Buffer *create(GraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags usageFlags); template <typename T> static inline Buffer *create(GraphicsContext *ctx, const std::vector<T> &v, BufferUsageFlags usageFlags) { return create(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } virtual ~Buffer() {} virtual void *map() = 0; virtual void unmap() = 0; virtual void upload(const void *data, uint32_t size, uint32_t offset = 0) = 0; virtual void download(void *data, uint32_t size, uint32_t offset = 0) = 0; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Buffer.h"},{"location":"api/Files/Buffer_8h/#srcngfxgraphicsbufferh","text":"","title":"src/ngfx/graphics/Buffer.h"},{"location":"api/Files/Buffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Buffer_8h/#classes","text":"Name class ngfx::Buffer","title":"Classes"},{"location":"api/Files/Buffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <vector> namespace ngfx { class GraphicsContext; class Buffer { public: static Buffer *create(GraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags usageFlags); template <typename T> static inline Buffer *create(GraphicsContext *ctx, const std::vector<T> &v, BufferUsageFlags usageFlags) { return create(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } virtual ~Buffer() {} virtual void *map() = 0; virtual void unmap() = 0; virtual void upload(const void *data, uint32_t size, uint32_t offset = 0) = 0; virtual void download(void *data, uint32_t size, uint32_t offset = 0) = 0; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Camera_8cpp/","text":"src/ngfx/graphics/Camera.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Camera.h\" #include \"ngfx/core/DebugUtil.h\" #include <glm/gtx/euler_angles.hpp> #include <glm/gtx/transform.hpp> using namespace ngfx; void Camera::onKey(KeyCode code, InputAction action) {} void Camera::onScroll(double xOffset, double yOffset) { zoom += float(yOffset) / 10.0f; } void Camera::onCursorPos(double x, double y) { auto &s = inputState; if (s.state == 1) { s.x = x; s.y = y; s.state = 2; } else if (s.state == 2) { double dx = x - s.x, dy = y - s.y; yaw += float(radians(dx * 10.0f)); pitch += float(radians(dy * 10.0f)); s.x = x; s.y = y; } } void Camera::onMouseButton(MouseButton button, InputAction action) { auto &s = inputState; if (button == MOUSE_BUTTON_MIDDLE) { if (s.state == 0 && action == PRESS) s.state = 1; else if (s.state != 0 && action == RELEASE) s.state = 0; } } void Camera::update() { viewMat = translate(vec3(panX, panY, 0)) * translate(vec3(0, 0, zoom)) * yawPitchRoll(radians(yaw), radians(pitch), radians(roll)); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Camera.cpp"},{"location":"api/Files/Camera_8cpp/#srcngfxgraphicscameracpp","text":"","title":"src/ngfx/graphics/Camera.cpp"},{"location":"api/Files/Camera_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Camera.h\" #include \"ngfx/core/DebugUtil.h\" #include <glm/gtx/euler_angles.hpp> #include <glm/gtx/transform.hpp> using namespace ngfx; void Camera::onKey(KeyCode code, InputAction action) {} void Camera::onScroll(double xOffset, double yOffset) { zoom += float(yOffset) / 10.0f; } void Camera::onCursorPos(double x, double y) { auto &s = inputState; if (s.state == 1) { s.x = x; s.y = y; s.state = 2; } else if (s.state == 2) { double dx = x - s.x, dy = y - s.y; yaw += float(radians(dx * 10.0f)); pitch += float(radians(dy * 10.0f)); s.x = x; s.y = y; } } void Camera::onMouseButton(MouseButton button, InputAction action) { auto &s = inputState; if (button == MOUSE_BUTTON_MIDDLE) { if (s.state == 0 && action == PRESS) s.state = 1; else if (s.state != 0 && action == RELEASE) s.state = 0; } } void Camera::update() { viewMat = translate(vec3(panX, panY, 0)) * translate(vec3(0, 0, zoom)) * yawPitchRoll(radians(yaw), radians(pitch), radians(roll)); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Camera_8h/","text":"src/ngfx/graphics/Camera.h Namespaces Name ngfx Classes Name class ngfx::Camera Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/input/InputListener.h\" #include <glm/glm.hpp> using namespace glm; namespace ngfx { class Camera : public InputListener { public: virtual ~Camera() {} void onKey(KeyCode keyCode, InputAction keyAction) override; void onScroll(double xoffset, double yoffset) override; void onCursorPos(double x, double y) override; void onMouseButton(MouseButton button, InputAction action) override; void update(); float panX = 0.0f, panY = 0.0f, zoom = 0.0f, yaw = 0.0f, pitch = 0.0f, roll = 0.0f; mat4 viewMat; private: struct { uint32_t state = 0; double x = -1.0, y = -1.0; } inputState; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Camera.h"},{"location":"api/Files/Camera_8h/#srcngfxgraphicscamerah","text":"","title":"src/ngfx/graphics/Camera.h"},{"location":"api/Files/Camera_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Camera_8h/#classes","text":"Name class ngfx::Camera","title":"Classes"},{"location":"api/Files/Camera_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/input/InputListener.h\" #include <glm/glm.hpp> using namespace glm; namespace ngfx { class Camera : public InputListener { public: virtual ~Camera() {} void onKey(KeyCode keyCode, InputAction keyAction) override; void onScroll(double xoffset, double yoffset) override; void onCursorPos(double x, double y) override; void onMouseButton(MouseButton button, InputAction action) override; void update(); float panX = 0.0f, panY = 0.0f, zoom = 0.0f, yaw = 0.0f, pitch = 0.0f, roll = 0.0f; mat4 viewMat; private: struct { uint32_t state = 0; double x = -1.0, y = -1.0; } inputState; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/CommandBuffer_8h/","text":"src/ngfx/graphics/CommandBuffer.h Namespaces Name ngfx Classes Name class ngfx::CommandBuffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class GraphicsContext; class CommandBuffer { public: static CommandBuffer * create(GraphicsContext *ctx, CommandBufferLevel level = COMMAND_BUFFER_LEVEL_PRIMARY); virtual ~CommandBuffer() {} virtual void begin() = 0; virtual void end() = 0; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/CommandBuffer.h"},{"location":"api/Files/CommandBuffer_8h/#srcngfxgraphicscommandbufferh","text":"","title":"src/ngfx/graphics/CommandBuffer.h"},{"location":"api/Files/CommandBuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/CommandBuffer_8h/#classes","text":"Name class ngfx::CommandBuffer","title":"Classes"},{"location":"api/Files/CommandBuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class GraphicsContext; class CommandBuffer { public: static CommandBuffer * create(GraphicsContext *ctx, CommandBufferLevel level = COMMAND_BUFFER_LEVEL_PRIMARY); virtual ~CommandBuffer() {} virtual void begin() = 0; virtual void end() = 0; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ComputeApplication_8cpp/","text":"src/ngfx/compute/ComputeApplication.cpp Namespaces Name glm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/compute/ComputeApplication.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include \"ngfx/graphics/Graphics.h\" #include <memory> using namespace ngfx; using namespace glm; using namespace std; ComputeApplication::ComputeApplication(const std::string &name, int w, int h) : appName(name), w(w), h(h) {} void ComputeApplication::init() { graphicsContext.reset(GraphicsContext::create(appName.c_str())); if (w == 0 && h == 0) graphicsContext->setSurface(nullptr); else { window.reset(Window::create( graphicsContext.get(), appName.c_str(), [&](Window *thiz) { graphicsContext->setSurface(thiz->surface); })); } graphics.reset(Graphics::create(graphicsContext.get())); } void ComputeApplication::recordCommandBuffer(CommandBuffer *commandBuffer) { commandBuffer->begin(); onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } void ComputeApplication::run() { init(); onInit(); auto commandBuffer = graphicsContext->computeCommandBuffer(); recordCommandBuffer(commandBuffer); onUpdate(); doCompute(commandBuffer); close(); } void ComputeApplication::close() {} void ComputeApplication::doCompute(CommandBuffer *commandBuffer) { Timer timer; graphicsContext->submit(commandBuffer); graphics->waitIdle(commandBuffer); timer.update(); NGFX_LOG(\"compute elapsed: %f\", timer.elapsed); onComputeFinished(); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/compute/ComputeApplication.cpp"},{"location":"api/Files/ComputeApplication_8cpp/#srcngfxcomputecomputeapplicationcpp","text":"","title":"src/ngfx/compute/ComputeApplication.cpp"},{"location":"api/Files/ComputeApplication_8cpp/#namespaces","text":"Name glm","title":"Namespaces"},{"location":"api/Files/ComputeApplication_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/compute/ComputeApplication.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include \"ngfx/graphics/Graphics.h\" #include <memory> using namespace ngfx; using namespace glm; using namespace std; ComputeApplication::ComputeApplication(const std::string &name, int w, int h) : appName(name), w(w), h(h) {} void ComputeApplication::init() { graphicsContext.reset(GraphicsContext::create(appName.c_str())); if (w == 0 && h == 0) graphicsContext->setSurface(nullptr); else { window.reset(Window::create( graphicsContext.get(), appName.c_str(), [&](Window *thiz) { graphicsContext->setSurface(thiz->surface); })); } graphics.reset(Graphics::create(graphicsContext.get())); } void ComputeApplication::recordCommandBuffer(CommandBuffer *commandBuffer) { commandBuffer->begin(); onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } void ComputeApplication::run() { init(); onInit(); auto commandBuffer = graphicsContext->computeCommandBuffer(); recordCommandBuffer(commandBuffer); onUpdate(); doCompute(commandBuffer); close(); } void ComputeApplication::close() {} void ComputeApplication::doCompute(CommandBuffer *commandBuffer) { Timer timer; graphicsContext->submit(commandBuffer); graphics->waitIdle(commandBuffer); timer.update(); NGFX_LOG(\"compute elapsed: %f\", timer.elapsed); onComputeFinished(); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ComputeApplication_8h/","text":"src/ngfx/compute/ComputeApplication.h Namespaces Name ngfx Classes Name class ngfx::ComputeApplication Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/graphics/Window.h\" namespace ngfx { class ComputeApplication { public: ComputeApplication(const std::string &name, int w = 0, int h = 0); virtual ~ComputeApplication() {} virtual void onInit() {} virtual void onRecordCommandBuffer(CommandBuffer *commandBuffer) {} virtual void onUpdate() {} virtual void run(); protected: virtual void init(); virtual void close(); virtual void doCompute(CommandBuffer *commandBuffer); virtual void onComputeFinished() {} virtual void recordCommandBuffer(CommandBuffer *commandBuffer); std::unique_ptr<Graphics> graphics; std::unique_ptr<Window> window; std::unique_ptr<GraphicsContext> graphicsContext; std::string appName; int w, h; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/compute/ComputeApplication.h"},{"location":"api/Files/ComputeApplication_8h/#srcngfxcomputecomputeapplicationh","text":"","title":"src/ngfx/compute/ComputeApplication.h"},{"location":"api/Files/ComputeApplication_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ComputeApplication_8h/#classes","text":"Name class ngfx::ComputeApplication","title":"Classes"},{"location":"api/Files/ComputeApplication_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/graphics/Window.h\" namespace ngfx { class ComputeApplication { public: ComputeApplication(const std::string &name, int w = 0, int h = 0); virtual ~ComputeApplication() {} virtual void onInit() {} virtual void onRecordCommandBuffer(CommandBuffer *commandBuffer) {} virtual void onUpdate() {} virtual void run(); protected: virtual void init(); virtual void close(); virtual void doCompute(CommandBuffer *commandBuffer); virtual void onComputeFinished() {} virtual void recordCommandBuffer(CommandBuffer *commandBuffer); std::unique_ptr<Graphics> graphics; std::unique_ptr<Window> window; std::unique_ptr<GraphicsContext> graphicsContext; std::string appName; int w, h; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ComputeOp_8h/","text":"src/ngfx/compute/ComputeOp.h Namespaces Name ngfx Classes Name class ngfx::ComputeOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class ComputeOp { public: ComputeOp(GraphicsContext *ctx) : ctx(ctx) {} virtual ~ComputeOp() {} virtual void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) = 0; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/compute/ComputeOp.h"},{"location":"api/Files/ComputeOp_8h/#srcngfxcomputecomputeoph","text":"","title":"src/ngfx/compute/ComputeOp.h"},{"location":"api/Files/ComputeOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ComputeOp_8h/#classes","text":"Name class ngfx::ComputeOp","title":"Classes"},{"location":"api/Files/ComputeOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class ComputeOp { public: ComputeOp(GraphicsContext *ctx) : ctx(ctx) {} virtual ~ComputeOp() {} virtual void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) = 0; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ComputePass_8h/","text":"src/ngfx/compute/ComputePass.h Namespaces Name ngfx Classes Name class ngfx::ComputePass Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" namespace ngfx { class GraphicsContext; class ComputePass { public: virtual ~ComputePass() {} virtual void begin(GraphicsContext *ctx, CommandBuffer *commandBuffer) {} virtual void end(CommandBuffer *commandBuffer) {} }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/compute/ComputePass.h"},{"location":"api/Files/ComputePass_8h/#srcngfxcomputecomputepassh","text":"","title":"src/ngfx/compute/ComputePass.h"},{"location":"api/Files/ComputePass_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ComputePass_8h/#classes","text":"Name class ngfx::ComputePass","title":"Classes"},{"location":"api/Files/ComputePass_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" namespace ngfx { class GraphicsContext; class ComputePass { public: virtual ~ComputePass() {} virtual void begin(GraphicsContext *ctx, CommandBuffer *commandBuffer) {} virtual void end(CommandBuffer *commandBuffer) {} }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ComputePipeline_8h/","text":"src/ngfx/compute/ComputePipeline.h Namespaces Name ngfx Classes Name class ngfx::ComputePipeline Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Pipeline.h\" #include \"ngfx/graphics/ShaderModule.h\" namespace ngfx { class GraphicsContext; class ComputePipeline : public Pipeline { public: static ComputePipeline *create(GraphicsContext *graphicsContext, ComputeShaderModule *cs); virtual ~ComputePipeline() {} std::vector<uint32_t> descriptorBindings; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/compute/ComputePipeline.h"},{"location":"api/Files/ComputePipeline_8h/#srcngfxcomputecomputepipelineh","text":"","title":"src/ngfx/compute/ComputePipeline.h"},{"location":"api/Files/ComputePipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ComputePipeline_8h/#classes","text":"Name class ngfx::ComputePipeline","title":"Classes"},{"location":"api/Files/ComputePipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Pipeline.h\" #include \"ngfx/graphics/ShaderModule.h\" namespace ngfx { class GraphicsContext; class ComputePipeline : public Pipeline { public: static ComputePipeline *create(GraphicsContext *graphicsContext, ComputeShaderModule *cs); virtual ~ComputePipeline() {} std::vector<uint32_t> descriptorBindings; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Config_8h/","text":"src/ngfx/graphics/Config.h Defines Name PREFERRED_NUM_SWAPCHAIN_IMAGES ENABLE_VSYNC USE_PRECOMPILED_SHADERS ORIGIN_BOTTOM_LEFT Macro Documentation define PREFERRED_NUM_SWAPCHAIN_IMAGES #define PREFERRED_NUM_SWAPCHAIN_IMAGES 3 define ENABLE_VSYNC #define ENABLE_VSYNC define USE_PRECOMPILED_SHADERS #define USE_PRECOMPILED_SHADERS define ORIGIN_BOTTOM_LEFT #define ORIGIN_BOTTOM_LEFT Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> #define PREFERRED_NUM_SWAPCHAIN_IMAGES 3 #define ENABLE_VSYNC #define USE_PRECOMPILED_SHADERS #define ORIGIN_BOTTOM_LEFT Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Config.h"},{"location":"api/Files/Config_8h/#srcngfxgraphicsconfigh","text":"","title":"src/ngfx/graphics/Config.h"},{"location":"api/Files/Config_8h/#defines","text":"Name PREFERRED_NUM_SWAPCHAIN_IMAGES ENABLE_VSYNC USE_PRECOMPILED_SHADERS ORIGIN_BOTTOM_LEFT","title":"Defines"},{"location":"api/Files/Config_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/Config_8h/#define-preferred_num_swapchain_images","text":"#define PREFERRED_NUM_SWAPCHAIN_IMAGES 3","title":"define PREFERRED_NUM_SWAPCHAIN_IMAGES"},{"location":"api/Files/Config_8h/#define-enable_vsync","text":"#define ENABLE_VSYNC","title":"define ENABLE_VSYNC"},{"location":"api/Files/Config_8h/#define-use_precompiled_shaders","text":"#define USE_PRECOMPILED_SHADERS","title":"define USE_PRECOMPILED_SHADERS"},{"location":"api/Files/Config_8h/#define-origin_bottom_left","text":"#define ORIGIN_BOTTOM_LEFT","title":"define ORIGIN_BOTTOM_LEFT"},{"location":"api/Files/Config_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> #define PREFERRED_NUM_SWAPCHAIN_IMAGES 3 #define ENABLE_VSYNC #define USE_PRECOMPILED_SHADERS #define ORIGIN_BOTTOM_LEFT Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/DebugUtil_8h/","text":"src/ngfx/core/DebugUtil.h Classes Name struct DebugUtil Defines Name PRETTY_FUNCTION NGFX_LOG (fmt, ...) NGFX_LOG_TRACE (fmt, ...) NGFX_TODO (fmt, ...) NGFX_ERR (fmt, ...) Macro Documentation define PRETTY_FUNCTION #define __PRETTY_FUNCTION__ __FUNCTION__ define NGFX_LOG #define NGFX_LOG( fmt, ... ) fprintf(stderr, fmt \"\\n\", ##__VA_ARGS__) define NGFX_LOG_TRACE #define NGFX_LOG_TRACE( fmt, ... ) NGFX_LOG(\"[%s][%s][%d] \" fmt, __FILE__, __PRETTY_FUNCTION__, __LINE__, \\ ##__VA_ARGS__) define NGFX_TODO #define NGFX_TODO( fmt, ... ) NGFX_LOG(\"[%s][%s][%d] TODO: \" fmt, __FILE__, __FUNCTION__, __LINE__, \\ ##__VA_ARGS__) define NGFX_ERR #define NGFX_ERR( fmt, ... ) { \\ fprintf(stderr, \"ERROR: [%s][%s][%d] \" fmt \"\\n\", __FILE__, \\ __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \\ DebugUtil::Exit(1); \\ } Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdio> #include <cstdlib> #ifndef __PRETTY_FUNCTION__ #define __PRETTY_FUNCTION__ __FUNCTION__ #endif #define NGFX_LOG(fmt, ...) fprintf(stderr, fmt \"\\n\", ##__VA_ARGS__) #define NGFX_LOG_TRACE(fmt, ...) \\ NGFX_LOG(\"[%s][%s][%d] \" fmt, __FILE__, __PRETTY_FUNCTION__, __LINE__, \\ ##__VA_ARGS__) #define NGFX_TODO(fmt, ...) \\ NGFX_LOG(\"[%s][%s][%d] TODO: \" fmt, __FILE__, __FUNCTION__, __LINE__, \\ ##__VA_ARGS__) #include <cstdint> struct DebugUtil { static inline void Exit(uint32_t code) { exit(code); }; }; #define NGFX_ERR(fmt, ...) \\ { \\ fprintf(stderr, \"ERROR: [%s][%s][%d] \" fmt \"\\n\", __FILE__, \\ __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \\ DebugUtil::Exit(1); \\ } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/DebugUtil.h"},{"location":"api/Files/DebugUtil_8h/#srcngfxcoredebugutilh","text":"","title":"src/ngfx/core/DebugUtil.h"},{"location":"api/Files/DebugUtil_8h/#classes","text":"Name struct DebugUtil","title":"Classes"},{"location":"api/Files/DebugUtil_8h/#defines","text":"Name PRETTY_FUNCTION NGFX_LOG (fmt, ...) NGFX_LOG_TRACE (fmt, ...) NGFX_TODO (fmt, ...) NGFX_ERR (fmt, ...)","title":"Defines"},{"location":"api/Files/DebugUtil_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/DebugUtil_8h/#define-pretty_function","text":"#define __PRETTY_FUNCTION__ __FUNCTION__","title":"define PRETTY_FUNCTION"},{"location":"api/Files/DebugUtil_8h/#define-ngfx_log","text":"#define NGFX_LOG( fmt, ... ) fprintf(stderr, fmt \"\\n\", ##__VA_ARGS__)","title":"define NGFX_LOG"},{"location":"api/Files/DebugUtil_8h/#define-ngfx_log_trace","text":"#define NGFX_LOG_TRACE( fmt, ... ) NGFX_LOG(\"[%s][%s][%d] \" fmt, __FILE__, __PRETTY_FUNCTION__, __LINE__, \\ ##__VA_ARGS__)","title":"define NGFX_LOG_TRACE"},{"location":"api/Files/DebugUtil_8h/#define-ngfx_todo","text":"#define NGFX_TODO( fmt, ... ) NGFX_LOG(\"[%s][%s][%d] TODO: \" fmt, __FILE__, __FUNCTION__, __LINE__, \\ ##__VA_ARGS__)","title":"define NGFX_TODO"},{"location":"api/Files/DebugUtil_8h/#define-ngfx_err","text":"#define NGFX_ERR( fmt, ... ) { \\ fprintf(stderr, \"ERROR: [%s][%s][%d] \" fmt \"\\n\", __FILE__, \\ __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \\ DebugUtil::Exit(1); \\ }","title":"define NGFX_ERR"},{"location":"api/Files/DebugUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdio> #include <cstdlib> #ifndef __PRETTY_FUNCTION__ #define __PRETTY_FUNCTION__ __FUNCTION__ #endif #define NGFX_LOG(fmt, ...) fprintf(stderr, fmt \"\\n\", ##__VA_ARGS__) #define NGFX_LOG_TRACE(fmt, ...) \\ NGFX_LOG(\"[%s][%s][%d] \" fmt, __FILE__, __PRETTY_FUNCTION__, __LINE__, \\ ##__VA_ARGS__) #define NGFX_TODO(fmt, ...) \\ NGFX_LOG(\"[%s][%s][%d] TODO: \" fmt, __FILE__, __FUNCTION__, __LINE__, \\ ##__VA_ARGS__) #include <cstdint> struct DebugUtil { static inline void Exit(uint32_t code) { exit(code); }; }; #define NGFX_ERR(fmt, ...) \\ { \\ fprintf(stderr, \"ERROR: [%s][%s][%d] \" fmt \"\\n\", __FILE__, \\ __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \\ DebugUtil::Exit(1); \\ } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Device_8h/","text":"src/ngfx/graphics/Device.h Namespaces Name ngfx Classes Name class ngfx::Device Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Device {}; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Device.h"},{"location":"api/Files/Device_8h/#srcngfxgraphicsdeviceh","text":"","title":"src/ngfx/graphics/Device.h"},{"location":"api/Files/Device_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Device_8h/#classes","text":"Name class ngfx::Device","title":"Classes"},{"location":"api/Files/Device_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Device {}; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/DrawColorOp_8cpp/","text":"src/ngfx/drawOps/DrawColorOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawColorOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawColorOp::DrawColorOp(GraphicsContext *ctx, const std::vector<glm::vec2> &pos, const glm::vec4 &color) : DrawOp(ctx) { bPos.reset(createVertexBuffer<vec2>(ctx, pos)); bUbo.reset(createUniformBuffer(ctx, &color, sizeof(color))); numVerts = uint32_t(pos.size()); createPipeline(); graphicsPipeline->getBindings({&U_UBO}, {&B_POS}); } void DrawColorOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec2)); graphics->bindUniformBuffer(commandBuffer, bUbo.get(), U_UBO, SHADER_STAGE_FRAGMENT_BIT); graphics->draw(commandBuffer, numVerts); } void DrawColorOp::createPipeline() { const std::string key = \"drawColorOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawColor.vert\").get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawColor.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/drawOps/DrawColorOp.cpp"},{"location":"api/Files/DrawColorOp_8cpp/#srcngfxdrawopsdrawcoloropcpp","text":"","title":"src/ngfx/drawOps/DrawColorOp.cpp"},{"location":"api/Files/DrawColorOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawColorOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawColorOp::DrawColorOp(GraphicsContext *ctx, const std::vector<glm::vec2> &pos, const glm::vec4 &color) : DrawOp(ctx) { bPos.reset(createVertexBuffer<vec2>(ctx, pos)); bUbo.reset(createUniformBuffer(ctx, &color, sizeof(color))); numVerts = uint32_t(pos.size()); createPipeline(); graphicsPipeline->getBindings({&U_UBO}, {&B_POS}); } void DrawColorOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec2)); graphics->bindUniformBuffer(commandBuffer, bUbo.get(), U_UBO, SHADER_STAGE_FRAGMENT_BIT); graphics->draw(commandBuffer, numVerts); } void DrawColorOp::createPipeline() { const std::string key = \"drawColorOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawColor.vert\").get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawColor.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/DrawColorOp_8h/","text":"src/ngfx/drawOps/DrawColorOp.h Namespaces Name ngfx Classes Name class ngfx::DrawColorOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/Graphics.h\" #include <memory> namespace ngfx { class DrawColorOp : public DrawOp { public: DrawColorOp(GraphicsContext *ctx, const std::vector<glm::vec2> &pos, const glm::vec4 &color); virtual ~DrawColorOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; std::unique_ptr<Buffer> bPos; std::unique_ptr<Buffer> bUbo; protected: virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t B_POS, U_UBO; uint32_t numVerts; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/drawOps/DrawColorOp.h"},{"location":"api/Files/DrawColorOp_8h/#srcngfxdrawopsdrawcoloroph","text":"","title":"src/ngfx/drawOps/DrawColorOp.h"},{"location":"api/Files/DrawColorOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/DrawColorOp_8h/#classes","text":"Name class ngfx::DrawColorOp","title":"Classes"},{"location":"api/Files/DrawColorOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/Graphics.h\" #include <memory> namespace ngfx { class DrawColorOp : public DrawOp { public: DrawColorOp(GraphicsContext *ctx, const std::vector<glm::vec2> &pos, const glm::vec4 &color); virtual ~DrawColorOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; std::unique_ptr<Buffer> bPos; std::unique_ptr<Buffer> bUbo; protected: virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t B_POS, U_UBO; uint32_t numVerts; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/DrawMeshOp_8cpp/","text":"src/ngfx/drawOps/DrawMeshOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawMeshOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawMeshOp::DrawMeshOp(GraphicsContext *ctx, MeshData &meshData) : DrawOp(ctx) { bPos.reset(createVertexBuffer<vec3>(ctx, meshData.pos)); bNormals.reset(createVertexBuffer<vec3>(ctx, meshData.normal)); bFaces.reset(createIndexBuffer<ivec3>(ctx, meshData.faces)); bUboVS.reset(createUniformBuffer(ctx, nullptr, sizeof(UBO_VS_Data))); bUboFS.reset(createUniformBuffer(ctx, nullptr, sizeof(UBO_FS_Data))); numVerts = uint32_t(meshData.pos.size()); numNormals = uint32_t(meshData.normal.size()); numFaces = uint32_t(meshData.faces.size()); createPipeline(); graphicsPipeline->getBindings({&U_UBO_VS, &U_UBO_FS}, {&B_POS, &B_NORMALS}); } void DrawMeshOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec3)); graphics->bindVertexBuffer(commandBuffer, bNormals.get(), B_NORMALS, sizeof(vec3)); graphics->bindIndexBuffer(commandBuffer, bFaces.get()); graphics->bindUniformBuffer(commandBuffer, bUboVS.get(), U_UBO_VS, SHADER_STAGE_VERTEX_BIT); graphics->bindUniformBuffer(commandBuffer, bUboFS.get(), U_UBO_FS, SHADER_STAGE_FRAGMENT_BIT); graphics->drawIndexed(commandBuffer, numFaces * 3); } void DrawMeshOp::update(mat4 &modelView, mat4 &modelViewInverseTranspose, mat4 &modelViewProj, LightData &lightData) { UBO_VS_Data uboVSData = {modelView, modelViewInverseTranspose, modelViewProj}; UBO_FS_Data uboFSData = {lightData}; bUboVS->upload(&uboVSData, sizeof(uboVSData)); bUboFS->upload(&uboFSData, sizeof(uboFSData)); } void DrawMeshOp::createPipeline() { const std::string key = \"drawMeshOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; state.depthTestEnable = true; state.depthWriteEnable = true; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawMesh.vert\").get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawMesh.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/drawOps/DrawMeshOp.cpp"},{"location":"api/Files/DrawMeshOp_8cpp/#srcngfxdrawopsdrawmeshopcpp","text":"","title":"src/ngfx/drawOps/DrawMeshOp.cpp"},{"location":"api/Files/DrawMeshOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawMeshOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawMeshOp::DrawMeshOp(GraphicsContext *ctx, MeshData &meshData) : DrawOp(ctx) { bPos.reset(createVertexBuffer<vec3>(ctx, meshData.pos)); bNormals.reset(createVertexBuffer<vec3>(ctx, meshData.normal)); bFaces.reset(createIndexBuffer<ivec3>(ctx, meshData.faces)); bUboVS.reset(createUniformBuffer(ctx, nullptr, sizeof(UBO_VS_Data))); bUboFS.reset(createUniformBuffer(ctx, nullptr, sizeof(UBO_FS_Data))); numVerts = uint32_t(meshData.pos.size()); numNormals = uint32_t(meshData.normal.size()); numFaces = uint32_t(meshData.faces.size()); createPipeline(); graphicsPipeline->getBindings({&U_UBO_VS, &U_UBO_FS}, {&B_POS, &B_NORMALS}); } void DrawMeshOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec3)); graphics->bindVertexBuffer(commandBuffer, bNormals.get(), B_NORMALS, sizeof(vec3)); graphics->bindIndexBuffer(commandBuffer, bFaces.get()); graphics->bindUniformBuffer(commandBuffer, bUboVS.get(), U_UBO_VS, SHADER_STAGE_VERTEX_BIT); graphics->bindUniformBuffer(commandBuffer, bUboFS.get(), U_UBO_FS, SHADER_STAGE_FRAGMENT_BIT); graphics->drawIndexed(commandBuffer, numFaces * 3); } void DrawMeshOp::update(mat4 &modelView, mat4 &modelViewInverseTranspose, mat4 &modelViewProj, LightData &lightData) { UBO_VS_Data uboVSData = {modelView, modelViewInverseTranspose, modelViewProj}; UBO_FS_Data uboFSData = {lightData}; bUboVS->upload(&uboVSData, sizeof(uboVSData)); bUboFS->upload(&uboFSData, sizeof(uboFSData)); } void DrawMeshOp::createPipeline() { const std::string key = \"drawMeshOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; state.depthTestEnable = true; state.depthWriteEnable = true; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawMesh.vert\").get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawMesh.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/DrawMeshOp_8h/","text":"src/ngfx/drawOps/DrawMeshOp.h Namespaces Name ngfx Classes Name class ngfx::DrawMeshOp struct ngfx::DrawMeshOp::LightData Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/graphics/MeshData.h\" #include <memory> namespace ngfx { class DrawMeshOp : public DrawOp { public: DrawMeshOp(GraphicsContext *ctx, MeshData &meshData); virtual ~DrawMeshOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; struct LightData { vec4 ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f); vec4 diffuse = vec4(1.0f); vec4 specular = vec4(1.0f); vec4 lightViewPos = vec4(0.0f, 0.0f, 1.0f, 1.0f); vec2 shininess = vec2(10.0f, 0.0f), padding; }; virtual void update(mat4 &modelView, mat4 &modelViewInverseTranspose, mat4 &modelViewProj, LightData &lightData); std::unique_ptr<Buffer> bPos, bNormals; std::unique_ptr<Buffer> bFaces; std::unique_ptr<Buffer> bUboVS, bUboFS; protected: struct UBO_VS_Data { mat4 modelView; mat4 modelViewInverseTranspose; mat4 modelViewProj; }; struct UBO_FS_Data { LightData light0; }; virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t B_POS, B_NORMALS, U_UBO_VS, U_UBO_FS; uint32_t numVerts, numNormals; uint32_t numFaces; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/drawOps/DrawMeshOp.h"},{"location":"api/Files/DrawMeshOp_8h/#srcngfxdrawopsdrawmeshoph","text":"","title":"src/ngfx/drawOps/DrawMeshOp.h"},{"location":"api/Files/DrawMeshOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/DrawMeshOp_8h/#classes","text":"Name class ngfx::DrawMeshOp struct ngfx::DrawMeshOp::LightData","title":"Classes"},{"location":"api/Files/DrawMeshOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/graphics/MeshData.h\" #include <memory> namespace ngfx { class DrawMeshOp : public DrawOp { public: DrawMeshOp(GraphicsContext *ctx, MeshData &meshData); virtual ~DrawMeshOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; struct LightData { vec4 ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f); vec4 diffuse = vec4(1.0f); vec4 specular = vec4(1.0f); vec4 lightViewPos = vec4(0.0f, 0.0f, 1.0f, 1.0f); vec2 shininess = vec2(10.0f, 0.0f), padding; }; virtual void update(mat4 &modelView, mat4 &modelViewInverseTranspose, mat4 &modelViewProj, LightData &lightData); std::unique_ptr<Buffer> bPos, bNormals; std::unique_ptr<Buffer> bFaces; std::unique_ptr<Buffer> bUboVS, bUboFS; protected: struct UBO_VS_Data { mat4 modelView; mat4 modelViewInverseTranspose; mat4 modelViewProj; }; struct UBO_FS_Data { LightData light0; }; virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t B_POS, B_NORMALS, U_UBO_VS, U_UBO_FS; uint32_t numVerts, numNormals; uint32_t numFaces; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/DrawOp_8h/","text":"src/ngfx/graphics/DrawOp.h Namespaces Name ngfx Classes Name class ngfx::DrawOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class DrawOp { public: DrawOp(GraphicsContext *ctx) : ctx(ctx) {} virtual ~DrawOp() {} virtual void draw(CommandBuffer *commandBuffer, Graphics *graphics) = 0; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/DrawOp.h"},{"location":"api/Files/DrawOp_8h/#srcngfxgraphicsdrawoph","text":"","title":"src/ngfx/graphics/DrawOp.h"},{"location":"api/Files/DrawOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/DrawOp_8h/#classes","text":"Name class ngfx::DrawOp","title":"Classes"},{"location":"api/Files/DrawOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class DrawOp { public: DrawOp(GraphicsContext *ctx) : ctx(ctx) {} virtual ~DrawOp() {} virtual void draw(CommandBuffer *commandBuffer, Graphics *graphics) = 0; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/DrawTextureOp_8cpp/","text":"src/ngfx/drawOps/DrawTextureOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawTextureOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawTextureOp::DrawTextureOp(GraphicsContext *ctx, Texture *texture, const std::vector<glm::vec2> &pos, const std::vector<glm::vec2> &texCoord) : DrawOp(ctx), texture(texture) { bPos.reset(createVertexBuffer<vec2>(ctx, pos)); bTexCoord.reset(createVertexBuffer<vec2>(ctx, texCoord)); numVerts = uint32_t(pos.size()); createPipeline(); graphicsPipeline->getBindings({&U_TEXTURE}, {&B_POS, &B_TEXCOORD}); } void DrawTextureOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec2)); graphics->bindVertexBuffer(commandBuffer, bTexCoord.get(), B_TEXCOORD, sizeof(vec2)); graphics->bindTexture(commandBuffer, texture, U_TEXTURE); graphics->draw(commandBuffer, numVerts); } void DrawTextureOp::createPipeline() { const std::string key = \"drawTextureOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawTexture.vert\") .get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawTexture.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/drawOps/DrawTextureOp.cpp"},{"location":"api/Files/DrawTextureOp_8cpp/#srcngfxdrawopsdrawtextureopcpp","text":"","title":"src/ngfx/drawOps/DrawTextureOp.cpp"},{"location":"api/Files/DrawTextureOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawTextureOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawTextureOp::DrawTextureOp(GraphicsContext *ctx, Texture *texture, const std::vector<glm::vec2> &pos, const std::vector<glm::vec2> &texCoord) : DrawOp(ctx), texture(texture) { bPos.reset(createVertexBuffer<vec2>(ctx, pos)); bTexCoord.reset(createVertexBuffer<vec2>(ctx, texCoord)); numVerts = uint32_t(pos.size()); createPipeline(); graphicsPipeline->getBindings({&U_TEXTURE}, {&B_POS, &B_TEXCOORD}); } void DrawTextureOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec2)); graphics->bindVertexBuffer(commandBuffer, bTexCoord.get(), B_TEXCOORD, sizeof(vec2)); graphics->bindTexture(commandBuffer, texture, U_TEXTURE); graphics->draw(commandBuffer, numVerts); } void DrawTextureOp::createPipeline() { const std::string key = \"drawTextureOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawTexture.vert\") .get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawTexture.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/DrawTextureOp_8h/","text":"src/ngfx/drawOps/DrawTextureOp.h Namespaces Name ngfx Classes Name class ngfx::DrawTextureOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/DrawOp.h\" #include <memory> namespace ngfx { class DrawTextureOp : public DrawOp { public: DrawTextureOp(GraphicsContext *ctx, Texture *texture) : DrawTextureOp(ctx, texture, {glm::vec2(-1, 1), glm::vec2(-1, -1), glm::vec2(1, 1), glm::vec2(1, -1)}, {glm::vec2(0, 0), glm::vec2(0, 1), glm::vec2(1, 0), glm::vec2(1, 1)}) {} DrawTextureOp(GraphicsContext *ctx, Texture *texture, const std::vector<glm::vec2> &pos, const std::vector<glm::vec2> &texCoord); virtual ~DrawTextureOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; std::unique_ptr<Buffer> bPos, bTexCoord; Texture *texture; protected: virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t numVerts; uint32_t B_POS, B_TEXCOORD, U_TEXTURE; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/drawOps/DrawTextureOp.h"},{"location":"api/Files/DrawTextureOp_8h/#srcngfxdrawopsdrawtextureoph","text":"","title":"src/ngfx/drawOps/DrawTextureOp.h"},{"location":"api/Files/DrawTextureOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/DrawTextureOp_8h/#classes","text":"Name class ngfx::DrawTextureOp","title":"Classes"},{"location":"api/Files/DrawTextureOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/DrawOp.h\" #include <memory> namespace ngfx { class DrawTextureOp : public DrawOp { public: DrawTextureOp(GraphicsContext *ctx, Texture *texture) : DrawTextureOp(ctx, texture, {glm::vec2(-1, 1), glm::vec2(-1, -1), glm::vec2(1, 1), glm::vec2(1, -1)}, {glm::vec2(0, 0), glm::vec2(0, 1), glm::vec2(1, 0), glm::vec2(1, 1)}) {} DrawTextureOp(GraphicsContext *ctx, Texture *texture, const std::vector<glm::vec2> &pos, const std::vector<glm::vec2> &texCoord); virtual ~DrawTextureOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; std::unique_ptr<Buffer> bPos, bTexCoord; Texture *texture; protected: virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t numVerts; uint32_t B_POS, B_TEXCOORD, U_TEXTURE; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/FPSCounter_8cpp/","text":"src/ngfx/core/FPSCounter.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/FPSCounter.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void FPSCounter::update() { numFrames++; if (numFrames == 100) { timer.update(); fps = 100 / timer.elapsed; NGFX_LOG(\"FPS: %3.2f\", fps); numFrames = 0; } } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/FPSCounter.cpp"},{"location":"api/Files/FPSCounter_8cpp/#srcngfxcorefpscountercpp","text":"","title":"src/ngfx/core/FPSCounter.cpp"},{"location":"api/Files/FPSCounter_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/FPSCounter.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void FPSCounter::update() { numFrames++; if (numFrames == 100) { timer.update(); fps = 100 / timer.elapsed; NGFX_LOG(\"FPS: %3.2f\", fps); numFrames = 0; } } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/FPSCounter_8h/","text":"src/ngfx/core/FPSCounter.h Namespaces Name ngfx Classes Name class ngfx::FPSCounter Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/Timer.h\" namespace ngfx { class FPSCounter { public: FPSCounter() {} void update(); float fps = 0.0f; private: int numFrames = 0; Timer timer; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/FPSCounter.h"},{"location":"api/Files/FPSCounter_8h/#srcngfxcorefpscounterh","text":"","title":"src/ngfx/core/FPSCounter.h"},{"location":"api/Files/FPSCounter_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/FPSCounter_8h/#classes","text":"Name class ngfx::FPSCounter","title":"Classes"},{"location":"api/Files/FPSCounter_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/Timer.h\" namespace ngfx { class FPSCounter { public: FPSCounter() {} void update(); float fps = 0.0f; private: int numFrames = 0; Timer timer; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Fence_8h/","text":"src/ngfx/graphics/Fence.h Namespaces Name ngfx Classes Name class ngfx::Fence Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class Fence { public: static Fence *create(Device *device, FenceCreateFlags flags = 0); virtual ~Fence() {} virtual void wait() = 0; virtual void reset() = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Fence.h"},{"location":"api/Files/Fence_8h/#srcngfxgraphicsfenceh","text":"","title":"src/ngfx/graphics/Fence.h"},{"location":"api/Files/Fence_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Fence_8h/#classes","text":"Name class ngfx::Fence","title":"Classes"},{"location":"api/Files/Fence_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class Fence { public: static Fence *create(Device *device, FenceCreateFlags flags = 0); virtual ~Fence() {} virtual void wait() = 0; virtual void reset() = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/FileUtil_8cpp/","text":"src/ngfx/core/FileUtil.cpp Namespaces Name std std::chrono Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"FileUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/File.h\" #include <cassert> #include <chrono> #include <cstring> #include <fstream> using namespace std; namespace fs = std::filesystem; using namespace ngfx; using namespace std::chrono; bool FileUtil::getmtime(const string &filename, fs::file_time_type &mtime) { if (!fs::exists(filename)) { return false; } mtime = fs::last_write_time(filename); return true; } bool FileUtil::srcFileNewerThanOutFile(const string &srcFileName, const string &targetFileName) { fs::file_time_type srcTimeStamp, targetTimeStamp; getmtime(srcFileName, srcTimeStamp); if (!getmtime(targetFileName, targetTimeStamp)) return true; if (srcTimeStamp > targetTimeStamp) return true; return false; } string FileUtil::tempDir() { return fs::canonical(fs::temp_directory_path()).string(); } FileUtil::Lock::Lock(const std::string &path, uint32_t timeoutMs) : lockPath(path + \".lock\"), timeoutMs(timeoutMs) { fs::path fpath(path); auto t0 = system_clock::now(); while (fs::exists(lockPath)) { std::this_thread::sleep_for(milliseconds(10)); auto t1 = system_clock::now(); if (duration_cast<milliseconds>(t1 - t0).count() > timeoutMs) { NGFX_ERR(\"file locked: %s, timeoutMs: %d\", path.c_str(), timeoutMs); } } writeFile(lockPath, \"\"); } FileUtil::Lock::~Lock() { fs::remove(lockPath); } string FileUtil::readFile(const string &path) { File file; file.read(path); return string(file.data.get(), file.size); } void FileUtil::writeFile(const string &path, const string &contents) { ofstream out(path, ofstream::binary); assert(out); out.write(contents.data(), contents.size()); out.close(); } vector<string> FileUtil::splitExt(const string &filename) { auto it = filename.find_last_of('.'); return {filename.substr(0, it), filename.substr(it)}; } vector<string> FileUtil::findFiles(const string &path) { vector<string> files; for (auto &entry : fs::directory_iterator(path)) { fs::path filePath = entry.path(); files.push_back(filePath.make_preferred().string()); } return files; } vector<string> FileUtil::findFiles(const string &path, const string &ext) { vector<string> files; for (auto &entry : fs::directory_iterator(path)) { fs::path filePath = entry.path(); if (filePath.extension() != ext) continue; files.push_back(filePath.make_preferred().string()); } return files; } vector<string> FileUtil::filterFiles(const vector<string> &files, const string &fileFilter) { vector<string> filteredFiles; for (const string &file : files) { if (strstr(file.c_str(), fileFilter.c_str())) filteredFiles.push_back(file); } return filteredFiles; } vector<string> FileUtil::findFiles(const vector<string> &paths, const vector<string> &extensions) { vector<string> files; for (const string &path : paths) { for (const string &ext : extensions) { vector<string> filteredFiles = findFiles(path, ext); files.insert(files.end(), filteredFiles.begin(), filteredFiles.end()); } } return files; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/FileUtil.cpp"},{"location":"api/Files/FileUtil_8cpp/#srcngfxcorefileutilcpp","text":"","title":"src/ngfx/core/FileUtil.cpp"},{"location":"api/Files/FileUtil_8cpp/#namespaces","text":"Name std std::chrono","title":"Namespaces"},{"location":"api/Files/FileUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"FileUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/File.h\" #include <cassert> #include <chrono> #include <cstring> #include <fstream> using namespace std; namespace fs = std::filesystem; using namespace ngfx; using namespace std::chrono; bool FileUtil::getmtime(const string &filename, fs::file_time_type &mtime) { if (!fs::exists(filename)) { return false; } mtime = fs::last_write_time(filename); return true; } bool FileUtil::srcFileNewerThanOutFile(const string &srcFileName, const string &targetFileName) { fs::file_time_type srcTimeStamp, targetTimeStamp; getmtime(srcFileName, srcTimeStamp); if (!getmtime(targetFileName, targetTimeStamp)) return true; if (srcTimeStamp > targetTimeStamp) return true; return false; } string FileUtil::tempDir() { return fs::canonical(fs::temp_directory_path()).string(); } FileUtil::Lock::Lock(const std::string &path, uint32_t timeoutMs) : lockPath(path + \".lock\"), timeoutMs(timeoutMs) { fs::path fpath(path); auto t0 = system_clock::now(); while (fs::exists(lockPath)) { std::this_thread::sleep_for(milliseconds(10)); auto t1 = system_clock::now(); if (duration_cast<milliseconds>(t1 - t0).count() > timeoutMs) { NGFX_ERR(\"file locked: %s, timeoutMs: %d\", path.c_str(), timeoutMs); } } writeFile(lockPath, \"\"); } FileUtil::Lock::~Lock() { fs::remove(lockPath); } string FileUtil::readFile(const string &path) { File file; file.read(path); return string(file.data.get(), file.size); } void FileUtil::writeFile(const string &path, const string &contents) { ofstream out(path, ofstream::binary); assert(out); out.write(contents.data(), contents.size()); out.close(); } vector<string> FileUtil::splitExt(const string &filename) { auto it = filename.find_last_of('.'); return {filename.substr(0, it), filename.substr(it)}; } vector<string> FileUtil::findFiles(const string &path) { vector<string> files; for (auto &entry : fs::directory_iterator(path)) { fs::path filePath = entry.path(); files.push_back(filePath.make_preferred().string()); } return files; } vector<string> FileUtil::findFiles(const string &path, const string &ext) { vector<string> files; for (auto &entry : fs::directory_iterator(path)) { fs::path filePath = entry.path(); if (filePath.extension() != ext) continue; files.push_back(filePath.make_preferred().string()); } return files; } vector<string> FileUtil::filterFiles(const vector<string> &files, const string &fileFilter) { vector<string> filteredFiles; for (const string &file : files) { if (strstr(file.c_str(), fileFilter.c_str())) filteredFiles.push_back(file); } return filteredFiles; } vector<string> FileUtil::findFiles(const vector<string> &paths, const vector<string> &extensions) { vector<string> files; for (const string &path : paths) { for (const string &ext : extensions) { vector<string> filteredFiles = findFiles(path, ext); files.insert(files.end(), filteredFiles.begin(), filteredFiles.end()); } } return files; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/FileUtil_8h/","text":"src/ngfx/core/FileUtil.h Namespaces Name ngfx Classes Name class ngfx::FileUtil struct ngfx::FileUtil::Lock Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include <filesystem> #include <string> #include <thread> #include <vector> namespace ngfx { class FileUtil { public: static bool getmtime(const std::string &filename, std::filesystem::file_time_type &mtime); static bool srcFileNewerThanOutFile(const std::string &srcFileName, const std::string &targetFileName); static std::string tempDir(); struct Lock { Lock(const std::string &path, uint32_t timeoutMs = 3000); ~Lock(); std::string lockPath; uint32_t timeoutMs; }; static std::string readFile(const std::string &path); static void writeFile(const std::string &path, const std::string &contents); static std::vector<std::string> splitExt(const std::string &filename); static std::vector<std::string> findFiles(const std::string &path); static std::vector<std::string> findFiles(const std::string &path, const std::string &ext); static std::vector<std::string> filterFiles(const std::vector<std::string> &files, const std::string &fileFilter); static std::vector<std::string> findFiles(const std::vector<std::string> &paths, const std::vector<std::string> &extensions); }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/FileUtil.h"},{"location":"api/Files/FileUtil_8h/#srcngfxcorefileutilh","text":"","title":"src/ngfx/core/FileUtil.h"},{"location":"api/Files/FileUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/FileUtil_8h/#classes","text":"Name class ngfx::FileUtil struct ngfx::FileUtil::Lock","title":"Classes"},{"location":"api/Files/FileUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include <filesystem> #include <string> #include <thread> #include <vector> namespace ngfx { class FileUtil { public: static bool getmtime(const std::string &filename, std::filesystem::file_time_type &mtime); static bool srcFileNewerThanOutFile(const std::string &srcFileName, const std::string &targetFileName); static std::string tempDir(); struct Lock { Lock(const std::string &path, uint32_t timeoutMs = 3000); ~Lock(); std::string lockPath; uint32_t timeoutMs; }; static std::string readFile(const std::string &path); static void writeFile(const std::string &path, const std::string &contents); static std::vector<std::string> splitExt(const std::string &filename); static std::vector<std::string> findFiles(const std::string &path); static std::vector<std::string> findFiles(const std::string &path, const std::string &ext); static std::vector<std::string> filterFiles(const std::vector<std::string> &files, const std::string &fileFilter); static std::vector<std::string> findFiles(const std::vector<std::string> &paths, const std::vector<std::string> &extensions); }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/File_8cpp/","text":"src/ngfx/core/File.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/File.h\" #include \"ngfx/core/DebugUtil.h\" #include <cstdlib> #include <fstream> using namespace ngfx; void File::read(const std::string &filename) { std::ifstream in(filename.c_str(), std::ios::binary | std::ios::in | std::ios::ate); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); size = int(in.tellg()); in.seekg(0, std::ios::beg); data.reset(new char[size]); in.read(data.get(), size); in.close(); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/File.cpp"},{"location":"api/Files/File_8cpp/#srcngfxcorefilecpp","text":"","title":"src/ngfx/core/File.cpp"},{"location":"api/Files/File_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/File.h\" #include \"ngfx/core/DebugUtil.h\" #include <cstdlib> #include <fstream> using namespace ngfx; void File::read(const std::string &filename) { std::ifstream in(filename.c_str(), std::ios::binary | std::ios::in | std::ios::ate); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); size = int(in.tellg()); in.seekg(0, std::ios::beg); data.reset(new char[size]); in.read(data.get(), size); in.close(); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/File_8h/","text":"src/ngfx/core/File.h Namespaces Name ngfx Classes Name class ngfx::File Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <memory> #include <string> namespace ngfx { class File { public: void read(const std::string &filename); std::unique_ptr<char[]> data; int size; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/File.h"},{"location":"api/Files/File_8h/#srcngfxcorefileh","text":"","title":"src/ngfx/core/File.h"},{"location":"api/Files/File_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/File_8h/#classes","text":"Name class ngfx::File","title":"Classes"},{"location":"api/Files/File_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <memory> #include <string> namespace ngfx { class File { public: void read(const std::string &filename); std::unique_ptr<char[]> data; int size; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/FilterOp_8cpp/","text":"src/ngfx/graphics/FilterOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/FilterOp.h\" using namespace ngfx; FilterOp::FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight) : DrawOp(ctx) { uint32_t w = dstWidth, h = dstHeight, size = w * h * 4; outputTexture.reset(Texture::create( ctx, graphics, nullptr, PIXELFORMAT_RGBA8_UNORM, size, w, h, 1, 1, ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_DST_BIT | IMAGE_USAGE_COLOR_ATTACHMENT_BIT))); outputFramebuffer.reset(Framebuffer::create(ctx->device, ctx->defaultOffscreenRenderPass, {{outputTexture.get()}}, w, h)); } void FilterOp::apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics) { outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL); ctx->beginOffscreenRenderPass(commandBuffer, graphics, outputFramebuffer.get()); draw(commandBuffer, graphics); ctx->endOffscreenRenderPass(commandBuffer, graphics); outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/FilterOp.cpp"},{"location":"api/Files/FilterOp_8cpp/#srcngfxgraphicsfilteropcpp","text":"","title":"src/ngfx/graphics/FilterOp.cpp"},{"location":"api/Files/FilterOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/FilterOp.h\" using namespace ngfx; FilterOp::FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight) : DrawOp(ctx) { uint32_t w = dstWidth, h = dstHeight, size = w * h * 4; outputTexture.reset(Texture::create( ctx, graphics, nullptr, PIXELFORMAT_RGBA8_UNORM, size, w, h, 1, 1, ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_DST_BIT | IMAGE_USAGE_COLOR_ATTACHMENT_BIT))); outputFramebuffer.reset(Framebuffer::create(ctx->device, ctx->defaultOffscreenRenderPass, {{outputTexture.get()}}, w, h)); } void FilterOp::apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics) { outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL); ctx->beginOffscreenRenderPass(commandBuffer, graphics, outputFramebuffer.get()); draw(commandBuffer, graphics); ctx->endOffscreenRenderPass(commandBuffer, graphics); outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/FilterOp_8h/","text":"src/ngfx/graphics/FilterOp.h Namespaces Name ngfx Classes Name class ngfx::FilterOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class FilterOp : public DrawOp { public: FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight); virtual ~FilterOp() {} void apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics); std::unique_ptr<Texture> outputTexture; std::unique_ptr<Framebuffer> outputFramebuffer; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/FilterOp.h"},{"location":"api/Files/FilterOp_8h/#srcngfxgraphicsfilteroph","text":"","title":"src/ngfx/graphics/FilterOp.h"},{"location":"api/Files/FilterOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/FilterOp_8h/#classes","text":"Name class ngfx::FilterOp","title":"Classes"},{"location":"api/Files/FilterOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class FilterOp : public DrawOp { public: FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight); virtual ~FilterOp() {} void apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics); std::unique_ptr<Texture> outputTexture; std::unique_ptr<Framebuffer> outputFramebuffer; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Framebuffer_8h/","text":"src/ngfx/graphics/Framebuffer.h Namespaces Name ngfx Classes Name class ngfx::Framebuffer struct ngfx::Framebuffer::Attachment Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Texture.h\" #include <vector> namespace ngfx { class Framebuffer { public: struct Attachment { Texture *texture = nullptr; uint32_t level = 0, layer = 0; }; static Framebuffer *create(Device *device, RenderPass *renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers = 1); virtual ~Framebuffer() {} uint32_t w, h, layers, numAttachments; std::vector<Attachment> attachments; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Framebuffer.h"},{"location":"api/Files/Framebuffer_8h/#srcngfxgraphicsframebufferh","text":"","title":"src/ngfx/graphics/Framebuffer.h"},{"location":"api/Files/Framebuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Framebuffer_8h/#classes","text":"Name class ngfx::Framebuffer struct ngfx::Framebuffer::Attachment","title":"Classes"},{"location":"api/Files/Framebuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Texture.h\" #include <vector> namespace ngfx { class Framebuffer { public: struct Attachment { Texture *texture = nullptr; uint32_t level = 0, layer = 0; }; static Framebuffer *create(Device *device, RenderPass *renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers = 1); virtual ~Framebuffer() {} uint32_t w, h, layers, numAttachments; std::vector<Attachment> attachments; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/GraphicsContext_8h/","text":"src/ngfx/graphics/GraphicsContext.h Namespaces Name ngfx Classes Name class ngfx::GraphicsContext struct ngfx::GraphicsContext::AttachmentDescription struct ngfx::GraphicsContext::RenderPassConfig Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePass.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/PipelineCache.h\" #include \"ngfx/graphics/Queue.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Surface.h\" #include \"ngfx/graphics/Swapchain.h\" #include <optional> #include <vector> namespace ngfx { class GraphicsContext { public: static GraphicsContext *create(const char *appName, bool enableDepthStencil = false, bool debug = true); virtual ~GraphicsContext() {} virtual void setSurface(Surface *surface) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { auto framebuffer = swapchainFramebuffers[currentImageIndex]; uint32_t w = framebuffer->w, h = framebuffer->h; graphics->beginRenderPass(commandBuffer, defaultRenderPass, framebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, w, h}); graphics->setScissor(commandBuffer, {0, 0, w, h}); } virtual void beginOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics, Framebuffer *outputFramebuffer) { graphics->beginRenderPass(commandBuffer, defaultOffscreenRenderPass, outputFramebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); graphics->setScissor(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); } virtual void endRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void endOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void submit(CommandBuffer *commandBuffer) { queue->submit(commandBuffer); } Device *device; uint32_t numDrawCommandBuffers = 0; virtual CommandBuffer *drawCommandBuffer(int32_t index = -1) = 0; virtual CommandBuffer *copyCommandBuffer() = 0; virtual CommandBuffer *computeCommandBuffer() = 0; struct AttachmentDescription { bool operator==(const AttachmentDescription &rhs) const { return rhs.format == format && rhs.initialLayout == initialLayout && rhs.finalLayout == finalLayout; } PixelFormat format; std::optional<ImageLayout> initialLayout, finalLayout; }; struct RenderPassConfig { bool operator==(const RenderPassConfig &rhs) const { return rhs.colorAttachmentDescriptions == colorAttachmentDescriptions && rhs.depthStencilAttachmentDescription == depthStencilAttachmentDescription && rhs.enableDepthStencilResolve == enableDepthStencilResolve && rhs.numSamples == numSamples; }; uint32_t numColorAttachments() const { return uint32_t(colorAttachmentDescriptions.size()); } std::vector<AttachmentDescription> colorAttachmentDescriptions; std::optional<AttachmentDescription> depthStencilAttachmentDescription; bool enableDepthStencilResolve = false; uint32_t numSamples = 1; }; virtual RenderPass *getRenderPass(RenderPassConfig config) = 0; std::vector<Framebuffer *> swapchainFramebuffers; Queue *queue = nullptr; RenderPass *defaultRenderPass = nullptr, *defaultOffscreenRenderPass = nullptr; Swapchain *swapchain = nullptr; Surface *surface = nullptr; uint32_t currentImageIndex = 0; std::vector<Fence *> frameFences; Fence *computeFence = nullptr; Semaphore *presentCompleteSemaphore = nullptr, *renderCompleteSemaphore = nullptr; PipelineCache *pipelineCache = nullptr; PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED, defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED, depthFormat = PIXELFORMAT_UNDEFINED; glm::vec4 clearColor = glm::vec4(0.0f); protected: bool debug = false, enableDepthStencil = false; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/GraphicsContext.h"},{"location":"api/Files/GraphicsContext_8h/#srcngfxgraphicsgraphicscontexth","text":"","title":"src/ngfx/graphics/GraphicsContext.h"},{"location":"api/Files/GraphicsContext_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GraphicsContext_8h/#classes","text":"Name class ngfx::GraphicsContext struct ngfx::GraphicsContext::AttachmentDescription struct ngfx::GraphicsContext::RenderPassConfig","title":"Classes"},{"location":"api/Files/GraphicsContext_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePass.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/PipelineCache.h\" #include \"ngfx/graphics/Queue.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Surface.h\" #include \"ngfx/graphics/Swapchain.h\" #include <optional> #include <vector> namespace ngfx { class GraphicsContext { public: static GraphicsContext *create(const char *appName, bool enableDepthStencil = false, bool debug = true); virtual ~GraphicsContext() {} virtual void setSurface(Surface *surface) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { auto framebuffer = swapchainFramebuffers[currentImageIndex]; uint32_t w = framebuffer->w, h = framebuffer->h; graphics->beginRenderPass(commandBuffer, defaultRenderPass, framebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, w, h}); graphics->setScissor(commandBuffer, {0, 0, w, h}); } virtual void beginOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics, Framebuffer *outputFramebuffer) { graphics->beginRenderPass(commandBuffer, defaultOffscreenRenderPass, outputFramebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); graphics->setScissor(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); } virtual void endRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void endOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void submit(CommandBuffer *commandBuffer) { queue->submit(commandBuffer); } Device *device; uint32_t numDrawCommandBuffers = 0; virtual CommandBuffer *drawCommandBuffer(int32_t index = -1) = 0; virtual CommandBuffer *copyCommandBuffer() = 0; virtual CommandBuffer *computeCommandBuffer() = 0; struct AttachmentDescription { bool operator==(const AttachmentDescription &rhs) const { return rhs.format == format && rhs.initialLayout == initialLayout && rhs.finalLayout == finalLayout; } PixelFormat format; std::optional<ImageLayout> initialLayout, finalLayout; }; struct RenderPassConfig { bool operator==(const RenderPassConfig &rhs) const { return rhs.colorAttachmentDescriptions == colorAttachmentDescriptions && rhs.depthStencilAttachmentDescription == depthStencilAttachmentDescription && rhs.enableDepthStencilResolve == enableDepthStencilResolve && rhs.numSamples == numSamples; }; uint32_t numColorAttachments() const { return uint32_t(colorAttachmentDescriptions.size()); } std::vector<AttachmentDescription> colorAttachmentDescriptions; std::optional<AttachmentDescription> depthStencilAttachmentDescription; bool enableDepthStencilResolve = false; uint32_t numSamples = 1; }; virtual RenderPass *getRenderPass(RenderPassConfig config) = 0; std::vector<Framebuffer *> swapchainFramebuffers; Queue *queue = nullptr; RenderPass *defaultRenderPass = nullptr, *defaultOffscreenRenderPass = nullptr; Swapchain *swapchain = nullptr; Surface *surface = nullptr; uint32_t currentImageIndex = 0; std::vector<Fence *> frameFences; Fence *computeFence = nullptr; Semaphore *presentCompleteSemaphore = nullptr, *renderCompleteSemaphore = nullptr; PipelineCache *pipelineCache = nullptr; PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED, defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED, depthFormat = PIXELFORMAT_UNDEFINED; glm::vec4 clearColor = glm::vec4(0.0f); protected: bool debug = false, enableDepthStencil = false; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/GraphicsCore_8h/","text":"src/ngfx/graphics/GraphicsCore.h Namespaces Name ngfx Classes Name struct ngfx::Rect2D Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> #include <string> #ifdef NGFX_GRAPHICS_BACKEND_VULKAN #include \"ngfx/porting/vulkan/VKGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_DIRECT3D12 #include \"ngfx/porting/d3d/D3DGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_METAL #include \"ngfx/porting/metal/MTLGraphicsCore.h\" #endif namespace ngfx { typedef uint32_t Flags; typedef Flags PipelineStageFlags; typedef Flags ShaderStageFlags; typedef Flags FenceCreateFlags; typedef Flags ImageUsageFlags; typedef Flags ColorComponentFlags; typedef Flags BufferUsageFlags; struct Rect2D { int32_t x, y; uint32_t w, h; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/GraphicsCore.h"},{"location":"api/Files/GraphicsCore_8h/#srcngfxgraphicsgraphicscoreh","text":"","title":"src/ngfx/graphics/GraphicsCore.h"},{"location":"api/Files/GraphicsCore_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GraphicsCore_8h/#classes","text":"Name struct ngfx::Rect2D","title":"Classes"},{"location":"api/Files/GraphicsCore_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> #include <string> #ifdef NGFX_GRAPHICS_BACKEND_VULKAN #include \"ngfx/porting/vulkan/VKGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_DIRECT3D12 #include \"ngfx/porting/d3d/D3DGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_METAL #include \"ngfx/porting/metal/MTLGraphicsCore.h\" #endif namespace ngfx { typedef uint32_t Flags; typedef Flags PipelineStageFlags; typedef Flags ShaderStageFlags; typedef Flags FenceCreateFlags; typedef Flags ImageUsageFlags; typedef Flags ColorComponentFlags; typedef Flags BufferUsageFlags; struct Rect2D { int32_t x, y; uint32_t w, h; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/GraphicsPipeline_8cpp/","text":"src/ngfx/graphics/GraphicsPipeline.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/GraphicsPipeline.h\" #include <set> using namespace ngfx; void GraphicsPipeline::getBindings( std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings) { for (uint32_t j = 0; j < pDescriptorBindings.size(); j++) *pDescriptorBindings[j] = descriptorBindings[j]; for (uint32_t j = 0; j < pVertexAttribBindings.size(); j++) *pVertexAttribBindings[j] = vertexAttributeBindings[j]; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/GraphicsPipeline.cpp"},{"location":"api/Files/GraphicsPipeline_8cpp/#srcngfxgraphicsgraphicspipelinecpp","text":"","title":"src/ngfx/graphics/GraphicsPipeline.cpp"},{"location":"api/Files/GraphicsPipeline_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/GraphicsPipeline.h\" #include <set> using namespace ngfx; void GraphicsPipeline::getBindings( std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings) { for (uint32_t j = 0; j < pDescriptorBindings.size(); j++) *pDescriptorBindings[j] = descriptorBindings[j]; for (uint32_t j = 0; j < pVertexAttribBindings.size(); j++) *pVertexAttribBindings[j] = vertexAttributeBindings[j]; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/GraphicsPipeline_8h/","text":"src/ngfx/graphics/GraphicsPipeline.h Namespaces Name ngfx Classes Name class ngfx::GraphicsPipeline struct ngfx::GraphicsPipeline::State struct ngfx::GraphicsPipeline::Descriptor Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Pipeline.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/ShaderModule.h\" #include <set> #include <vector> namespace ngfx { class GraphicsContext; class GraphicsPipeline : public Pipeline { public: struct State { PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; PolygonMode polygonMode = POLYGON_MODE_FILL; bool blendEnable = false; BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendOp colorBlendOp = BLEND_OP_ADD, alphaBlendOp = BLEND_OP_ADD; uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT; CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT; FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE; float lineWidth = 1.0f; bool depthTestEnable = false, depthWriteEnable = false; RenderPass *renderPass = nullptr; uint32_t numSamples = 1, numColorAttachments = 1; }; struct Descriptor { DescriptorType type; ShaderStageFlags stageFlags = SHADER_STAGE_ALL; }; static GraphicsPipeline * create(GraphicsContext *graphicsContext, const State &state, VertexShaderModule *vs, FragmentShaderModule *fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes = {}); virtual ~GraphicsPipeline() {} void getBindings(std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings); std::vector<uint32_t> descriptorBindings, vertexAttributeBindings; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/GraphicsPipeline.h"},{"location":"api/Files/GraphicsPipeline_8h/#srcngfxgraphicsgraphicspipelineh","text":"","title":"src/ngfx/graphics/GraphicsPipeline.h"},{"location":"api/Files/GraphicsPipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GraphicsPipeline_8h/#classes","text":"Name class ngfx::GraphicsPipeline struct ngfx::GraphicsPipeline::State struct ngfx::GraphicsPipeline::Descriptor","title":"Classes"},{"location":"api/Files/GraphicsPipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Pipeline.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/ShaderModule.h\" #include <set> #include <vector> namespace ngfx { class GraphicsContext; class GraphicsPipeline : public Pipeline { public: struct State { PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; PolygonMode polygonMode = POLYGON_MODE_FILL; bool blendEnable = false; BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendOp colorBlendOp = BLEND_OP_ADD, alphaBlendOp = BLEND_OP_ADD; uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT; CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT; FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE; float lineWidth = 1.0f; bool depthTestEnable = false, depthWriteEnable = false; RenderPass *renderPass = nullptr; uint32_t numSamples = 1, numColorAttachments = 1; }; struct Descriptor { DescriptorType type; ShaderStageFlags stageFlags = SHADER_STAGE_ALL; }; static GraphicsPipeline * create(GraphicsContext *graphicsContext, const State &state, VertexShaderModule *vs, FragmentShaderModule *fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes = {}); virtual ~GraphicsPipeline() {} void getBindings(std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings); std::vector<uint32_t> descriptorBindings, vertexAttributeBindings; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Graphics_8h/","text":"src/ngfx/graphics/Graphics.h Namespaces Name ngfx Classes Name class ngfx::Graphics Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/graphics/Texture.h\" #include <cstdint> #include <glm/glm.hpp> namespace ngfx { class Graphics { public: static Graphics *create(GraphicsContext *ctx); virtual ~Graphics() {} virtual void beginComputePass(CommandBuffer *commandBuffer) = 0; virtual void endComputePass(CommandBuffer *commandBuffer) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) = 0; virtual void endRenderPass(CommandBuffer *commandBuffer) = 0; virtual void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) = 0; virtual void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat = INDEXFORMAT_UINT32) = 0; virtual void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) = 0; virtual void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) = 0; virtual void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) = 0; // TODO: copyBuffer: ToBuffer, copyBuffer: ToTexture, copyTexture: ToBuffer, // blit virtual void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) = 0; virtual void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) = 0; virtual void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) = 0; virtual void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void waitIdle(CommandBuffer *cmdBuffer) = 0; Rect2D scissorRect; Rect2D viewport; Pipeline *currentPipeline = nullptr; RenderPass *currentRenderPass = nullptr; Framebuffer *currentFramebuffer = nullptr; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Graphics.h"},{"location":"api/Files/Graphics_8h/#srcngfxgraphicsgraphicsh","text":"","title":"src/ngfx/graphics/Graphics.h"},{"location":"api/Files/Graphics_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Graphics_8h/#classes","text":"Name class ngfx::Graphics","title":"Classes"},{"location":"api/Files/Graphics_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/graphics/Texture.h\" #include <cstdint> #include <glm/glm.hpp> namespace ngfx { class Graphics { public: static Graphics *create(GraphicsContext *ctx); virtual ~Graphics() {} virtual void beginComputePass(CommandBuffer *commandBuffer) = 0; virtual void endComputePass(CommandBuffer *commandBuffer) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) = 0; virtual void endRenderPass(CommandBuffer *commandBuffer) = 0; virtual void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) = 0; virtual void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat = INDEXFORMAT_UINT32) = 0; virtual void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) = 0; virtual void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) = 0; virtual void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) = 0; // TODO: copyBuffer: ToBuffer, copyBuffer: ToTexture, copyTexture: ToBuffer, // blit virtual void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) = 0; virtual void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) = 0; virtual void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) = 0; virtual void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void waitIdle(CommandBuffer *cmdBuffer) = 0; Rect2D scissorRect; Rect2D viewport; Pipeline *currentPipeline = nullptr; RenderPass *currentRenderPass = nullptr; Framebuffer *currentFramebuffer = nullptr; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/InputListener_8h/","text":"src/ngfx/input/InputListener.h Namespaces Name ngfx Classes Name class ngfx::InputListener Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/input/InputMap.h\" namespace ngfx { class InputListener { public: virtual void onKey(KeyCode code, InputAction action) {} virtual void onScroll(double xoffset, double yoffset) {} virtual void onCursorPos(double x, double y) {} virtual void onMouseButton(MouseButton button, InputAction action) {} }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/input/InputListener.h"},{"location":"api/Files/InputListener_8h/#srcngfxinputinputlistenerh","text":"","title":"src/ngfx/input/InputListener.h"},{"location":"api/Files/InputListener_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/InputListener_8h/#classes","text":"Name class ngfx::InputListener","title":"Classes"},{"location":"api/Files/InputListener_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/input/InputMap.h\" namespace ngfx { class InputListener { public: virtual void onKey(KeyCode code, InputAction action) {} virtual void onScroll(double xoffset, double yoffset) {} virtual void onCursorPos(double x, double y) {} virtual void onMouseButton(MouseButton button, InputAction action) {} }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/InputMap_8h/","text":"src/ngfx/input/InputMap.h Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #ifdef NGFX_WINDOW_BACKEND_GLFW #include \"ngfx/porting/glfw/GLFWInputMap.h\" #endif #ifdef NGFX_WINDOW_BACKEND_WINDOWS #include \"ngfx/porting/windows/WInputMap.h\" #endif #ifdef NGFX_WINDOW_BACKEND_APPKIT #include \"ngfx/porting/appkit/AppKitInputMap.h\" #endif Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/input/InputMap.h"},{"location":"api/Files/InputMap_8h/#srcngfxinputinputmaph","text":"","title":"src/ngfx/input/InputMap.h"},{"location":"api/Files/InputMap_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #ifdef NGFX_WINDOW_BACKEND_GLFW #include \"ngfx/porting/glfw/GLFWInputMap.h\" #endif #ifdef NGFX_WINDOW_BACKEND_WINDOWS #include \"ngfx/porting/windows/WInputMap.h\" #endif #ifdef NGFX_WINDOW_BACKEND_APPKIT #include \"ngfx/porting/appkit/AppKitInputMap.h\" #endif Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/","text":"src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp Defines Name VEC4_LOAD (src, j) Macro Documentation define VEC4_LOAD #define VEC4_LOAD( src, j ) vec4(src.data[j], src.data[j + 1], src.data[j + 2], src.data[j + 3]) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/computeOps/MatrixMultiplyCPUOp.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include <glm/glm.hpp> using namespace ngfx; using namespace glm; MatrixMultiplyCPUOp::MatrixMultiplyCPUOp(MatrixParam src0, MatrixParam src1, MatrixParam dst) : MatrixMultiplyOp(nullptr), dst(dst) { update(src0, src1); } MatrixMultiplyCPUOp::~MatrixMultiplyCPUOp() {} void MatrixMultiplyCPUOp::apply(CommandBuffer *, Graphics *) { matrixMultiply(); } void MatrixMultiplyCPUOp::update(MatrixParam src0, MatrixParam src1) { this->src0 = src0; this->src1 = src1; src1t_data.resize(src1.w * src1.h); src1t = {src1.h, src1.w, src1t_data.data()}; transpose(src1, src1t); } void MatrixMultiplyCPUOp::transpose(MatrixParam &src, MatrixParam &dst) { Timer timer; float *dst_data = dst.data; for (uint32_t dst_row = 0; dst_row < dst.h; dst_row++) { for (uint32_t dst_col = 0; dst_col < dst.w; dst_col++) { float *src_data = &src.data[dst_col * src.w + dst_row]; *dst_data++ = *src_data; } } timer.update(); NGFX_LOG(\"transpose elapsed: %f\", timer.elapsed); } #define VEC4_LOAD(src, j) \\ vec4(src.data[j], src.data[j + 1], src.data[j + 2], src.data[j + 3]) void MatrixMultiplyCPUOp::matrixMultiply() { Timer timer; float *dst_data = dst.data; for (uint32_t dst_row = 0; dst_row < dst.h; dst_row++) { uint32_t src0_offset = dst_row * src0.w; for (uint32_t dst_col = 0; dst_col < dst.w; dst_col++) { uint32_t src1t_offset = dst_col * src1t.h; float c = 0.0f; for (uint32_t j = 0; j < src0.w; j += 4) { vec4 a0 = VEC4_LOAD(src0, src0_offset + j), b0 = VEC4_LOAD(src1t, src1t_offset + j); c += dot(a0, b0); } *dst_data++ = c; } } timer.update(); NGFX_LOG(\"CPU matrix multiply elapsed: %f\", timer.elapsed); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/#srcngfxcomputeopsmatrixmultiplycpuopcpp","text":"","title":"src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/#defines","text":"Name VEC4_LOAD (src, j)","title":"Defines"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/#define-vec4_load","text":"#define VEC4_LOAD( src, j ) vec4(src.data[j], src.data[j + 1], src.data[j + 2], src.data[j + 3])","title":"define VEC4_LOAD"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/computeOps/MatrixMultiplyCPUOp.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include <glm/glm.hpp> using namespace ngfx; using namespace glm; MatrixMultiplyCPUOp::MatrixMultiplyCPUOp(MatrixParam src0, MatrixParam src1, MatrixParam dst) : MatrixMultiplyOp(nullptr), dst(dst) { update(src0, src1); } MatrixMultiplyCPUOp::~MatrixMultiplyCPUOp() {} void MatrixMultiplyCPUOp::apply(CommandBuffer *, Graphics *) { matrixMultiply(); } void MatrixMultiplyCPUOp::update(MatrixParam src0, MatrixParam src1) { this->src0 = src0; this->src1 = src1; src1t_data.resize(src1.w * src1.h); src1t = {src1.h, src1.w, src1t_data.data()}; transpose(src1, src1t); } void MatrixMultiplyCPUOp::transpose(MatrixParam &src, MatrixParam &dst) { Timer timer; float *dst_data = dst.data; for (uint32_t dst_row = 0; dst_row < dst.h; dst_row++) { for (uint32_t dst_col = 0; dst_col < dst.w; dst_col++) { float *src_data = &src.data[dst_col * src.w + dst_row]; *dst_data++ = *src_data; } } timer.update(); NGFX_LOG(\"transpose elapsed: %f\", timer.elapsed); } #define VEC4_LOAD(src, j) \\ vec4(src.data[j], src.data[j + 1], src.data[j + 2], src.data[j + 3]) void MatrixMultiplyCPUOp::matrixMultiply() { Timer timer; float *dst_data = dst.data; for (uint32_t dst_row = 0; dst_row < dst.h; dst_row++) { uint32_t src0_offset = dst_row * src0.w; for (uint32_t dst_col = 0; dst_col < dst.w; dst_col++) { uint32_t src1t_offset = dst_col * src1t.h; float c = 0.0f; for (uint32_t j = 0; j < src0.w; j += 4) { vec4 a0 = VEC4_LOAD(src0, src0_offset + j), b0 = VEC4_LOAD(src1t, src1t_offset + j); c += dot(a0, b0); } *dst_data++ = c; } } timer.update(); NGFX_LOG(\"CPU matrix multiply elapsed: %f\", timer.elapsed); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MatrixMultiplyCPUOp_8h/","text":"src/ngfx/computeOps/MatrixMultiplyCPUOp.h Namespaces Name ngfx Classes Name class ngfx::MatrixMultiplyCPUOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/computeOps/MatrixMultiplyOp.h\" namespace ngfx { class MatrixMultiplyCPUOp : public MatrixMultiplyOp { public: MatrixMultiplyCPUOp(MatrixParam src0, MatrixParam src1, MatrixParam dst); virtual ~MatrixMultiplyCPUOp(); void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) override; void update(MatrixParam src0, MatrixParam src1) override; static void transpose(MatrixParam &src, MatrixParam &dst); protected: void matrixMultiply(); std::vector<float> src1t_data; MatrixParam src0, src1, src1t, dst; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/computeOps/MatrixMultiplyCPUOp.h"},{"location":"api/Files/MatrixMultiplyCPUOp_8h/#srcngfxcomputeopsmatrixmultiplycpuoph","text":"","title":"src/ngfx/computeOps/MatrixMultiplyCPUOp.h"},{"location":"api/Files/MatrixMultiplyCPUOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MatrixMultiplyCPUOp_8h/#classes","text":"Name class ngfx::MatrixMultiplyCPUOp","title":"Classes"},{"location":"api/Files/MatrixMultiplyCPUOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/computeOps/MatrixMultiplyOp.h\" namespace ngfx { class MatrixMultiplyCPUOp : public MatrixMultiplyOp { public: MatrixMultiplyCPUOp(MatrixParam src0, MatrixParam src1, MatrixParam dst); virtual ~MatrixMultiplyCPUOp(); void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) override; void update(MatrixParam src0, MatrixParam src1) override; static void transpose(MatrixParam &src, MatrixParam &dst); protected: void matrixMultiply(); std::vector<float> src1t_data; MatrixParam src0, src1, src1t, dst; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MatrixMultiplyGPUOp_8cpp/","text":"src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/computeOps/MatrixMultiplyGPUOp.h\" #include \"ngfx/computeOps/MatrixMultiplyCPUOp.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include \"ngfx/graphics/BufferUtil.h\" using namespace ngfx; MatrixMultiplyGPUOp::MatrixMultiplyGPUOp(GraphicsContext *ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst) : MatrixMultiplyOp(ctx), dst(dst) { update(src0, src1); createPipeline(); } MatrixMultiplyGPUOp::~MatrixMultiplyGPUOp() {} void MatrixMultiplyGPUOp::apply(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindComputePipeline(commandBuffer, computePipeline); graphics->bindUniformBuffer(commandBuffer, bUbo.get(), U_UBO, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bSrc0.get(), SSBO_SRC0, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bSrc1.get(), SSBO_SRC1, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bDst.get(), SSBO_DST, SHADER_STAGE_COMPUTE_BIT); graphics->dispatch(commandBuffer, dst.w, dst.h, 1, 1, 1, 1); } void MatrixMultiplyGPUOp::update(MatrixParam src0, MatrixParam src1) { std::vector<float> src1t_data(size_t(src1.w * src1.h)); MatrixParam src1t = {src1.h, src1.w, src1t_data.data()}; MatrixMultiplyCPUOp::transpose(src1, src1t); UboData uboData = {int32_t(src0.w), int32_t(src0.h), int32_t(src1t.w), int32_t(src1t.h), int32_t(dst.w), int32_t(dst.h)}; bUbo.reset(createUniformBuffer(ctx, &uboData, sizeof(uboData))); bSrc0.reset( createStorageBuffer(ctx, src0.data, src0.w * src0.h * sizeof(float))); bSrc1.reset( createStorageBuffer(ctx, src1t.data, src1.w * src1.h * sizeof(float))); bDst.reset(createStorageBuffer(ctx, dst.data, dst.w * dst.h * sizeof(float))); } void MatrixMultiplyGPUOp::createPipeline() { const std::string key = \"matrixMultiplyOp\"; computePipeline = (ComputePipeline *)ctx->pipelineCache->get(key); if (computePipeline) return; computePipeline = ComputePipeline::create( ctx, ComputeShaderModule::create(ctx->device, \"matrixMultiply.comp\").get()); ctx->pipelineCache->add(key, computePipeline); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp"},{"location":"api/Files/MatrixMultiplyGPUOp_8cpp/#srcngfxcomputeopsmatrixmultiplygpuopcpp","text":"","title":"src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp"},{"location":"api/Files/MatrixMultiplyGPUOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/computeOps/MatrixMultiplyGPUOp.h\" #include \"ngfx/computeOps/MatrixMultiplyCPUOp.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include \"ngfx/graphics/BufferUtil.h\" using namespace ngfx; MatrixMultiplyGPUOp::MatrixMultiplyGPUOp(GraphicsContext *ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst) : MatrixMultiplyOp(ctx), dst(dst) { update(src0, src1); createPipeline(); } MatrixMultiplyGPUOp::~MatrixMultiplyGPUOp() {} void MatrixMultiplyGPUOp::apply(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindComputePipeline(commandBuffer, computePipeline); graphics->bindUniformBuffer(commandBuffer, bUbo.get(), U_UBO, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bSrc0.get(), SSBO_SRC0, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bSrc1.get(), SSBO_SRC1, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bDst.get(), SSBO_DST, SHADER_STAGE_COMPUTE_BIT); graphics->dispatch(commandBuffer, dst.w, dst.h, 1, 1, 1, 1); } void MatrixMultiplyGPUOp::update(MatrixParam src0, MatrixParam src1) { std::vector<float> src1t_data(size_t(src1.w * src1.h)); MatrixParam src1t = {src1.h, src1.w, src1t_data.data()}; MatrixMultiplyCPUOp::transpose(src1, src1t); UboData uboData = {int32_t(src0.w), int32_t(src0.h), int32_t(src1t.w), int32_t(src1t.h), int32_t(dst.w), int32_t(dst.h)}; bUbo.reset(createUniformBuffer(ctx, &uboData, sizeof(uboData))); bSrc0.reset( createStorageBuffer(ctx, src0.data, src0.w * src0.h * sizeof(float))); bSrc1.reset( createStorageBuffer(ctx, src1t.data, src1.w * src1.h * sizeof(float))); bDst.reset(createStorageBuffer(ctx, dst.data, dst.w * dst.h * sizeof(float))); } void MatrixMultiplyGPUOp::createPipeline() { const std::string key = \"matrixMultiplyOp\"; computePipeline = (ComputePipeline *)ctx->pipelineCache->get(key); if (computePipeline) return; computePipeline = ComputePipeline::create( ctx, ComputeShaderModule::create(ctx->device, \"matrixMultiply.comp\").get()); ctx->pipelineCache->add(key, computePipeline); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MatrixMultiplyGPUOp_8h/","text":"src/ngfx/computeOps/MatrixMultiplyGPUOp.h Namespaces Name ngfx Classes Name class ngfx::MatrixMultiplyGPUOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/computeOps/MatrixMultiplyOp.h\" #include \"ngfx/graphics/Graphics.h\" namespace ngfx { class MatrixMultiplyGPUOp : public MatrixMultiplyOp { public: MatrixMultiplyGPUOp(GraphicsContext *ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst); virtual ~MatrixMultiplyGPUOp(); virtual void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr); virtual void update(MatrixParam src0, MatrixParam src1); std::unique_ptr<Buffer> bUbo; std::unique_ptr<Buffer> bSrc0, bSrc1, bDst; protected: struct UboData { int32_t src0_w, src0_h, src1t_w, src1t_h, dst_w, dst_h; }; void createPipeline(); ComputePipeline *computePipeline; uint32_t U_UBO = 0, SSBO_SRC0 = 1, SSBO_SRC1 = 2, SSBO_DST = 3; MatrixParam dst; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/computeOps/MatrixMultiplyGPUOp.h"},{"location":"api/Files/MatrixMultiplyGPUOp_8h/#srcngfxcomputeopsmatrixmultiplygpuoph","text":"","title":"src/ngfx/computeOps/MatrixMultiplyGPUOp.h"},{"location":"api/Files/MatrixMultiplyGPUOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MatrixMultiplyGPUOp_8h/#classes","text":"Name class ngfx::MatrixMultiplyGPUOp","title":"Classes"},{"location":"api/Files/MatrixMultiplyGPUOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/computeOps/MatrixMultiplyOp.h\" #include \"ngfx/graphics/Graphics.h\" namespace ngfx { class MatrixMultiplyGPUOp : public MatrixMultiplyOp { public: MatrixMultiplyGPUOp(GraphicsContext *ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst); virtual ~MatrixMultiplyGPUOp(); virtual void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr); virtual void update(MatrixParam src0, MatrixParam src1); std::unique_ptr<Buffer> bUbo; std::unique_ptr<Buffer> bSrc0, bSrc1, bDst; protected: struct UboData { int32_t src0_w, src0_h, src1t_w, src1t_h, dst_w, dst_h; }; void createPipeline(); ComputePipeline *computePipeline; uint32_t U_UBO = 0, SSBO_SRC0 = 1, SSBO_SRC1 = 2, SSBO_DST = 3; MatrixParam dst; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MatrixMultiplyOp_8h/","text":"src/ngfx/computeOps/MatrixMultiplyOp.h Namespaces Name ngfx Classes Name class ngfx::MatrixMultiplyOp struct ngfx::MatrixMultiplyOp::MatrixParam Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputeOp.h\" #include <memory> namespace ngfx { class MatrixMultiplyOp : public ComputeOp { public: struct MatrixParam { uint32_t w, h; float *data; }; MatrixMultiplyOp(GraphicsContext *ctx) : ComputeOp(ctx) {} virtual ~MatrixMultiplyOp() {} void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) override = 0; virtual void update(MatrixParam src0, MatrixParam src1) = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/computeOps/MatrixMultiplyOp.h"},{"location":"api/Files/MatrixMultiplyOp_8h/#srcngfxcomputeopsmatrixmultiplyoph","text":"","title":"src/ngfx/computeOps/MatrixMultiplyOp.h"},{"location":"api/Files/MatrixMultiplyOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MatrixMultiplyOp_8h/#classes","text":"Name class ngfx::MatrixMultiplyOp struct ngfx::MatrixMultiplyOp::MatrixParam","title":"Classes"},{"location":"api/Files/MatrixMultiplyOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputeOp.h\" #include <memory> namespace ngfx { class MatrixMultiplyOp : public ComputeOp { public: struct MatrixParam { uint32_t w, h; float *data; }; MatrixMultiplyOp(GraphicsContext *ctx) : ComputeOp(ctx) {} virtual ~MatrixMultiplyOp() {} void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) override = 0; virtual void update(MatrixParam src0, MatrixParam src1) = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MeshData_8h/","text":"src/ngfx/graphics/MeshData.h Namespaces Name ngfx Classes Name struct ngfx::MeshData Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <glm/glm.hpp> #include <vector> using namespace glm; namespace ngfx { struct MeshData { std::vector<vec3> pos, normal; std::vector<ivec3> faces; vec3 bounds[2] = {vec3(FLT_MAX), vec3(FLT_MIN)}; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/MeshData.h"},{"location":"api/Files/MeshData_8h/#srcngfxgraphicsmeshdatah","text":"","title":"src/ngfx/graphics/MeshData.h"},{"location":"api/Files/MeshData_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MeshData_8h/#classes","text":"Name struct ngfx::MeshData","title":"Classes"},{"location":"api/Files/MeshData_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <glm/glm.hpp> #include <vector> using namespace glm; namespace ngfx { struct MeshData { std::vector<vec3> pos, normal; std::vector<ivec3> faces; vec3 bounds[2] = {vec3(FLT_MAX), vec3(FLT_MIN)}; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MeshUtil_8cpp/","text":"src/ngfx/graphics/MeshUtil.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/MeshUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <glm/gtc/type_ptr.hpp> using namespace ngfx; using namespace std; void MeshUtil::importMesh(const std::string &file, MeshData &meshData) { ifstream in(file, ios::binary); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts, numNormals, numFaces; in.read((char *)&numVerts, sizeof(numVerts)); pos.resize(numVerts); in.read((char *)value_ptr(bounds[0]), sizeof(bounds[0])); in.read((char *)value_ptr(bounds[1]), sizeof(bounds[1])); in.read((char *)pos.data(), pos.size() * sizeof(pos[0])); in.read((char *)&numNormals, sizeof(numNormals)); normals.resize(numNormals); in.read((char *)normals.data(), normals.size() * sizeof(normals[0])); in.read((char *)&numFaces, sizeof(numFaces)); faces.resize(numFaces); in.read((char *)faces.data(), faces.size() * sizeof(faces[0])); in.close(); } void MeshUtil::exportMesh(const std::string &file, MeshData &meshData) { ofstream out(file, ios::binary); if (!out.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts = pos.size(), numNormals = normals.size(), numFaces = faces.size(); out.write((const char *)&numVerts, sizeof(numVerts)); out.write((const char *)value_ptr(bounds[0]), sizeof(bounds[0])); out.write((const char *)value_ptr(bounds[1]), sizeof(bounds[1])); out.write((const char *)pos.data(), pos.size() * sizeof(pos[0])); out.write((const char *)&numNormals, sizeof(numNormals)); out.write((const char *)normals.data(), normals.size() * sizeof(normals[0])); out.write((const char *)&numFaces, sizeof(numFaces)); out.write((const char *)faces.data(), faces.size() * sizeof(faces[0])); out.close(); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/MeshUtil.cpp"},{"location":"api/Files/MeshUtil_8cpp/#srcngfxgraphicsmeshutilcpp","text":"","title":"src/ngfx/graphics/MeshUtil.cpp"},{"location":"api/Files/MeshUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/MeshUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <glm/gtc/type_ptr.hpp> using namespace ngfx; using namespace std; void MeshUtil::importMesh(const std::string &file, MeshData &meshData) { ifstream in(file, ios::binary); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts, numNormals, numFaces; in.read((char *)&numVerts, sizeof(numVerts)); pos.resize(numVerts); in.read((char *)value_ptr(bounds[0]), sizeof(bounds[0])); in.read((char *)value_ptr(bounds[1]), sizeof(bounds[1])); in.read((char *)pos.data(), pos.size() * sizeof(pos[0])); in.read((char *)&numNormals, sizeof(numNormals)); normals.resize(numNormals); in.read((char *)normals.data(), normals.size() * sizeof(normals[0])); in.read((char *)&numFaces, sizeof(numFaces)); faces.resize(numFaces); in.read((char *)faces.data(), faces.size() * sizeof(faces[0])); in.close(); } void MeshUtil::exportMesh(const std::string &file, MeshData &meshData) { ofstream out(file, ios::binary); if (!out.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts = pos.size(), numNormals = normals.size(), numFaces = faces.size(); out.write((const char *)&numVerts, sizeof(numVerts)); out.write((const char *)value_ptr(bounds[0]), sizeof(bounds[0])); out.write((const char *)value_ptr(bounds[1]), sizeof(bounds[1])); out.write((const char *)pos.data(), pos.size() * sizeof(pos[0])); out.write((const char *)&numNormals, sizeof(numNormals)); out.write((const char *)normals.data(), normals.size() * sizeof(normals[0])); out.write((const char *)&numFaces, sizeof(numFaces)); out.write((const char *)faces.data(), faces.size() * sizeof(faces[0])); out.close(); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MeshUtil_8h/","text":"src/ngfx/graphics/MeshUtil.h Namespaces Name ngfx Classes Name struct ngfx::MeshUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/MeshData.h\" #include <string> namespace ngfx { struct MeshUtil { static void importMesh(const std::string &file, MeshData &meshData); static void exportMesh(const std::string &file, MeshData &meshData); }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/MeshUtil.h"},{"location":"api/Files/MeshUtil_8h/#srcngfxgraphicsmeshutilh","text":"","title":"src/ngfx/graphics/MeshUtil.h"},{"location":"api/Files/MeshUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MeshUtil_8h/#classes","text":"Name struct ngfx::MeshUtil","title":"Classes"},{"location":"api/Files/MeshUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/MeshData.h\" #include <string> namespace ngfx { struct MeshUtil { static void importMesh(const std::string &file, MeshData &meshData); static void exportMesh(const std::string &file, MeshData &meshData); }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/PipelineCache_8cpp/","text":"src/ngfx/graphics/PipelineCache.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/PipelineCache.h\" using namespace ngfx; Pipeline *PipelineCache::get(const std::string &key) { if (v.find(key) == v.end()) return nullptr; return v[key].get(); } void PipelineCache::add(const std::string &key, Pipeline *value) { v[key].reset(value); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/PipelineCache.cpp"},{"location":"api/Files/PipelineCache_8cpp/#srcngfxgraphicspipelinecachecpp","text":"","title":"src/ngfx/graphics/PipelineCache.cpp"},{"location":"api/Files/PipelineCache_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/PipelineCache.h\" using namespace ngfx; Pipeline *PipelineCache::get(const std::string &key) { if (v.find(key) == v.end()) return nullptr; return v[key].get(); } void PipelineCache::add(const std::string &key, Pipeline *value) { v[key].reset(value); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/PipelineCache_8h/","text":"src/ngfx/graphics/PipelineCache.h Namespaces Name ngfx Classes Name class ngfx::PipelineCache Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Pipeline.h\" #include <map> #include <memory> #include <string> namespace ngfx { class PipelineCache { public: virtual ~PipelineCache() {} virtual Pipeline *get(const std::string &key); virtual void add(const std::string &key, Pipeline *value); private: std::map<std::string, std::unique_ptr<Pipeline>> v; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/PipelineCache.h"},{"location":"api/Files/PipelineCache_8h/#srcngfxgraphicspipelinecacheh","text":"","title":"src/ngfx/graphics/PipelineCache.h"},{"location":"api/Files/PipelineCache_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/PipelineCache_8h/#classes","text":"Name class ngfx::PipelineCache","title":"Classes"},{"location":"api/Files/PipelineCache_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Pipeline.h\" #include <map> #include <memory> #include <string> namespace ngfx { class PipelineCache { public: virtual ~PipelineCache() {} virtual Pipeline *get(const std::string &key); virtual void add(const std::string &key, Pipeline *value); private: std::map<std::string, std::unique_ptr<Pipeline>> v; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Pipeline_8h/","text":"src/ngfx/graphics/Pipeline.h Namespaces Name ngfx Classes Name class ngfx::Pipeline Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Pipeline { public: virtual ~Pipeline() {} }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Pipeline.h"},{"location":"api/Files/Pipeline_8h/#srcngfxgraphicspipelineh","text":"","title":"src/ngfx/graphics/Pipeline.h"},{"location":"api/Files/Pipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Pipeline_8h/#classes","text":"Name class ngfx::Pipeline","title":"Classes"},{"location":"api/Files/Pipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Pipeline { public: virtual ~Pipeline() {} }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ProcessUtil_8cpp/","text":"src/ngfx/core/ProcessUtil.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ProcessUtil.h\" #ifdef _WIN32 #include <windows.h> #else #include <unistd.h> #endif using namespace ngfx; int ProcessUtil::getPID() { #ifdef _WIN32 return GetCurrentProcessId(); #else return getpid(); #endif } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/ProcessUtil.cpp"},{"location":"api/Files/ProcessUtil_8cpp/#srcngfxcoreprocessutilcpp","text":"","title":"src/ngfx/core/ProcessUtil.cpp"},{"location":"api/Files/ProcessUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ProcessUtil.h\" #ifdef _WIN32 #include <windows.h> #else #include <unistd.h> #endif using namespace ngfx; int ProcessUtil::getPID() { #ifdef _WIN32 return GetCurrentProcessId(); #else return getpid(); #endif } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ProcessUtil_8h/","text":"src/ngfx/core/ProcessUtil.h Namespaces Name ngfx Classes Name class ngfx::ProcessUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class ProcessUtil { public: static int getPID(); }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/ProcessUtil.h"},{"location":"api/Files/ProcessUtil_8h/#srcngfxcoreprocessutilh","text":"","title":"src/ngfx/core/ProcessUtil.h"},{"location":"api/Files/ProcessUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ProcessUtil_8h/#classes","text":"Name class ngfx::ProcessUtil","title":"Classes"},{"location":"api/Files/ProcessUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class ProcessUtil { public: static int getPID(); }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Queue_8h/","text":"src/ngfx/graphics/Queue.h Namespaces Name ngfx Classes Name class ngfx::Queue Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Fence.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Swapchain.h\" #include <vector> namespace ngfx { class Queue { public: virtual ~Queue() {} virtual void present() = 0; virtual void submit(CommandBuffer *commandBuffer) = 0; virtual void waitIdle() = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Queue.h"},{"location":"api/Files/Queue_8h/#srcngfxgraphicsqueueh","text":"","title":"src/ngfx/graphics/Queue.h"},{"location":"api/Files/Queue_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Queue_8h/#classes","text":"Name class ngfx::Queue","title":"Classes"},{"location":"api/Files/Queue_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Fence.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Swapchain.h\" #include <vector> namespace ngfx { class Queue { public: virtual ~Queue() {} virtual void present() = 0; virtual void submit(CommandBuffer *commandBuffer) = 0; virtual void waitIdle() = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/RegexUtil_8cpp/","text":"src/ngfx/regex/RegexUtil.cpp Functions Name RegexUtil::Match toMatch (smatch & m) Functions Documentation function toMatch static RegexUtil::Match toMatch( smatch & m ) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"RegexUtil.h\" #include \"ngfx/core/DebugUtil.h\" using namespace std; using namespace ngfx; static RegexUtil::Match toMatch(smatch &m) { RegexUtil::Match match; match.s.resize(m.size()); for (uint32_t j = 0; j < m.size(); j++) match.s[j] = m.str(j); return match; } vector<RegexUtil::Match> RegexUtil::findAll(const regex &p, string contents) { vector<Match> matches; smatch m; while (regex_search(contents, m, p)) { matches.push_back(toMatch(m)); contents = m.suffix().str(); } return matches; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/regex/RegexUtil.cpp"},{"location":"api/Files/RegexUtil_8cpp/#srcngfxregexregexutilcpp","text":"","title":"src/ngfx/regex/RegexUtil.cpp"},{"location":"api/Files/RegexUtil_8cpp/#functions","text":"Name RegexUtil::Match toMatch (smatch & m)","title":"Functions"},{"location":"api/Files/RegexUtil_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/RegexUtil_8cpp/#function-tomatch","text":"static RegexUtil::Match toMatch( smatch & m )","title":"function toMatch"},{"location":"api/Files/RegexUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"RegexUtil.h\" #include \"ngfx/core/DebugUtil.h\" using namespace std; using namespace ngfx; static RegexUtil::Match toMatch(smatch &m) { RegexUtil::Match match; match.s.resize(m.size()); for (uint32_t j = 0; j < m.size(); j++) match.s[j] = m.str(j); return match; } vector<RegexUtil::Match> RegexUtil::findAll(const regex &p, string contents) { vector<Match> matches; smatch m; while (regex_search(contents, m, p)) { matches.push_back(toMatch(m)); contents = m.suffix().str(); } return matches; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/RegexUtil_8h/","text":"src/ngfx/regex/RegexUtil.h Namespaces Name ngfx Classes Name class ngfx::RegexUtil struct ngfx::RegexUtil::Match Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <regex> namespace ngfx { class RegexUtil { public: struct Match { std::vector<std::string> s; }; static std::vector<Match> findAll(const std::regex &p, std::string contents); }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/regex/RegexUtil.h"},{"location":"api/Files/RegexUtil_8h/#srcngfxregexregexutilh","text":"","title":"src/ngfx/regex/RegexUtil.h"},{"location":"api/Files/RegexUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/RegexUtil_8h/#classes","text":"Name class ngfx::RegexUtil struct ngfx::RegexUtil::Match","title":"Classes"},{"location":"api/Files/RegexUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <regex> namespace ngfx { class RegexUtil { public: struct Match { std::vector<std::string> s; }; static std::vector<Match> findAll(const std::regex &p, std::string contents); }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/RenderPass_8h/","text":"src/ngfx/graphics/RenderPass.h Namespaces Name ngfx Classes Name class ngfx::RenderPass Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Framebuffer; class RenderPass { public: virtual ~RenderPass() {} Framebuffer *currentFramebuffer = nullptr; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/RenderPass.h"},{"location":"api/Files/RenderPass_8h/#srcngfxgraphicsrenderpassh","text":"","title":"src/ngfx/graphics/RenderPass.h"},{"location":"api/Files/RenderPass_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/RenderPass_8h/#classes","text":"Name class ngfx::RenderPass","title":"Classes"},{"location":"api/Files/RenderPass_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Framebuffer; class RenderPass { public: virtual ~RenderPass() {} Framebuffer *currentFramebuffer = nullptr; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Semaphore_8h/","text":"src/ngfx/graphics/Semaphore.h Namespaces Name ngfx Classes Name class ngfx::Semaphore Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include <cstdint> namespace ngfx { class Semaphore { public: static Semaphore *create(Device *device); virtual ~Semaphore() {} virtual uint64_t wait() = 0; virtual void signal(uint64_t value = 1) = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Semaphore.h"},{"location":"api/Files/Semaphore_8h/#srcngfxgraphicssemaphoreh","text":"","title":"src/ngfx/graphics/Semaphore.h"},{"location":"api/Files/Semaphore_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Semaphore_8h/#classes","text":"Name class ngfx::Semaphore","title":"Classes"},{"location":"api/Files/Semaphore_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include <cstdint> namespace ngfx { class Semaphore { public: static Semaphore *create(Device *device); virtual ~Semaphore() {} virtual uint64_t wait() = 0; virtual void signal(uint64_t value = 1) = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ShaderModule_8cpp/","text":"src/ngfx/graphics/ShaderModule.cpp Classes Name struct VertexFormatInfo Functions Name void parseAttributes (ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs) void parseDescriptors (ifstream & in, vector< ShaderModule::DescriptorInfo > & descs) void parseBufferMemberInfos (ifstream & in, ShaderModule::BufferMemberInfos & memberInfos) void parseBufferInfos (ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages) Attributes Name map< string, VertexFormatInfo > vertexFormatMap map< string, VertexInputRate > vertexInputRateMap map< string, DescriptorType > descriptorTypeMap Defines Name VF_ITEM (s, count, elementSize) ITEM (s) Functions Documentation function parseAttributes static void parseAttributes( ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs ) function parseDescriptors static void parseDescriptors( ifstream & in, vector< ShaderModule::DescriptorInfo > & descs ) function parseBufferMemberInfos static void parseBufferMemberInfos( ifstream & in, ShaderModule::BufferMemberInfos & memberInfos ) function parseBufferInfos static void parseBufferInfos( ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages ) Attributes Documentation variable vertexFormatMap static map< string, VertexFormatInfo > vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}}; variable vertexInputRateMap static map< string, VertexInputRate > vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), }; variable descriptorTypeMap static map< string, DescriptorType > descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)}; Macro Documentation define VF_ITEM #define VF_ITEM( s, count, elementSize ) { \\ #s, { s, count, elementSize } \\ } define ITEM #define ITEM( s ) { #s, s } Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <map> using namespace ngfx; using namespace std; #define VF_ITEM(s, count, elementSize) \\ { \\ #s, { s, count, elementSize } \\ } struct VertexFormatInfo { VertexFormat format; uint32_t count, elementSize; }; static map<string, VertexFormatInfo> vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}}; #define ITEM(s) \\ { #s, s } static map<string, VertexInputRate> vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), }; static map<string, DescriptorType> descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)}; static void parseAttributes(ifstream &in, vector<VertexShaderModule::AttributeDescription> &attrs) { string token; uint32_t numAttributes; in >> token >> numAttributes; attrs.resize(numAttributes); for (uint32_t j = 0; j < numAttributes; j++) { auto &attr = attrs[j]; string formatStr; in >> attr.name >> attr.semantic >> attr.location >> formatStr; auto formatInfo = vertexFormatMap.at(formatStr); attr.format = formatInfo.format; attr.count = formatInfo.count; attr.elementSize = formatInfo.elementSize; } } static void parseDescriptors(ifstream &in, vector<ShaderModule::DescriptorInfo> &descs) { string token; int numDescriptors; in >> token >> numDescriptors; descs.resize(numDescriptors); for (uint32_t j = 0; j < uint32_t(numDescriptors); j++) { auto &desc = descs[j]; string descriptorTypeStr; in >> desc.name >> descriptorTypeStr >> desc.set; desc.type = descriptorTypeMap.at(descriptorTypeStr); } } static void parseBufferMemberInfos(ifstream &in, ShaderModule::BufferMemberInfos &memberInfos) { uint32_t numMemberInfos; in >> numMemberInfos; for (uint32_t j = 0; j < numMemberInfos; j++) { ShaderModule::BufferMemberInfo memberInfo; string memberName; in >> memberName >> memberInfo.offset >> memberInfo.size >> memberInfo.arrayCount >> memberInfo.arrayStride; memberInfos[memberName] = memberInfo; } } static void parseBufferInfos(ifstream &in, string key, ShaderModule::BufferInfos &bufferInfos, ShaderStageFlags shaderStages) { string token; in >> token; if (token != key) return; uint32_t numUniformBufferInfos; in >> numUniformBufferInfos; for (uint32_t j = 0; j < numUniformBufferInfos; j++) { ShaderModule::BufferInfo bufferInfo; in >> bufferInfo.name >> bufferInfo.set; bufferInfo.shaderStages = shaderStages; parseBufferMemberInfos(in, bufferInfo.memberInfos); bufferInfos[bufferInfo.name] = std::move(bufferInfo); } } void ShaderModule::initBindings(std::ifstream &in, ShaderStageFlags shaderStages) { parseDescriptors(in, descriptors); parseBufferInfos(in, \"UNIFORM_BUFFER_INFOS\", uniformBufferInfos, shaderStages); parseBufferInfos(in, \"SHADER_STORAGE_BUFFER_INFOS\", shaderStorageBufferInfos, shaderStages); } void ShaderModule::initBindings(const std::string &filename, ShaderStageFlags shaderStages) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); initBindings(in, shaderStages); in.close(); } void VertexShaderModule::initBindings(const std::string &filename) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); parseAttributes(in, attributes); ShaderModule::initBindings(in, SHADER_STAGE_VERTEX_BIT); in.close(); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/ShaderModule.cpp"},{"location":"api/Files/ShaderModule_8cpp/#srcngfxgraphicsshadermodulecpp","text":"","title":"src/ngfx/graphics/ShaderModule.cpp"},{"location":"api/Files/ShaderModule_8cpp/#classes","text":"Name struct VertexFormatInfo","title":"Classes"},{"location":"api/Files/ShaderModule_8cpp/#functions","text":"Name void parseAttributes (ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs) void parseDescriptors (ifstream & in, vector< ShaderModule::DescriptorInfo > & descs) void parseBufferMemberInfos (ifstream & in, ShaderModule::BufferMemberInfos & memberInfos) void parseBufferInfos (ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages)","title":"Functions"},{"location":"api/Files/ShaderModule_8cpp/#attributes","text":"Name map< string, VertexFormatInfo > vertexFormatMap map< string, VertexInputRate > vertexInputRateMap map< string, DescriptorType > descriptorTypeMap","title":"Attributes"},{"location":"api/Files/ShaderModule_8cpp/#defines","text":"Name VF_ITEM (s, count, elementSize) ITEM (s)","title":"Defines"},{"location":"api/Files/ShaderModule_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/ShaderModule_8cpp/#function-parseattributes","text":"static void parseAttributes( ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs )","title":"function parseAttributes"},{"location":"api/Files/ShaderModule_8cpp/#function-parsedescriptors","text":"static void parseDescriptors( ifstream & in, vector< ShaderModule::DescriptorInfo > & descs )","title":"function parseDescriptors"},{"location":"api/Files/ShaderModule_8cpp/#function-parsebuffermemberinfos","text":"static void parseBufferMemberInfos( ifstream & in, ShaderModule::BufferMemberInfos & memberInfos )","title":"function parseBufferMemberInfos"},{"location":"api/Files/ShaderModule_8cpp/#function-parsebufferinfos","text":"static void parseBufferInfos( ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages )","title":"function parseBufferInfos"},{"location":"api/Files/ShaderModule_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/ShaderModule_8cpp/#variable-vertexformatmap","text":"static map< string, VertexFormatInfo > vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}};","title":"variable vertexFormatMap"},{"location":"api/Files/ShaderModule_8cpp/#variable-vertexinputratemap","text":"static map< string, VertexInputRate > vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), };","title":"variable vertexInputRateMap"},{"location":"api/Files/ShaderModule_8cpp/#variable-descriptortypemap","text":"static map< string, DescriptorType > descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)};","title":"variable descriptorTypeMap"},{"location":"api/Files/ShaderModule_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/ShaderModule_8cpp/#define-vf_item","text":"#define VF_ITEM( s, count, elementSize ) { \\ #s, { s, count, elementSize } \\ }","title":"define VF_ITEM"},{"location":"api/Files/ShaderModule_8cpp/#define-item","text":"#define ITEM( s ) { #s, s }","title":"define ITEM"},{"location":"api/Files/ShaderModule_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <map> using namespace ngfx; using namespace std; #define VF_ITEM(s, count, elementSize) \\ { \\ #s, { s, count, elementSize } \\ } struct VertexFormatInfo { VertexFormat format; uint32_t count, elementSize; }; static map<string, VertexFormatInfo> vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}}; #define ITEM(s) \\ { #s, s } static map<string, VertexInputRate> vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), }; static map<string, DescriptorType> descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)}; static void parseAttributes(ifstream &in, vector<VertexShaderModule::AttributeDescription> &attrs) { string token; uint32_t numAttributes; in >> token >> numAttributes; attrs.resize(numAttributes); for (uint32_t j = 0; j < numAttributes; j++) { auto &attr = attrs[j]; string formatStr; in >> attr.name >> attr.semantic >> attr.location >> formatStr; auto formatInfo = vertexFormatMap.at(formatStr); attr.format = formatInfo.format; attr.count = formatInfo.count; attr.elementSize = formatInfo.elementSize; } } static void parseDescriptors(ifstream &in, vector<ShaderModule::DescriptorInfo> &descs) { string token; int numDescriptors; in >> token >> numDescriptors; descs.resize(numDescriptors); for (uint32_t j = 0; j < uint32_t(numDescriptors); j++) { auto &desc = descs[j]; string descriptorTypeStr; in >> desc.name >> descriptorTypeStr >> desc.set; desc.type = descriptorTypeMap.at(descriptorTypeStr); } } static void parseBufferMemberInfos(ifstream &in, ShaderModule::BufferMemberInfos &memberInfos) { uint32_t numMemberInfos; in >> numMemberInfos; for (uint32_t j = 0; j < numMemberInfos; j++) { ShaderModule::BufferMemberInfo memberInfo; string memberName; in >> memberName >> memberInfo.offset >> memberInfo.size >> memberInfo.arrayCount >> memberInfo.arrayStride; memberInfos[memberName] = memberInfo; } } static void parseBufferInfos(ifstream &in, string key, ShaderModule::BufferInfos &bufferInfos, ShaderStageFlags shaderStages) { string token; in >> token; if (token != key) return; uint32_t numUniformBufferInfos; in >> numUniformBufferInfos; for (uint32_t j = 0; j < numUniformBufferInfos; j++) { ShaderModule::BufferInfo bufferInfo; in >> bufferInfo.name >> bufferInfo.set; bufferInfo.shaderStages = shaderStages; parseBufferMemberInfos(in, bufferInfo.memberInfos); bufferInfos[bufferInfo.name] = std::move(bufferInfo); } } void ShaderModule::initBindings(std::ifstream &in, ShaderStageFlags shaderStages) { parseDescriptors(in, descriptors); parseBufferInfos(in, \"UNIFORM_BUFFER_INFOS\", uniformBufferInfos, shaderStages); parseBufferInfos(in, \"SHADER_STORAGE_BUFFER_INFOS\", shaderStorageBufferInfos, shaderStages); } void ShaderModule::initBindings(const std::string &filename, ShaderStageFlags shaderStages) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); initBindings(in, shaderStages); in.close(); } void VertexShaderModule::initBindings(const std::string &filename) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); parseAttributes(in, attributes); ShaderModule::initBindings(in, SHADER_STAGE_VERTEX_BIT); in.close(); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ShaderModule_8h/","text":"src/ngfx/graphics/ShaderModule.h Namespaces Name ngfx Classes Name class ngfx::ShaderModule struct ngfx::ShaderModule::DescriptorInfo struct ngfx::ShaderModule::BufferMemberInfo struct ngfx::ShaderModule::BufferInfo class ngfx::VertexShaderModule struct ngfx::VertexShaderModule::AttributeDescription class ngfx::FragmentShaderModule class ngfx::ComputeShaderModule Defines Name ENABLE_NGL_INTEGRATION Macro Documentation define ENABLE_NGL_INTEGRATION #define ENABLE_NGL_INTEGRATION Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <map> #include <memory> #include <string> #include <vector> #define ENABLE_NGL_INTEGRATION namespace ngfx { class ShaderModule { public: virtual ~ShaderModule() {} struct DescriptorInfo { std::string name; uint32_t set; DescriptorType type; }; typedef std::vector<DescriptorInfo> DescriptorInfos; DescriptorInfos descriptors; inline DescriptorInfo *findDescriptorInfo(const std::string &name) { for (auto &desc : descriptors) { if (desc.name == name) return &desc; } return nullptr; } struct BufferMemberInfo { uint32_t offset, size, arrayCount, arrayStride; }; typedef std::map<std::string, BufferMemberInfo> BufferMemberInfos; struct BufferInfo { std::string name; uint32_t set; ShaderStageFlags shaderStages; BufferMemberInfos memberInfos; }; typedef std::map<std::string, BufferInfo> BufferInfos; inline BufferInfo *findUniformBufferInfo(const std::string &name) { auto it = uniformBufferInfos.find(name); if (it == uniformBufferInfos.end()) return nullptr; return &it->second; } inline BufferInfo *findStorageBufferInfo(const std::string &name) { auto it = shaderStorageBufferInfos.find(name); if (it == shaderStorageBufferInfos.end()) return nullptr; return &it->second; } BufferInfos uniformBufferInfos, shaderStorageBufferInfos; void initBindings(std::ifstream &in, ShaderStageFlags shaderStages); void initBindings(const std::string &filename, ShaderStageFlags shaderStages); }; class VertexShaderModule : public ShaderModule { public: static std::unique_ptr<VertexShaderModule> create(Device *device, const std::string &filename); virtual ~VertexShaderModule() {} struct AttributeDescription { std::string semantic; uint32_t location; VertexFormat format; std::string name; uint32_t count, elementSize; }; std::vector<AttributeDescription> attributes; inline AttributeDescription *findAttribute(const std::string &name) { for (auto &attr : attributes) { if (attr.name == name) return &attr; } return nullptr; } void initBindings(const std::string &filename); }; class FragmentShaderModule : public ShaderModule { public: static std::unique_ptr<FragmentShaderModule> create(Device *device, const std::string &filename); virtual ~FragmentShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_FRAGMENT_BIT); } }; class ComputeShaderModule : public ShaderModule { public: static std::unique_ptr<ComputeShaderModule> create(Device *device, const std::string &filename); virtual ~ComputeShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_COMPUTE_BIT); } }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/ShaderModule.h"},{"location":"api/Files/ShaderModule_8h/#srcngfxgraphicsshadermoduleh","text":"","title":"src/ngfx/graphics/ShaderModule.h"},{"location":"api/Files/ShaderModule_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ShaderModule_8h/#classes","text":"Name class ngfx::ShaderModule struct ngfx::ShaderModule::DescriptorInfo struct ngfx::ShaderModule::BufferMemberInfo struct ngfx::ShaderModule::BufferInfo class ngfx::VertexShaderModule struct ngfx::VertexShaderModule::AttributeDescription class ngfx::FragmentShaderModule class ngfx::ComputeShaderModule","title":"Classes"},{"location":"api/Files/ShaderModule_8h/#defines","text":"Name ENABLE_NGL_INTEGRATION","title":"Defines"},{"location":"api/Files/ShaderModule_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/ShaderModule_8h/#define-enable_ngl_integration","text":"#define ENABLE_NGL_INTEGRATION","title":"define ENABLE_NGL_INTEGRATION"},{"location":"api/Files/ShaderModule_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <map> #include <memory> #include <string> #include <vector> #define ENABLE_NGL_INTEGRATION namespace ngfx { class ShaderModule { public: virtual ~ShaderModule() {} struct DescriptorInfo { std::string name; uint32_t set; DescriptorType type; }; typedef std::vector<DescriptorInfo> DescriptorInfos; DescriptorInfos descriptors; inline DescriptorInfo *findDescriptorInfo(const std::string &name) { for (auto &desc : descriptors) { if (desc.name == name) return &desc; } return nullptr; } struct BufferMemberInfo { uint32_t offset, size, arrayCount, arrayStride; }; typedef std::map<std::string, BufferMemberInfo> BufferMemberInfos; struct BufferInfo { std::string name; uint32_t set; ShaderStageFlags shaderStages; BufferMemberInfos memberInfos; }; typedef std::map<std::string, BufferInfo> BufferInfos; inline BufferInfo *findUniformBufferInfo(const std::string &name) { auto it = uniformBufferInfos.find(name); if (it == uniformBufferInfos.end()) return nullptr; return &it->second; } inline BufferInfo *findStorageBufferInfo(const std::string &name) { auto it = shaderStorageBufferInfos.find(name); if (it == shaderStorageBufferInfos.end()) return nullptr; return &it->second; } BufferInfos uniformBufferInfos, shaderStorageBufferInfos; void initBindings(std::ifstream &in, ShaderStageFlags shaderStages); void initBindings(const std::string &filename, ShaderStageFlags shaderStages); }; class VertexShaderModule : public ShaderModule { public: static std::unique_ptr<VertexShaderModule> create(Device *device, const std::string &filename); virtual ~VertexShaderModule() {} struct AttributeDescription { std::string semantic; uint32_t location; VertexFormat format; std::string name; uint32_t count, elementSize; }; std::vector<AttributeDescription> attributes; inline AttributeDescription *findAttribute(const std::string &name) { for (auto &attr : attributes) { if (attr.name == name) return &attr; } return nullptr; } void initBindings(const std::string &filename); }; class FragmentShaderModule : public ShaderModule { public: static std::unique_ptr<FragmentShaderModule> create(Device *device, const std::string &filename); virtual ~FragmentShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_FRAGMENT_BIT); } }; class ComputeShaderModule : public ShaderModule { public: static std::unique_ptr<ComputeShaderModule> create(Device *device, const std::string &filename); virtual ~ComputeShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_COMPUTE_BIT); } }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ShaderTools_8cpp/","text":"src/ngfx/graphics/ShaderTools.cpp Functions Name string getEnv (const string & name) json * getEntry (const json & data, const string & key) shaderc_shader_kind toShaderKind (const string & ext) Attributes Name auto readFile auto writeFile auto toLower Defines Name V (func) PATCH Functions Documentation function getEnv static string getEnv( const string & name ) function getEntry static json * getEntry( const json & data, const string & key ) function toShaderKind static shaderc_shader_kind toShaderKind( const string & ext ) Attributes Documentation variable readFile auto readFile = FileUtil::readFile; variable writeFile auto writeFile = FileUtil::writeFile; variable toLower auto toLower = StringUtil::toLower; Macro Documentation define V #define V( func ) { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ } define PATCH #define PATCH string(\"patch\") Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ShaderTools.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/FileUtil.h\" #include \"ngfx/core/StringUtil.h\" #include <cctype> #include <filesystem> #include <fstream> #include <regex> #include <set> #include <spirv_cross/spirv_glsl.hpp> #include <spirv_cross/spirv_hlsl.hpp> #include <spirv_cross/spirv_msl.hpp> #include <spirv_cross/spirv_reflect.hpp> #include <sstream> using namespace std; using namespace ngfx; auto readFile = FileUtil::readFile; auto writeFile = FileUtil::writeFile; auto toLower = StringUtil::toLower; namespace fs = std::filesystem; #define V(func) \\ { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ } #ifdef _WIN32 #define PATCH string(\"patch.exe\") #else #define PATCH string(\"patch\") #endif static string getEnv(const string &name) { char *value = getenv(name.c_str()); return (value ? value : \"\"); } static json *getEntry(const json &data, const string &key) { auto it = data.find(key); if (it == data.end()) return nullptr; return (json *)&it.value(); } ShaderTools::ShaderTools(bool verbose) : verbose(verbose) { defaultIncludePaths = {\"ngfx/data/shaders\", \"nodegl/data/shaders\"}; } int ShaderTools::cmd(string str) { if (verbose) { NGFX_LOG(\">> %s\", str.c_str()); } else str += \" >> /dev/null 2>&1\"; return system(str.c_str()); } bool ShaderTools::findIncludeFile(const string &includeFilename, const vector<string> &includePaths, string &includeFile) { for (const string &includePath : includePaths) { fs::path filename = includePath / fs::path(includeFilename); if (fs::exists(filename)) { includeFile = filename.string(); return true; } } return false; } int ShaderTools::preprocess(const string &src, const string &dataPath, string &dst) { dst = \"\"; vector<string> includePaths = defaultIncludePaths; includePaths.push_back(dataPath); istringstream sstream(src); string line; while (std::getline(sstream, line)) { smatch matchIncludeGroups; bool matchInclude = regex_search(line, matchIncludeGroups, regex(\"#include \\\"([^\\\"]*)\")); if (matchInclude) { string includeFilename = matchIncludeGroups[1]; string includeFilePath; findIncludeFile(includeFilename, includePaths, includeFilePath); dst += readFile(includeFilePath); } else { dst += line + \"\\n\"; } } return 0; } int ShaderTools::compileShaderGLSL( const string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, string &spv, bool verbose, shaderc_optimization_level optimizationLevel) { shaderc::Compiler compiler; shaderc::CompileOptions compileOptions; for (const MacroDefinition &define : defines) { compileOptions.AddMacroDefinition(define.name, define.value); } compileOptions.SetOptimizationLevel(optimizationLevel); compileOptions.SetGenerateDebugInfo(); auto result = compiler.CompileGlslToSpv(src, shaderKind, \"\", compileOptions); if (result.GetCompilationStatus() != shaderc_compilation_status_success) { NGFX_ERR(\"cannot compile file: %s\", result.GetErrorMessage().c_str()); return 1; } spv = string((const char *)result.cbegin(), sizeof(uint32_t) * (result.cend() - result.cbegin())); return 0; } int ShaderTools::removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst) { int ret = 0; string spv; V(compileShaderGLSL(src, shaderKind, defines, spv, false)); spirv_cross::CompilerGLSL compilerGLSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto activeVariables = compilerGLSL.get_active_interface_variables(); compilerGLSL.get_shader_resources(activeVariables); compilerGLSL.set_enabled_interface_variables(move(activeVariables)); spirv_cross::CompilerGLSL::Options opts; opts.vulkan_semantics = true; compilerGLSL.set_common_options(opts); dst = compilerGLSL.compile(); return 0; } int ShaderTools::patchShaderLayoutsGLSL(const string &src, string &dst) { dst = \"\"; istringstream sstream(src); string line; while (std::getline(sstream, line)) { // Patch GLSL shader layouts smatch g; bool matchLayout = regex_search(line, g, regex(\"^(.*)\" \"layout\\\\s*\\\\(\" \"([^)]*)\" \"binding[\\\\s]*=[\\\\s]*\" \"([\\\\d]+)\" \"([^)]*)\" \"\\\\)\" \"(.*)\\r*$\")); if (matchLayout) { dst += g[1].str() + \"layout(\" + g[2].str() + \"set = \" + g[3].str() + \", binding = 0\" + g[4].str() + \")\" + g[5].str() + \"\\n\"; } else { dst += line + \"\\n\"; } } return 0; } static shaderc_shader_kind toShaderKind(const string &ext) { static const map<string, shaderc_shader_kind> shaderKindMap = { {\".vert\", shaderc_vertex_shader}, {\".frag\", shaderc_fragment_shader}, {\".comp\", shaderc_compute_shader}}; return shaderKindMap.at(ext); } int ShaderTools::compileShaderGLSL(string filename, const MacroDefinitions &defines, const string &outDir, vector<string> &outFiles, int flags) { string parentPath = fs::path(filename).parent_path().string(); filename = fs::path(filename).filename().string(); string inFileName = fs::path(parentPath + \"/\" + filename).make_preferred().string(); string outFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string src, dst; int ret = 0; src = FileUtil::readFile(inFileName); string ext = FileUtil::splitExt(inFileName)[1]; shaderc_shader_kind shaderKind = toShaderKind(ext); if (flags & REMOVE_UNUSED_VARIABLES) { V(removeUnusedVariablesGLSL(src, shaderKind, defines, dst)); src = move(dst); } if (flags & PATCH_SHADER_LAYOUTS_GLSL) { V(patchShaderLayoutsGLSL(src, dst)); src = move(dst); } V(compileShaderGLSL(src, shaderKind, defines, dst)); writeFile(outFileName, dst); outFiles.push_back(outFileName); return 0; } int ShaderTools::compileShaderMSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".metal\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".metallib\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string debugFlags = \"-gline-tables-only -MO\"; int result = cmd(\"xcrun -sdk macosx metal \" + debugFlags + \" -c \" + inFileName + \" -o \" + outDir + \"/\" + strippedFilename + \".air && \" \"xcrun -sdk macosx metallib \" + outDir + \"/\" + strippedFilename + \".air -o \" + outFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::compileShaderHLSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".hlsl\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".dxc\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string shaderModel = \"\"; if (strstr(inFileName.c_str(), \".vert\")) shaderModel = \"vs_5_0\"; else if (strstr(inFileName.c_str(), \".frag\")) shaderModel = \"ps_5_0\"; else if (strstr(inFileName.c_str(), \".comp\")) shaderModel = \"cs_5_0\"; int result = cmd(\"dxc.exe /T \" + shaderModel + \" /Fo \" + outFileName + \" \" + inFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::convertSPVToMSL(const string &spv, shaderc_shader_kind shaderKind, string &msl) { spirv_cross::CompilerMSL compilerMSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); msl = compilerMSL.compile(); return 0; } int ShaderTools::convertSPVToHLSL(const string &spv, shaderc_shader_kind shaderKind, string &hlsl, uint32_t shaderModel) { spirv_cross::CompilerHLSL compilerHLSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto options = compilerHLSL.get_hlsl_options(); options.shader_model = shaderModel; compilerHLSL.set_hlsl_options(options); hlsl = compilerHLSL.compile(); return 0; } int ShaderTools::convertShader(const string &file, const string &extraArgs, string outDir, Format fmt, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string strippedFilename = splitFilename[0]; string ext = FileUtil::splitExt(strippedFilename)[1]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".spv\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + (fmt == FORMAT_MSL ? \".metal\" : \".hlsl\")) .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string spv = FileUtil::readFile(inFileName), dst; int result; if (fmt == FORMAT_MSL) { result = convertSPVToMSL(spv, toShaderKind(ext), dst); } else { result = convertSPVToHLSL(spv, toShaderKind(ext), dst); } FileUtil::writeFile(outFileName, dst); string args = (fmt == FORMAT_MSL ? \"--msl\" : \"--hlsl --shader-model 60\") + extraArgs; if (result == 0) NGFX_LOG(\"converted file: %s to %s\", inFileName.c_str(), outFileName.c_str()); else NGFX_ERR(\"cannot convert file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } bool ShaderTools::findMetalReflectData( const vector<RegexUtil::Match> &metalReflectData, const string &name, RegexUtil::Match &match) { for (const RegexUtil::Match &data : metalReflectData) { if (data.s[2] == name) { match = data; return true; } else if (strstr(data.s[1].c_str(), name.c_str())) { match = data; return true; } } return false; } int ShaderTools::patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect) { auto glslReflectJson = json::parse(glslReflect); MetalReflectData metalReflectData; if (ext == \".vert\") { metalReflectData.attributes = RegexUtil::findAll(regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[\" \"attribute\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); } metalReflectData.buffers = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[buffer\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); metalReflectData.textures = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[texture\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); uint32_t numDescriptors = (textures ? textures->size() : 0) + (images ? images->size() : 0) + (ubos ? ubos->size() : 0) + (ssbos ? ssbos->size() : 0); // update input bindings if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { RegexUtil::Match metalInputReflectData; bool foundMatch = findMetalReflectData( metalReflectData.attributes, input[\"name\"], metalInputReflectData); if (!foundMatch) { return 1; } input[\"location\"] = stoi(metalInputReflectData.s[3]) + numDescriptors; } } // update descriptor bindings if (textures) for (json &descriptor : *textures) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } if (ubos) for (json &descriptor : *ubos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (ssbos) for (json &descriptor : *ssbos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (images) for (json &descriptor : *images) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } mslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect) { auto glslReflectJson = json::parse(glslReflect); HLSLReflectData hlslReflectData; // parse semantics if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { regex p(input[\"name\"].get<string>() + \"\\\\s*:\\\\s*([^;]*);\"); vector<RegexUtil::Match> hlslReflectData = RegexUtil::findAll(p, hlsl); input[\"semantic\"] = hlslReflectData[0].s[1]; } } // get descriptors json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); map<int, json *> descriptors; if (textures) for (auto &desc : *textures) descriptors[desc[\"set\"].get<int>()] = &desc; if (ubos) for (auto &desc : *ubos) descriptors[desc[\"set\"].get<int>()] = &desc; if (ssbos) for (auto &desc : *ssbos) descriptors[desc[\"set\"].get<int>()] = &desc; if (images) for (auto &desc : *images) descriptors[desc[\"set\"].get<int>()] = &desc; // patch descriptor bindings set<int> sets; set<string> samplerTypes = {\"sampler2D\", \"sampler3D\", \"samplerCube\"}; for (const auto &kv : descriptors) { uint32_t set = kv.first; json &desc = *kv.second; while (sets.find(set) != sets.end()) set += 1; desc[\"set\"] = set; sets.insert(set); if (samplerTypes.find(desc[\"type\"]) != samplerTypes.end()) sets.insert(set + 1); } hlslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::genShaderReflectionGLSL(const string &, const string &ext, const string &spv, string &glslMap) { spirv_cross::CompilerReflection compilerReflection( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto reflectOutput = compilerReflection.compile(); glslMap = json::parse(reflectOutput).dump(4); return 0; } int ShaderTools::genShaderReflectionMSL(const string &msl, const string &ext, const string &spv, string &mslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataMSL(glslReflect, ext, msl, mslMap); } int ShaderTools::genShaderReflectionHLSL(const string &hlsl, const string &ext, const string &spv, string &hlslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataHLSL(glslReflect, ext, hlsl, hlslMap); } string ShaderTools::parseReflectionData(const json &reflectData, string ext) { string contents = \"\"; if (ext == \".vert\") { json *inputs = getEntry(reflectData, \"inputs\"); contents += \"INPUT_ATTRIBUTES \" + to_string(inputs->size()) + \"\\n\"; for (const json &input : *inputs) { string inputName = input[\"name\"]; string inputSemantic = \"\"; string inputNameLower = toLower(inputName); inputSemantic = \"UNDEFINED\"; if (input.find(\"semantic\") != input.end()) inputSemantic = input[\"semantic\"]; map<string, string> inputTypeMap = { {\"float\", \"VERTEXFORMAT_FLOAT\"}, {\"vec2\", \"VERTEXFORMAT_FLOAT2\"}, {\"vec3\", \"VERTEXFORMAT_FLOAT3\"}, {\"vec4\", \"VERTEXFORMAT_FLOAT4\"}, {\"ivec2\", \"VERTEXFORMAT_INT2\"}, {\"ivec3\", \"VERTEXFORMAT_INT3\"}, {\"ivec4\", \"VERTEXFORMAT_INT4\"}, {\"mat2\", \"VERTEXFORMAT_MAT2\"}, {\"mat3\", \"VERTEXFORMAT_MAT3\"}, {\"mat4\", \"VERTEXFORMAT_MAT4\"}}; string inputType = inputTypeMap[input[\"type\"]]; contents += \"\\t\" + inputName + \" \" + inputSemantic + \" \" + to_string(input[\"location\"].get<int>()) + \" \" + inputType + \"\\n\"; } } json *textures = getEntry(reflectData, \"textures\"), *ubos = getEntry(reflectData, \"ubos\"), *ssbos = getEntry(reflectData, \"ssbos\"), *images = getEntry(reflectData, \"images\"), *types = getEntry(reflectData, \"types\"); json uniformBufferInfos; json shaderStorageBufferInfos; std::function<void(const json &, json &, uint32_t, string)> parseMembers = [&](const json &membersData, json &members, uint32_t baseOffset = 0, string baseName = \"\") { for (const json &memberData : membersData) { const map<string, int> typeSizeMap = { {\"int\", 4}, {\"uint\", 4}, {\"float\", 4}, {\"vec2\", 8}, {\"vec3\", 12}, {\"vec4\", 16}, {\"ivec2\", 8}, {\"ivec3\", 12}, {\"ivec4\", 16}, {\"uvec2\", 8}, {\"uvec3\", 12}, {\"uvec4\", 16}, {\"mat2\", 16}, {\"mat3\", 36}, {\"mat4\", 64}}; string memberType = memberData[\"type\"]; if (typeSizeMap.find(memberType) != typeSizeMap.end()) { json member = memberData; member[\"name\"] = baseName + member[\"name\"].get<string>(); member[\"size\"] = typeSizeMap.at(memberType); member[\"offset\"] = member[\"offset\"].get<int>() + baseOffset; member[\"array_count\"] = (member.find(\"array\") != member.end()) ? member[\"array\"][0].get<int>() : 0; member[\"array_stride\"] = (member.find(\"array_stride\") != member.end()) ? member[\"array_stride\"].get<int>() : 0; members.push_back(member); } else if (types->find(memberType) != types->end()) { const json &type = (*types)[memberType]; parseMembers(type[\"members\"], members, baseOffset + memberData[\"offset\"].get<int>(), baseName + memberData[\"name\"].get<string>() + \".\"); } else NGFX_ERR(\"unrecognized type: {memberType}\"); } }; auto parseBuffers = [&](const json &buffers, json &bufferInfos) { for (const json &buffer : buffers) { const json &bufferType = (*types)[buffer[\"type\"].get<string>()]; json bufferMembers = {}; parseMembers(bufferType[\"members\"], bufferMembers, 0, \"\"); json bufferInfo = {{\"name\", buffer[\"name\"].get<string>()}, {\"set\", buffer[\"set\"].get<int>()}, {\"binding\", buffer[\"binding\"].get<int>()}, {\"members\", bufferMembers}}; bufferInfos.push_back(bufferInfo); } }; if (ubos) parseBuffers(*ubos, uniformBufferInfos); if (ssbos) parseBuffers(*ssbos, shaderStorageBufferInfos); json textureDescriptors = {}; json bufferDescriptors = {}; if (textures) for (const json &texture : *textures) { textureDescriptors[to_string(texture[\"set\"].get<int>())] = { {\"type\", texture[\"type\"]}, {\"name\", texture[\"name\"]}, {\"set\", texture[\"set\"]}, {\"binding\", texture[\"binding\"]}}; } if (images) for (const json &image : *images) { textureDescriptors[to_string(image[\"set\"].get<int>())] = { {\"type\", image[\"type\"]}, {\"name\", image[\"name\"]}, {\"set\", image[\"set\"]}, {\"binding\", image[\"binding\"]}}; } if (ubos) for (const json &ubo : *ubos) { bufferDescriptors[to_string(ubo[\"set\"].get<int>())] = { {\"type\", \"uniformBuffer\"}, {\"name\", ubo[\"name\"]}, {\"set\", ubo[\"set\"]}, {\"binding\", ubo[\"binding\"]}}; } if (ssbos) for (const json &ssbo : *ssbos) { bufferDescriptors[to_string(ssbo[\"set\"].get<int>())] = { {\"type\", \"shaderStorageBuffer\"}, {\"name\", ssbo[\"name\"]}, {\"set\", ssbo[\"set\"]}, {\"binding\", ssbo[\"binding\"]}}; } contents += \"DESCRIPTORS \" + to_string(textureDescriptors.size() + bufferDescriptors.size()) + \"\\n\"; map<string, string> descriptorTypeMap = { {\"sampler2D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"sampler3D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"samplerCube\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"image2D\", \"DESCRIPTOR_TYPE_STORAGE_IMAGE\"}, {\"uniformBuffer\", \"DESCRIPTOR_TYPE_UNIFORM_BUFFER\"}, {\"shaderStorageBuffer\", \"DESCRIPTOR_TYPE_STORAGE_BUFFER\"}}; for (auto &[key, val] : textureDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } for (auto &[key, val] : bufferDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } auto processBufferInfos = [&](const json &bufferInfo) -> string { string contents = \"\"; const json &memberInfos = bufferInfo[\"members\"]; contents += bufferInfo[\"name\"].get<string>() + \" \" + to_string(bufferInfo[\"set\"].get<int>()) + \" \" + to_string(memberInfos.size()) + \"\\n\"; for (const json &m : memberInfos) { contents += m[\"name\"].get<string>() + \" \" + to_string(m[\"offset\"].get<int>()) + \" \" + to_string(m[\"size\"].get<int>()) + \" \" + to_string(m[\"array_count\"].get<int>()) + \" \" + to_string(m[\"array_stride\"].get<int>()) + \"\\n\"; } return contents; }; contents += \"UNIFORM_BUFFER_INFOS \" + to_string(uniformBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : uniformBufferInfos) { contents += processBufferInfos(bufferInfo); } contents += \"SHADER_STORAGE_BUFFER_INFOS \" + to_string(shaderStorageBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : shaderStorageBufferInfos) { contents += processBufferInfos(bufferInfo); } return contents; } int ShaderTools::generateShaderMapGLSL(const string &file, string outDir, vector<string> &outFiles) { string filename = fs::path(file).filename().string(); string ext = FileUtil::splitExt(filename)[1]; string glslFileName = fs::path(outDir + \"/\" + filename).make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); string glslMapFileName = fs::path(outDir + \"/\" + filename + \".map\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(glslFileName, glslMapFileName)) { outFiles.push_back(glslMapFileName); return 0; } string glsl = \"\", spv = readFile(spvFileName), glslReflect; genShaderReflectionGLSL(glsl, ext, spv, glslReflect); auto glslReflectJson = json::parse(glslReflect); string glslMap = parseReflectionData(glslReflectJson, ext); writeFile(glslMapFileName, glslMap); outFiles.push_back(glslMapFileName); return 0; } int ShaderTools::generateShaderMapMSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string mslFileName = fs::path(outDir + \"/\" + glslFilename + \".metal\") .make_preferred() .string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string mslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".metal.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(mslFileName, mslMapFileName)) { outFiles.push_back(mslMapFileName); return 0; } string msl = readFile(mslFileName), spv = readFile(spvFileName), mslReflect; genShaderReflectionMSL(msl, ext, spv, mslReflect); auto mslReflectJson = json::parse(mslReflect); string mslMap = parseReflectionData(mslReflectJson, ext); writeFile(mslMapFileName, mslMap); outFiles.push_back(mslMapFileName); return 0; } int ShaderTools::generateShaderMapHLSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string hlslFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl\").make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string hlslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(hlslFileName, hlslMapFileName)) { outFiles.push_back(hlslMapFileName); return 0; } string hlsl = readFile(hlslFileName), spv = readFile(spvFileName), hlslReflect; genShaderReflectionHLSL(hlsl, ext, spv, hlslReflect); auto hlslReflectJson = json::parse(hlslReflect); string hlslMap = parseReflectionData(hlslReflectJson, ext); writeFile(hlslMapFileName, hlslMap); outFiles.push_back(hlslMapFileName); return 0; } vector<string> ShaderTools::convertShaders(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) convertShader(file, \"\", outDir, fmt, outFiles); return outFiles; } vector<string> ShaderTools::compileShaders(const vector<string> &files, string outDir, Format fmt, const MacroDefinitions &defines, int flags) { #ifdef GRAPHICS_BACKEND_VULKAN defines += \" -DGRAPHICS_BACKEND_VULKAN=1\"; #endif vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) compileShaderGLSL(file, defines, outDir, outFiles, flags); else if (fmt == FORMAT_MSL) compileShaderMSL(file, defines, outDir, outFiles); else if (fmt == FORMAT_HLSL) compileShaderHLSL(file, defines, outDir, outFiles); } return outFiles; } void ShaderTools::applyPatches(const vector<string> &patchFiles, string outDir) { for (const string &patchFile : patchFiles) { string filename = FileUtil::splitExt(fs::path(patchFile).string())[0]; NGFX_LOG(\"filename: %s\", filename.c_str()); string outFile = fs::path(outDir + \"/\" + filename).make_preferred().string(); if (fs::exists(outFile)) { NGFX_LOG(\"applying patch: {patchFile}\"); string cmdStr = PATCH + \" -N -u \" + outFile + \" -i \" + patchFile; cmd(cmdStr); } } } vector<string> ShaderTools::generateShaderMaps(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) generateShaderMapGLSL(file, outDir, outFiles); else if (fmt == FORMAT_MSL) generateShaderMapMSL(file, outDir, outFiles); else if (fmt == FORMAT_HLSL) generateShaderMapHLSL(file, outDir, outFiles); } return outFiles; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/ShaderTools.cpp"},{"location":"api/Files/ShaderTools_8cpp/#srcngfxgraphicsshadertoolscpp","text":"","title":"src/ngfx/graphics/ShaderTools.cpp"},{"location":"api/Files/ShaderTools_8cpp/#functions","text":"Name string getEnv (const string & name) json * getEntry (const json & data, const string & key) shaderc_shader_kind toShaderKind (const string & ext)","title":"Functions"},{"location":"api/Files/ShaderTools_8cpp/#attributes","text":"Name auto readFile auto writeFile auto toLower","title":"Attributes"},{"location":"api/Files/ShaderTools_8cpp/#defines","text":"Name V (func) PATCH","title":"Defines"},{"location":"api/Files/ShaderTools_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/ShaderTools_8cpp/#function-getenv","text":"static string getEnv( const string & name )","title":"function getEnv"},{"location":"api/Files/ShaderTools_8cpp/#function-getentry","text":"static json * getEntry( const json & data, const string & key )","title":"function getEntry"},{"location":"api/Files/ShaderTools_8cpp/#function-toshaderkind","text":"static shaderc_shader_kind toShaderKind( const string & ext )","title":"function toShaderKind"},{"location":"api/Files/ShaderTools_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/ShaderTools_8cpp/#variable-readfile","text":"auto readFile = FileUtil::readFile;","title":"variable readFile"},{"location":"api/Files/ShaderTools_8cpp/#variable-writefile","text":"auto writeFile = FileUtil::writeFile;","title":"variable writeFile"},{"location":"api/Files/ShaderTools_8cpp/#variable-tolower","text":"auto toLower = StringUtil::toLower;","title":"variable toLower"},{"location":"api/Files/ShaderTools_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/ShaderTools_8cpp/#define-v","text":"#define V( func ) { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ }","title":"define V"},{"location":"api/Files/ShaderTools_8cpp/#define-patch","text":"#define PATCH string(\"patch\")","title":"define PATCH"},{"location":"api/Files/ShaderTools_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ShaderTools.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/FileUtil.h\" #include \"ngfx/core/StringUtil.h\" #include <cctype> #include <filesystem> #include <fstream> #include <regex> #include <set> #include <spirv_cross/spirv_glsl.hpp> #include <spirv_cross/spirv_hlsl.hpp> #include <spirv_cross/spirv_msl.hpp> #include <spirv_cross/spirv_reflect.hpp> #include <sstream> using namespace std; using namespace ngfx; auto readFile = FileUtil::readFile; auto writeFile = FileUtil::writeFile; auto toLower = StringUtil::toLower; namespace fs = std::filesystem; #define V(func) \\ { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ } #ifdef _WIN32 #define PATCH string(\"patch.exe\") #else #define PATCH string(\"patch\") #endif static string getEnv(const string &name) { char *value = getenv(name.c_str()); return (value ? value : \"\"); } static json *getEntry(const json &data, const string &key) { auto it = data.find(key); if (it == data.end()) return nullptr; return (json *)&it.value(); } ShaderTools::ShaderTools(bool verbose) : verbose(verbose) { defaultIncludePaths = {\"ngfx/data/shaders\", \"nodegl/data/shaders\"}; } int ShaderTools::cmd(string str) { if (verbose) { NGFX_LOG(\">> %s\", str.c_str()); } else str += \" >> /dev/null 2>&1\"; return system(str.c_str()); } bool ShaderTools::findIncludeFile(const string &includeFilename, const vector<string> &includePaths, string &includeFile) { for (const string &includePath : includePaths) { fs::path filename = includePath / fs::path(includeFilename); if (fs::exists(filename)) { includeFile = filename.string(); return true; } } return false; } int ShaderTools::preprocess(const string &src, const string &dataPath, string &dst) { dst = \"\"; vector<string> includePaths = defaultIncludePaths; includePaths.push_back(dataPath); istringstream sstream(src); string line; while (std::getline(sstream, line)) { smatch matchIncludeGroups; bool matchInclude = regex_search(line, matchIncludeGroups, regex(\"#include \\\"([^\\\"]*)\")); if (matchInclude) { string includeFilename = matchIncludeGroups[1]; string includeFilePath; findIncludeFile(includeFilename, includePaths, includeFilePath); dst += readFile(includeFilePath); } else { dst += line + \"\\n\"; } } return 0; } int ShaderTools::compileShaderGLSL( const string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, string &spv, bool verbose, shaderc_optimization_level optimizationLevel) { shaderc::Compiler compiler; shaderc::CompileOptions compileOptions; for (const MacroDefinition &define : defines) { compileOptions.AddMacroDefinition(define.name, define.value); } compileOptions.SetOptimizationLevel(optimizationLevel); compileOptions.SetGenerateDebugInfo(); auto result = compiler.CompileGlslToSpv(src, shaderKind, \"\", compileOptions); if (result.GetCompilationStatus() != shaderc_compilation_status_success) { NGFX_ERR(\"cannot compile file: %s\", result.GetErrorMessage().c_str()); return 1; } spv = string((const char *)result.cbegin(), sizeof(uint32_t) * (result.cend() - result.cbegin())); return 0; } int ShaderTools::removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst) { int ret = 0; string spv; V(compileShaderGLSL(src, shaderKind, defines, spv, false)); spirv_cross::CompilerGLSL compilerGLSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto activeVariables = compilerGLSL.get_active_interface_variables(); compilerGLSL.get_shader_resources(activeVariables); compilerGLSL.set_enabled_interface_variables(move(activeVariables)); spirv_cross::CompilerGLSL::Options opts; opts.vulkan_semantics = true; compilerGLSL.set_common_options(opts); dst = compilerGLSL.compile(); return 0; } int ShaderTools::patchShaderLayoutsGLSL(const string &src, string &dst) { dst = \"\"; istringstream sstream(src); string line; while (std::getline(sstream, line)) { // Patch GLSL shader layouts smatch g; bool matchLayout = regex_search(line, g, regex(\"^(.*)\" \"layout\\\\s*\\\\(\" \"([^)]*)\" \"binding[\\\\s]*=[\\\\s]*\" \"([\\\\d]+)\" \"([^)]*)\" \"\\\\)\" \"(.*)\\r*$\")); if (matchLayout) { dst += g[1].str() + \"layout(\" + g[2].str() + \"set = \" + g[3].str() + \", binding = 0\" + g[4].str() + \")\" + g[5].str() + \"\\n\"; } else { dst += line + \"\\n\"; } } return 0; } static shaderc_shader_kind toShaderKind(const string &ext) { static const map<string, shaderc_shader_kind> shaderKindMap = { {\".vert\", shaderc_vertex_shader}, {\".frag\", shaderc_fragment_shader}, {\".comp\", shaderc_compute_shader}}; return shaderKindMap.at(ext); } int ShaderTools::compileShaderGLSL(string filename, const MacroDefinitions &defines, const string &outDir, vector<string> &outFiles, int flags) { string parentPath = fs::path(filename).parent_path().string(); filename = fs::path(filename).filename().string(); string inFileName = fs::path(parentPath + \"/\" + filename).make_preferred().string(); string outFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string src, dst; int ret = 0; src = FileUtil::readFile(inFileName); string ext = FileUtil::splitExt(inFileName)[1]; shaderc_shader_kind shaderKind = toShaderKind(ext); if (flags & REMOVE_UNUSED_VARIABLES) { V(removeUnusedVariablesGLSL(src, shaderKind, defines, dst)); src = move(dst); } if (flags & PATCH_SHADER_LAYOUTS_GLSL) { V(patchShaderLayoutsGLSL(src, dst)); src = move(dst); } V(compileShaderGLSL(src, shaderKind, defines, dst)); writeFile(outFileName, dst); outFiles.push_back(outFileName); return 0; } int ShaderTools::compileShaderMSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".metal\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".metallib\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string debugFlags = \"-gline-tables-only -MO\"; int result = cmd(\"xcrun -sdk macosx metal \" + debugFlags + \" -c \" + inFileName + \" -o \" + outDir + \"/\" + strippedFilename + \".air && \" \"xcrun -sdk macosx metallib \" + outDir + \"/\" + strippedFilename + \".air -o \" + outFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::compileShaderHLSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".hlsl\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".dxc\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string shaderModel = \"\"; if (strstr(inFileName.c_str(), \".vert\")) shaderModel = \"vs_5_0\"; else if (strstr(inFileName.c_str(), \".frag\")) shaderModel = \"ps_5_0\"; else if (strstr(inFileName.c_str(), \".comp\")) shaderModel = \"cs_5_0\"; int result = cmd(\"dxc.exe /T \" + shaderModel + \" /Fo \" + outFileName + \" \" + inFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::convertSPVToMSL(const string &spv, shaderc_shader_kind shaderKind, string &msl) { spirv_cross::CompilerMSL compilerMSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); msl = compilerMSL.compile(); return 0; } int ShaderTools::convertSPVToHLSL(const string &spv, shaderc_shader_kind shaderKind, string &hlsl, uint32_t shaderModel) { spirv_cross::CompilerHLSL compilerHLSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto options = compilerHLSL.get_hlsl_options(); options.shader_model = shaderModel; compilerHLSL.set_hlsl_options(options); hlsl = compilerHLSL.compile(); return 0; } int ShaderTools::convertShader(const string &file, const string &extraArgs, string outDir, Format fmt, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string strippedFilename = splitFilename[0]; string ext = FileUtil::splitExt(strippedFilename)[1]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".spv\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + (fmt == FORMAT_MSL ? \".metal\" : \".hlsl\")) .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string spv = FileUtil::readFile(inFileName), dst; int result; if (fmt == FORMAT_MSL) { result = convertSPVToMSL(spv, toShaderKind(ext), dst); } else { result = convertSPVToHLSL(spv, toShaderKind(ext), dst); } FileUtil::writeFile(outFileName, dst); string args = (fmt == FORMAT_MSL ? \"--msl\" : \"--hlsl --shader-model 60\") + extraArgs; if (result == 0) NGFX_LOG(\"converted file: %s to %s\", inFileName.c_str(), outFileName.c_str()); else NGFX_ERR(\"cannot convert file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } bool ShaderTools::findMetalReflectData( const vector<RegexUtil::Match> &metalReflectData, const string &name, RegexUtil::Match &match) { for (const RegexUtil::Match &data : metalReflectData) { if (data.s[2] == name) { match = data; return true; } else if (strstr(data.s[1].c_str(), name.c_str())) { match = data; return true; } } return false; } int ShaderTools::patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect) { auto glslReflectJson = json::parse(glslReflect); MetalReflectData metalReflectData; if (ext == \".vert\") { metalReflectData.attributes = RegexUtil::findAll(regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[\" \"attribute\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); } metalReflectData.buffers = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[buffer\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); metalReflectData.textures = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[texture\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); uint32_t numDescriptors = (textures ? textures->size() : 0) + (images ? images->size() : 0) + (ubos ? ubos->size() : 0) + (ssbos ? ssbos->size() : 0); // update input bindings if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { RegexUtil::Match metalInputReflectData; bool foundMatch = findMetalReflectData( metalReflectData.attributes, input[\"name\"], metalInputReflectData); if (!foundMatch) { return 1; } input[\"location\"] = stoi(metalInputReflectData.s[3]) + numDescriptors; } } // update descriptor bindings if (textures) for (json &descriptor : *textures) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } if (ubos) for (json &descriptor : *ubos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (ssbos) for (json &descriptor : *ssbos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (images) for (json &descriptor : *images) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } mslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect) { auto glslReflectJson = json::parse(glslReflect); HLSLReflectData hlslReflectData; // parse semantics if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { regex p(input[\"name\"].get<string>() + \"\\\\s*:\\\\s*([^;]*);\"); vector<RegexUtil::Match> hlslReflectData = RegexUtil::findAll(p, hlsl); input[\"semantic\"] = hlslReflectData[0].s[1]; } } // get descriptors json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); map<int, json *> descriptors; if (textures) for (auto &desc : *textures) descriptors[desc[\"set\"].get<int>()] = &desc; if (ubos) for (auto &desc : *ubos) descriptors[desc[\"set\"].get<int>()] = &desc; if (ssbos) for (auto &desc : *ssbos) descriptors[desc[\"set\"].get<int>()] = &desc; if (images) for (auto &desc : *images) descriptors[desc[\"set\"].get<int>()] = &desc; // patch descriptor bindings set<int> sets; set<string> samplerTypes = {\"sampler2D\", \"sampler3D\", \"samplerCube\"}; for (const auto &kv : descriptors) { uint32_t set = kv.first; json &desc = *kv.second; while (sets.find(set) != sets.end()) set += 1; desc[\"set\"] = set; sets.insert(set); if (samplerTypes.find(desc[\"type\"]) != samplerTypes.end()) sets.insert(set + 1); } hlslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::genShaderReflectionGLSL(const string &, const string &ext, const string &spv, string &glslMap) { spirv_cross::CompilerReflection compilerReflection( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto reflectOutput = compilerReflection.compile(); glslMap = json::parse(reflectOutput).dump(4); return 0; } int ShaderTools::genShaderReflectionMSL(const string &msl, const string &ext, const string &spv, string &mslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataMSL(glslReflect, ext, msl, mslMap); } int ShaderTools::genShaderReflectionHLSL(const string &hlsl, const string &ext, const string &spv, string &hlslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataHLSL(glslReflect, ext, hlsl, hlslMap); } string ShaderTools::parseReflectionData(const json &reflectData, string ext) { string contents = \"\"; if (ext == \".vert\") { json *inputs = getEntry(reflectData, \"inputs\"); contents += \"INPUT_ATTRIBUTES \" + to_string(inputs->size()) + \"\\n\"; for (const json &input : *inputs) { string inputName = input[\"name\"]; string inputSemantic = \"\"; string inputNameLower = toLower(inputName); inputSemantic = \"UNDEFINED\"; if (input.find(\"semantic\") != input.end()) inputSemantic = input[\"semantic\"]; map<string, string> inputTypeMap = { {\"float\", \"VERTEXFORMAT_FLOAT\"}, {\"vec2\", \"VERTEXFORMAT_FLOAT2\"}, {\"vec3\", \"VERTEXFORMAT_FLOAT3\"}, {\"vec4\", \"VERTEXFORMAT_FLOAT4\"}, {\"ivec2\", \"VERTEXFORMAT_INT2\"}, {\"ivec3\", \"VERTEXFORMAT_INT3\"}, {\"ivec4\", \"VERTEXFORMAT_INT4\"}, {\"mat2\", \"VERTEXFORMAT_MAT2\"}, {\"mat3\", \"VERTEXFORMAT_MAT3\"}, {\"mat4\", \"VERTEXFORMAT_MAT4\"}}; string inputType = inputTypeMap[input[\"type\"]]; contents += \"\\t\" + inputName + \" \" + inputSemantic + \" \" + to_string(input[\"location\"].get<int>()) + \" \" + inputType + \"\\n\"; } } json *textures = getEntry(reflectData, \"textures\"), *ubos = getEntry(reflectData, \"ubos\"), *ssbos = getEntry(reflectData, \"ssbos\"), *images = getEntry(reflectData, \"images\"), *types = getEntry(reflectData, \"types\"); json uniformBufferInfos; json shaderStorageBufferInfos; std::function<void(const json &, json &, uint32_t, string)> parseMembers = [&](const json &membersData, json &members, uint32_t baseOffset = 0, string baseName = \"\") { for (const json &memberData : membersData) { const map<string, int> typeSizeMap = { {\"int\", 4}, {\"uint\", 4}, {\"float\", 4}, {\"vec2\", 8}, {\"vec3\", 12}, {\"vec4\", 16}, {\"ivec2\", 8}, {\"ivec3\", 12}, {\"ivec4\", 16}, {\"uvec2\", 8}, {\"uvec3\", 12}, {\"uvec4\", 16}, {\"mat2\", 16}, {\"mat3\", 36}, {\"mat4\", 64}}; string memberType = memberData[\"type\"]; if (typeSizeMap.find(memberType) != typeSizeMap.end()) { json member = memberData; member[\"name\"] = baseName + member[\"name\"].get<string>(); member[\"size\"] = typeSizeMap.at(memberType); member[\"offset\"] = member[\"offset\"].get<int>() + baseOffset; member[\"array_count\"] = (member.find(\"array\") != member.end()) ? member[\"array\"][0].get<int>() : 0; member[\"array_stride\"] = (member.find(\"array_stride\") != member.end()) ? member[\"array_stride\"].get<int>() : 0; members.push_back(member); } else if (types->find(memberType) != types->end()) { const json &type = (*types)[memberType]; parseMembers(type[\"members\"], members, baseOffset + memberData[\"offset\"].get<int>(), baseName + memberData[\"name\"].get<string>() + \".\"); } else NGFX_ERR(\"unrecognized type: {memberType}\"); } }; auto parseBuffers = [&](const json &buffers, json &bufferInfos) { for (const json &buffer : buffers) { const json &bufferType = (*types)[buffer[\"type\"].get<string>()]; json bufferMembers = {}; parseMembers(bufferType[\"members\"], bufferMembers, 0, \"\"); json bufferInfo = {{\"name\", buffer[\"name\"].get<string>()}, {\"set\", buffer[\"set\"].get<int>()}, {\"binding\", buffer[\"binding\"].get<int>()}, {\"members\", bufferMembers}}; bufferInfos.push_back(bufferInfo); } }; if (ubos) parseBuffers(*ubos, uniformBufferInfos); if (ssbos) parseBuffers(*ssbos, shaderStorageBufferInfos); json textureDescriptors = {}; json bufferDescriptors = {}; if (textures) for (const json &texture : *textures) { textureDescriptors[to_string(texture[\"set\"].get<int>())] = { {\"type\", texture[\"type\"]}, {\"name\", texture[\"name\"]}, {\"set\", texture[\"set\"]}, {\"binding\", texture[\"binding\"]}}; } if (images) for (const json &image : *images) { textureDescriptors[to_string(image[\"set\"].get<int>())] = { {\"type\", image[\"type\"]}, {\"name\", image[\"name\"]}, {\"set\", image[\"set\"]}, {\"binding\", image[\"binding\"]}}; } if (ubos) for (const json &ubo : *ubos) { bufferDescriptors[to_string(ubo[\"set\"].get<int>())] = { {\"type\", \"uniformBuffer\"}, {\"name\", ubo[\"name\"]}, {\"set\", ubo[\"set\"]}, {\"binding\", ubo[\"binding\"]}}; } if (ssbos) for (const json &ssbo : *ssbos) { bufferDescriptors[to_string(ssbo[\"set\"].get<int>())] = { {\"type\", \"shaderStorageBuffer\"}, {\"name\", ssbo[\"name\"]}, {\"set\", ssbo[\"set\"]}, {\"binding\", ssbo[\"binding\"]}}; } contents += \"DESCRIPTORS \" + to_string(textureDescriptors.size() + bufferDescriptors.size()) + \"\\n\"; map<string, string> descriptorTypeMap = { {\"sampler2D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"sampler3D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"samplerCube\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"image2D\", \"DESCRIPTOR_TYPE_STORAGE_IMAGE\"}, {\"uniformBuffer\", \"DESCRIPTOR_TYPE_UNIFORM_BUFFER\"}, {\"shaderStorageBuffer\", \"DESCRIPTOR_TYPE_STORAGE_BUFFER\"}}; for (auto &[key, val] : textureDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } for (auto &[key, val] : bufferDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } auto processBufferInfos = [&](const json &bufferInfo) -> string { string contents = \"\"; const json &memberInfos = bufferInfo[\"members\"]; contents += bufferInfo[\"name\"].get<string>() + \" \" + to_string(bufferInfo[\"set\"].get<int>()) + \" \" + to_string(memberInfos.size()) + \"\\n\"; for (const json &m : memberInfos) { contents += m[\"name\"].get<string>() + \" \" + to_string(m[\"offset\"].get<int>()) + \" \" + to_string(m[\"size\"].get<int>()) + \" \" + to_string(m[\"array_count\"].get<int>()) + \" \" + to_string(m[\"array_stride\"].get<int>()) + \"\\n\"; } return contents; }; contents += \"UNIFORM_BUFFER_INFOS \" + to_string(uniformBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : uniformBufferInfos) { contents += processBufferInfos(bufferInfo); } contents += \"SHADER_STORAGE_BUFFER_INFOS \" + to_string(shaderStorageBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : shaderStorageBufferInfos) { contents += processBufferInfos(bufferInfo); } return contents; } int ShaderTools::generateShaderMapGLSL(const string &file, string outDir, vector<string> &outFiles) { string filename = fs::path(file).filename().string(); string ext = FileUtil::splitExt(filename)[1]; string glslFileName = fs::path(outDir + \"/\" + filename).make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); string glslMapFileName = fs::path(outDir + \"/\" + filename + \".map\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(glslFileName, glslMapFileName)) { outFiles.push_back(glslMapFileName); return 0; } string glsl = \"\", spv = readFile(spvFileName), glslReflect; genShaderReflectionGLSL(glsl, ext, spv, glslReflect); auto glslReflectJson = json::parse(glslReflect); string glslMap = parseReflectionData(glslReflectJson, ext); writeFile(glslMapFileName, glslMap); outFiles.push_back(glslMapFileName); return 0; } int ShaderTools::generateShaderMapMSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string mslFileName = fs::path(outDir + \"/\" + glslFilename + \".metal\") .make_preferred() .string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string mslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".metal.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(mslFileName, mslMapFileName)) { outFiles.push_back(mslMapFileName); return 0; } string msl = readFile(mslFileName), spv = readFile(spvFileName), mslReflect; genShaderReflectionMSL(msl, ext, spv, mslReflect); auto mslReflectJson = json::parse(mslReflect); string mslMap = parseReflectionData(mslReflectJson, ext); writeFile(mslMapFileName, mslMap); outFiles.push_back(mslMapFileName); return 0; } int ShaderTools::generateShaderMapHLSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string hlslFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl\").make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string hlslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(hlslFileName, hlslMapFileName)) { outFiles.push_back(hlslMapFileName); return 0; } string hlsl = readFile(hlslFileName), spv = readFile(spvFileName), hlslReflect; genShaderReflectionHLSL(hlsl, ext, spv, hlslReflect); auto hlslReflectJson = json::parse(hlslReflect); string hlslMap = parseReflectionData(hlslReflectJson, ext); writeFile(hlslMapFileName, hlslMap); outFiles.push_back(hlslMapFileName); return 0; } vector<string> ShaderTools::convertShaders(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) convertShader(file, \"\", outDir, fmt, outFiles); return outFiles; } vector<string> ShaderTools::compileShaders(const vector<string> &files, string outDir, Format fmt, const MacroDefinitions &defines, int flags) { #ifdef GRAPHICS_BACKEND_VULKAN defines += \" -DGRAPHICS_BACKEND_VULKAN=1\"; #endif vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) compileShaderGLSL(file, defines, outDir, outFiles, flags); else if (fmt == FORMAT_MSL) compileShaderMSL(file, defines, outDir, outFiles); else if (fmt == FORMAT_HLSL) compileShaderHLSL(file, defines, outDir, outFiles); } return outFiles; } void ShaderTools::applyPatches(const vector<string> &patchFiles, string outDir) { for (const string &patchFile : patchFiles) { string filename = FileUtil::splitExt(fs::path(patchFile).string())[0]; NGFX_LOG(\"filename: %s\", filename.c_str()); string outFile = fs::path(outDir + \"/\" + filename).make_preferred().string(); if (fs::exists(outFile)) { NGFX_LOG(\"applying patch: {patchFile}\"); string cmdStr = PATCH + \" -N -u \" + outFile + \" -i \" + patchFile; cmd(cmdStr); } } } vector<string> ShaderTools::generateShaderMaps(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) generateShaderMapGLSL(file, outDir, outFiles); else if (fmt == FORMAT_MSL) generateShaderMapMSL(file, outDir, outFiles); else if (fmt == FORMAT_HLSL) generateShaderMapHLSL(file, outDir, outFiles); } return outFiles; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ShaderTools_8h/","text":"src/ngfx/graphics/ShaderTools.h Namespaces Name ngfx Classes Name class ngfx::ShaderTools struct ngfx::ShaderTools::MacroDefinition Types Name using nlohmann::json json Types Documentation using json using json = nlohmann::json; Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/regex/RegexUtil.h\" #include <ctime> #include <json.hpp> #include <map> #include <regex> #include <shaderc/shaderc.hpp> #include <string> #include <vector> using json = nlohmann::json; namespace ngfx { class ShaderTools { public: ShaderTools(bool verbose = false); enum { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2 }; enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL }; struct MacroDefinition { std::string name, value; }; typedef std::vector<MacroDefinition> MacroDefinitions; std::vector<std::string> compileShaders(const std::vector<std::string> &files, std::string outDir, Format fmt = FORMAT_GLSL, const MacroDefinitions &defines = {}, int flags = 0); std::vector<std::string> convertShaders(const std::vector<std::string> &files, std::string outDir, Format fmt); std::vector<std::string> generateShaderMaps(const std::vector<std::string> &files, std::string outDir, Format fmt); private: void applyPatches(const std::vector<std::string> &patchFiles, std::string outDir); int cmd(std::string str); int compileShaderGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &spv, bool verbose = true, shaderc_optimization_level optimizationLevel = shaderc_optimization_level_performance); int compileShaderGLSL(std::string filename, const MacroDefinitions &defines, const std::string &outDir, std::vector<std::string> &outFiles, int flags = 0); int compileShaderHLSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int compileShaderMSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int convertSPVToHLSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &hlsl, uint32_t shaderModel = 60); int convertSPVToMSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &msl); int convertShader(const std::string &file, const std::string &extraArgs, std::string outDir, Format fmt, std::vector<std::string> &outFiles); bool findIncludeFile(const std::string &includeFilename, const std::vector<std::string> &includePaths, std::string &includeFile); struct MetalReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; struct HLSLReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; bool findMetalReflectData(const std::vector<RegexUtil::Match> &metalReflectData, const std::string &name, RegexUtil::Match &match); int genShaderReflectionGLSL(const std::string &glsl, const std::string &ext, const std::string &spv, std::string &glslMap); int genShaderReflectionHLSL(const std::string &hlsl, const std::string &ext, const std::string &spv, std::string &hlslMap); int genShaderReflectionMSL(const std::string &msl, const std::string &ext, const std::string &spv, std::string &mslMap); int generateShaderMapGLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapHLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapMSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); std::string parseReflectionData(const json &reflectData, std::string ext); int patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect); int patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect); int patchShaderLayoutsGLSL(const std::string &src, std::string &dst); int preprocess(const std::string &src, const std::string &dataPath, std::string &dst); int removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst); bool verbose = false; std::vector<std::string> defaultIncludePaths; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/ShaderTools.h"},{"location":"api/Files/ShaderTools_8h/#srcngfxgraphicsshadertoolsh","text":"","title":"src/ngfx/graphics/ShaderTools.h"},{"location":"api/Files/ShaderTools_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ShaderTools_8h/#classes","text":"Name class ngfx::ShaderTools struct ngfx::ShaderTools::MacroDefinition","title":"Classes"},{"location":"api/Files/ShaderTools_8h/#types","text":"Name using nlohmann::json json","title":"Types"},{"location":"api/Files/ShaderTools_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Files/ShaderTools_8h/#using-json","text":"using json = nlohmann::json;","title":"using json"},{"location":"api/Files/ShaderTools_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/regex/RegexUtil.h\" #include <ctime> #include <json.hpp> #include <map> #include <regex> #include <shaderc/shaderc.hpp> #include <string> #include <vector> using json = nlohmann::json; namespace ngfx { class ShaderTools { public: ShaderTools(bool verbose = false); enum { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2 }; enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL }; struct MacroDefinition { std::string name, value; }; typedef std::vector<MacroDefinition> MacroDefinitions; std::vector<std::string> compileShaders(const std::vector<std::string> &files, std::string outDir, Format fmt = FORMAT_GLSL, const MacroDefinitions &defines = {}, int flags = 0); std::vector<std::string> convertShaders(const std::vector<std::string> &files, std::string outDir, Format fmt); std::vector<std::string> generateShaderMaps(const std::vector<std::string> &files, std::string outDir, Format fmt); private: void applyPatches(const std::vector<std::string> &patchFiles, std::string outDir); int cmd(std::string str); int compileShaderGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &spv, bool verbose = true, shaderc_optimization_level optimizationLevel = shaderc_optimization_level_performance); int compileShaderGLSL(std::string filename, const MacroDefinitions &defines, const std::string &outDir, std::vector<std::string> &outFiles, int flags = 0); int compileShaderHLSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int compileShaderMSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int convertSPVToHLSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &hlsl, uint32_t shaderModel = 60); int convertSPVToMSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &msl); int convertShader(const std::string &file, const std::string &extraArgs, std::string outDir, Format fmt, std::vector<std::string> &outFiles); bool findIncludeFile(const std::string &includeFilename, const std::vector<std::string> &includePaths, std::string &includeFile); struct MetalReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; struct HLSLReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; bool findMetalReflectData(const std::vector<RegexUtil::Match> &metalReflectData, const std::string &name, RegexUtil::Match &match); int genShaderReflectionGLSL(const std::string &glsl, const std::string &ext, const std::string &spv, std::string &glslMap); int genShaderReflectionHLSL(const std::string &hlsl, const std::string &ext, const std::string &spv, std::string &hlslMap); int genShaderReflectionMSL(const std::string &msl, const std::string &ext, const std::string &spv, std::string &mslMap); int generateShaderMapGLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapHLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapMSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); std::string parseReflectionData(const json &reflectData, std::string ext); int patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect); int patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect); int patchShaderLayoutsGLSL(const std::string &src, std::string &dst); int preprocess(const std::string &src, const std::string &dataPath, std::string &dst); int removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst); bool verbose = false; std::vector<std::string> defaultIncludePaths; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/StringUtil_8cpp/","text":"src/ngfx/core/StringUtil.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/StringUtil.h\" #include <codecvt> #include <locale> #include <string> using namespace std; using namespace ngfx; string StringUtil::toLower(const string &str) { string r = str; for (uint32_t j = 0; j < r.size(); j++) r[j] = tolower(r[j]); return r; } std::wstring StringUtil::toWString(const std::string &str) { std::wstring target; std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter; return converter.from_bytes(str); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/StringUtil.cpp"},{"location":"api/Files/StringUtil_8cpp/#srcngfxcorestringutilcpp","text":"","title":"src/ngfx/core/StringUtil.cpp"},{"location":"api/Files/StringUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/StringUtil.h\" #include <codecvt> #include <locale> #include <string> using namespace std; using namespace ngfx; string StringUtil::toLower(const string &str) { string r = str; for (uint32_t j = 0; j < r.size(); j++) r[j] = tolower(r[j]); return r; } std::wstring StringUtil::toWString(const std::string &str) { std::wstring target; std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter; return converter.from_bytes(str); } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/StringUtil_8h/","text":"src/ngfx/core/StringUtil.h Namespaces Name ngfx Classes Name class ngfx::StringUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> namespace ngfx { class StringUtil { public: static std::string toLower(const std::string &str); static std::wstring toWString(const std::string &str); }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/StringUtil.h"},{"location":"api/Files/StringUtil_8h/#srcngfxcorestringutilh","text":"","title":"src/ngfx/core/StringUtil.h"},{"location":"api/Files/StringUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/StringUtil_8h/#classes","text":"Name class ngfx::StringUtil","title":"Classes"},{"location":"api/Files/StringUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> namespace ngfx { class StringUtil { public: static std::string toLower(const std::string &str); static std::wstring toWString(const std::string &str); }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Surface_8h/","text":"src/ngfx/graphics/Surface.h Namespaces Name ngfx Classes Name class ngfx::Surface Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> namespace ngfx { class Surface { public: Surface() {} Surface(uint32_t w, uint32_t h, bool offscreen = false) : w(w), h(h), offscreen(offscreen) {} virtual ~Surface() {} uint32_t w = 0, h = 0; bool offscreen = false; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Surface.h"},{"location":"api/Files/Surface_8h/#srcngfxgraphicssurfaceh","text":"","title":"src/ngfx/graphics/Surface.h"},{"location":"api/Files/Surface_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Surface_8h/#classes","text":"Name class ngfx::Surface","title":"Classes"},{"location":"api/Files/Surface_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> namespace ngfx { class Surface { public: Surface() {} Surface(uint32_t w, uint32_t h, bool offscreen = false) : w(w), h(h), offscreen(offscreen) {} virtual ~Surface() {} uint32_t w = 0, h = 0; bool offscreen = false; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Swapchain_8h/","text":"src/ngfx/graphics/Swapchain.h Namespaces Name ngfx Classes Name class ngfx::Swapchain Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Semaphore.h\" #include <cstdint> namespace ngfx { class Swapchain { public: virtual ~Swapchain() {} virtual void acquireNextImage() = 0; uint32_t numImages; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Swapchain.h"},{"location":"api/Files/Swapchain_8h/#srcngfxgraphicsswapchainh","text":"","title":"src/ngfx/graphics/Swapchain.h"},{"location":"api/Files/Swapchain_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Swapchain_8h/#classes","text":"Name class ngfx::Swapchain","title":"Classes"},{"location":"api/Files/Swapchain_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Semaphore.h\" #include <cstdint> namespace ngfx { class Swapchain { public: virtual ~Swapchain() {} virtual void acquireNextImage() = 0; uint32_t numImages; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Texture_8cpp/","text":"src/ngfx/graphics/Texture.cpp Defines Name STB_IMAGE_IMPLEMENTATION Macro Documentation define STB_IMAGE_IMPLEMENTATION #define STB_IMAGE_IMPLEMENTATION Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Texture.h\" #define STB_IMAGE_IMPLEMENTATION #include <memory> #include <stb_image.h> using namespace ngfx; Texture *Texture::create(GraphicsContext *ctx, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { int w, h, channels; std::unique_ptr<stbi_uc> data(stbi_load(filename, &w, &h, &channels, 4)); assert(data); Texture *texture = create(ctx, graphics, data.get(), PIXELFORMAT_RGBA8_UNORM, w * h * 4, w, h, 1, 1, imageUsageFlags, textureType, genMipmaps, minFilter, magFilter, mipFilter, numSamples); return texture; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Texture.cpp"},{"location":"api/Files/Texture_8cpp/#srcngfxgraphicstexturecpp","text":"","title":"src/ngfx/graphics/Texture.cpp"},{"location":"api/Files/Texture_8cpp/#defines","text":"Name STB_IMAGE_IMPLEMENTATION","title":"Defines"},{"location":"api/Files/Texture_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/Texture_8cpp/#define-stb_image_implementation","text":"#define STB_IMAGE_IMPLEMENTATION","title":"define STB_IMAGE_IMPLEMENTATION"},{"location":"api/Files/Texture_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Texture.h\" #define STB_IMAGE_IMPLEMENTATION #include <memory> #include <stb_image.h> using namespace ngfx; Texture *Texture::create(GraphicsContext *ctx, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { int w, h, channels; std::unique_ptr<stbi_uc> data(stbi_load(filename, &w, &h, &channels, 4)); assert(data); Texture *texture = create(ctx, graphics, data.get(), PIXELFORMAT_RGBA8_UNORM, w * h * 4, w, h, 1, 1, imageUsageFlags, textureType, genMipmaps, minFilter, magFilter, mipFilter, numSamples); return texture; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Texture_8h/","text":"src/ngfx/graphics/Texture.h Namespaces Name ngfx Classes Name class ngfx::Texture Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" namespace ngfx { class Graphics; class GraphicsContext; class Texture { public: static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, void *data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); virtual ~Texture() {} virtual void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) = 0; virtual void generateMipmaps(CommandBuffer *commandBuffer) = 0; PixelFormat format; uint32_t w = 0, h = 0, d = 1, arrayLayers = 1, mipLevels = 1, numSamples = 1; ImageUsageFlags imageUsageFlags; TextureType textureType; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Texture.h"},{"location":"api/Files/Texture_8h/#srcngfxgraphicstextureh","text":"","title":"src/ngfx/graphics/Texture.h"},{"location":"api/Files/Texture_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Texture_8h/#classes","text":"Name class ngfx::Texture","title":"Classes"},{"location":"api/Files/Texture_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" namespace ngfx { class Graphics; class GraphicsContext; class Texture { public: static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, void *data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); virtual ~Texture() {} virtual void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) = 0; virtual void generateMipmaps(CommandBuffer *commandBuffer) = 0; PixelFormat format; uint32_t w = 0, h = 0, d = 1, arrayLayers = 1, mipLevels = 1, numSamples = 1; ImageUsageFlags imageUsageFlags; TextureType textureType; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Timer_8cpp/","text":"src/ngfx/core/Timer.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/Timer.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; using namespace std::chrono; Timer::Timer() { t0 = system_clock::now(); } void Timer::update() { auto t1 = system_clock::now(); elapsed = duration_cast<nanoseconds>(t1 - t0).count() / float(1e9); t0 = t1; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/Timer.cpp"},{"location":"api/Files/Timer_8cpp/#srcngfxcoretimercpp","text":"","title":"src/ngfx/core/Timer.cpp"},{"location":"api/Files/Timer_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/Timer.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; using namespace std::chrono; Timer::Timer() { t0 = system_clock::now(); } void Timer::update() { auto t1 = system_clock::now(); elapsed = duration_cast<nanoseconds>(t1 - t0).count() / float(1e9); t0 = t1; } Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Timer_8h/","text":"src/ngfx/core/Timer.h Namespaces Name ngfx Classes Name class ngfx::Timer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <chrono> namespace ngfx { class Timer { public: Timer(); void update(); float elapsed; std::chrono::system_clock::time_point t0; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/Timer.h"},{"location":"api/Files/Timer_8h/#srcngfxcoretimerh","text":"","title":"src/ngfx/core/Timer.h"},{"location":"api/Files/Timer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Timer_8h/#classes","text":"Name class ngfx::Timer","title":"Classes"},{"location":"api/Files/Timer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <chrono> namespace ngfx { class Timer { public: Timer(); void update(); float elapsed; std::chrono::system_clock::time_point t0; }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Util_8cpp/","text":"src/ngfx/core/Util.cpp Source code #include \"ngfx/core/Util.h\" using namespace ngfx; uint64_t Util::hash(const std::string &s) { uint64_t result = 2166136261U; for (const char &c : s) { result = 127 * result + uint8_t(c); } return result; }; Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/Util.cpp"},{"location":"api/Files/Util_8cpp/#srcngfxcoreutilcpp","text":"","title":"src/ngfx/core/Util.cpp"},{"location":"api/Files/Util_8cpp/#source-code","text":"#include \"ngfx/core/Util.h\" using namespace ngfx; uint64_t Util::hash(const std::string &s) { uint64_t result = 2166136261U; for (const char &c : s) { result = 127 * result + uint8_t(c); } return result; }; Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Util_8h/","text":"src/ngfx/core/Util.h Namespaces Name ngfx Classes Name class ngfx::Util Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <algorithm> #include <string> #include <vector> namespace ngfx { class Util { public: template <typename T> static bool contains(std::vector<T> &v, T item) { return (std::find(v.begin(), v.end(), item) != v.end()); } static uint64_t hash(const std::string &s); }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core/Util.h"},{"location":"api/Files/Util_8h/#srcngfxcoreutilh","text":"","title":"src/ngfx/core/Util.h"},{"location":"api/Files/Util_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Util_8h/#classes","text":"Name class ngfx::Util","title":"Classes"},{"location":"api/Files/Util_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <algorithm> #include <string> #include <vector> namespace ngfx { class Util { public: template <typename T> static bool contains(std::vector<T> &v, T item) { return (std::find(v.begin(), v.end(), item) != v.end()); } static uint64_t hash(const std::string &s); }; } // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Window_8h/","text":"src/ngfx/graphics/Window.h Namespaces Name ngfx Classes Name class ngfx::Window Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/input/InputMap.h\" #include <functional> namespace ngfx { class GraphicsContext; class Window { public: static Window *create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w = DISPLAY_WIDTH, int h = DISPLAY_HEIGHT); virtual ~Window() {} virtual bool shouldClose() = 0; virtual void pollEvents() = 0; enum { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1 }; int w, h; Surface *surface = nullptr; std::function<void()> onUpdate = nullptr, onPaint = nullptr; std::function<void(KeyCode code, InputAction action)> onKey = nullptr; std::function<void(double xoffset, double yoffset)> onScroll = nullptr; std::function<void(double x, double y)> onCursorPos = nullptr; std::function<void(MouseButton button, InputAction action)> onMouseButton = nullptr; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics/Window.h"},{"location":"api/Files/Window_8h/#srcngfxgraphicswindowh","text":"","title":"src/ngfx/graphics/Window.h"},{"location":"api/Files/Window_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Window_8h/#classes","text":"Name class ngfx::Window","title":"Classes"},{"location":"api/Files/Window_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/input/InputMap.h\" #include <functional> namespace ngfx { class GraphicsContext; class Window { public: static Window *create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w = DISPLAY_WIDTH, int h = DISPLAY_HEIGHT); virtual ~Window() {} virtual bool shouldClose() = 0; virtual void pollEvents() = 0; enum { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1 }; int w, h; Surface *surface = nullptr; std::function<void()> onUpdate = nullptr, onPaint = nullptr; std::function<void(KeyCode code, InputAction action)> onKey = nullptr; std::function<void(double xoffset, double yoffset)> onScroll = nullptr; std::function<void(double x, double y)> onCursorPos = nullptr; std::function<void(MouseButton button, InputAction action)> onMouseButton = nullptr; }; }; // namespace ngfx Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/dir_30faf12615bf536facf6068fc9db1a7e/","text":"src/ngfx/computeOps Files Name src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp src/ngfx/computeOps/MatrixMultiplyCPUOp.h src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp src/ngfx/computeOps/MatrixMultiplyGPUOp.h src/ngfx/computeOps/MatrixMultiplyOp.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/computeOps"},{"location":"api/Files/dir_30faf12615bf536facf6068fc9db1a7e/#srcngfxcomputeops","text":"","title":"src/ngfx/computeOps"},{"location":"api/Files/dir_30faf12615bf536facf6068fc9db1a7e/#files","text":"Name src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp src/ngfx/computeOps/MatrixMultiplyCPUOp.h src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp src/ngfx/computeOps/MatrixMultiplyGPUOp.h src/ngfx/computeOps/MatrixMultiplyOp.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Files"},{"location":"api/Files/dir_61819f5050c989815f217f007bce688d/","text":"src/ngfx/graphics Files Name src/ngfx/graphics/Buffer.h src/ngfx/graphics/BufferUtil.h src/ngfx/graphics/Camera.cpp src/ngfx/graphics/Camera.h src/ngfx/graphics/CommandBuffer.h src/ngfx/graphics/Config.h src/ngfx/graphics/Device.h src/ngfx/graphics/DrawOp.h src/ngfx/graphics/Fence.h src/ngfx/graphics/FilterOp.cpp src/ngfx/graphics/FilterOp.h src/ngfx/graphics/Framebuffer.h src/ngfx/graphics/Graphics.h src/ngfx/graphics/GraphicsContext.h src/ngfx/graphics/GraphicsCore.h src/ngfx/graphics/GraphicsPipeline.cpp src/ngfx/graphics/GraphicsPipeline.h src/ngfx/graphics/MeshData.h src/ngfx/graphics/MeshUtil.cpp src/ngfx/graphics/MeshUtil.h src/ngfx/graphics/Pipeline.h src/ngfx/graphics/PipelineCache.cpp src/ngfx/graphics/PipelineCache.h src/ngfx/graphics/Queue.h src/ngfx/graphics/RenderPass.h src/ngfx/graphics/Semaphore.h src/ngfx/graphics/ShaderModule.cpp src/ngfx/graphics/ShaderModule.h src/ngfx/graphics/ShaderTools.cpp src/ngfx/graphics/ShaderTools.h src/ngfx/graphics/Surface.h src/ngfx/graphics/Swapchain.h src/ngfx/graphics/Texture.cpp src/ngfx/graphics/Texture.h src/ngfx/graphics/Window.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/graphics"},{"location":"api/Files/dir_61819f5050c989815f217f007bce688d/#srcngfxgraphics","text":"","title":"src/ngfx/graphics"},{"location":"api/Files/dir_61819f5050c989815f217f007bce688d/#files","text":"Name src/ngfx/graphics/Buffer.h src/ngfx/graphics/BufferUtil.h src/ngfx/graphics/Camera.cpp src/ngfx/graphics/Camera.h src/ngfx/graphics/CommandBuffer.h src/ngfx/graphics/Config.h src/ngfx/graphics/Device.h src/ngfx/graphics/DrawOp.h src/ngfx/graphics/Fence.h src/ngfx/graphics/FilterOp.cpp src/ngfx/graphics/FilterOp.h src/ngfx/graphics/Framebuffer.h src/ngfx/graphics/Graphics.h src/ngfx/graphics/GraphicsContext.h src/ngfx/graphics/GraphicsCore.h src/ngfx/graphics/GraphicsPipeline.cpp src/ngfx/graphics/GraphicsPipeline.h src/ngfx/graphics/MeshData.h src/ngfx/graphics/MeshUtil.cpp src/ngfx/graphics/MeshUtil.h src/ngfx/graphics/Pipeline.h src/ngfx/graphics/PipelineCache.cpp src/ngfx/graphics/PipelineCache.h src/ngfx/graphics/Queue.h src/ngfx/graphics/RenderPass.h src/ngfx/graphics/Semaphore.h src/ngfx/graphics/ShaderModule.cpp src/ngfx/graphics/ShaderModule.h src/ngfx/graphics/ShaderTools.cpp src/ngfx/graphics/ShaderTools.h src/ngfx/graphics/Surface.h src/ngfx/graphics/Swapchain.h src/ngfx/graphics/Texture.cpp src/ngfx/graphics/Texture.h src/ngfx/graphics/Window.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Files"},{"location":"api/Files/dir_63a95ed4093c85063905e55b50c4c57a/","text":"src/ngfx/compute Files Name src/ngfx/compute/ComputeApplication.cpp src/ngfx/compute/ComputeApplication.h src/ngfx/compute/ComputeOp.h src/ngfx/compute/ComputePass.h src/ngfx/compute/ComputePipeline.h Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"src/ngfx/compute"},{"location":"api/Files/dir_63a95ed4093c85063905e55b50c4c57a/#srcngfxcompute","text":"","title":"src/ngfx/compute"},{"location":"api/Files/dir_63a95ed4093c85063905e55b50c4c57a/#files","text":"Name src/ngfx/compute/ComputeApplication.cpp src/ngfx/compute/ComputeApplication.h src/ngfx/compute/ComputeOp.h src/ngfx/compute/ComputePass.h src/ngfx/compute/ComputePipeline.h Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"Files"},{"location":"api/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"src Directories Name src/ngfx Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"src"},{"location":"api/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#src","text":"","title":"src"},{"location":"api/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Name src/ngfx Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"Directories"},{"location":"api/Files/dir_6a2981783036dd447c2e297205838fbc/","text":"src/ngfx/input Files Name src/ngfx/input/InputListener.h src/ngfx/input/InputMap.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/input"},{"location":"api/Files/dir_6a2981783036dd447c2e297205838fbc/#srcngfxinput","text":"","title":"src/ngfx/input"},{"location":"api/Files/dir_6a2981783036dd447c2e297205838fbc/#files","text":"Name src/ngfx/input/InputListener.h src/ngfx/input/InputMap.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Files"},{"location":"api/Files/dir_836d6044c9b9d906d07510ab7de02523/","text":"src/ngfx/drawOps Files Name src/ngfx/drawOps/DrawColorOp.cpp src/ngfx/drawOps/DrawColorOp.h src/ngfx/drawOps/DrawMeshOp.cpp src/ngfx/drawOps/DrawMeshOp.h src/ngfx/drawOps/DrawTextureOp.cpp src/ngfx/drawOps/DrawTextureOp.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/drawOps"},{"location":"api/Files/dir_836d6044c9b9d906d07510ab7de02523/#srcngfxdrawops","text":"","title":"src/ngfx/drawOps"},{"location":"api/Files/dir_836d6044c9b9d906d07510ab7de02523/#files","text":"Name src/ngfx/drawOps/DrawColorOp.cpp src/ngfx/drawOps/DrawColorOp.h src/ngfx/drawOps/DrawMeshOp.cpp src/ngfx/drawOps/DrawMeshOp.h src/ngfx/drawOps/DrawTextureOp.cpp src/ngfx/drawOps/DrawTextureOp.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Files"},{"location":"api/Files/dir_ba89cfdb2985c20790f90acbff1b244e/","text":"src/ngfx/regex Files Name src/ngfx/regex/RegexUtil.cpp src/ngfx/regex/RegexUtil.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/regex"},{"location":"api/Files/dir_ba89cfdb2985c20790f90acbff1b244e/#srcngfxregex","text":"","title":"src/ngfx/regex"},{"location":"api/Files/dir_ba89cfdb2985c20790f90acbff1b244e/#files","text":"Name src/ngfx/regex/RegexUtil.cpp src/ngfx/regex/RegexUtil.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Files"},{"location":"api/Files/dir_bf4520687725fcb8943bc560a06cbd17/","text":"src/ngfx Directories Name src/ngfx/compute src/ngfx/computeOps src/ngfx/core src/ngfx/drawOps src/ngfx/graphics src/ngfx/input src/ngfx/regex Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"src/ngfx"},{"location":"api/Files/dir_bf4520687725fcb8943bc560a06cbd17/#srcngfx","text":"","title":"src/ngfx"},{"location":"api/Files/dir_bf4520687725fcb8943bc560a06cbd17/#directories","text":"Name src/ngfx/compute src/ngfx/computeOps src/ngfx/core src/ngfx/drawOps src/ngfx/graphics src/ngfx/input src/ngfx/regex Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"Directories"},{"location":"api/Files/dir_f0cfb9d6257f0cbc5e7e8cb8f2cdcbe0/","text":"src/ngfx/core Files Name src/ngfx/core/Application.h src/ngfx/core/BaseApplication.cpp src/ngfx/core/BaseApplication.h src/ngfx/core/DebugUtil.h src/ngfx/core/File.cpp src/ngfx/core/File.h src/ngfx/core/FileUtil.cpp src/ngfx/core/FileUtil.h src/ngfx/core/FPSCounter.cpp src/ngfx/core/FPSCounter.h src/ngfx/core/ProcessUtil.cpp src/ngfx/core/ProcessUtil.h src/ngfx/core/StringUtil.cpp src/ngfx/core/StringUtil.h src/ngfx/core/Timer.cpp src/ngfx/core/Timer.h src/ngfx/core/Util.cpp src/ngfx/core/Util.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"src/ngfx/core"},{"location":"api/Files/dir_f0cfb9d6257f0cbc5e7e8cb8f2cdcbe0/#srcngfxcore","text":"","title":"src/ngfx/core"},{"location":"api/Files/dir_f0cfb9d6257f0cbc5e7e8cb8f2cdcbe0/#files","text":"Name src/ngfx/core/Application.h src/ngfx/core/BaseApplication.cpp src/ngfx/core/BaseApplication.h src/ngfx/core/DebugUtil.h src/ngfx/core/File.cpp src/ngfx/core/File.h src/ngfx/core/FileUtil.cpp src/ngfx/core/FileUtil.h src/ngfx/core/FPSCounter.cpp src/ngfx/core/FPSCounter.h src/ngfx/core/ProcessUtil.cpp src/ngfx/core/ProcessUtil.h src/ngfx/core/StringUtil.cpp src/ngfx/core/StringUtil.h src/ngfx/core/Timer.cpp src/ngfx/core/Timer.h src/ngfx/core/Util.cpp src/ngfx/core/Util.h Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Files"},{"location":"api/Modules/","text":"Modules Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Modules"},{"location":"api/Modules/#modules","text":"Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Modules"},{"location":"api/Namespaces/","text":"Namespaces namespace glm namespace ngfx namespace std namespace std::chrono namespace std::placeholders Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Namespaces"},{"location":"api/Namespaces/#namespaces","text":"namespace glm namespace ngfx namespace std namespace std::chrono namespace std::placeholders Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Namespaces"},{"location":"api/Namespaces/namespaceglm/","text":"glm Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"glm"},{"location":"api/Namespaces/namespaceglm/#glm","text":"Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"glm"},{"location":"api/Namespaces/namespacengfx/","text":"ngfx Classes Name class ngfx::BaseApplication class ngfx::Buffer class ngfx::Camera class ngfx::CommandBuffer class ngfx::ComputeApplication class ngfx::ComputeOp class ngfx::ComputePass class ngfx::ComputePipeline class ngfx::ComputeShaderModule class ngfx::Device class ngfx::DrawColorOp class ngfx::DrawMeshOp class ngfx::DrawOp class ngfx::DrawTextureOp class ngfx::Fence class ngfx::File class ngfx::FileUtil class ngfx::FilterOp class ngfx::FPSCounter class ngfx::FragmentShaderModule class ngfx::Framebuffer class ngfx::Graphics class ngfx::GraphicsContext class ngfx::GraphicsPipeline class ngfx::InputListener class ngfx::MatrixMultiplyCPUOp class ngfx::MatrixMultiplyGPUOp class ngfx::MatrixMultiplyOp struct ngfx::MeshData struct ngfx::MeshUtil class ngfx::Pipeline class ngfx::PipelineCache class ngfx::ProcessUtil class ngfx::Queue struct ngfx::Rect2D class ngfx::RegexUtil class ngfx::RenderPass class ngfx::Semaphore class ngfx::ShaderModule class ngfx::ShaderTools class ngfx::StringUtil class ngfx::Surface class ngfx::Swapchain class ngfx::Texture class ngfx::Timer class ngfx::Util class ngfx::VertexShaderModule class ngfx::Window Types Name typedef uint32_t Flags typedef Flags PipelineStageFlags typedef Flags ShaderStageFlags typedef Flags FenceCreateFlags typedef Flags ImageUsageFlags typedef Flags ColorComponentFlags typedef Flags BufferUsageFlags Functions Name Buffer * createVertexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) template <typename T > Buffer * createVertexBuffer ( GraphicsContext * ctx, const std::vector< T > & v) Buffer * createIndexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t)) template <typename T > Buffer * createIndexBuffer ( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t)) Buffer * createUniformBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) Buffer * createStorageBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) Types Documentation typedef Flags typedef uint32_t ngfx::Flags; typedef PipelineStageFlags typedef Flags ngfx::PipelineStageFlags; typedef ShaderStageFlags typedef Flags ngfx::ShaderStageFlags; typedef FenceCreateFlags typedef Flags ngfx::FenceCreateFlags; typedef ImageUsageFlags typedef Flags ngfx::ImageUsageFlags; typedef ColorComponentFlags typedef Flags ngfx::ColorComponentFlags; typedef BufferUsageFlags typedef Flags ngfx::BufferUsageFlags; Functions Documentation function createVertexBuffer static Buffer * createVertexBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) Create a vertex buffer function createVertexBuffer template <typename T > static inline Buffer * createVertexBuffer( GraphicsContext * ctx, const std::vector< T > & v ) Parameters : ctx The graphics context v The buffer data Create a vertex buffer function createIndexBuffer static Buffer * createIndexBuffer( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) stride The stride of the input data (in bytes) Create an index buffer function createIndexBuffer template <typename T > static inline Buffer * createIndexBuffer( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context v The buffer data stride The stride of the input data (in bytes) Create an index buffer function createUniformBuffer static Buffer * createUniformBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a uniform buffer function createStorageBuffer static Buffer * createStorageBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a storage buffer Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"ngfx"},{"location":"api/Namespaces/namespacengfx/#ngfx","text":"","title":"ngfx"},{"location":"api/Namespaces/namespacengfx/#classes","text":"Name class ngfx::BaseApplication class ngfx::Buffer class ngfx::Camera class ngfx::CommandBuffer class ngfx::ComputeApplication class ngfx::ComputeOp class ngfx::ComputePass class ngfx::ComputePipeline class ngfx::ComputeShaderModule class ngfx::Device class ngfx::DrawColorOp class ngfx::DrawMeshOp class ngfx::DrawOp class ngfx::DrawTextureOp class ngfx::Fence class ngfx::File class ngfx::FileUtil class ngfx::FilterOp class ngfx::FPSCounter class ngfx::FragmentShaderModule class ngfx::Framebuffer class ngfx::Graphics class ngfx::GraphicsContext class ngfx::GraphicsPipeline class ngfx::InputListener class ngfx::MatrixMultiplyCPUOp class ngfx::MatrixMultiplyGPUOp class ngfx::MatrixMultiplyOp struct ngfx::MeshData struct ngfx::MeshUtil class ngfx::Pipeline class ngfx::PipelineCache class ngfx::ProcessUtil class ngfx::Queue struct ngfx::Rect2D class ngfx::RegexUtil class ngfx::RenderPass class ngfx::Semaphore class ngfx::ShaderModule class ngfx::ShaderTools class ngfx::StringUtil class ngfx::Surface class ngfx::Swapchain class ngfx::Texture class ngfx::Timer class ngfx::Util class ngfx::VertexShaderModule class ngfx::Window","title":"Classes"},{"location":"api/Namespaces/namespacengfx/#types","text":"Name typedef uint32_t Flags typedef Flags PipelineStageFlags typedef Flags ShaderStageFlags typedef Flags FenceCreateFlags typedef Flags ImageUsageFlags typedef Flags ColorComponentFlags typedef Flags BufferUsageFlags","title":"Types"},{"location":"api/Namespaces/namespacengfx/#functions","text":"Name Buffer * createVertexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) template <typename T > Buffer * createVertexBuffer ( GraphicsContext * ctx, const std::vector< T > & v) Buffer * createIndexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t)) template <typename T > Buffer * createIndexBuffer ( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t)) Buffer * createUniformBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) Buffer * createStorageBuffer ( GraphicsContext * ctx, const void * data, uint32_t size)","title":"Functions"},{"location":"api/Namespaces/namespacengfx/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Namespaces/namespacengfx/#typedef-flags","text":"typedef uint32_t ngfx::Flags;","title":"typedef Flags"},{"location":"api/Namespaces/namespacengfx/#typedef-pipelinestageflags","text":"typedef Flags ngfx::PipelineStageFlags;","title":"typedef PipelineStageFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-shaderstageflags","text":"typedef Flags ngfx::ShaderStageFlags;","title":"typedef ShaderStageFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-fencecreateflags","text":"typedef Flags ngfx::FenceCreateFlags;","title":"typedef FenceCreateFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-imageusageflags","text":"typedef Flags ngfx::ImageUsageFlags;","title":"typedef ImageUsageFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-colorcomponentflags","text":"typedef Flags ngfx::ColorComponentFlags;","title":"typedef ColorComponentFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-bufferusageflags","text":"typedef Flags ngfx::BufferUsageFlags;","title":"typedef BufferUsageFlags"},{"location":"api/Namespaces/namespacengfx/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Namespaces/namespacengfx/#function-createvertexbuffer","text":"static Buffer * createVertexBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) Create a vertex buffer","title":"function createVertexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createvertexbuffer_1","text":"template <typename T > static inline Buffer * createVertexBuffer( GraphicsContext * ctx, const std::vector< T > & v ) Parameters : ctx The graphics context v The buffer data Create a vertex buffer","title":"function createVertexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createindexbuffer","text":"static Buffer * createIndexBuffer( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) stride The stride of the input data (in bytes) Create an index buffer","title":"function createIndexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createindexbuffer_1","text":"template <typename T > static inline Buffer * createIndexBuffer( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context v The buffer data stride The stride of the input data (in bytes) Create an index buffer","title":"function createIndexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createuniformbuffer","text":"static Buffer * createUniformBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a uniform buffer","title":"function createUniformBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createstoragebuffer","text":"static Buffer * createStorageBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a storage buffer Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"function createStorageBuffer"},{"location":"api/Namespaces/namespacestd/","text":"std Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"std"},{"location":"api/Namespaces/namespacestd/#std","text":"Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"std"},{"location":"api/Namespaces/namespacestd_1_1chrono/","text":"std::chrono Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"std::chrono"},{"location":"api/Namespaces/namespacestd_1_1chrono/#stdchrono","text":"Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"std::chrono"},{"location":"api/Namespaces/namespacestd_1_1placeholders/","text":"std::placeholders Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"std::placeholders"},{"location":"api/Namespaces/namespacestd_1_1placeholders/#stdplaceholders","text":"Updated on 14 March 2021 at 11:29:17 Pacific Daylight Time","title":"std::placeholders"},{"location":"api/Pages/","text":"Pages Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Pages"},{"location":"api/Pages/#pages","text":"Updated on 14 March 2021 at 11:29:18 Pacific Daylight Time","title":"Pages"}]}