{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"api/Classes/","text":"Classes class BufferUtil class Camera class CommandBuffer class DrawOp class Fence struct VertexFormatInfo namespace glm namespace ngfx class Buffer class Camera class CommandBuffer class ComputeShaderModule class Device class DrawOp class Fence class FilterOp class FragmentShaderModule class Framebuffer struct Attachment class Graphics class GraphicsContext struct AttachmentDescription struct RenderPassConfig class GraphicsPipeline struct Descriptor struct State struct MeshData struct MeshUtil class Pipeline class PipelineCache class Queue struct Rect2D class RenderPass class Semaphore class ShaderModule struct BufferInfo struct BufferMemberInfo struct DescriptorInfo class ShaderTools struct HLSLReflectData struct MacroDefinition struct MetalReflectData class Surface class Swapchain class Texture class VertexShaderModule struct AttributeDescription class Window namespace std Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Classes"},{"location":"api/Classes/#classes","text":"class BufferUtil class Camera class CommandBuffer class DrawOp class Fence struct VertexFormatInfo namespace glm namespace ngfx class Buffer class Camera class CommandBuffer class ComputeShaderModule class Device class DrawOp class Fence class FilterOp class FragmentShaderModule class Framebuffer struct Attachment class Graphics class GraphicsContext struct AttachmentDescription struct RenderPassConfig class GraphicsPipeline struct Descriptor struct State struct MeshData struct MeshUtil class Pipeline class PipelineCache class Queue struct Rect2D class RenderPass class Semaphore class ShaderModule struct BufferInfo struct BufferMemberInfo struct DescriptorInfo class ShaderTools struct HLSLReflectData struct MacroDefinition struct MetalReflectData class Surface class Swapchain class Texture class VertexShaderModule struct AttributeDescription class Window namespace std Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Classes"},{"location":"api/Classes/classBufferUtil/","text":"BufferUtil More... #include <BufferUtil.h> Detailed Description class BufferUtil; This utility module provides helper functions for creating various types of specialized GPU buffers Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"BufferUtil"},{"location":"api/Classes/classBufferUtil/#bufferutil","text":"More... #include <BufferUtil.h>","title":"BufferUtil"},{"location":"api/Classes/classBufferUtil/#detailed-description","text":"class BufferUtil; This utility module provides helper functions for creating various types of specialized GPU buffers Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Detailed Description"},{"location":"api/Classes/classCamera/","text":"Camera More... #include <Camera.h> Detailed Description class Camera; This class supports 2D and 3D camera operations. It supports, panning, zooming, and rotation. It also supports user input via keyboard, mouse, and touch events. Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Camera"},{"location":"api/Classes/classCamera/#camera","text":"More... #include <Camera.h>","title":"Camera"},{"location":"api/Classes/classCamera/#detailed-description","text":"class Camera; This class supports 2D and 3D camera operations. It supports, panning, zooming, and rotation. It also supports user input via keyboard, mouse, and touch events. Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Detailed Description"},{"location":"api/Classes/classCommandBuffer/","text":"CommandBuffer More... #include <CommandBuffer.h> Detailed Description class CommandBuffer; This class supports GPU command buffer operations, including recording draw commands and submitting them to the GPU. It supports primary and secondary command buffers. Secondary command buffers can be recorded in parallel, using multiple threads, and can be added to a primary command buffer. Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"CommandBuffer"},{"location":"api/Classes/classCommandBuffer/#commandbuffer","text":"More... #include <CommandBuffer.h>","title":"CommandBuffer"},{"location":"api/Classes/classCommandBuffer/#detailed-description","text":"class CommandBuffer; This class supports GPU command buffer operations, including recording draw commands and submitting them to the GPU. It supports primary and secondary command buffers. Secondary command buffers can be recorded in parallel, using multiple threads, and can be added to a primary command buffer. Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Detailed Description"},{"location":"api/Classes/classDrawOp/","text":"DrawOp More... #include <DrawOp.h> Detailed Description class DrawOp; This class defines the interface for draw operations. Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"DrawOp"},{"location":"api/Classes/classDrawOp/#drawop","text":"More... #include <DrawOp.h>","title":"DrawOp"},{"location":"api/Classes/classDrawOp/#detailed-description","text":"class DrawOp; This class defines the interface for draw operations. Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Detailed Description"},{"location":"api/Classes/classFence/","text":"Fence More... #include <Fence.h> Detailed Description class Fence; This class implements a fence synchronization mechanism. The CPU waits for the fence to be signaled by the GPU when an operation is completed. Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Fence"},{"location":"api/Classes/classFence/#fence","text":"More... #include <Fence.h>","title":"Fence"},{"location":"api/Classes/classFence/#detailed-description","text":"class Fence; This class implements a fence synchronization mechanism. The CPU waits for the fence to be signaled by the GPU when an operation is completed. Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Detailed Description"},{"location":"api/Classes/classngfx_1_1Buffer/","text":"ngfx::Buffer More... #include <Buffer.h> Public Functions Name Buffer * create ( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags) template <typename T > Buffer * create ( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags) virtual ~Buffer () virtual void * map () =0 virtual void unmap () =0 virtual void upload (const void * data, uint32_t size, uint32_t offset =0) =0 virtual void download (void * data, uint32_t size, uint32_t offset =0) =0 Detailed Description class ngfx::Buffer; This class defines the interface for a graphics buffer. Each backend is responsible for implementing this interface via a subclass. The same buffer object can support multiple usage scenarios, including storing uniform data, vertex buffer data, index buffer data, etc. In addition, on shared memory architectures, it supports shared CPU/GPU access. Public Functions Documentation function create static Buffer * create( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) usageFlags The buffer usage flags Create a graphics buffer function create template <typename T > static inline Buffer * create( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags ) function ~Buffer inline virtual ~Buffer() Destroy the buffer function map virtual void * map() =0 Map the buffer contents for CPU read/write access function unmap virtual void unmap() =0 Unmap the buffer function upload virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Upload the CPU data to the GPU buffer function download virtual void download( void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Download the GPU data to CPU-accessible memory Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"ngfx::Buffer"},{"location":"api/Classes/classngfx_1_1Buffer/#ngfxbuffer","text":"More... #include <Buffer.h>","title":"ngfx::Buffer"},{"location":"api/Classes/classngfx_1_1Buffer/#public-functions","text":"Name Buffer * create ( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags) template <typename T > Buffer * create ( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags) virtual ~Buffer () virtual void * map () =0 virtual void unmap () =0 virtual void upload (const void * data, uint32_t size, uint32_t offset =0) =0 virtual void download (void * data, uint32_t size, uint32_t offset =0) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Buffer/#detailed-description","text":"class ngfx::Buffer; This class defines the interface for a graphics buffer. Each backend is responsible for implementing this interface via a subclass. The same buffer object can support multiple usage scenarios, including storing uniform data, vertex buffer data, index buffer data, etc. In addition, on shared memory architectures, it supports shared CPU/GPU access.","title":"Detailed Description"},{"location":"api/Classes/classngfx_1_1Buffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Buffer/#function-create","text":"static Buffer * create( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) usageFlags The buffer usage flags Create a graphics buffer","title":"function create"},{"location":"api/Classes/classngfx_1_1Buffer/#function-create_1","text":"template <typename T > static inline Buffer * create( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags )","title":"function create"},{"location":"api/Classes/classngfx_1_1Buffer/#function-buffer","text":"inline virtual ~Buffer() Destroy the buffer","title":"function ~Buffer"},{"location":"api/Classes/classngfx_1_1Buffer/#function-map","text":"virtual void * map() =0 Map the buffer contents for CPU read/write access","title":"function map"},{"location":"api/Classes/classngfx_1_1Buffer/#function-unmap","text":"virtual void unmap() =0 Unmap the buffer","title":"function unmap"},{"location":"api/Classes/classngfx_1_1Buffer/#function-upload","text":"virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Upload the CPU data to the GPU buffer","title":"function upload"},{"location":"api/Classes/classngfx_1_1Buffer/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Download the GPU data to CPU-accessible memory Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"function download"},{"location":"api/Classes/classngfx_1_1Camera/","text":"ngfx::Camera Inherits from InputListener Public Functions Name virtual ~Camera () void onKey (KeyCode keyCode, InputAction keyAction) override void onScroll (double xoffset, double yoffset) override void onCursorPos (double x, double y) override void onMouseButton (MouseButton button, InputAction action) override void update () Public Attributes Name float panX float panY float zoom float yaw float pitch float roll mat4 viewMat uint32_t state double x double y Public Functions Documentation function ~Camera inline virtual ~Camera() Destroy the camera function onKey void onKey( KeyCode keyCode, InputAction keyAction ) override Parameters : keyCode The key code keyAction The key action Handle key press input event function onScroll void onScroll( double xoffset, double yoffset ) override Parameters : xoffset The relative x offset yoffset The relative y offset Handle scroll input event function onCursorPos void onCursorPos( double x, double y ) override Parameters : x The relative x movement y The relative y movement Handle cursor move event function onMouseButton void onMouseButton( MouseButton button, InputAction action ) override Parameters : button The mouse button action The mouse button event Handle mouse button event function update void update() Update camera parameters This function is called once per frame Public Attributes Documentation variable panX float panX = 0.0f; The camera pan along the x axis variable panY float panY = 0.0f; The camera pan along the y axis variable zoom float zoom = 0.0f; The camera zoom variable yaw float yaw = 0.0f; The camera yaw (radians) variable pitch float pitch = 0.0f; The camera pitch (radians) variable roll float roll = 0.0f; The camera roll (radians) The camera view matrix variable viewMat mat4 viewMat; variable state uint32_t state = 0; variable x double x = -1.0; variable y double y = -1.0; Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"ngfx::Camera"},{"location":"api/Classes/classngfx_1_1Camera/#ngfxcamera","text":"Inherits from InputListener","title":"ngfx::Camera"},{"location":"api/Classes/classngfx_1_1Camera/#public-functions","text":"Name virtual ~Camera () void onKey (KeyCode keyCode, InputAction keyAction) override void onScroll (double xoffset, double yoffset) override void onCursorPos (double x, double y) override void onMouseButton (MouseButton button, InputAction action) override void update ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Camera/#public-attributes","text":"Name float panX float panY float zoom float yaw float pitch float roll mat4 viewMat uint32_t state double x double y","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Camera/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Camera/#function-camera","text":"inline virtual ~Camera() Destroy the camera","title":"function ~Camera"},{"location":"api/Classes/classngfx_1_1Camera/#function-onkey","text":"void onKey( KeyCode keyCode, InputAction keyAction ) override Parameters : keyCode The key code keyAction The key action Handle key press input event","title":"function onKey"},{"location":"api/Classes/classngfx_1_1Camera/#function-onscroll","text":"void onScroll( double xoffset, double yoffset ) override Parameters : xoffset The relative x offset yoffset The relative y offset Handle scroll input event","title":"function onScroll"},{"location":"api/Classes/classngfx_1_1Camera/#function-oncursorpos","text":"void onCursorPos( double x, double y ) override Parameters : x The relative x movement y The relative y movement Handle cursor move event","title":"function onCursorPos"},{"location":"api/Classes/classngfx_1_1Camera/#function-onmousebutton","text":"void onMouseButton( MouseButton button, InputAction action ) override Parameters : button The mouse button action The mouse button event Handle mouse button event","title":"function onMouseButton"},{"location":"api/Classes/classngfx_1_1Camera/#function-update","text":"void update() Update camera parameters This function is called once per frame","title":"function update"},{"location":"api/Classes/classngfx_1_1Camera/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Camera/#variable-panx","text":"float panX = 0.0f; The camera pan along the x axis","title":"variable panX"},{"location":"api/Classes/classngfx_1_1Camera/#variable-pany","text":"float panY = 0.0f; The camera pan along the y axis","title":"variable panY"},{"location":"api/Classes/classngfx_1_1Camera/#variable-zoom","text":"float zoom = 0.0f; The camera zoom","title":"variable zoom"},{"location":"api/Classes/classngfx_1_1Camera/#variable-yaw","text":"float yaw = 0.0f; The camera yaw (radians)","title":"variable yaw"},{"location":"api/Classes/classngfx_1_1Camera/#variable-pitch","text":"float pitch = 0.0f; The camera pitch (radians)","title":"variable pitch"},{"location":"api/Classes/classngfx_1_1Camera/#variable-roll","text":"float roll = 0.0f; The camera roll (radians) The camera view matrix","title":"variable roll"},{"location":"api/Classes/classngfx_1_1Camera/#variable-viewmat","text":"mat4 viewMat;","title":"variable viewMat"},{"location":"api/Classes/classngfx_1_1Camera/#variable-state","text":"uint32_t state = 0;","title":"variable state"},{"location":"api/Classes/classngfx_1_1Camera/#variable-x","text":"double x = -1.0;","title":"variable x"},{"location":"api/Classes/classngfx_1_1Camera/#variable-y","text":"double y = -1.0; Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"variable y"},{"location":"api/Classes/classngfx_1_1CommandBuffer/","text":"ngfx::CommandBuffer Public Functions Name CommandBuffer * create ( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY) virtual ~CommandBuffer () virtual void begin () =0 virtual void end () =0 Public Functions Documentation function create static CommandBuffer * create( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY ) Parameters : ctx The graphics context level The command buffer level Create the command buffer function ~CommandBuffer inline virtual ~CommandBuffer() Destroy the command buffer function begin virtual void begin() =0 Begin recording function end virtual void end() =0 End recording Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"ngfx::CommandBuffer"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#ngfxcommandbuffer","text":"","title":"ngfx::CommandBuffer"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#public-functions","text":"Name CommandBuffer * create ( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY) virtual ~CommandBuffer () virtual void begin () =0 virtual void end () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-create","text":"static CommandBuffer * create( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY ) Parameters : ctx The graphics context level The command buffer level Create the command buffer","title":"function create"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-commandbuffer","text":"inline virtual ~CommandBuffer() Destroy the command buffer","title":"function ~CommandBuffer"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-begin","text":"virtual void begin() =0 Begin recording","title":"function begin"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-end","text":"virtual void end() =0 End recording Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"function end"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/","text":"ngfx::ComputeShaderModule Inherits from ngfx::ShaderModule Public Functions Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename) Additional inherited members Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function create static std::unique_ptr< ComputeShaderModule > create( Device * device, const std::string & filename ) function ~ComputeShaderModule inline virtual ~ComputeShaderModule() function initBindings inline void initBindings( const std::string & filename ) Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"ngfx::ComputeShaderModule"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#ngfxcomputeshadermodule","text":"Inherits from ngfx::ShaderModule","title":"ngfx::ComputeShaderModule"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#public-functions","text":"Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#function-create","text":"static std::unique_ptr< ComputeShaderModule > create( Device * device, const std::string & filename )","title":"function create"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#function-computeshadermodule","text":"inline virtual ~ComputeShaderModule()","title":"function ~ComputeShaderModule"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#function-initbindings","text":"inline void initBindings( const std::string & filename ) Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1Device/","text":"ngfx::Device Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"ngfx::Device"},{"location":"api/Classes/classngfx_1_1Device/#ngfxdevice","text":"Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"ngfx::Device"},{"location":"api/Classes/classngfx_1_1DrawOp/","text":"ngfx::DrawOp Inherited by ngfx::FilterOp Public Functions Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0 Protected Attributes Name GraphicsContext * ctx Public Functions Documentation function DrawOp inline DrawOp( GraphicsContext * ctx ) Parameters : ctx The graphics context Create the draw operation function ~DrawOp inline virtual ~DrawOp() Destroy the draw op function draw virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) =0 Parameters : commandBuffer The command buffer graphics The graphics object Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer. Protected Attributes Documentation variable ctx GraphicsContext * ctx; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#ngfxdrawop","text":"Inherited by ngfx::FilterOp","title":"ngfx::DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#public-functions","text":"Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1DrawOp/#protected-attributes","text":"Name GraphicsContext * ctx","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1DrawOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawOp/#function-drawop","text":"inline DrawOp( GraphicsContext * ctx ) Parameters : ctx The graphics context Create the draw operation","title":"function DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#function-drawop_1","text":"inline virtual ~DrawOp() Destroy the draw op","title":"function ~DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#function-draw","text":"virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) =0 Parameters : commandBuffer The command buffer graphics The graphics object Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer.","title":"function draw"},{"location":"api/Classes/classngfx_1_1DrawOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawOp/#variable-ctx","text":"GraphicsContext * ctx; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1Fence/","text":"ngfx::Fence Public Functions Name Fence * create ( Device * device, FenceCreateFlags flags =0) virtual ~Fence () virtual void wait () =0 virtual void reset () =0 Public Functions Documentation function create static Fence * create( Device * device, FenceCreateFlags flags =0 ) Parameters : device The GPU device handle flags Additional fence create flags (optional) Create the fence object function ~Fence inline virtual ~Fence() Destroy the fence object function wait virtual void wait() =0 Wait for the fence to be signaled by the GPU function reset virtual void reset() =0 Reset the fence Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Fence"},{"location":"api/Classes/classngfx_1_1Fence/#ngfxfence","text":"","title":"ngfx::Fence"},{"location":"api/Classes/classngfx_1_1Fence/#public-functions","text":"Name Fence * create ( Device * device, FenceCreateFlags flags =0) virtual ~Fence () virtual void wait () =0 virtual void reset () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Fence/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Fence/#function-create","text":"static Fence * create( Device * device, FenceCreateFlags flags =0 ) Parameters : device The GPU device handle flags Additional fence create flags (optional) Create the fence object","title":"function create"},{"location":"api/Classes/classngfx_1_1Fence/#function-fence","text":"inline virtual ~Fence() Destroy the fence object","title":"function ~Fence"},{"location":"api/Classes/classngfx_1_1Fence/#function-wait","text":"virtual void wait() =0 Wait for the fence to be signaled by the GPU","title":"function wait"},{"location":"api/Classes/classngfx_1_1Fence/#function-reset","text":"virtual void reset() =0 Reset the fence Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"function reset"},{"location":"api/Classes/classngfx_1_1FilterOp/","text":"ngfx::FilterOp Inherits from ngfx::DrawOp Public Functions Name FilterOp ( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight) virtual ~FilterOp () void apply ( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics) Public Attributes Name std::unique_ptr< Texture > outputTexture std::unique_ptr< Framebuffer > outputFramebuffer Additional inherited members Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0 Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx Public Functions Documentation function FilterOp FilterOp( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight ) function ~FilterOp inline virtual ~FilterOp() function apply void apply( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics ) Public Attributes Documentation variable outputTexture std::unique_ptr< Texture > outputTexture; variable outputFramebuffer std::unique_ptr< Framebuffer > outputFramebuffer; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#ngfxfilterop","text":"Inherits from ngfx::DrawOp","title":"ngfx::FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-functions","text":"Name FilterOp ( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight) virtual ~FilterOp () void apply ( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-attributes","text":"Name std::unique_ptr< Texture > outputTexture std::unique_ptr< Framebuffer > outputFramebuffer","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1FilterOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0 Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1FilterOp/#function-filterop","text":"FilterOp( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight )","title":"function FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#function-filterop_1","text":"inline virtual ~FilterOp()","title":"function ~FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#function-apply","text":"void apply( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics )","title":"function apply"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1FilterOp/#variable-outputtexture","text":"std::unique_ptr< Texture > outputTexture;","title":"variable outputTexture"},{"location":"api/Classes/classngfx_1_1FilterOp/#variable-outputframebuffer","text":"std::unique_ptr< Framebuffer > outputFramebuffer; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable outputFramebuffer"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/","text":"ngfx::FragmentShaderModule Inherits from ngfx::ShaderModule Public Functions Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename) Additional inherited members Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function create static std::unique_ptr< FragmentShaderModule > create( Device * device, const std::string & filename ) function ~FragmentShaderModule inline virtual ~FragmentShaderModule() function initBindings inline void initBindings( const std::string & filename ) Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::FragmentShaderModule"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#ngfxfragmentshadermodule","text":"Inherits from ngfx::ShaderModule","title":"ngfx::FragmentShaderModule"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#public-functions","text":"Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#function-create","text":"static std::unique_ptr< FragmentShaderModule > create( Device * device, const std::string & filename )","title":"function create"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#function-fragmentshadermodule","text":"inline virtual ~FragmentShaderModule()","title":"function ~FragmentShaderModule"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#function-initbindings","text":"inline void initBindings( const std::string & filename ) Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1Framebuffer/","text":"ngfx::Framebuffer Public Classes Name struct Attachment Public Functions Name Framebuffer * create ( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1) virtual ~Framebuffer () Public Attributes Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments Public Functions Documentation function create static Framebuffer * create( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1 ) function ~Framebuffer inline virtual ~Framebuffer() Public Attributes Documentation variable w uint32_t w; variable h uint32_t h; variable layers uint32_t layers; variable numAttachments uint32_t numAttachments; variable attachments std::vector< Attachment > attachments; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Framebuffer"},{"location":"api/Classes/classngfx_1_1Framebuffer/#ngfxframebuffer","text":"","title":"ngfx::Framebuffer"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-classes","text":"Name struct Attachment","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-functions","text":"Name Framebuffer * create ( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1) virtual ~Framebuffer ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-attributes","text":"Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Framebuffer/#function-create","text":"static Framebuffer * create( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1Framebuffer/#function-framebuffer","text":"inline virtual ~Framebuffer()","title":"function ~Framebuffer"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-w","text":"uint32_t w;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-h","text":"uint32_t h;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-layers","text":"uint32_t layers;","title":"variable layers"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-numattachments","text":"uint32_t numAttachments;","title":"variable numAttachments"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-attachments","text":"std::vector< Attachment > attachments; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable attachments"},{"location":"api/Classes/classngfx_1_1Graphics/","text":"ngfx::Graphics Public Functions Name Graphics * create ( GraphicsContext * ctx) virtual ~Graphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) =0 virtual void endComputePass ( CommandBuffer * commandBuffer) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) =0 virtual void endRenderPass ( CommandBuffer * commandBuffer) =0 virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) =0 virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32) =0 virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) =0 virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) =0 virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) =0 virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) =0 virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) =0 virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) =0 virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void waitIdle ( CommandBuffer * cmdBuffer) =0 Public Attributes Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer Protected Attributes Name GraphicsContext * ctx Public Functions Documentation function create static Graphics * create( GraphicsContext * ctx ) function ~Graphics inline virtual ~Graphics() function beginComputePass virtual void beginComputePass( CommandBuffer * commandBuffer ) =0 function endComputePass virtual void endComputePass( CommandBuffer * commandBuffer ) =0 function beginRenderPass virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) =0 function endRenderPass virtual void endRenderPass( CommandBuffer * commandBuffer ) =0 function bindVertexBuffer virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) =0 function bindIndexBuffer virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32 ) =0 function bindUniformBuffer virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0 function bindStorageBuffer virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0 function bindComputePipeline virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) =0 function bindGraphicsPipeline virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) =0 function bindTexture virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) =0 function draw virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) =0 function drawIndexed virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) =0 function dispatch virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) =0 function setViewport virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) =0 function setScissor virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) =0 function waitIdle virtual void waitIdle( CommandBuffer * cmdBuffer ) =0 Public Attributes Documentation variable scissorRect Rect2D scissorRect; variable viewport Rect2D viewport; variable currentPipeline Pipeline * currentPipeline = nullptr; variable currentRenderPass RenderPass * currentRenderPass = nullptr; variable currentFramebuffer Framebuffer * currentFramebuffer = nullptr; Protected Attributes Documentation variable ctx GraphicsContext * ctx; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Graphics"},{"location":"api/Classes/classngfx_1_1Graphics/#ngfxgraphics","text":"","title":"ngfx::Graphics"},{"location":"api/Classes/classngfx_1_1Graphics/#public-functions","text":"Name Graphics * create ( GraphicsContext * ctx) virtual ~Graphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) =0 virtual void endComputePass ( CommandBuffer * commandBuffer) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) =0 virtual void endRenderPass ( CommandBuffer * commandBuffer) =0 virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) =0 virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32) =0 virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) =0 virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) =0 virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) =0 virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) =0 virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) =0 virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) =0 virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void waitIdle ( CommandBuffer * cmdBuffer) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Graphics/#public-attributes","text":"Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Graphics/#protected-attributes","text":"Name GraphicsContext * ctx","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1Graphics/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Graphics/#function-create","text":"static Graphics * create( GraphicsContext * ctx )","title":"function create"},{"location":"api/Classes/classngfx_1_1Graphics/#function-graphics","text":"inline virtual ~Graphics()","title":"function ~Graphics"},{"location":"api/Classes/classngfx_1_1Graphics/#function-begincomputepass","text":"virtual void beginComputePass( CommandBuffer * commandBuffer ) =0","title":"function beginComputePass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-endcomputepass","text":"virtual void endComputePass( CommandBuffer * commandBuffer ) =0","title":"function endComputePass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-beginrenderpass","text":"virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) =0","title":"function beginRenderPass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-endrenderpass","text":"virtual void endRenderPass( CommandBuffer * commandBuffer ) =0","title":"function endRenderPass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindvertexbuffer","text":"virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) =0","title":"function bindVertexBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindindexbuffer","text":"virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32 ) =0","title":"function bindIndexBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-binduniformbuffer","text":"virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0","title":"function bindUniformBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindstoragebuffer","text":"virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0","title":"function bindStorageBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindcomputepipeline","text":"virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) =0","title":"function bindComputePipeline"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindgraphicspipeline","text":"virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) =0","title":"function bindGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindtexture","text":"virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) =0","title":"function bindTexture"},{"location":"api/Classes/classngfx_1_1Graphics/#function-draw","text":"virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) =0","title":"function draw"},{"location":"api/Classes/classngfx_1_1Graphics/#function-drawindexed","text":"virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) =0","title":"function drawIndexed"},{"location":"api/Classes/classngfx_1_1Graphics/#function-dispatch","text":"virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) =0","title":"function dispatch"},{"location":"api/Classes/classngfx_1_1Graphics/#function-setviewport","text":"virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) =0","title":"function setViewport"},{"location":"api/Classes/classngfx_1_1Graphics/#function-setscissor","text":"virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) =0","title":"function setScissor"},{"location":"api/Classes/classngfx_1_1Graphics/#function-waitidle","text":"virtual void waitIdle( CommandBuffer * cmdBuffer ) =0","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1Graphics/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-scissorrect","text":"Rect2D scissorRect;","title":"variable scissorRect"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-viewport","text":"Rect2D viewport;","title":"variable viewport"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-currentpipeline","text":"Pipeline * currentPipeline = nullptr;","title":"variable currentPipeline"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-currentrenderpass","text":"RenderPass * currentRenderPass = nullptr;","title":"variable currentRenderPass"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-currentframebuffer","text":"Framebuffer * currentFramebuffer = nullptr;","title":"variable currentFramebuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-ctx","text":"GraphicsContext * ctx; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1GraphicsContext/","text":"ngfx::GraphicsContext Public Classes Name struct AttachmentDescription struct RenderPassConfig Public Functions Name GraphicsContext * create (const char * appName, bool enableDepthStencil =false, bool debug =true) virtual ~GraphicsContext () virtual void setSurface ( Surface * surface) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void submit ( CommandBuffer * commandBuffer) virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) =0 virtual CommandBuffer * copyCommandBuffer () =0 virtual CommandBuffer * computeCommandBuffer () =0 virtual RenderPass * getRenderPass ( RenderPassConfig config) =0 Public Attributes Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor Protected Attributes Name bool debug bool enableDepthStencil Public Functions Documentation function create static GraphicsContext * create( const char * appName, bool enableDepthStencil =false, bool debug =true ) function ~GraphicsContext inline virtual ~GraphicsContext() function setSurface virtual void setSurface( Surface * surface ) =0 function beginRenderPass inline virtual void beginRenderPass( CommandBuffer * commandBuffer, Graphics * graphics ) function beginOffscreenRenderPass inline virtual void beginOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer ) function endRenderPass inline virtual void endRenderPass( CommandBuffer * commandBuffer, Graphics * graphics ) function endOffscreenRenderPass inline virtual void endOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics ) function submit inline virtual void submit( CommandBuffer * commandBuffer ) function drawCommandBuffer virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) =0 function copyCommandBuffer virtual CommandBuffer * copyCommandBuffer() =0 function computeCommandBuffer virtual CommandBuffer * computeCommandBuffer() =0 function getRenderPass virtual RenderPass * getRenderPass( RenderPassConfig config ) =0 Public Attributes Documentation variable device Device * device; variable numDrawCommandBuffers uint32_t numDrawCommandBuffers = 0; variable swapchainFramebuffers std::vector< Framebuffer * > swapchainFramebuffers; variable queue Queue * queue = nullptr; variable defaultRenderPass RenderPass * defaultRenderPass = nullptr; variable defaultOffscreenRenderPass RenderPass * defaultOffscreenRenderPass = nullptr; variable swapchain Swapchain * swapchain = nullptr; variable surface Surface * surface = nullptr; variable currentImageIndex uint32_t currentImageIndex = 0; variable frameFences std::vector< Fence * > frameFences; variable computeFence Fence * computeFence = nullptr; variable presentCompleteSemaphore Semaphore * presentCompleteSemaphore = nullptr; variable renderCompleteSemaphore Semaphore * renderCompleteSemaphore = nullptr; variable pipelineCache PipelineCache * pipelineCache = nullptr; variable surfaceFormat PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED; variable defaultOffscreenSurfaceFormat PixelFormat defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED; variable depthFormat PixelFormat depthFormat = PIXELFORMAT_UNDEFINED; variable clearColor glm::vec4 clearColor = glm::vec4(0.0f); Protected Attributes Documentation variable debug bool debug = false; variable enableDepthStencil bool enableDepthStencil = false; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::GraphicsContext"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#ngfxgraphicscontext","text":"","title":"ngfx::GraphicsContext"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-classes","text":"Name struct AttachmentDescription struct RenderPassConfig","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-functions","text":"Name GraphicsContext * create (const char * appName, bool enableDepthStencil =false, bool debug =true) virtual ~GraphicsContext () virtual void setSurface ( Surface * surface) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void submit ( CommandBuffer * commandBuffer) virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) =0 virtual CommandBuffer * copyCommandBuffer () =0 virtual CommandBuffer * computeCommandBuffer () =0 virtual RenderPass * getRenderPass ( RenderPassConfig config) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-attributes","text":"Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#protected-attributes","text":"Name bool debug bool enableDepthStencil","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-create","text":"static GraphicsContext * create( const char * appName, bool enableDepthStencil =false, bool debug =true )","title":"function create"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-graphicscontext","text":"inline virtual ~GraphicsContext()","title":"function ~GraphicsContext"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-setsurface","text":"virtual void setSurface( Surface * surface ) =0","title":"function setSurface"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-beginrenderpass","text":"inline virtual void beginRenderPass( CommandBuffer * commandBuffer, Graphics * graphics )","title":"function beginRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-beginoffscreenrenderpass","text":"inline virtual void beginOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer )","title":"function beginOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-endrenderpass","text":"inline virtual void endRenderPass( CommandBuffer * commandBuffer, Graphics * graphics )","title":"function endRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-endoffscreenrenderpass","text":"inline virtual void endOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics )","title":"function endOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-submit","text":"inline virtual void submit( CommandBuffer * commandBuffer )","title":"function submit"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-drawcommandbuffer","text":"virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) =0","title":"function drawCommandBuffer"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-copycommandbuffer","text":"virtual CommandBuffer * copyCommandBuffer() =0","title":"function copyCommandBuffer"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-computecommandbuffer","text":"virtual CommandBuffer * computeCommandBuffer() =0","title":"function computeCommandBuffer"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-getrenderpass","text":"virtual RenderPass * getRenderPass( RenderPassConfig config ) =0","title":"function getRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-device","text":"Device * device;","title":"variable device"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-numdrawcommandbuffers","text":"uint32_t numDrawCommandBuffers = 0;","title":"variable numDrawCommandBuffers"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-swapchainframebuffers","text":"std::vector< Framebuffer * > swapchainFramebuffers;","title":"variable swapchainFramebuffers"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-queue","text":"Queue * queue = nullptr;","title":"variable queue"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-defaultrenderpass","text":"RenderPass * defaultRenderPass = nullptr;","title":"variable defaultRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-defaultoffscreenrenderpass","text":"RenderPass * defaultOffscreenRenderPass = nullptr;","title":"variable defaultOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-swapchain","text":"Swapchain * swapchain = nullptr;","title":"variable swapchain"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-surface","text":"Surface * surface = nullptr;","title":"variable surface"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-currentimageindex","text":"uint32_t currentImageIndex = 0;","title":"variable currentImageIndex"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-framefences","text":"std::vector< Fence * > frameFences;","title":"variable frameFences"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-computefence","text":"Fence * computeFence = nullptr;","title":"variable computeFence"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-presentcompletesemaphore","text":"Semaphore * presentCompleteSemaphore = nullptr;","title":"variable presentCompleteSemaphore"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-rendercompletesemaphore","text":"Semaphore * renderCompleteSemaphore = nullptr;","title":"variable renderCompleteSemaphore"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-pipelinecache","text":"PipelineCache * pipelineCache = nullptr;","title":"variable pipelineCache"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-surfaceformat","text":"PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED;","title":"variable surfaceFormat"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-defaultoffscreensurfaceformat","text":"PixelFormat defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED;","title":"variable defaultOffscreenSurfaceFormat"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-depthformat","text":"PixelFormat depthFormat = PIXELFORMAT_UNDEFINED;","title":"variable depthFormat"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-clearcolor","text":"glm::vec4 clearColor = glm::vec4(0.0f);","title":"variable clearColor"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-debug","text":"bool debug = false;","title":"variable debug"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-enabledepthstencil","text":"bool enableDepthStencil = false; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable enableDepthStencil"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/","text":"ngfx::GraphicsPipeline Inherits from ngfx::Pipeline Public Classes Name struct Descriptor struct State Public Functions Name GraphicsPipeline * create ( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={}) virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings) Public Attributes Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings Additional inherited members Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create static GraphicsPipeline * create( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={} ) function ~GraphicsPipeline inline virtual ~GraphicsPipeline() function getBindings void getBindings( std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings ) Public Attributes Documentation variable descriptorBindings std::vector< uint32_t > descriptorBindings; variable vertexAttributeBindings std::vector< uint32_t > vertexAttributeBindings; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::GraphicsPipeline"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#ngfxgraphicspipeline","text":"Inherits from ngfx::Pipeline","title":"ngfx::GraphicsPipeline"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-classes","text":"Name struct Descriptor struct State","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-functions","text":"Name GraphicsPipeline * create ( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={}) virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-attributes","text":"Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#additional-inherited-members","text":"Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#function-create","text":"static GraphicsPipeline * create( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={} )","title":"function create"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#function-graphicspipeline","text":"inline virtual ~GraphicsPipeline()","title":"function ~GraphicsPipeline"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#function-getbindings","text":"void getBindings( std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings )","title":"function getBindings"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#variable-descriptorbindings","text":"std::vector< uint32_t > descriptorBindings;","title":"variable descriptorBindings"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#variable-vertexattributebindings","text":"std::vector< uint32_t > vertexAttributeBindings; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable vertexAttributeBindings"},{"location":"api/Classes/classngfx_1_1Pipeline/","text":"ngfx::Pipeline Inherited by ngfx::GraphicsPipeline Public Functions Name virtual ~Pipeline () Public Functions Documentation function ~Pipeline inline virtual ~Pipeline() Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Pipeline"},{"location":"api/Classes/classngfx_1_1Pipeline/#ngfxpipeline","text":"Inherited by ngfx::GraphicsPipeline","title":"ngfx::Pipeline"},{"location":"api/Classes/classngfx_1_1Pipeline/#public-functions","text":"Name virtual ~Pipeline ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Pipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Pipeline/#function-pipeline","text":"inline virtual ~Pipeline() Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"function ~Pipeline"},{"location":"api/Classes/classngfx_1_1PipelineCache/","text":"ngfx::PipelineCache Public Functions Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value) Public Functions Documentation function ~PipelineCache inline virtual ~PipelineCache() function get virtual Pipeline * get( const std::string & key ) function add virtual void add( const std::string & key, Pipeline * value ) Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::PipelineCache"},{"location":"api/Classes/classngfx_1_1PipelineCache/#ngfxpipelinecache","text":"","title":"ngfx::PipelineCache"},{"location":"api/Classes/classngfx_1_1PipelineCache/#public-functions","text":"Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1PipelineCache/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1PipelineCache/#function-pipelinecache","text":"inline virtual ~PipelineCache()","title":"function ~PipelineCache"},{"location":"api/Classes/classngfx_1_1PipelineCache/#function-get","text":"virtual Pipeline * get( const std::string & key )","title":"function get"},{"location":"api/Classes/classngfx_1_1PipelineCache/#function-add","text":"virtual void add( const std::string & key, Pipeline * value ) Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"function add"},{"location":"api/Classes/classngfx_1_1Queue/","text":"ngfx::Queue Public Functions Name virtual ~Queue () virtual void present () =0 virtual void submit ( CommandBuffer * commandBuffer) =0 virtual void waitIdle () =0 Public Functions Documentation function ~Queue inline virtual ~Queue() function present virtual void present() =0 function submit virtual void submit( CommandBuffer * commandBuffer ) =0 function waitIdle virtual void waitIdle() =0 Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Queue"},{"location":"api/Classes/classngfx_1_1Queue/#ngfxqueue","text":"","title":"ngfx::Queue"},{"location":"api/Classes/classngfx_1_1Queue/#public-functions","text":"Name virtual ~Queue () virtual void present () =0 virtual void submit ( CommandBuffer * commandBuffer) =0 virtual void waitIdle () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Queue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Queue/#function-queue","text":"inline virtual ~Queue()","title":"function ~Queue"},{"location":"api/Classes/classngfx_1_1Queue/#function-present","text":"virtual void present() =0","title":"function present"},{"location":"api/Classes/classngfx_1_1Queue/#function-submit","text":"virtual void submit( CommandBuffer * commandBuffer ) =0","title":"function submit"},{"location":"api/Classes/classngfx_1_1Queue/#function-waitidle","text":"virtual void waitIdle() =0 Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1RenderPass/","text":"ngfx::RenderPass Public Functions Name virtual ~RenderPass () Public Attributes Name Framebuffer * currentFramebuffer Public Functions Documentation function ~RenderPass inline virtual ~RenderPass() Public Attributes Documentation variable currentFramebuffer Framebuffer * currentFramebuffer = nullptr; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::RenderPass"},{"location":"api/Classes/classngfx_1_1RenderPass/#ngfxrenderpass","text":"","title":"ngfx::RenderPass"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-functions","text":"Name virtual ~RenderPass ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-attributes","text":"Name Framebuffer * currentFramebuffer","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1RenderPass/#function-renderpass","text":"inline virtual ~RenderPass()","title":"function ~RenderPass"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1RenderPass/#variable-currentframebuffer","text":"Framebuffer * currentFramebuffer = nullptr; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable currentFramebuffer"},{"location":"api/Classes/classngfx_1_1Semaphore/","text":"ngfx::Semaphore Public Functions Name Semaphore * create ( Device * device) virtual ~Semaphore () virtual uint64_t wait () =0 virtual void signal (uint64_t value =1) =0 Public Functions Documentation function create static Semaphore * create( Device * device ) function ~Semaphore inline virtual ~Semaphore() function wait virtual uint64_t wait() =0 function signal virtual void signal( uint64_t value =1 ) =0 Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Semaphore"},{"location":"api/Classes/classngfx_1_1Semaphore/#ngfxsemaphore","text":"","title":"ngfx::Semaphore"},{"location":"api/Classes/classngfx_1_1Semaphore/#public-functions","text":"Name Semaphore * create ( Device * device) virtual ~Semaphore () virtual uint64_t wait () =0 virtual void signal (uint64_t value =1) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Semaphore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-create","text":"static Semaphore * create( Device * device )","title":"function create"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-semaphore","text":"inline virtual ~Semaphore()","title":"function ~Semaphore"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-wait","text":"virtual uint64_t wait() =0","title":"function wait"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-signal","text":"virtual void signal( uint64_t value =1 ) =0 Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"function signal"},{"location":"api/Classes/classngfx_1_1ShaderModule/","text":"ngfx::ShaderModule Inherited by ngfx::ComputeShaderModule , ngfx::FragmentShaderModule , ngfx::VertexShaderModule Public Classes Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Types Documentation typedef DescriptorInfos typedef std::vector<DescriptorInfo> ngfx::ShaderModule::DescriptorInfos; typedef BufferMemberInfos typedef std::map<std::string, BufferMemberInfo> ngfx::ShaderModule::BufferMemberInfos; typedef BufferInfos typedef std::map<std::string, BufferInfo> ngfx::ShaderModule::BufferInfos; Public Functions Documentation function ~ShaderModule inline virtual ~ShaderModule() function findDescriptorInfo inline DescriptorInfo * findDescriptorInfo( const std::string & name ) function findUniformBufferInfo inline BufferInfo * findUniformBufferInfo( const std::string & name ) function findStorageBufferInfo inline BufferInfo * findStorageBufferInfo( const std::string & name ) function initBindings void initBindings( std::ifstream & in, ShaderStageFlags shaderStages ) function initBindings void initBindings( const std::string & filename, ShaderStageFlags shaderStages ) Public Attributes Documentation variable descriptors DescriptorInfos descriptors; variable uniformBufferInfos BufferInfos uniformBufferInfos; variable shaderStorageBufferInfos BufferInfos shaderStorageBufferInfos; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::ShaderModule"},{"location":"api/Classes/classngfx_1_1ShaderModule/#ngfxshadermodule","text":"Inherited by ngfx::ComputeShaderModule , ngfx::FragmentShaderModule , ngfx::VertexShaderModule","title":"ngfx::ShaderModule"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-classes","text":"Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-types","text":"Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos","title":"Public Types"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-functions","text":"Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-attributes","text":"Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1ShaderModule/#typedef-descriptorinfos","text":"typedef std::vector<DescriptorInfo> ngfx::ShaderModule::DescriptorInfos;","title":"typedef DescriptorInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#typedef-buffermemberinfos","text":"typedef std::map<std::string, BufferMemberInfo> ngfx::ShaderModule::BufferMemberInfos;","title":"typedef BufferMemberInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#typedef-bufferinfos","text":"typedef std::map<std::string, BufferInfo> ngfx::ShaderModule::BufferInfos;","title":"typedef BufferInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-shadermodule","text":"inline virtual ~ShaderModule()","title":"function ~ShaderModule"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-finddescriptorinfo","text":"inline DescriptorInfo * findDescriptorInfo( const std::string & name )","title":"function findDescriptorInfo"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-finduniformbufferinfo","text":"inline BufferInfo * findUniformBufferInfo( const std::string & name )","title":"function findUniformBufferInfo"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-findstoragebufferinfo","text":"inline BufferInfo * findStorageBufferInfo( const std::string & name )","title":"function findStorageBufferInfo"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-initbindings","text":"void initBindings( std::ifstream & in, ShaderStageFlags shaderStages )","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-initbindings_1","text":"void initBindings( const std::string & filename, ShaderStageFlags shaderStages )","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1ShaderModule/#variable-descriptors","text":"DescriptorInfos descriptors;","title":"variable descriptors"},{"location":"api/Classes/classngfx_1_1ShaderModule/#variable-uniformbufferinfos","text":"BufferInfos uniformBufferInfos;","title":"variable uniformBufferInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#variable-shaderstoragebufferinfos","text":"BufferInfos shaderStorageBufferInfos; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable shaderStorageBufferInfos"},{"location":"api/Classes/classngfx_1_1ShaderTools/","text":"ngfx::ShaderTools Public Classes Name struct MacroDefinition Public Types Name enum @1 { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2} enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL} typedef std::vector< MacroDefinition > MacroDefinitions Public Functions Name ShaderTools (bool verbose =false) std::vector< std::string > compileShaders (const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0) std::vector< std::string > convertShaders (const std::vector< std::string > & files, std::string outDir, Format fmt) std::vector< std::string > generateShaderMaps (const std::vector< std::string > & files, std::string outDir, Format fmt) Public Types Documentation enum @1 Enumerator Value Description PATCH_SHADER_LAYOUTS_GLSL 1 REMOVE_UNUSED_VARIABLES 2 enum Format Enumerator Value Description FORMAT_GLSL FORMAT_HLSL FORMAT_MSL typedef MacroDefinitions typedef std::vector<MacroDefinition> ngfx::ShaderTools::MacroDefinitions; Public Functions Documentation function ShaderTools ShaderTools( bool verbose =false ) function compileShaders std::vector< std::string > compileShaders( const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0 ) function convertShaders std::vector< std::string > convertShaders( const std::vector< std::string > & files, std::string outDir, Format fmt ) function generateShaderMaps std::vector< std::string > generateShaderMaps( const std::vector< std::string > & files, std::string outDir, Format fmt ) Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::ShaderTools"},{"location":"api/Classes/classngfx_1_1ShaderTools/#ngfxshadertools","text":"","title":"ngfx::ShaderTools"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-classes","text":"Name struct MacroDefinition","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-types","text":"Name enum @1 { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2} enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL} typedef std::vector< MacroDefinition > MacroDefinitions","title":"Public Types"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-functions","text":"Name ShaderTools (bool verbose =false) std::vector< std::string > compileShaders (const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0) std::vector< std::string > convertShaders (const std::vector< std::string > & files, std::string outDir, Format fmt) std::vector< std::string > generateShaderMaps (const std::vector< std::string > & files, std::string outDir, Format fmt)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1ShaderTools/#enum-1","text":"Enumerator Value Description PATCH_SHADER_LAYOUTS_GLSL 1 REMOVE_UNUSED_VARIABLES 2","title":"enum @1"},{"location":"api/Classes/classngfx_1_1ShaderTools/#enum-format","text":"Enumerator Value Description FORMAT_GLSL FORMAT_HLSL FORMAT_MSL","title":"enum Format"},{"location":"api/Classes/classngfx_1_1ShaderTools/#typedef-macrodefinitions","text":"typedef std::vector<MacroDefinition> ngfx::ShaderTools::MacroDefinitions;","title":"typedef MacroDefinitions"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-shadertools","text":"ShaderTools( bool verbose =false )","title":"function ShaderTools"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-compileshaders","text":"std::vector< std::string > compileShaders( const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0 )","title":"function compileShaders"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-convertshaders","text":"std::vector< std::string > convertShaders( const std::vector< std::string > & files, std::string outDir, Format fmt )","title":"function convertShaders"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-generateshadermaps","text":"std::vector< std::string > generateShaderMaps( const std::vector< std::string > & files, std::string outDir, Format fmt ) Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"function generateShaderMaps"},{"location":"api/Classes/classngfx_1_1Surface/","text":"ngfx::Surface Public Functions Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface () Public Attributes Name uint32_t w uint32_t h bool offscreen Public Functions Documentation function Surface inline Surface() function Surface inline Surface( uint32_t w, uint32_t h, bool offscreen =false ) function ~Surface inline virtual ~Surface() Public Attributes Documentation variable w uint32_t w = 0; variable h uint32_t h = 0; variable offscreen bool offscreen = false; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Surface"},{"location":"api/Classes/classngfx_1_1Surface/#ngfxsurface","text":"","title":"ngfx::Surface"},{"location":"api/Classes/classngfx_1_1Surface/#public-functions","text":"Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Surface/#public-attributes","text":"Name uint32_t w uint32_t h bool offscreen","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Surface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Surface/#function-surface","text":"inline Surface()","title":"function Surface"},{"location":"api/Classes/classngfx_1_1Surface/#function-surface_1","text":"inline Surface( uint32_t w, uint32_t h, bool offscreen =false )","title":"function Surface"},{"location":"api/Classes/classngfx_1_1Surface/#function-surface_2","text":"inline virtual ~Surface()","title":"function ~Surface"},{"location":"api/Classes/classngfx_1_1Surface/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Surface/#variable-w","text":"uint32_t w = 0;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Surface/#variable-h","text":"uint32_t h = 0;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Surface/#variable-offscreen","text":"bool offscreen = false; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable offscreen"},{"location":"api/Classes/classngfx_1_1Swapchain/","text":"ngfx::Swapchain Public Functions Name virtual ~Swapchain () virtual void acquireNextImage () =0 Public Attributes Name uint32_t numImages Public Functions Documentation function ~Swapchain inline virtual ~Swapchain() function acquireNextImage virtual void acquireNextImage() =0 Public Attributes Documentation variable numImages uint32_t numImages; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Swapchain"},{"location":"api/Classes/classngfx_1_1Swapchain/#ngfxswapchain","text":"","title":"ngfx::Swapchain"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-functions","text":"Name virtual ~Swapchain () virtual void acquireNextImage () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-attributes","text":"Name uint32_t numImages","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Swapchain/#function-swapchain","text":"inline virtual ~Swapchain()","title":"function ~Swapchain"},{"location":"api/Classes/classngfx_1_1Swapchain/#function-acquirenextimage","text":"virtual void acquireNextImage() =0","title":"function acquireNextImage"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Swapchain/#variable-numimages","text":"uint32_t numImages; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable numImages"},{"location":"api/Classes/classngfx_1_1Texture/","text":"ngfx::Texture Public Functions Name Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT virtual ~Texture () virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) =0 virtual void generateMipmaps ( CommandBuffer * commandBuffer) =0 Public Attributes Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType Public Functions Documentation function create static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 ) function create static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 ) function ~Texture inline virtual ~Texture() function upload virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0 function download virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0 function changeLayout virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) =0 function generateMipmaps virtual void generateMipmaps( CommandBuffer * commandBuffer ) =0 Public Attributes Documentation variable format PixelFormat format; variable w uint32_t w = 0; variable h uint32_t h = 0; variable d uint32_t d = 1; variable arrayLayers uint32_t arrayLayers = 1; variable mipLevels uint32_t mipLevels = 1; variable numSamples uint32_t numSamples = 1; variable imageUsageFlags ImageUsageFlags imageUsageFlags; variable textureType TextureType textureType; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Texture"},{"location":"api/Classes/classngfx_1_1Texture/#ngfxtexture","text":"","title":"ngfx::Texture"},{"location":"api/Classes/classngfx_1_1Texture/#public-functions","text":"Name Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT virtual ~Texture () virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) =0 virtual void generateMipmaps ( CommandBuffer * commandBuffer) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Texture/#public-attributes","text":"Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Texture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Texture/#function-create","text":"static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1Texture/#function-create_1","text":"static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1Texture/#function-texture","text":"inline virtual ~Texture()","title":"function ~Texture"},{"location":"api/Classes/classngfx_1_1Texture/#function-upload","text":"virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0","title":"function upload"},{"location":"api/Classes/classngfx_1_1Texture/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0","title":"function download"},{"location":"api/Classes/classngfx_1_1Texture/#function-changelayout","text":"virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) =0","title":"function changeLayout"},{"location":"api/Classes/classngfx_1_1Texture/#function-generatemipmaps","text":"virtual void generateMipmaps( CommandBuffer * commandBuffer ) =0","title":"function generateMipmaps"},{"location":"api/Classes/classngfx_1_1Texture/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Texture/#variable-format","text":"PixelFormat format;","title":"variable format"},{"location":"api/Classes/classngfx_1_1Texture/#variable-w","text":"uint32_t w = 0;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Texture/#variable-h","text":"uint32_t h = 0;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Texture/#variable-d","text":"uint32_t d = 1;","title":"variable d"},{"location":"api/Classes/classngfx_1_1Texture/#variable-arraylayers","text":"uint32_t arrayLayers = 1;","title":"variable arrayLayers"},{"location":"api/Classes/classngfx_1_1Texture/#variable-miplevels","text":"uint32_t mipLevels = 1;","title":"variable mipLevels"},{"location":"api/Classes/classngfx_1_1Texture/#variable-numsamples","text":"uint32_t numSamples = 1;","title":"variable numSamples"},{"location":"api/Classes/classngfx_1_1Texture/#variable-imageusageflags","text":"ImageUsageFlags imageUsageFlags;","title":"variable imageUsageFlags"},{"location":"api/Classes/classngfx_1_1Texture/#variable-texturetype","text":"TextureType textureType; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable textureType"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/","text":"ngfx::VertexShaderModule Inherits from ngfx::ShaderModule Public Classes Name struct AttributeDescription Public Functions Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename) Public Attributes Name std::vector< AttributeDescription > attributes Additional inherited members Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function create static std::unique_ptr< VertexShaderModule > create( Device * device, const std::string & filename ) function ~VertexShaderModule inline virtual ~VertexShaderModule() function findAttribute inline AttributeDescription * findAttribute( const std::string & name ) function initBindings void initBindings( const std::string & filename ) Public Attributes Documentation variable attributes std::vector< AttributeDescription > attributes; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::VertexShaderModule"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#ngfxvertexshadermodule","text":"Inherits from ngfx::ShaderModule","title":"ngfx::VertexShaderModule"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-classes","text":"Name struct AttributeDescription","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-functions","text":"Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-attributes","text":"Name std::vector< AttributeDescription > attributes","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-create","text":"static std::unique_ptr< VertexShaderModule > create( Device * device, const std::string & filename )","title":"function create"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-vertexshadermodule","text":"inline virtual ~VertexShaderModule()","title":"function ~VertexShaderModule"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-findattribute","text":"inline AttributeDescription * findAttribute( const std::string & name )","title":"function findAttribute"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-initbindings","text":"void initBindings( const std::string & filename )","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#variable-attributes","text":"std::vector< AttributeDescription > attributes; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable attributes"},{"location":"api/Classes/classngfx_1_1Window/","text":"ngfx::Window Public Types Name enum @2 { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1} Public Functions Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () virtual bool shouldClose () =0 virtual void pollEvents () =0 Public Attributes Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton Public Types Documentation enum @2 Enumerator Value Description DISPLAY_WIDTH -1 DISPLAY_HEIGHT -1 Public Functions Documentation function create static Window * create( GraphicsContext * graphicsContext, const char * title, std::function< void(Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT ) function ~Window inline virtual ~Window() function shouldClose virtual bool shouldClose() =0 function pollEvents virtual void pollEvents() =0 Public Attributes Documentation variable w int w; variable h int h; variable surface Surface * surface = nullptr; variable onUpdate std::function< void()> onUpdate = nullptr; variable onPaint std::function< void()> onPaint = nullptr; variable onKey std::function< void(KeyCode code, InputAction action)> onKey = nullptr; variable onScroll std::function< void(double xoffset, double yoffset)> onScroll = nullptr; variable onCursorPos std::function< void(double x, double y)> onCursorPos = nullptr; variable onMouseButton std::function< void(MouseButton button, InputAction action)> onMouseButton = nullptr; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Window"},{"location":"api/Classes/classngfx_1_1Window/#ngfxwindow","text":"","title":"ngfx::Window"},{"location":"api/Classes/classngfx_1_1Window/#public-types","text":"Name enum @2 { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1}","title":"Public Types"},{"location":"api/Classes/classngfx_1_1Window/#public-functions","text":"Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () virtual bool shouldClose () =0 virtual void pollEvents () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Window/#public-attributes","text":"Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Window/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1Window/#enum-2","text":"Enumerator Value Description DISPLAY_WIDTH -1 DISPLAY_HEIGHT -1","title":"enum @2"},{"location":"api/Classes/classngfx_1_1Window/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Window/#function-create","text":"static Window * create( GraphicsContext * graphicsContext, const char * title, std::function< void(Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT )","title":"function create"},{"location":"api/Classes/classngfx_1_1Window/#function-window","text":"inline virtual ~Window()","title":"function ~Window"},{"location":"api/Classes/classngfx_1_1Window/#function-shouldclose","text":"virtual bool shouldClose() =0","title":"function shouldClose"},{"location":"api/Classes/classngfx_1_1Window/#function-pollevents","text":"virtual void pollEvents() =0","title":"function pollEvents"},{"location":"api/Classes/classngfx_1_1Window/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Window/#variable-w","text":"int w;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Window/#variable-h","text":"int h;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Window/#variable-surface","text":"Surface * surface = nullptr;","title":"variable surface"},{"location":"api/Classes/classngfx_1_1Window/#variable-onupdate","text":"std::function< void()> onUpdate = nullptr;","title":"variable onUpdate"},{"location":"api/Classes/classngfx_1_1Window/#variable-onpaint","text":"std::function< void()> onPaint = nullptr;","title":"variable onPaint"},{"location":"api/Classes/classngfx_1_1Window/#variable-onkey","text":"std::function< void(KeyCode code, InputAction action)> onKey = nullptr;","title":"variable onKey"},{"location":"api/Classes/classngfx_1_1Window/#variable-onscroll","text":"std::function< void(double xoffset, double yoffset)> onScroll = nullptr;","title":"variable onScroll"},{"location":"api/Classes/classngfx_1_1Window/#variable-oncursorpos","text":"std::function< void(double x, double y)> onCursorPos = nullptr;","title":"variable onCursorPos"},{"location":"api/Classes/classngfx_1_1Window/#variable-onmousebutton","text":"std::function< void(MouseButton button, InputAction action)> onMouseButton = nullptr; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable onMouseButton"},{"location":"api/Classes/structVertexFormatInfo/","text":"VertexFormatInfo Public Attributes Name VertexFormat format uint32_t count uint32_t elementSize Public Attributes Documentation variable format VertexFormat format; variable count uint32_t count; variable elementSize uint32_t elementSize; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"VertexFormatInfo"},{"location":"api/Classes/structVertexFormatInfo/#vertexformatinfo","text":"","title":"VertexFormatInfo"},{"location":"api/Classes/structVertexFormatInfo/#public-attributes","text":"Name VertexFormat format uint32_t count uint32_t elementSize","title":"Public Attributes"},{"location":"api/Classes/structVertexFormatInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structVertexFormatInfo/#variable-format","text":"VertexFormat format;","title":"variable format"},{"location":"api/Classes/structVertexFormatInfo/#variable-count","text":"uint32_t count;","title":"variable count"},{"location":"api/Classes/structVertexFormatInfo/#variable-elementsize","text":"uint32_t elementSize; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable elementSize"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/","text":"ngfx::Framebuffer::Attachment Public Attributes Name Texture * texture uint32_t level uint32_t layer Public Attributes Documentation variable texture Texture * texture = nullptr; variable level uint32_t level = 0; variable layer uint32_t layer = 0; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Framebuffer::Attachment"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#ngfxframebufferattachment","text":"","title":"ngfx::Framebuffer::Attachment"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#public-attributes","text":"Name Texture * texture uint32_t level uint32_t layer","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#variable-texture","text":"Texture * texture = nullptr;","title":"variable texture"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#variable-level","text":"uint32_t level = 0;","title":"variable level"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#variable-layer","text":"uint32_t layer = 0; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable layer"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/","text":"ngfx::GraphicsContext::AttachmentDescription Public Functions Name bool operator== (const AttachmentDescription & rhs) const Public Attributes Name PixelFormat format std::optional< ImageLayout > initialLayout std::optional< ImageLayout > finalLayout Public Functions Documentation function operator== inline bool operator==( const AttachmentDescription & rhs ) const Public Attributes Documentation variable format PixelFormat format; variable initialLayout std::optional< ImageLayout > initialLayout; variable finalLayout std::optional< ImageLayout > finalLayout; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::GraphicsContext::AttachmentDescription"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#ngfxgraphicscontextattachmentdescription","text":"","title":"ngfx::GraphicsContext::AttachmentDescription"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-functions","text":"Name bool operator== (const AttachmentDescription & rhs) const","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-attributes","text":"Name PixelFormat format std::optional< ImageLayout > initialLayout std::optional< ImageLayout > finalLayout","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#function-operator","text":"inline bool operator==( const AttachmentDescription & rhs ) const","title":"function operator=="},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#variable-format","text":"PixelFormat format;","title":"variable format"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#variable-initiallayout","text":"std::optional< ImageLayout > initialLayout;","title":"variable initialLayout"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#variable-finallayout","text":"std::optional< ImageLayout > finalLayout; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable finalLayout"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/","text":"ngfx::GraphicsContext::RenderPassConfig Public Functions Name bool operator== (const RenderPassConfig & rhs) const uint32_t numColorAttachments () const Public Attributes Name std::vector< AttachmentDescription > colorAttachmentDescriptions std::optional< AttachmentDescription > depthStencilAttachmentDescription bool enableDepthStencilResolve uint32_t numSamples Public Functions Documentation function operator== inline bool operator==( const RenderPassConfig & rhs ) const function numColorAttachments inline uint32_t numColorAttachments() const Public Attributes Documentation variable colorAttachmentDescriptions std::vector< AttachmentDescription > colorAttachmentDescriptions; variable depthStencilAttachmentDescription std::optional< AttachmentDescription > depthStencilAttachmentDescription; variable enableDepthStencilResolve bool enableDepthStencilResolve = false; variable numSamples uint32_t numSamples = 1; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::GraphicsContext::RenderPassConfig"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#ngfxgraphicscontextrenderpassconfig","text":"","title":"ngfx::GraphicsContext::RenderPassConfig"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-functions","text":"Name bool operator== (const RenderPassConfig & rhs) const uint32_t numColorAttachments () const","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-attributes","text":"Name std::vector< AttachmentDescription > colorAttachmentDescriptions std::optional< AttachmentDescription > depthStencilAttachmentDescription bool enableDepthStencilResolve uint32_t numSamples","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#function-operator","text":"inline bool operator==( const RenderPassConfig & rhs ) const","title":"function operator=="},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#function-numcolorattachments","text":"inline uint32_t numColorAttachments() const","title":"function numColorAttachments"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-colorattachmentdescriptions","text":"std::vector< AttachmentDescription > colorAttachmentDescriptions;","title":"variable colorAttachmentDescriptions"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-depthstencilattachmentdescription","text":"std::optional< AttachmentDescription > depthStencilAttachmentDescription;","title":"variable depthStencilAttachmentDescription"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-enabledepthstencilresolve","text":"bool enableDepthStencilResolve = false;","title":"variable enableDepthStencilResolve"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-numsamples","text":"uint32_t numSamples = 1; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable numSamples"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/","text":"ngfx::GraphicsPipeline::Descriptor Public Attributes Name DescriptorType type ShaderStageFlags stageFlags Public Attributes Documentation variable type DescriptorType type; variable stageFlags ShaderStageFlags stageFlags = SHADER_STAGE_ALL; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::GraphicsPipeline::Descriptor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#ngfxgraphicspipelinedescriptor","text":"","title":"ngfx::GraphicsPipeline::Descriptor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#public-attributes","text":"Name DescriptorType type ShaderStageFlags stageFlags","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#variable-type","text":"DescriptorType type;","title":"variable type"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#variable-stageflags","text":"ShaderStageFlags stageFlags = SHADER_STAGE_ALL; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable stageFlags"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/","text":"ngfx::GraphicsPipeline::State Public Attributes Name PrimitiveTopology primitiveTopology PolygonMode polygonMode bool blendEnable BlendFactor srcColorBlendFactor BlendFactor dstColorBlendFactor BlendFactor srcAlphaBlendFactor BlendFactor dstAlphaBlendFactor BlendOp colorBlendOp BlendOp alphaBlendOp uint8_t colorWriteMask CullModeFlags cullModeFlags FrontFace frontFace float lineWidth bool depthTestEnable bool depthWriteEnable RenderPass * renderPass uint32_t numSamples uint32_t numColorAttachments Public Attributes Documentation variable primitiveTopology PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; variable polygonMode PolygonMode polygonMode = POLYGON_MODE_FILL; variable blendEnable bool blendEnable = false; variable srcColorBlendFactor BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA; variable dstColorBlendFactor BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; variable srcAlphaBlendFactor BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA; variable dstAlphaBlendFactor BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; variable colorBlendOp BlendOp colorBlendOp = BLEND_OP_ADD; variable alphaBlendOp BlendOp alphaBlendOp = BLEND_OP_ADD; variable colorWriteMask uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT; variable cullModeFlags CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT; variable frontFace FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE; variable lineWidth float lineWidth = 1.0f; variable depthTestEnable bool depthTestEnable = false; variable depthWriteEnable bool depthWriteEnable = false; variable renderPass RenderPass * renderPass = nullptr; variable numSamples uint32_t numSamples = 1; variable numColorAttachments uint32_t numColorAttachments = 1; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::GraphicsPipeline::State"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#ngfxgraphicspipelinestate","text":"","title":"ngfx::GraphicsPipeline::State"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#public-attributes","text":"Name PrimitiveTopology primitiveTopology PolygonMode polygonMode bool blendEnable BlendFactor srcColorBlendFactor BlendFactor dstColorBlendFactor BlendFactor srcAlphaBlendFactor BlendFactor dstAlphaBlendFactor BlendOp colorBlendOp BlendOp alphaBlendOp uint8_t colorWriteMask CullModeFlags cullModeFlags FrontFace frontFace float lineWidth bool depthTestEnable bool depthWriteEnable RenderPass * renderPass uint32_t numSamples uint32_t numColorAttachments","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-primitivetopology","text":"PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;","title":"variable primitiveTopology"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-polygonmode","text":"PolygonMode polygonMode = POLYGON_MODE_FILL;","title":"variable polygonMode"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-blendenable","text":"bool blendEnable = false;","title":"variable blendEnable"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-srccolorblendfactor","text":"BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA;","title":"variable srcColorBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-dstcolorblendfactor","text":"BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;","title":"variable dstColorBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-srcalphablendfactor","text":"BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA;","title":"variable srcAlphaBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-dstalphablendfactor","text":"BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;","title":"variable dstAlphaBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-colorblendop","text":"BlendOp colorBlendOp = BLEND_OP_ADD;","title":"variable colorBlendOp"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-alphablendop","text":"BlendOp alphaBlendOp = BLEND_OP_ADD;","title":"variable alphaBlendOp"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-colorwritemask","text":"uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT;","title":"variable colorWriteMask"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-cullmodeflags","text":"CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT;","title":"variable cullModeFlags"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-frontface","text":"FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE;","title":"variable frontFace"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-linewidth","text":"float lineWidth = 1.0f;","title":"variable lineWidth"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-depthtestenable","text":"bool depthTestEnable = false;","title":"variable depthTestEnable"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-depthwriteenable","text":"bool depthWriteEnable = false;","title":"variable depthWriteEnable"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-renderpass","text":"RenderPass * renderPass = nullptr;","title":"variable renderPass"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-numsamples","text":"uint32_t numSamples = 1;","title":"variable numSamples"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-numcolorattachments","text":"uint32_t numColorAttachments = 1; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable numColorAttachments"},{"location":"api/Classes/structngfx_1_1MeshData/","text":"ngfx::MeshData Public Attributes Name std::vector< vec3 > pos std::vector< vec3 > normal std::vector< ivec3 > faces vec3 bounds Public Attributes Documentation variable pos std::vector< vec3 > pos; variable normal std::vector< vec3 > normal; variable faces std::vector< ivec3 > faces; variable bounds vec3 bounds = {vec3(FLT_MAX), vec3(FLT_MIN)}; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::MeshData"},{"location":"api/Classes/structngfx_1_1MeshData/#ngfxmeshdata","text":"","title":"ngfx::MeshData"},{"location":"api/Classes/structngfx_1_1MeshData/#public-attributes","text":"Name std::vector< vec3 > pos std::vector< vec3 > normal std::vector< ivec3 > faces vec3 bounds","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1MeshData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-pos","text":"std::vector< vec3 > pos;","title":"variable pos"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-normal","text":"std::vector< vec3 > normal;","title":"variable normal"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-faces","text":"std::vector< ivec3 > faces;","title":"variable faces"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-bounds","text":"vec3 bounds = {vec3(FLT_MAX), vec3(FLT_MIN)}; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable bounds"},{"location":"api/Classes/structngfx_1_1MeshUtil/","text":"ngfx::MeshUtil Public Functions Name void importMesh (const std::string & file, MeshData & meshData) void exportMesh (const std::string & file, MeshData & meshData) Public Functions Documentation function importMesh static void importMesh( const std::string & file, MeshData & meshData ) function exportMesh static void exportMesh( const std::string & file, MeshData & meshData ) Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::MeshUtil"},{"location":"api/Classes/structngfx_1_1MeshUtil/#ngfxmeshutil","text":"","title":"ngfx::MeshUtil"},{"location":"api/Classes/structngfx_1_1MeshUtil/#public-functions","text":"Name void importMesh (const std::string & file, MeshData & meshData) void exportMesh (const std::string & file, MeshData & meshData)","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1MeshUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1MeshUtil/#function-importmesh","text":"static void importMesh( const std::string & file, MeshData & meshData )","title":"function importMesh"},{"location":"api/Classes/structngfx_1_1MeshUtil/#function-exportmesh","text":"static void exportMesh( const std::string & file, MeshData & meshData ) Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"function exportMesh"},{"location":"api/Classes/structngfx_1_1Rect2D/","text":"ngfx::Rect2D Public Attributes Name int32_t x int32_t y uint32_t w uint32_t h Public Attributes Documentation variable x int32_t x; variable y int32_t y; variable w uint32_t w; variable h uint32_t h; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::Rect2D"},{"location":"api/Classes/structngfx_1_1Rect2D/#ngfxrect2d","text":"","title":"ngfx::Rect2D"},{"location":"api/Classes/structngfx_1_1Rect2D/#public-attributes","text":"Name int32_t x int32_t y uint32_t w uint32_t h","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1Rect2D/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-x","text":"int32_t x;","title":"variable x"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-y","text":"int32_t y;","title":"variable y"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-w","text":"uint32_t w;","title":"variable w"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-h","text":"uint32_t h; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable h"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/","text":"ngfx::ShaderModule::BufferInfo Public Attributes Name std::string name uint32_t set ShaderStageFlags shaderStages BufferMemberInfos memberInfos Public Attributes Documentation variable name std::string name; variable set uint32_t set; variable shaderStages ShaderStageFlags shaderStages; variable memberInfos BufferMemberInfos memberInfos; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::ShaderModule::BufferInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#ngfxshadermodulebufferinfo","text":"","title":"ngfx::ShaderModule::BufferInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#public-attributes","text":"Name std::string name uint32_t set ShaderStageFlags shaderStages BufferMemberInfos memberInfos","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-set","text":"uint32_t set;","title":"variable set"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-shaderstages","text":"ShaderStageFlags shaderStages;","title":"variable shaderStages"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-memberinfos","text":"BufferMemberInfos memberInfos; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable memberInfos"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/","text":"ngfx::ShaderModule::BufferMemberInfo Public Attributes Name uint32_t offset uint32_t size uint32_t arrayCount uint32_t arrayStride Public Attributes Documentation variable offset uint32_t offset; variable size uint32_t size; variable arrayCount uint32_t arrayCount; variable arrayStride uint32_t arrayStride; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::ShaderModule::BufferMemberInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#ngfxshadermodulebuffermemberinfo","text":"","title":"ngfx::ShaderModule::BufferMemberInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#public-attributes","text":"Name uint32_t offset uint32_t size uint32_t arrayCount uint32_t arrayStride","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-offset","text":"uint32_t offset;","title":"variable offset"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-size","text":"uint32_t size;","title":"variable size"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-arraycount","text":"uint32_t arrayCount;","title":"variable arrayCount"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-arraystride","text":"uint32_t arrayStride; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable arrayStride"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/","text":"ngfx::ShaderModule::DescriptorInfo Public Attributes Name std::string name uint32_t set DescriptorType type Public Attributes Documentation variable name std::string name; variable set uint32_t set; variable type DescriptorType type; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::ShaderModule::DescriptorInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#ngfxshadermoduledescriptorinfo","text":"","title":"ngfx::ShaderModule::DescriptorInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#public-attributes","text":"Name std::string name uint32_t set DescriptorType type","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#variable-set","text":"uint32_t set;","title":"variable set"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#variable-type","text":"DescriptorType type; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable type"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/","text":"ngfx::ShaderTools::HLSLReflectData Public Attributes Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures Public Attributes Documentation variable attributes std::vector< RegexUtil::Match > attributes; variable buffers std::vector< RegexUtil::Match > buffers; variable textures std::vector< RegexUtil::Match > textures; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::ShaderTools::HLSLReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#ngfxshadertoolshlslreflectdata","text":"","title":"ngfx::ShaderTools::HLSLReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#public-attributes","text":"Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#variable-attributes","text":"std::vector< RegexUtil::Match > attributes;","title":"variable attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#variable-buffers","text":"std::vector< RegexUtil::Match > buffers;","title":"variable buffers"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#variable-textures","text":"std::vector< RegexUtil::Match > textures; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable textures"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/","text":"ngfx::ShaderTools::MacroDefinition Public Attributes Name std::string name std::string value Public Attributes Documentation variable name std::string name; variable value std::string value; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::ShaderTools::MacroDefinition"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#ngfxshadertoolsmacrodefinition","text":"","title":"ngfx::ShaderTools::MacroDefinition"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#public-attributes","text":"Name std::string name std::string value","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#variable-value","text":"std::string value; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable value"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/","text":"ngfx::ShaderTools::MetalReflectData Public Attributes Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures Public Attributes Documentation variable attributes std::vector< RegexUtil::Match > attributes; variable buffers std::vector< RegexUtil::Match > buffers; variable textures std::vector< RegexUtil::Match > textures; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::ShaderTools::MetalReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#ngfxshadertoolsmetalreflectdata","text":"","title":"ngfx::ShaderTools::MetalReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#public-attributes","text":"Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#variable-attributes","text":"std::vector< RegexUtil::Match > attributes;","title":"variable attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#variable-buffers","text":"std::vector< RegexUtil::Match > buffers;","title":"variable buffers"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#variable-textures","text":"std::vector< RegexUtil::Match > textures; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable textures"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/","text":"ngfx::VertexShaderModule::AttributeDescription Public Attributes Name std::string semantic uint32_t location VertexFormat format std::string name uint32_t count uint32_t elementSize Public Attributes Documentation variable semantic std::string semantic; variable location uint32_t location; variable format VertexFormat format; variable name std::string name; variable count uint32_t count; variable elementSize uint32_t elementSize; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"ngfx::VertexShaderModule::AttributeDescription"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#ngfxvertexshadermoduleattributedescription","text":"","title":"ngfx::VertexShaderModule::AttributeDescription"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#public-attributes","text":"Name std::string semantic uint32_t location VertexFormat format std::string name uint32_t count uint32_t elementSize","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-semantic","text":"std::string semantic;","title":"variable semantic"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-location","text":"uint32_t location;","title":"variable location"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-format","text":"VertexFormat format;","title":"variable format"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-count","text":"uint32_t count;","title":"variable count"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-elementsize","text":"uint32_t elementSize; Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"variable elementSize"},{"location":"api/Examples/","text":"Examples Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Examples"},{"location":"api/Examples/#examples","text":"Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Examples"},{"location":"api/Files/","text":"Files dir src dir src/ngfx dir src/ngfx/graphics file src/ngfx/graphics/Buffer.h file src/ngfx/graphics/BufferUtil.h file src/ngfx/graphics/Camera.cpp file src/ngfx/graphics/Camera.h file src/ngfx/graphics/CommandBuffer.h file src/ngfx/graphics/Config.h file src/ngfx/graphics/Device.h file src/ngfx/graphics/DrawOp.h file src/ngfx/graphics/Fence.h file src/ngfx/graphics/FilterOp.cpp file src/ngfx/graphics/FilterOp.h file src/ngfx/graphics/Framebuffer.h file src/ngfx/graphics/Graphics.h file src/ngfx/graphics/GraphicsContext.h file src/ngfx/graphics/GraphicsCore.h file src/ngfx/graphics/GraphicsPipeline.cpp file src/ngfx/graphics/GraphicsPipeline.h file src/ngfx/graphics/MeshData.h file src/ngfx/graphics/MeshUtil.cpp file src/ngfx/graphics/MeshUtil.h file src/ngfx/graphics/Pipeline.h file src/ngfx/graphics/PipelineCache.cpp file src/ngfx/graphics/PipelineCache.h file src/ngfx/graphics/Queue.h file src/ngfx/graphics/RenderPass.h file src/ngfx/graphics/Semaphore.h file src/ngfx/graphics/ShaderModule.cpp file src/ngfx/graphics/ShaderModule.h file src/ngfx/graphics/ShaderTools.cpp file src/ngfx/graphics/ShaderTools.h file src/ngfx/graphics/Surface.h file src/ngfx/graphics/Swapchain.h file src/ngfx/graphics/Texture.cpp file src/ngfx/graphics/Texture.h file src/ngfx/graphics/Window.h Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Files"},{"location":"api/Files/#files","text":"dir src dir src/ngfx dir src/ngfx/graphics file src/ngfx/graphics/Buffer.h file src/ngfx/graphics/BufferUtil.h file src/ngfx/graphics/Camera.cpp file src/ngfx/graphics/Camera.h file src/ngfx/graphics/CommandBuffer.h file src/ngfx/graphics/Config.h file src/ngfx/graphics/Device.h file src/ngfx/graphics/DrawOp.h file src/ngfx/graphics/Fence.h file src/ngfx/graphics/FilterOp.cpp file src/ngfx/graphics/FilterOp.h file src/ngfx/graphics/Framebuffer.h file src/ngfx/graphics/Graphics.h file src/ngfx/graphics/GraphicsContext.h file src/ngfx/graphics/GraphicsCore.h file src/ngfx/graphics/GraphicsPipeline.cpp file src/ngfx/graphics/GraphicsPipeline.h file src/ngfx/graphics/MeshData.h file src/ngfx/graphics/MeshUtil.cpp file src/ngfx/graphics/MeshUtil.h file src/ngfx/graphics/Pipeline.h file src/ngfx/graphics/PipelineCache.cpp file src/ngfx/graphics/PipelineCache.h file src/ngfx/graphics/Queue.h file src/ngfx/graphics/RenderPass.h file src/ngfx/graphics/Semaphore.h file src/ngfx/graphics/ShaderModule.cpp file src/ngfx/graphics/ShaderModule.h file src/ngfx/graphics/ShaderTools.cpp file src/ngfx/graphics/ShaderTools.h file src/ngfx/graphics/Surface.h file src/ngfx/graphics/Swapchain.h file src/ngfx/graphics/Texture.cpp file src/ngfx/graphics/Texture.h file src/ngfx/graphics/Window.h Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Files"},{"location":"api/Files/BufferUtil_8h/","text":"src/ngfx/graphics/BufferUtil.h Namespaces Name ngfx Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" namespace ngfx { static Buffer *createVertexBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_VERTEX_BUFFER_BIT); } template <typename T> static inline Buffer *createVertexBuffer(GraphicsContext *ctx, const std::vector<T> &v) { return createVertexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createIndexBuffer(GraphicsContext *ctx, const void *data, uint32_t size, uint32_t stride = sizeof(uint32_t)) { return Buffer::create(ctx, data, size, BUFFER_USAGE_INDEX_BUFFER_BIT); } template <typename T> static inline Buffer *createIndexBuffer(GraphicsContext *ctx, const std::vector<T> &v, uint32_t stride = sizeof(uint32_t)) { return createIndexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createUniformBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_UNIFORM_BUFFER_BIT); } static Buffer *createStorageBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_STORAGE_BUFFER_BIT); } }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/BufferUtil.h"},{"location":"api/Files/BufferUtil_8h/#srcngfxgraphicsbufferutilh","text":"","title":"src/ngfx/graphics/BufferUtil.h"},{"location":"api/Files/BufferUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/BufferUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" namespace ngfx { static Buffer *createVertexBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_VERTEX_BUFFER_BIT); } template <typename T> static inline Buffer *createVertexBuffer(GraphicsContext *ctx, const std::vector<T> &v) { return createVertexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createIndexBuffer(GraphicsContext *ctx, const void *data, uint32_t size, uint32_t stride = sizeof(uint32_t)) { return Buffer::create(ctx, data, size, BUFFER_USAGE_INDEX_BUFFER_BIT); } template <typename T> static inline Buffer *createIndexBuffer(GraphicsContext *ctx, const std::vector<T> &v, uint32_t stride = sizeof(uint32_t)) { return createIndexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createUniformBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_UNIFORM_BUFFER_BIT); } static Buffer *createStorageBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_STORAGE_BUFFER_BIT); } }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Buffer_8h/","text":"src/ngfx/graphics/Buffer.h Namespaces Name ngfx Classes Name class ngfx::Buffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <vector> namespace ngfx { class GraphicsContext; class Buffer { public: static Buffer *create(GraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags usageFlags); template <typename T> static inline Buffer *create(GraphicsContext *ctx, const std::vector<T> &v, BufferUsageFlags usageFlags) { return create(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } virtual ~Buffer() {} virtual void *map() = 0; virtual void unmap() = 0; virtual void upload(const void *data, uint32_t size, uint32_t offset = 0) = 0; virtual void download(void *data, uint32_t size, uint32_t offset = 0) = 0; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Buffer.h"},{"location":"api/Files/Buffer_8h/#srcngfxgraphicsbufferh","text":"","title":"src/ngfx/graphics/Buffer.h"},{"location":"api/Files/Buffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Buffer_8h/#classes","text":"Name class ngfx::Buffer","title":"Classes"},{"location":"api/Files/Buffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <vector> namespace ngfx { class GraphicsContext; class Buffer { public: static Buffer *create(GraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags usageFlags); template <typename T> static inline Buffer *create(GraphicsContext *ctx, const std::vector<T> &v, BufferUsageFlags usageFlags) { return create(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } virtual ~Buffer() {} virtual void *map() = 0; virtual void unmap() = 0; virtual void upload(const void *data, uint32_t size, uint32_t offset = 0) = 0; virtual void download(void *data, uint32_t size, uint32_t offset = 0) = 0; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Camera_8cpp/","text":"src/ngfx/graphics/Camera.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Camera.h\" #include \"ngfx/core/DebugUtil.h\" #include <glm/gtx/euler_angles.hpp> #include <glm/gtx/transform.hpp> using namespace ngfx; void Camera::onKey(KeyCode code, InputAction action) {} void Camera::onScroll(double xOffset, double yOffset) { zoom += float(yOffset) / 10.0f; } void Camera::onCursorPos(double x, double y) { auto &s = inputState; if (s.state == 1) { s.x = x; s.y = y; s.state = 2; } else if (s.state == 2) { double dx = x - s.x, dy = y - s.y; yaw += float(radians(dx * 10.0f)); pitch += float(radians(dy * 10.0f)); s.x = x; s.y = y; } } void Camera::onMouseButton(MouseButton button, InputAction action) { auto &s = inputState; if (button == MOUSE_BUTTON_MIDDLE) { if (s.state == 0 && action == PRESS) s.state = 1; else if (s.state != 0 && action == RELEASE) s.state = 0; } } void Camera::update() { viewMat = translate(vec3(panX, panY, 0)) * translate(vec3(0, 0, zoom)) * yawPitchRoll(radians(yaw), radians(pitch), radians(roll)); } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Camera.cpp"},{"location":"api/Files/Camera_8cpp/#srcngfxgraphicscameracpp","text":"","title":"src/ngfx/graphics/Camera.cpp"},{"location":"api/Files/Camera_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Camera.h\" #include \"ngfx/core/DebugUtil.h\" #include <glm/gtx/euler_angles.hpp> #include <glm/gtx/transform.hpp> using namespace ngfx; void Camera::onKey(KeyCode code, InputAction action) {} void Camera::onScroll(double xOffset, double yOffset) { zoom += float(yOffset) / 10.0f; } void Camera::onCursorPos(double x, double y) { auto &s = inputState; if (s.state == 1) { s.x = x; s.y = y; s.state = 2; } else if (s.state == 2) { double dx = x - s.x, dy = y - s.y; yaw += float(radians(dx * 10.0f)); pitch += float(radians(dy * 10.0f)); s.x = x; s.y = y; } } void Camera::onMouseButton(MouseButton button, InputAction action) { auto &s = inputState; if (button == MOUSE_BUTTON_MIDDLE) { if (s.state == 0 && action == PRESS) s.state = 1; else if (s.state != 0 && action == RELEASE) s.state = 0; } } void Camera::update() { viewMat = translate(vec3(panX, panY, 0)) * translate(vec3(0, 0, zoom)) * yawPitchRoll(radians(yaw), radians(pitch), radians(roll)); } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Camera_8h/","text":"src/ngfx/graphics/Camera.h Namespaces Name ngfx glm Classes Name class ngfx::Camera Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/input/InputListener.h\" #include <glm/glm.hpp> using namespace glm; namespace ngfx { class Camera : public InputListener { public: virtual ~Camera() {} void onKey(KeyCode keyCode, InputAction keyAction) override; void onScroll(double xoffset, double yoffset) override; void onCursorPos(double x, double y) override; void onMouseButton(MouseButton button, InputAction action) override; void update(); float panX = 0.0f, panY = 0.0f, zoom = 0.0f, yaw = 0.0f, pitch = 0.0f, roll = 0.0f; mat4 viewMat; private: struct { uint32_t state = 0; double x = -1.0, y = -1.0; } inputState; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Camera.h"},{"location":"api/Files/Camera_8h/#srcngfxgraphicscamerah","text":"","title":"src/ngfx/graphics/Camera.h"},{"location":"api/Files/Camera_8h/#namespaces","text":"Name ngfx glm","title":"Namespaces"},{"location":"api/Files/Camera_8h/#classes","text":"Name class ngfx::Camera","title":"Classes"},{"location":"api/Files/Camera_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/input/InputListener.h\" #include <glm/glm.hpp> using namespace glm; namespace ngfx { class Camera : public InputListener { public: virtual ~Camera() {} void onKey(KeyCode keyCode, InputAction keyAction) override; void onScroll(double xoffset, double yoffset) override; void onCursorPos(double x, double y) override; void onMouseButton(MouseButton button, InputAction action) override; void update(); float panX = 0.0f, panY = 0.0f, zoom = 0.0f, yaw = 0.0f, pitch = 0.0f, roll = 0.0f; mat4 viewMat; private: struct { uint32_t state = 0; double x = -1.0, y = -1.0; } inputState; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/CommandBuffer_8h/","text":"src/ngfx/graphics/CommandBuffer.h Namespaces Name ngfx Classes Name class ngfx::CommandBuffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class GraphicsContext; class CommandBuffer { public: static CommandBuffer * create(GraphicsContext *ctx, CommandBufferLevel level = COMMAND_BUFFER_LEVEL_PRIMARY); virtual ~CommandBuffer() {} virtual void begin() = 0; virtual void end() = 0; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/CommandBuffer.h"},{"location":"api/Files/CommandBuffer_8h/#srcngfxgraphicscommandbufferh","text":"","title":"src/ngfx/graphics/CommandBuffer.h"},{"location":"api/Files/CommandBuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/CommandBuffer_8h/#classes","text":"Name class ngfx::CommandBuffer","title":"Classes"},{"location":"api/Files/CommandBuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class GraphicsContext; class CommandBuffer { public: static CommandBuffer * create(GraphicsContext *ctx, CommandBufferLevel level = COMMAND_BUFFER_LEVEL_PRIMARY); virtual ~CommandBuffer() {} virtual void begin() = 0; virtual void end() = 0; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Config_8h/","text":"src/ngfx/graphics/Config.h Defines Name PREFERRED_NUM_SWAPCHAIN_IMAGES ENABLE_VSYNC USE_PRECOMPILED_SHADERS ORIGIN_BOTTOM_LEFT Macro Documentation define PREFERRED_NUM_SWAPCHAIN_IMAGES #define PREFERRED_NUM_SWAPCHAIN_IMAGES 3 define ENABLE_VSYNC #define ENABLE_VSYNC define USE_PRECOMPILED_SHADERS #define USE_PRECOMPILED_SHADERS define ORIGIN_BOTTOM_LEFT #define ORIGIN_BOTTOM_LEFT Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> #define PREFERRED_NUM_SWAPCHAIN_IMAGES 3 #define ENABLE_VSYNC #define USE_PRECOMPILED_SHADERS #define ORIGIN_BOTTOM_LEFT Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Config.h"},{"location":"api/Files/Config_8h/#srcngfxgraphicsconfigh","text":"","title":"src/ngfx/graphics/Config.h"},{"location":"api/Files/Config_8h/#defines","text":"Name PREFERRED_NUM_SWAPCHAIN_IMAGES ENABLE_VSYNC USE_PRECOMPILED_SHADERS ORIGIN_BOTTOM_LEFT","title":"Defines"},{"location":"api/Files/Config_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/Config_8h/#define-preferred_num_swapchain_images","text":"#define PREFERRED_NUM_SWAPCHAIN_IMAGES 3","title":"define PREFERRED_NUM_SWAPCHAIN_IMAGES"},{"location":"api/Files/Config_8h/#define-enable_vsync","text":"#define ENABLE_VSYNC","title":"define ENABLE_VSYNC"},{"location":"api/Files/Config_8h/#define-use_precompiled_shaders","text":"#define USE_PRECOMPILED_SHADERS","title":"define USE_PRECOMPILED_SHADERS"},{"location":"api/Files/Config_8h/#define-origin_bottom_left","text":"#define ORIGIN_BOTTOM_LEFT","title":"define ORIGIN_BOTTOM_LEFT"},{"location":"api/Files/Config_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> #define PREFERRED_NUM_SWAPCHAIN_IMAGES 3 #define ENABLE_VSYNC #define USE_PRECOMPILED_SHADERS #define ORIGIN_BOTTOM_LEFT Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Device_8h/","text":"src/ngfx/graphics/Device.h Namespaces Name ngfx Classes Name class ngfx::Device Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Device {}; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Device.h"},{"location":"api/Files/Device_8h/#srcngfxgraphicsdeviceh","text":"","title":"src/ngfx/graphics/Device.h"},{"location":"api/Files/Device_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Device_8h/#classes","text":"Name class ngfx::Device","title":"Classes"},{"location":"api/Files/Device_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Device {}; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/DrawOp_8h/","text":"src/ngfx/graphics/DrawOp.h Namespaces Name ngfx Classes Name class ngfx::DrawOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class DrawOp { public: DrawOp(GraphicsContext *ctx) : ctx(ctx) {} virtual ~DrawOp() {} virtual void draw(CommandBuffer *commandBuffer, Graphics *graphics) = 0; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/DrawOp.h"},{"location":"api/Files/DrawOp_8h/#srcngfxgraphicsdrawoph","text":"","title":"src/ngfx/graphics/DrawOp.h"},{"location":"api/Files/DrawOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/DrawOp_8h/#classes","text":"Name class ngfx::DrawOp","title":"Classes"},{"location":"api/Files/DrawOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class DrawOp { public: DrawOp(GraphicsContext *ctx) : ctx(ctx) {} virtual ~DrawOp() {} virtual void draw(CommandBuffer *commandBuffer, Graphics *graphics) = 0; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Fence_8h/","text":"src/ngfx/graphics/Fence.h Namespaces Name ngfx Classes Name class ngfx::Fence Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class Fence { public: static Fence *create(Device *device, FenceCreateFlags flags = 0); virtual ~Fence() {} virtual void wait() = 0; virtual void reset() = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Fence.h"},{"location":"api/Files/Fence_8h/#srcngfxgraphicsfenceh","text":"","title":"src/ngfx/graphics/Fence.h"},{"location":"api/Files/Fence_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Fence_8h/#classes","text":"Name class ngfx::Fence","title":"Classes"},{"location":"api/Files/Fence_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class Fence { public: static Fence *create(Device *device, FenceCreateFlags flags = 0); virtual ~Fence() {} virtual void wait() = 0; virtual void reset() = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/FilterOp_8cpp/","text":"src/ngfx/graphics/FilterOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/FilterOp.h\" using namespace ngfx; FilterOp::FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight) : DrawOp(ctx) { uint32_t w = dstWidth, h = dstHeight, size = w * h * 4; outputTexture.reset(Texture::create( ctx, graphics, nullptr, PIXELFORMAT_RGBA8_UNORM, size, w, h, 1, 1, ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_DST_BIT | IMAGE_USAGE_COLOR_ATTACHMENT_BIT))); outputFramebuffer.reset(Framebuffer::create(ctx->device, ctx->defaultOffscreenRenderPass, {{outputTexture.get()}}, w, h)); } void FilterOp::apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics) { outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL); ctx->beginOffscreenRenderPass(commandBuffer, graphics, outputFramebuffer.get()); draw(commandBuffer, graphics); ctx->endOffscreenRenderPass(commandBuffer, graphics); outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL); } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/FilterOp.cpp"},{"location":"api/Files/FilterOp_8cpp/#srcngfxgraphicsfilteropcpp","text":"","title":"src/ngfx/graphics/FilterOp.cpp"},{"location":"api/Files/FilterOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/FilterOp.h\" using namespace ngfx; FilterOp::FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight) : DrawOp(ctx) { uint32_t w = dstWidth, h = dstHeight, size = w * h * 4; outputTexture.reset(Texture::create( ctx, graphics, nullptr, PIXELFORMAT_RGBA8_UNORM, size, w, h, 1, 1, ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_DST_BIT | IMAGE_USAGE_COLOR_ATTACHMENT_BIT))); outputFramebuffer.reset(Framebuffer::create(ctx->device, ctx->defaultOffscreenRenderPass, {{outputTexture.get()}}, w, h)); } void FilterOp::apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics) { outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL); ctx->beginOffscreenRenderPass(commandBuffer, graphics, outputFramebuffer.get()); draw(commandBuffer, graphics); ctx->endOffscreenRenderPass(commandBuffer, graphics); outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL); } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/FilterOp_8h/","text":"src/ngfx/graphics/FilterOp.h Namespaces Name ngfx Classes Name class ngfx::FilterOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class FilterOp : public DrawOp { public: FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight); virtual ~FilterOp() {} void apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics); std::unique_ptr<Texture> outputTexture; std::unique_ptr<Framebuffer> outputFramebuffer; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/FilterOp.h"},{"location":"api/Files/FilterOp_8h/#srcngfxgraphicsfilteroph","text":"","title":"src/ngfx/graphics/FilterOp.h"},{"location":"api/Files/FilterOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/FilterOp_8h/#classes","text":"Name class ngfx::FilterOp","title":"Classes"},{"location":"api/Files/FilterOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class FilterOp : public DrawOp { public: FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight); virtual ~FilterOp() {} void apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics); std::unique_ptr<Texture> outputTexture; std::unique_ptr<Framebuffer> outputFramebuffer; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Framebuffer_8h/","text":"src/ngfx/graphics/Framebuffer.h Namespaces Name ngfx Classes Name class ngfx::Framebuffer struct ngfx::Framebuffer::Attachment Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Texture.h\" #include <vector> namespace ngfx { class Framebuffer { public: struct Attachment { Texture *texture = nullptr; uint32_t level = 0, layer = 0; }; static Framebuffer *create(Device *device, RenderPass *renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers = 1); virtual ~Framebuffer() {} uint32_t w, h, layers, numAttachments; std::vector<Attachment> attachments; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Framebuffer.h"},{"location":"api/Files/Framebuffer_8h/#srcngfxgraphicsframebufferh","text":"","title":"src/ngfx/graphics/Framebuffer.h"},{"location":"api/Files/Framebuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Framebuffer_8h/#classes","text":"Name class ngfx::Framebuffer struct ngfx::Framebuffer::Attachment","title":"Classes"},{"location":"api/Files/Framebuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Texture.h\" #include <vector> namespace ngfx { class Framebuffer { public: struct Attachment { Texture *texture = nullptr; uint32_t level = 0, layer = 0; }; static Framebuffer *create(Device *device, RenderPass *renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers = 1); virtual ~Framebuffer() {} uint32_t w, h, layers, numAttachments; std::vector<Attachment> attachments; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/GraphicsContext_8h/","text":"src/ngfx/graphics/GraphicsContext.h Namespaces Name ngfx Classes Name class ngfx::GraphicsContext struct ngfx::GraphicsContext::AttachmentDescription struct ngfx::GraphicsContext::RenderPassConfig Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePass.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/PipelineCache.h\" #include \"ngfx/graphics/Queue.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Surface.h\" #include \"ngfx/graphics/Swapchain.h\" #include <optional> #include <vector> namespace ngfx { class GraphicsContext { public: static GraphicsContext *create(const char *appName, bool enableDepthStencil = false, bool debug = true); virtual ~GraphicsContext() {} virtual void setSurface(Surface *surface) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { auto framebuffer = swapchainFramebuffers[currentImageIndex]; uint32_t w = framebuffer->w, h = framebuffer->h; graphics->beginRenderPass(commandBuffer, defaultRenderPass, framebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, w, h}); graphics->setScissor(commandBuffer, {0, 0, w, h}); } virtual void beginOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics, Framebuffer *outputFramebuffer) { graphics->beginRenderPass(commandBuffer, defaultOffscreenRenderPass, outputFramebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); graphics->setScissor(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); } virtual void endRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void endOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void submit(CommandBuffer *commandBuffer) { queue->submit(commandBuffer); } Device *device; uint32_t numDrawCommandBuffers = 0; virtual CommandBuffer *drawCommandBuffer(int32_t index = -1) = 0; virtual CommandBuffer *copyCommandBuffer() = 0; virtual CommandBuffer *computeCommandBuffer() = 0; struct AttachmentDescription { bool operator==(const AttachmentDescription &rhs) const { return rhs.format == format && rhs.initialLayout == initialLayout && rhs.finalLayout == finalLayout; } PixelFormat format; std::optional<ImageLayout> initialLayout, finalLayout; }; struct RenderPassConfig { bool operator==(const RenderPassConfig &rhs) const { return rhs.colorAttachmentDescriptions == colorAttachmentDescriptions && rhs.depthStencilAttachmentDescription == depthStencilAttachmentDescription && rhs.enableDepthStencilResolve == enableDepthStencilResolve && rhs.numSamples == numSamples; }; uint32_t numColorAttachments() const { return uint32_t(colorAttachmentDescriptions.size()); } std::vector<AttachmentDescription> colorAttachmentDescriptions; std::optional<AttachmentDescription> depthStencilAttachmentDescription; bool enableDepthStencilResolve = false; uint32_t numSamples = 1; }; virtual RenderPass *getRenderPass(RenderPassConfig config) = 0; std::vector<Framebuffer *> swapchainFramebuffers; Queue *queue = nullptr; RenderPass *defaultRenderPass = nullptr, *defaultOffscreenRenderPass = nullptr; Swapchain *swapchain = nullptr; Surface *surface = nullptr; uint32_t currentImageIndex = 0; std::vector<Fence *> frameFences; Fence *computeFence = nullptr; Semaphore *presentCompleteSemaphore = nullptr, *renderCompleteSemaphore = nullptr; PipelineCache *pipelineCache = nullptr; PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED, defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED, depthFormat = PIXELFORMAT_UNDEFINED; glm::vec4 clearColor = glm::vec4(0.0f); protected: bool debug = false, enableDepthStencil = false; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/GraphicsContext.h"},{"location":"api/Files/GraphicsContext_8h/#srcngfxgraphicsgraphicscontexth","text":"","title":"src/ngfx/graphics/GraphicsContext.h"},{"location":"api/Files/GraphicsContext_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GraphicsContext_8h/#classes","text":"Name class ngfx::GraphicsContext struct ngfx::GraphicsContext::AttachmentDescription struct ngfx::GraphicsContext::RenderPassConfig","title":"Classes"},{"location":"api/Files/GraphicsContext_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePass.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/PipelineCache.h\" #include \"ngfx/graphics/Queue.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Surface.h\" #include \"ngfx/graphics/Swapchain.h\" #include <optional> #include <vector> namespace ngfx { class GraphicsContext { public: static GraphicsContext *create(const char *appName, bool enableDepthStencil = false, bool debug = true); virtual ~GraphicsContext() {} virtual void setSurface(Surface *surface) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { auto framebuffer = swapchainFramebuffers[currentImageIndex]; uint32_t w = framebuffer->w, h = framebuffer->h; graphics->beginRenderPass(commandBuffer, defaultRenderPass, framebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, w, h}); graphics->setScissor(commandBuffer, {0, 0, w, h}); } virtual void beginOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics, Framebuffer *outputFramebuffer) { graphics->beginRenderPass(commandBuffer, defaultOffscreenRenderPass, outputFramebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); graphics->setScissor(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); } virtual void endRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void endOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void submit(CommandBuffer *commandBuffer) { queue->submit(commandBuffer); } Device *device; uint32_t numDrawCommandBuffers = 0; virtual CommandBuffer *drawCommandBuffer(int32_t index = -1) = 0; virtual CommandBuffer *copyCommandBuffer() = 0; virtual CommandBuffer *computeCommandBuffer() = 0; struct AttachmentDescription { bool operator==(const AttachmentDescription &rhs) const { return rhs.format == format && rhs.initialLayout == initialLayout && rhs.finalLayout == finalLayout; } PixelFormat format; std::optional<ImageLayout> initialLayout, finalLayout; }; struct RenderPassConfig { bool operator==(const RenderPassConfig &rhs) const { return rhs.colorAttachmentDescriptions == colorAttachmentDescriptions && rhs.depthStencilAttachmentDescription == depthStencilAttachmentDescription && rhs.enableDepthStencilResolve == enableDepthStencilResolve && rhs.numSamples == numSamples; }; uint32_t numColorAttachments() const { return uint32_t(colorAttachmentDescriptions.size()); } std::vector<AttachmentDescription> colorAttachmentDescriptions; std::optional<AttachmentDescription> depthStencilAttachmentDescription; bool enableDepthStencilResolve = false; uint32_t numSamples = 1; }; virtual RenderPass *getRenderPass(RenderPassConfig config) = 0; std::vector<Framebuffer *> swapchainFramebuffers; Queue *queue = nullptr; RenderPass *defaultRenderPass = nullptr, *defaultOffscreenRenderPass = nullptr; Swapchain *swapchain = nullptr; Surface *surface = nullptr; uint32_t currentImageIndex = 0; std::vector<Fence *> frameFences; Fence *computeFence = nullptr; Semaphore *presentCompleteSemaphore = nullptr, *renderCompleteSemaphore = nullptr; PipelineCache *pipelineCache = nullptr; PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED, defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED, depthFormat = PIXELFORMAT_UNDEFINED; glm::vec4 clearColor = glm::vec4(0.0f); protected: bool debug = false, enableDepthStencil = false; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/GraphicsCore_8h/","text":"src/ngfx/graphics/GraphicsCore.h Namespaces Name ngfx Classes Name struct ngfx::Rect2D Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> #include <string> #ifdef NGFX_GRAPHICS_BACKEND_VULKAN #include \"ngfx/porting/vulkan/VKGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_DIRECT3D12 #include \"ngfx/porting/d3d/D3DGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_METAL #include \"ngfx/porting/metal/MTLGraphicsCore.h\" #endif namespace ngfx { typedef uint32_t Flags; typedef Flags PipelineStageFlags; typedef Flags ShaderStageFlags; typedef Flags FenceCreateFlags; typedef Flags ImageUsageFlags; typedef Flags ColorComponentFlags; typedef Flags BufferUsageFlags; struct Rect2D { int32_t x, y; uint32_t w, h; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/GraphicsCore.h"},{"location":"api/Files/GraphicsCore_8h/#srcngfxgraphicsgraphicscoreh","text":"","title":"src/ngfx/graphics/GraphicsCore.h"},{"location":"api/Files/GraphicsCore_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GraphicsCore_8h/#classes","text":"Name struct ngfx::Rect2D","title":"Classes"},{"location":"api/Files/GraphicsCore_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> #include <string> #ifdef NGFX_GRAPHICS_BACKEND_VULKAN #include \"ngfx/porting/vulkan/VKGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_DIRECT3D12 #include \"ngfx/porting/d3d/D3DGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_METAL #include \"ngfx/porting/metal/MTLGraphicsCore.h\" #endif namespace ngfx { typedef uint32_t Flags; typedef Flags PipelineStageFlags; typedef Flags ShaderStageFlags; typedef Flags FenceCreateFlags; typedef Flags ImageUsageFlags; typedef Flags ColorComponentFlags; typedef Flags BufferUsageFlags; struct Rect2D { int32_t x, y; uint32_t w, h; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/GraphicsPipeline_8cpp/","text":"src/ngfx/graphics/GraphicsPipeline.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/GraphicsPipeline.h\" #include <set> using namespace ngfx; void GraphicsPipeline::getBindings( std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings) { for (uint32_t j = 0; j < pDescriptorBindings.size(); j++) *pDescriptorBindings[j] = descriptorBindings[j]; for (uint32_t j = 0; j < pVertexAttribBindings.size(); j++) *pVertexAttribBindings[j] = vertexAttributeBindings[j]; } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/GraphicsPipeline.cpp"},{"location":"api/Files/GraphicsPipeline_8cpp/#srcngfxgraphicsgraphicspipelinecpp","text":"","title":"src/ngfx/graphics/GraphicsPipeline.cpp"},{"location":"api/Files/GraphicsPipeline_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/GraphicsPipeline.h\" #include <set> using namespace ngfx; void GraphicsPipeline::getBindings( std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings) { for (uint32_t j = 0; j < pDescriptorBindings.size(); j++) *pDescriptorBindings[j] = descriptorBindings[j]; for (uint32_t j = 0; j < pVertexAttribBindings.size(); j++) *pVertexAttribBindings[j] = vertexAttributeBindings[j]; } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/GraphicsPipeline_8h/","text":"src/ngfx/graphics/GraphicsPipeline.h Namespaces Name ngfx Classes Name class ngfx::GraphicsPipeline struct ngfx::GraphicsPipeline::State struct ngfx::GraphicsPipeline::Descriptor Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Pipeline.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/ShaderModule.h\" #include <set> #include <vector> namespace ngfx { class GraphicsContext; class GraphicsPipeline : public Pipeline { public: struct State { PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; PolygonMode polygonMode = POLYGON_MODE_FILL; bool blendEnable = false; BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendOp colorBlendOp = BLEND_OP_ADD, alphaBlendOp = BLEND_OP_ADD; uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT; CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT; FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE; float lineWidth = 1.0f; bool depthTestEnable = false, depthWriteEnable = false; RenderPass *renderPass = nullptr; uint32_t numSamples = 1, numColorAttachments = 1; }; struct Descriptor { DescriptorType type; ShaderStageFlags stageFlags = SHADER_STAGE_ALL; }; static GraphicsPipeline * create(GraphicsContext *graphicsContext, const State &state, VertexShaderModule *vs, FragmentShaderModule *fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes = {}); virtual ~GraphicsPipeline() {} void getBindings(std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings); std::vector<uint32_t> descriptorBindings, vertexAttributeBindings; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/GraphicsPipeline.h"},{"location":"api/Files/GraphicsPipeline_8h/#srcngfxgraphicsgraphicspipelineh","text":"","title":"src/ngfx/graphics/GraphicsPipeline.h"},{"location":"api/Files/GraphicsPipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GraphicsPipeline_8h/#classes","text":"Name class ngfx::GraphicsPipeline struct ngfx::GraphicsPipeline::State struct ngfx::GraphicsPipeline::Descriptor","title":"Classes"},{"location":"api/Files/GraphicsPipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Pipeline.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/ShaderModule.h\" #include <set> #include <vector> namespace ngfx { class GraphicsContext; class GraphicsPipeline : public Pipeline { public: struct State { PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; PolygonMode polygonMode = POLYGON_MODE_FILL; bool blendEnable = false; BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendOp colorBlendOp = BLEND_OP_ADD, alphaBlendOp = BLEND_OP_ADD; uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT; CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT; FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE; float lineWidth = 1.0f; bool depthTestEnable = false, depthWriteEnable = false; RenderPass *renderPass = nullptr; uint32_t numSamples = 1, numColorAttachments = 1; }; struct Descriptor { DescriptorType type; ShaderStageFlags stageFlags = SHADER_STAGE_ALL; }; static GraphicsPipeline * create(GraphicsContext *graphicsContext, const State &state, VertexShaderModule *vs, FragmentShaderModule *fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes = {}); virtual ~GraphicsPipeline() {} void getBindings(std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings); std::vector<uint32_t> descriptorBindings, vertexAttributeBindings; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Graphics_8h/","text":"src/ngfx/graphics/Graphics.h Namespaces Name ngfx Classes Name class ngfx::Graphics Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/graphics/Texture.h\" #include <cstdint> #include <glm/glm.hpp> namespace ngfx { class Graphics { public: static Graphics *create(GraphicsContext *ctx); virtual ~Graphics() {} virtual void beginComputePass(CommandBuffer *commandBuffer) = 0; virtual void endComputePass(CommandBuffer *commandBuffer) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) = 0; virtual void endRenderPass(CommandBuffer *commandBuffer) = 0; virtual void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) = 0; virtual void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat = INDEXFORMAT_UINT32) = 0; virtual void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) = 0; virtual void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) = 0; virtual void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) = 0; // TODO: copyBuffer: ToBuffer, copyBuffer: ToTexture, copyTexture: ToBuffer, // blit virtual void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) = 0; virtual void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) = 0; virtual void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) = 0; virtual void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void waitIdle(CommandBuffer *cmdBuffer) = 0; Rect2D scissorRect; Rect2D viewport; Pipeline *currentPipeline = nullptr; RenderPass *currentRenderPass = nullptr; Framebuffer *currentFramebuffer = nullptr; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Graphics.h"},{"location":"api/Files/Graphics_8h/#srcngfxgraphicsgraphicsh","text":"","title":"src/ngfx/graphics/Graphics.h"},{"location":"api/Files/Graphics_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Graphics_8h/#classes","text":"Name class ngfx::Graphics","title":"Classes"},{"location":"api/Files/Graphics_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/graphics/Texture.h\" #include <cstdint> #include <glm/glm.hpp> namespace ngfx { class Graphics { public: static Graphics *create(GraphicsContext *ctx); virtual ~Graphics() {} virtual void beginComputePass(CommandBuffer *commandBuffer) = 0; virtual void endComputePass(CommandBuffer *commandBuffer) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) = 0; virtual void endRenderPass(CommandBuffer *commandBuffer) = 0; virtual void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) = 0; virtual void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat = INDEXFORMAT_UINT32) = 0; virtual void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) = 0; virtual void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) = 0; virtual void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) = 0; // TODO: copyBuffer: ToBuffer, copyBuffer: ToTexture, copyTexture: ToBuffer, // blit virtual void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) = 0; virtual void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) = 0; virtual void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) = 0; virtual void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void waitIdle(CommandBuffer *cmdBuffer) = 0; Rect2D scissorRect; Rect2D viewport; Pipeline *currentPipeline = nullptr; RenderPass *currentRenderPass = nullptr; Framebuffer *currentFramebuffer = nullptr; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MeshData_8h/","text":"src/ngfx/graphics/MeshData.h Namespaces Name ngfx Classes Name struct ngfx::MeshData Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <glm/glm.hpp> #include <vector> using namespace glm; namespace ngfx { struct MeshData { std::vector<vec3> pos, normal; std::vector<ivec3> faces; vec3 bounds[2] = {vec3(FLT_MAX), vec3(FLT_MIN)}; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/MeshData.h"},{"location":"api/Files/MeshData_8h/#srcngfxgraphicsmeshdatah","text":"","title":"src/ngfx/graphics/MeshData.h"},{"location":"api/Files/MeshData_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MeshData_8h/#classes","text":"Name struct ngfx::MeshData","title":"Classes"},{"location":"api/Files/MeshData_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <glm/glm.hpp> #include <vector> using namespace glm; namespace ngfx { struct MeshData { std::vector<vec3> pos, normal; std::vector<ivec3> faces; vec3 bounds[2] = {vec3(FLT_MAX), vec3(FLT_MIN)}; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MeshUtil_8cpp/","text":"src/ngfx/graphics/MeshUtil.cpp Namespaces Name std Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/MeshUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <glm/gtc/type_ptr.hpp> using namespace ngfx; using namespace std; void MeshUtil::importMesh(const std::string &file, MeshData &meshData) { ifstream in(file, ios::binary); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts, numNormals, numFaces; in.read((char *)&numVerts, sizeof(numVerts)); pos.resize(numVerts); in.read((char *)value_ptr(bounds[0]), sizeof(bounds[0])); in.read((char *)value_ptr(bounds[1]), sizeof(bounds[1])); in.read((char *)pos.data(), pos.size() * sizeof(pos[0])); in.read((char *)&numNormals, sizeof(numNormals)); normals.resize(numNormals); in.read((char *)normals.data(), normals.size() * sizeof(normals[0])); in.read((char *)&numFaces, sizeof(numFaces)); faces.resize(numFaces); in.read((char *)faces.data(), faces.size() * sizeof(faces[0])); in.close(); } void MeshUtil::exportMesh(const std::string &file, MeshData &meshData) { ofstream out(file, ios::binary); if (!out.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts = pos.size(), numNormals = normals.size(), numFaces = faces.size(); out.write((const char *)&numVerts, sizeof(numVerts)); out.write((const char *)value_ptr(bounds[0]), sizeof(bounds[0])); out.write((const char *)value_ptr(bounds[1]), sizeof(bounds[1])); out.write((const char *)pos.data(), pos.size() * sizeof(pos[0])); out.write((const char *)&numNormals, sizeof(numNormals)); out.write((const char *)normals.data(), normals.size() * sizeof(normals[0])); out.write((const char *)&numFaces, sizeof(numFaces)); out.write((const char *)faces.data(), faces.size() * sizeof(faces[0])); out.close(); } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/MeshUtil.cpp"},{"location":"api/Files/MeshUtil_8cpp/#srcngfxgraphicsmeshutilcpp","text":"","title":"src/ngfx/graphics/MeshUtil.cpp"},{"location":"api/Files/MeshUtil_8cpp/#namespaces","text":"Name std","title":"Namespaces"},{"location":"api/Files/MeshUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/MeshUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <glm/gtc/type_ptr.hpp> using namespace ngfx; using namespace std; void MeshUtil::importMesh(const std::string &file, MeshData &meshData) { ifstream in(file, ios::binary); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts, numNormals, numFaces; in.read((char *)&numVerts, sizeof(numVerts)); pos.resize(numVerts); in.read((char *)value_ptr(bounds[0]), sizeof(bounds[0])); in.read((char *)value_ptr(bounds[1]), sizeof(bounds[1])); in.read((char *)pos.data(), pos.size() * sizeof(pos[0])); in.read((char *)&numNormals, sizeof(numNormals)); normals.resize(numNormals); in.read((char *)normals.data(), normals.size() * sizeof(normals[0])); in.read((char *)&numFaces, sizeof(numFaces)); faces.resize(numFaces); in.read((char *)faces.data(), faces.size() * sizeof(faces[0])); in.close(); } void MeshUtil::exportMesh(const std::string &file, MeshData &meshData) { ofstream out(file, ios::binary); if (!out.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts = pos.size(), numNormals = normals.size(), numFaces = faces.size(); out.write((const char *)&numVerts, sizeof(numVerts)); out.write((const char *)value_ptr(bounds[0]), sizeof(bounds[0])); out.write((const char *)value_ptr(bounds[1]), sizeof(bounds[1])); out.write((const char *)pos.data(), pos.size() * sizeof(pos[0])); out.write((const char *)&numNormals, sizeof(numNormals)); out.write((const char *)normals.data(), normals.size() * sizeof(normals[0])); out.write((const char *)&numFaces, sizeof(numFaces)); out.write((const char *)faces.data(), faces.size() * sizeof(faces[0])); out.close(); } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/MeshUtil_8h/","text":"src/ngfx/graphics/MeshUtil.h Namespaces Name ngfx Classes Name struct ngfx::MeshUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/MeshData.h\" #include <string> namespace ngfx { struct MeshUtil { static void importMesh(const std::string &file, MeshData &meshData); static void exportMesh(const std::string &file, MeshData &meshData); }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/MeshUtil.h"},{"location":"api/Files/MeshUtil_8h/#srcngfxgraphicsmeshutilh","text":"","title":"src/ngfx/graphics/MeshUtil.h"},{"location":"api/Files/MeshUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MeshUtil_8h/#classes","text":"Name struct ngfx::MeshUtil","title":"Classes"},{"location":"api/Files/MeshUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/MeshData.h\" #include <string> namespace ngfx { struct MeshUtil { static void importMesh(const std::string &file, MeshData &meshData); static void exportMesh(const std::string &file, MeshData &meshData); }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/PipelineCache_8cpp/","text":"src/ngfx/graphics/PipelineCache.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/PipelineCache.h\" using namespace ngfx; Pipeline *PipelineCache::get(const std::string &key) { if (v.find(key) == v.end()) return nullptr; return v[key].get(); } void PipelineCache::add(const std::string &key, Pipeline *value) { v[key].reset(value); } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/PipelineCache.cpp"},{"location":"api/Files/PipelineCache_8cpp/#srcngfxgraphicspipelinecachecpp","text":"","title":"src/ngfx/graphics/PipelineCache.cpp"},{"location":"api/Files/PipelineCache_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/PipelineCache.h\" using namespace ngfx; Pipeline *PipelineCache::get(const std::string &key) { if (v.find(key) == v.end()) return nullptr; return v[key].get(); } void PipelineCache::add(const std::string &key, Pipeline *value) { v[key].reset(value); } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/PipelineCache_8h/","text":"src/ngfx/graphics/PipelineCache.h Namespaces Name ngfx Classes Name class ngfx::PipelineCache Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Pipeline.h\" #include <map> #include <memory> #include <string> namespace ngfx { class PipelineCache { public: virtual ~PipelineCache() {} virtual Pipeline *get(const std::string &key); virtual void add(const std::string &key, Pipeline *value); private: std::map<std::string, std::unique_ptr<Pipeline>> v; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/PipelineCache.h"},{"location":"api/Files/PipelineCache_8h/#srcngfxgraphicspipelinecacheh","text":"","title":"src/ngfx/graphics/PipelineCache.h"},{"location":"api/Files/PipelineCache_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/PipelineCache_8h/#classes","text":"Name class ngfx::PipelineCache","title":"Classes"},{"location":"api/Files/PipelineCache_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Pipeline.h\" #include <map> #include <memory> #include <string> namespace ngfx { class PipelineCache { public: virtual ~PipelineCache() {} virtual Pipeline *get(const std::string &key); virtual void add(const std::string &key, Pipeline *value); private: std::map<std::string, std::unique_ptr<Pipeline>> v; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Pipeline_8h/","text":"src/ngfx/graphics/Pipeline.h Namespaces Name ngfx Classes Name class ngfx::Pipeline Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Pipeline { public: virtual ~Pipeline() {} }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Pipeline.h"},{"location":"api/Files/Pipeline_8h/#srcngfxgraphicspipelineh","text":"","title":"src/ngfx/graphics/Pipeline.h"},{"location":"api/Files/Pipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Pipeline_8h/#classes","text":"Name class ngfx::Pipeline","title":"Classes"},{"location":"api/Files/Pipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Pipeline { public: virtual ~Pipeline() {} }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Queue_8h/","text":"src/ngfx/graphics/Queue.h Namespaces Name ngfx Classes Name class ngfx::Queue Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Fence.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Swapchain.h\" #include <vector> namespace ngfx { class Queue { public: virtual ~Queue() {} virtual void present() = 0; virtual void submit(CommandBuffer *commandBuffer) = 0; virtual void waitIdle() = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Queue.h"},{"location":"api/Files/Queue_8h/#srcngfxgraphicsqueueh","text":"","title":"src/ngfx/graphics/Queue.h"},{"location":"api/Files/Queue_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Queue_8h/#classes","text":"Name class ngfx::Queue","title":"Classes"},{"location":"api/Files/Queue_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Fence.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Swapchain.h\" #include <vector> namespace ngfx { class Queue { public: virtual ~Queue() {} virtual void present() = 0; virtual void submit(CommandBuffer *commandBuffer) = 0; virtual void waitIdle() = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/RenderPass_8h/","text":"src/ngfx/graphics/RenderPass.h Namespaces Name ngfx Classes Name class ngfx::RenderPass Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Framebuffer; class RenderPass { public: virtual ~RenderPass() {} Framebuffer *currentFramebuffer = nullptr; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/RenderPass.h"},{"location":"api/Files/RenderPass_8h/#srcngfxgraphicsrenderpassh","text":"","title":"src/ngfx/graphics/RenderPass.h"},{"location":"api/Files/RenderPass_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/RenderPass_8h/#classes","text":"Name class ngfx::RenderPass","title":"Classes"},{"location":"api/Files/RenderPass_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Framebuffer; class RenderPass { public: virtual ~RenderPass() {} Framebuffer *currentFramebuffer = nullptr; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Semaphore_8h/","text":"src/ngfx/graphics/Semaphore.h Namespaces Name ngfx Classes Name class ngfx::Semaphore Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include <cstdint> namespace ngfx { class Semaphore { public: static Semaphore *create(Device *device); virtual ~Semaphore() {} virtual uint64_t wait() = 0; virtual void signal(uint64_t value = 1) = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Semaphore.h"},{"location":"api/Files/Semaphore_8h/#srcngfxgraphicssemaphoreh","text":"","title":"src/ngfx/graphics/Semaphore.h"},{"location":"api/Files/Semaphore_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Semaphore_8h/#classes","text":"Name class ngfx::Semaphore","title":"Classes"},{"location":"api/Files/Semaphore_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include <cstdint> namespace ngfx { class Semaphore { public: static Semaphore *create(Device *device); virtual ~Semaphore() {} virtual uint64_t wait() = 0; virtual void signal(uint64_t value = 1) = 0; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ShaderModule_8cpp/","text":"src/ngfx/graphics/ShaderModule.cpp Classes Name struct VertexFormatInfo Functions Name void parseAttributes (ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs) void parseDescriptors (ifstream & in, vector< ShaderModule::DescriptorInfo > & descs) void parseBufferMemberInfos (ifstream & in, ShaderModule::BufferMemberInfos & memberInfos) void parseBufferInfos (ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages) Attributes Name map< string, VertexFormatInfo > vertexFormatMap map< string, VertexInputRate > vertexInputRateMap map< string, DescriptorType > descriptorTypeMap Defines Name VF_ITEM (s, count, elementSize) ITEM (s) Functions Documentation function parseAttributes static void parseAttributes( ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs ) function parseDescriptors static void parseDescriptors( ifstream & in, vector< ShaderModule::DescriptorInfo > & descs ) function parseBufferMemberInfos static void parseBufferMemberInfos( ifstream & in, ShaderModule::BufferMemberInfos & memberInfos ) function parseBufferInfos static void parseBufferInfos( ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages ) Attributes Documentation variable vertexFormatMap static map< string, VertexFormatInfo > vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}}; variable vertexInputRateMap static map< string, VertexInputRate > vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), }; variable descriptorTypeMap static map< string, DescriptorType > descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)}; Macro Documentation define VF_ITEM #define VF_ITEM( s, count, elementSize ) { \\ #s, { s, count, elementSize } \\ } define ITEM #define ITEM( s ) { #s, s } Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <map> using namespace ngfx; using namespace std; #define VF_ITEM(s, count, elementSize) \\ { \\ #s, { s, count, elementSize } \\ } struct VertexFormatInfo { VertexFormat format; uint32_t count, elementSize; }; static map<string, VertexFormatInfo> vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}}; #define ITEM(s) \\ { #s, s } static map<string, VertexInputRate> vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), }; static map<string, DescriptorType> descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)}; static void parseAttributes(ifstream &in, vector<VertexShaderModule::AttributeDescription> &attrs) { string token; uint32_t numAttributes; in >> token >> numAttributes; attrs.resize(numAttributes); for (uint32_t j = 0; j < numAttributes; j++) { auto &attr = attrs[j]; string formatStr; in >> attr.name >> attr.semantic >> attr.location >> formatStr; auto formatInfo = vertexFormatMap.at(formatStr); attr.format = formatInfo.format; attr.count = formatInfo.count; attr.elementSize = formatInfo.elementSize; } } static void parseDescriptors(ifstream &in, vector<ShaderModule::DescriptorInfo> &descs) { string token; int numDescriptors; in >> token >> numDescriptors; descs.resize(numDescriptors); for (uint32_t j = 0; j < uint32_t(numDescriptors); j++) { auto &desc = descs[j]; string descriptorTypeStr; in >> desc.name >> descriptorTypeStr >> desc.set; desc.type = descriptorTypeMap.at(descriptorTypeStr); } } static void parseBufferMemberInfos(ifstream &in, ShaderModule::BufferMemberInfos &memberInfos) { uint32_t numMemberInfos; in >> numMemberInfos; for (uint32_t j = 0; j < numMemberInfos; j++) { ShaderModule::BufferMemberInfo memberInfo; string memberName; in >> memberName >> memberInfo.offset >> memberInfo.size >> memberInfo.arrayCount >> memberInfo.arrayStride; memberInfos[memberName] = memberInfo; } } static void parseBufferInfos(ifstream &in, string key, ShaderModule::BufferInfos &bufferInfos, ShaderStageFlags shaderStages) { string token; in >> token; if (token != key) return; uint32_t numUniformBufferInfos; in >> numUniformBufferInfos; for (uint32_t j = 0; j < numUniformBufferInfos; j++) { ShaderModule::BufferInfo bufferInfo; in >> bufferInfo.name >> bufferInfo.set; bufferInfo.shaderStages = shaderStages; parseBufferMemberInfos(in, bufferInfo.memberInfos); bufferInfos[bufferInfo.name] = std::move(bufferInfo); } } void ShaderModule::initBindings(std::ifstream &in, ShaderStageFlags shaderStages) { parseDescriptors(in, descriptors); parseBufferInfos(in, \"UNIFORM_BUFFER_INFOS\", uniformBufferInfos, shaderStages); parseBufferInfos(in, \"SHADER_STORAGE_BUFFER_INFOS\", shaderStorageBufferInfos, shaderStages); } void ShaderModule::initBindings(const std::string &filename, ShaderStageFlags shaderStages) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); initBindings(in, shaderStages); in.close(); } void VertexShaderModule::initBindings(const std::string &filename) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); parseAttributes(in, attributes); ShaderModule::initBindings(in, SHADER_STAGE_VERTEX_BIT); in.close(); } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/ShaderModule.cpp"},{"location":"api/Files/ShaderModule_8cpp/#srcngfxgraphicsshadermodulecpp","text":"","title":"src/ngfx/graphics/ShaderModule.cpp"},{"location":"api/Files/ShaderModule_8cpp/#classes","text":"Name struct VertexFormatInfo","title":"Classes"},{"location":"api/Files/ShaderModule_8cpp/#functions","text":"Name void parseAttributes (ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs) void parseDescriptors (ifstream & in, vector< ShaderModule::DescriptorInfo > & descs) void parseBufferMemberInfos (ifstream & in, ShaderModule::BufferMemberInfos & memberInfos) void parseBufferInfos (ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages)","title":"Functions"},{"location":"api/Files/ShaderModule_8cpp/#attributes","text":"Name map< string, VertexFormatInfo > vertexFormatMap map< string, VertexInputRate > vertexInputRateMap map< string, DescriptorType > descriptorTypeMap","title":"Attributes"},{"location":"api/Files/ShaderModule_8cpp/#defines","text":"Name VF_ITEM (s, count, elementSize) ITEM (s)","title":"Defines"},{"location":"api/Files/ShaderModule_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/ShaderModule_8cpp/#function-parseattributes","text":"static void parseAttributes( ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs )","title":"function parseAttributes"},{"location":"api/Files/ShaderModule_8cpp/#function-parsedescriptors","text":"static void parseDescriptors( ifstream & in, vector< ShaderModule::DescriptorInfo > & descs )","title":"function parseDescriptors"},{"location":"api/Files/ShaderModule_8cpp/#function-parsebuffermemberinfos","text":"static void parseBufferMemberInfos( ifstream & in, ShaderModule::BufferMemberInfos & memberInfos )","title":"function parseBufferMemberInfos"},{"location":"api/Files/ShaderModule_8cpp/#function-parsebufferinfos","text":"static void parseBufferInfos( ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages )","title":"function parseBufferInfos"},{"location":"api/Files/ShaderModule_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/ShaderModule_8cpp/#variable-vertexformatmap","text":"static map< string, VertexFormatInfo > vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}};","title":"variable vertexFormatMap"},{"location":"api/Files/ShaderModule_8cpp/#variable-vertexinputratemap","text":"static map< string, VertexInputRate > vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), };","title":"variable vertexInputRateMap"},{"location":"api/Files/ShaderModule_8cpp/#variable-descriptortypemap","text":"static map< string, DescriptorType > descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)};","title":"variable descriptorTypeMap"},{"location":"api/Files/ShaderModule_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/ShaderModule_8cpp/#define-vf_item","text":"#define VF_ITEM( s, count, elementSize ) { \\ #s, { s, count, elementSize } \\ }","title":"define VF_ITEM"},{"location":"api/Files/ShaderModule_8cpp/#define-item","text":"#define ITEM( s ) { #s, s }","title":"define ITEM"},{"location":"api/Files/ShaderModule_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <map> using namespace ngfx; using namespace std; #define VF_ITEM(s, count, elementSize) \\ { \\ #s, { s, count, elementSize } \\ } struct VertexFormatInfo { VertexFormat format; uint32_t count, elementSize; }; static map<string, VertexFormatInfo> vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}}; #define ITEM(s) \\ { #s, s } static map<string, VertexInputRate> vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), }; static map<string, DescriptorType> descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)}; static void parseAttributes(ifstream &in, vector<VertexShaderModule::AttributeDescription> &attrs) { string token; uint32_t numAttributes; in >> token >> numAttributes; attrs.resize(numAttributes); for (uint32_t j = 0; j < numAttributes; j++) { auto &attr = attrs[j]; string formatStr; in >> attr.name >> attr.semantic >> attr.location >> formatStr; auto formatInfo = vertexFormatMap.at(formatStr); attr.format = formatInfo.format; attr.count = formatInfo.count; attr.elementSize = formatInfo.elementSize; } } static void parseDescriptors(ifstream &in, vector<ShaderModule::DescriptorInfo> &descs) { string token; int numDescriptors; in >> token >> numDescriptors; descs.resize(numDescriptors); for (uint32_t j = 0; j < uint32_t(numDescriptors); j++) { auto &desc = descs[j]; string descriptorTypeStr; in >> desc.name >> descriptorTypeStr >> desc.set; desc.type = descriptorTypeMap.at(descriptorTypeStr); } } static void parseBufferMemberInfos(ifstream &in, ShaderModule::BufferMemberInfos &memberInfos) { uint32_t numMemberInfos; in >> numMemberInfos; for (uint32_t j = 0; j < numMemberInfos; j++) { ShaderModule::BufferMemberInfo memberInfo; string memberName; in >> memberName >> memberInfo.offset >> memberInfo.size >> memberInfo.arrayCount >> memberInfo.arrayStride; memberInfos[memberName] = memberInfo; } } static void parseBufferInfos(ifstream &in, string key, ShaderModule::BufferInfos &bufferInfos, ShaderStageFlags shaderStages) { string token; in >> token; if (token != key) return; uint32_t numUniformBufferInfos; in >> numUniformBufferInfos; for (uint32_t j = 0; j < numUniformBufferInfos; j++) { ShaderModule::BufferInfo bufferInfo; in >> bufferInfo.name >> bufferInfo.set; bufferInfo.shaderStages = shaderStages; parseBufferMemberInfos(in, bufferInfo.memberInfos); bufferInfos[bufferInfo.name] = std::move(bufferInfo); } } void ShaderModule::initBindings(std::ifstream &in, ShaderStageFlags shaderStages) { parseDescriptors(in, descriptors); parseBufferInfos(in, \"UNIFORM_BUFFER_INFOS\", uniformBufferInfos, shaderStages); parseBufferInfos(in, \"SHADER_STORAGE_BUFFER_INFOS\", shaderStorageBufferInfos, shaderStages); } void ShaderModule::initBindings(const std::string &filename, ShaderStageFlags shaderStages) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); initBindings(in, shaderStages); in.close(); } void VertexShaderModule::initBindings(const std::string &filename) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); parseAttributes(in, attributes); ShaderModule::initBindings(in, SHADER_STAGE_VERTEX_BIT); in.close(); } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ShaderModule_8h/","text":"src/ngfx/graphics/ShaderModule.h Namespaces Name ngfx Classes Name class ngfx::ShaderModule struct ngfx::ShaderModule::DescriptorInfo struct ngfx::ShaderModule::BufferMemberInfo struct ngfx::ShaderModule::BufferInfo class ngfx::VertexShaderModule struct ngfx::VertexShaderModule::AttributeDescription class ngfx::FragmentShaderModule class ngfx::ComputeShaderModule Defines Name ENABLE_NGL_INTEGRATION Macro Documentation define ENABLE_NGL_INTEGRATION #define ENABLE_NGL_INTEGRATION Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <map> #include <memory> #include <string> #include <vector> #define ENABLE_NGL_INTEGRATION namespace ngfx { class ShaderModule { public: virtual ~ShaderModule() {} struct DescriptorInfo { std::string name; uint32_t set; DescriptorType type; }; typedef std::vector<DescriptorInfo> DescriptorInfos; DescriptorInfos descriptors; inline DescriptorInfo *findDescriptorInfo(const std::string &name) { for (auto &desc : descriptors) { if (desc.name == name) return &desc; } return nullptr; } struct BufferMemberInfo { uint32_t offset, size, arrayCount, arrayStride; }; typedef std::map<std::string, BufferMemberInfo> BufferMemberInfos; struct BufferInfo { std::string name; uint32_t set; ShaderStageFlags shaderStages; BufferMemberInfos memberInfos; }; typedef std::map<std::string, BufferInfo> BufferInfos; inline BufferInfo *findUniformBufferInfo(const std::string &name) { auto it = uniformBufferInfos.find(name); if (it == uniformBufferInfos.end()) return nullptr; return &it->second; } inline BufferInfo *findStorageBufferInfo(const std::string &name) { auto it = shaderStorageBufferInfos.find(name); if (it == shaderStorageBufferInfos.end()) return nullptr; return &it->second; } BufferInfos uniformBufferInfos, shaderStorageBufferInfos; void initBindings(std::ifstream &in, ShaderStageFlags shaderStages); void initBindings(const std::string &filename, ShaderStageFlags shaderStages); }; class VertexShaderModule : public ShaderModule { public: static std::unique_ptr<VertexShaderModule> create(Device *device, const std::string &filename); virtual ~VertexShaderModule() {} struct AttributeDescription { std::string semantic; uint32_t location; VertexFormat format; std::string name; uint32_t count, elementSize; }; std::vector<AttributeDescription> attributes; inline AttributeDescription *findAttribute(const std::string &name) { for (auto &attr : attributes) { if (attr.name == name) return &attr; } return nullptr; } void initBindings(const std::string &filename); }; class FragmentShaderModule : public ShaderModule { public: static std::unique_ptr<FragmentShaderModule> create(Device *device, const std::string &filename); virtual ~FragmentShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_FRAGMENT_BIT); } }; class ComputeShaderModule : public ShaderModule { public: static std::unique_ptr<ComputeShaderModule> create(Device *device, const std::string &filename); virtual ~ComputeShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_COMPUTE_BIT); } }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/ShaderModule.h"},{"location":"api/Files/ShaderModule_8h/#srcngfxgraphicsshadermoduleh","text":"","title":"src/ngfx/graphics/ShaderModule.h"},{"location":"api/Files/ShaderModule_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ShaderModule_8h/#classes","text":"Name class ngfx::ShaderModule struct ngfx::ShaderModule::DescriptorInfo struct ngfx::ShaderModule::BufferMemberInfo struct ngfx::ShaderModule::BufferInfo class ngfx::VertexShaderModule struct ngfx::VertexShaderModule::AttributeDescription class ngfx::FragmentShaderModule class ngfx::ComputeShaderModule","title":"Classes"},{"location":"api/Files/ShaderModule_8h/#defines","text":"Name ENABLE_NGL_INTEGRATION","title":"Defines"},{"location":"api/Files/ShaderModule_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/ShaderModule_8h/#define-enable_ngl_integration","text":"#define ENABLE_NGL_INTEGRATION","title":"define ENABLE_NGL_INTEGRATION"},{"location":"api/Files/ShaderModule_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <map> #include <memory> #include <string> #include <vector> #define ENABLE_NGL_INTEGRATION namespace ngfx { class ShaderModule { public: virtual ~ShaderModule() {} struct DescriptorInfo { std::string name; uint32_t set; DescriptorType type; }; typedef std::vector<DescriptorInfo> DescriptorInfos; DescriptorInfos descriptors; inline DescriptorInfo *findDescriptorInfo(const std::string &name) { for (auto &desc : descriptors) { if (desc.name == name) return &desc; } return nullptr; } struct BufferMemberInfo { uint32_t offset, size, arrayCount, arrayStride; }; typedef std::map<std::string, BufferMemberInfo> BufferMemberInfos; struct BufferInfo { std::string name; uint32_t set; ShaderStageFlags shaderStages; BufferMemberInfos memberInfos; }; typedef std::map<std::string, BufferInfo> BufferInfos; inline BufferInfo *findUniformBufferInfo(const std::string &name) { auto it = uniformBufferInfos.find(name); if (it == uniformBufferInfos.end()) return nullptr; return &it->second; } inline BufferInfo *findStorageBufferInfo(const std::string &name) { auto it = shaderStorageBufferInfos.find(name); if (it == shaderStorageBufferInfos.end()) return nullptr; return &it->second; } BufferInfos uniformBufferInfos, shaderStorageBufferInfos; void initBindings(std::ifstream &in, ShaderStageFlags shaderStages); void initBindings(const std::string &filename, ShaderStageFlags shaderStages); }; class VertexShaderModule : public ShaderModule { public: static std::unique_ptr<VertexShaderModule> create(Device *device, const std::string &filename); virtual ~VertexShaderModule() {} struct AttributeDescription { std::string semantic; uint32_t location; VertexFormat format; std::string name; uint32_t count, elementSize; }; std::vector<AttributeDescription> attributes; inline AttributeDescription *findAttribute(const std::string &name) { for (auto &attr : attributes) { if (attr.name == name) return &attr; } return nullptr; } void initBindings(const std::string &filename); }; class FragmentShaderModule : public ShaderModule { public: static std::unique_ptr<FragmentShaderModule> create(Device *device, const std::string &filename); virtual ~FragmentShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_FRAGMENT_BIT); } }; class ComputeShaderModule : public ShaderModule { public: static std::unique_ptr<ComputeShaderModule> create(Device *device, const std::string &filename); virtual ~ComputeShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_COMPUTE_BIT); } }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ShaderTools_8cpp/","text":"src/ngfx/graphics/ShaderTools.cpp Functions Name string getEnv (const string & name) json * getEntry (const json & data, const string & key) shaderc_shader_kind toShaderKind (const string & ext) Attributes Name auto readFile auto writeFile auto toLower Defines Name V (func) PATCH Functions Documentation function getEnv static string getEnv( const string & name ) function getEntry static json * getEntry( const json & data, const string & key ) function toShaderKind static shaderc_shader_kind toShaderKind( const string & ext ) Attributes Documentation variable readFile auto readFile = FileUtil::readFile; variable writeFile auto writeFile = FileUtil::writeFile; variable toLower auto toLower = StringUtil::toLower; Macro Documentation define V #define V( func ) { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ } define PATCH #define PATCH string(\"patch\") Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ShaderTools.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/FileUtil.h\" #include \"ngfx/core/StringUtil.h\" #include <cctype> #include <filesystem> #include <fstream> #include <regex> #include <set> #include <spirv_cross/spirv_glsl.hpp> #include <spirv_cross/spirv_hlsl.hpp> #include <spirv_cross/spirv_msl.hpp> #include <spirv_cross/spirv_reflect.hpp> #include <sstream> using namespace std; using namespace ngfx; auto readFile = FileUtil::readFile; auto writeFile = FileUtil::writeFile; auto toLower = StringUtil::toLower; namespace fs = std::filesystem; #define V(func) \\ { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ } #ifdef _WIN32 #define PATCH string(\"patch.exe\") #else #define PATCH string(\"patch\") #endif static string getEnv(const string &name) { char *value = getenv(name.c_str()); return (value ? value : \"\"); } static json *getEntry(const json &data, const string &key) { auto it = data.find(key); if (it == data.end()) return nullptr; return (json *)&it.value(); } ShaderTools::ShaderTools(bool verbose) : verbose(verbose) { defaultIncludePaths = {\"ngfx/data/shaders\", \"nodegl/data/shaders\"}; } int ShaderTools::cmd(string str) { if (verbose) { NGFX_LOG(\">> %s\", str.c_str()); } else str += \" >> /dev/null 2>&1\"; return system(str.c_str()); } bool ShaderTools::findIncludeFile(const string &includeFilename, const vector<string> &includePaths, string &includeFile) { for (const string &includePath : includePaths) { fs::path filename = includePath / fs::path(includeFilename); if (fs::exists(filename)) { includeFile = filename.string(); return true; } } return false; } int ShaderTools::preprocess(const string &src, const string &dataPath, string &dst) { dst = \"\"; vector<string> includePaths = defaultIncludePaths; includePaths.push_back(dataPath); istringstream sstream(src); string line; while (std::getline(sstream, line)) { smatch matchIncludeGroups; bool matchInclude = regex_search(line, matchIncludeGroups, regex(\"#include \\\"([^\\\"]*)\")); if (matchInclude) { string includeFilename = matchIncludeGroups[1]; string includeFilePath; findIncludeFile(includeFilename, includePaths, includeFilePath); dst += readFile(includeFilePath); } else { dst += line + \"\\n\"; } } return 0; } int ShaderTools::compileShaderGLSL( const string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, string &spv, bool verbose, shaderc_optimization_level optimizationLevel) { shaderc::Compiler compiler; shaderc::CompileOptions compileOptions; for (const MacroDefinition &define : defines) { compileOptions.AddMacroDefinition(define.name, define.value); } compileOptions.SetOptimizationLevel(optimizationLevel); compileOptions.SetGenerateDebugInfo(); auto result = compiler.CompileGlslToSpv(src, shaderKind, \"\", compileOptions); if (result.GetCompilationStatus() != shaderc_compilation_status_success) { NGFX_ERR(\"cannot compile file: %s\", result.GetErrorMessage().c_str()); return 1; } spv = string((const char *)result.cbegin(), sizeof(uint32_t) * (result.cend() - result.cbegin())); return 0; } int ShaderTools::removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst) { int ret = 0; string spv; V(compileShaderGLSL(src, shaderKind, defines, spv, false)); spirv_cross::CompilerGLSL compilerGLSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto activeVariables = compilerGLSL.get_active_interface_variables(); compilerGLSL.get_shader_resources(activeVariables); compilerGLSL.set_enabled_interface_variables(move(activeVariables)); spirv_cross::CompilerGLSL::Options opts; opts.vulkan_semantics = true; compilerGLSL.set_common_options(opts); dst = compilerGLSL.compile(); return 0; } int ShaderTools::patchShaderLayoutsGLSL(const string &src, string &dst) { dst = \"\"; istringstream sstream(src); string line; while (std::getline(sstream, line)) { // Patch GLSL shader layouts smatch g; bool matchLayout = regex_search(line, g, regex(\"^(.*)\" \"layout\\\\s*\\\\(\" \"([^)]*)\" \"binding[\\\\s]*=[\\\\s]*\" \"([\\\\d]+)\" \"([^)]*)\" \"\\\\)\" \"(.*)\\r*$\")); if (matchLayout) { dst += g[1].str() + \"layout(\" + g[2].str() + \"set = \" + g[3].str() + \", binding = 0\" + g[4].str() + \")\" + g[5].str() + \"\\n\"; } else { dst += line + \"\\n\"; } } return 0; } static shaderc_shader_kind toShaderKind(const string &ext) { static const map<string, shaderc_shader_kind> shaderKindMap = { {\".vert\", shaderc_vertex_shader}, {\".frag\", shaderc_fragment_shader}, {\".comp\", shaderc_compute_shader}}; return shaderKindMap.at(ext); } int ShaderTools::compileShaderGLSL(string filename, const MacroDefinitions &defines, const string &outDir, vector<string> &outFiles, int flags) { string parentPath = fs::path(filename).parent_path().string(); filename = fs::path(filename).filename().string(); string inFileName = fs::path(parentPath + \"/\" + filename).make_preferred().string(); string outFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string src, dst; int ret = 0; src = FileUtil::readFile(inFileName); string ext = FileUtil::splitExt(inFileName)[1]; shaderc_shader_kind shaderKind = toShaderKind(ext); if (flags & REMOVE_UNUSED_VARIABLES) { V(removeUnusedVariablesGLSL(src, shaderKind, defines, dst)); src = move(dst); } if (flags & PATCH_SHADER_LAYOUTS_GLSL) { V(patchShaderLayoutsGLSL(src, dst)); src = move(dst); } V(compileShaderGLSL(src, shaderKind, defines, dst)); writeFile(outFileName, dst); outFiles.push_back(outFileName); return 0; } int ShaderTools::compileShaderMSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".metal\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".metallib\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string debugFlags = \"-gline-tables-only -MO\"; int result = cmd(\"xcrun -sdk macosx metal \" + debugFlags + \" -c \" + inFileName + \" -o \" + outDir + \"/\" + strippedFilename + \".air && \" \"xcrun -sdk macosx metallib \" + outDir + \"/\" + strippedFilename + \".air -o \" + outFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::compileShaderHLSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".hlsl\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".dxc\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string shaderModel = \"\"; if (strstr(inFileName.c_str(), \".vert\")) shaderModel = \"vs_5_0\"; else if (strstr(inFileName.c_str(), \".frag\")) shaderModel = \"ps_5_0\"; else if (strstr(inFileName.c_str(), \".comp\")) shaderModel = \"cs_5_0\"; int result = cmd(\"dxc.exe /T \" + shaderModel + \" /Fo \" + outFileName + \" \" + inFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::convertSPVToMSL(const string &spv, shaderc_shader_kind shaderKind, string &msl) { spirv_cross::CompilerMSL compilerMSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); msl = compilerMSL.compile(); return 0; } int ShaderTools::convertSPVToHLSL(const string &spv, shaderc_shader_kind shaderKind, string &hlsl, uint32_t shaderModel) { spirv_cross::CompilerHLSL compilerHLSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto options = compilerHLSL.get_hlsl_options(); options.shader_model = shaderModel; compilerHLSL.set_hlsl_options(options); hlsl = compilerHLSL.compile(); return 0; } int ShaderTools::convertShader(const string &file, const string &extraArgs, string outDir, Format fmt, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string strippedFilename = splitFilename[0]; string ext = FileUtil::splitExt(strippedFilename)[1]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".spv\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + (fmt == FORMAT_MSL ? \".metal\" : \".hlsl\")) .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string spv = FileUtil::readFile(inFileName), dst; int result; if (fmt == FORMAT_MSL) { result = convertSPVToMSL(spv, toShaderKind(ext), dst); } else { result = convertSPVToHLSL(spv, toShaderKind(ext), dst); } FileUtil::writeFile(outFileName, dst); string args = (fmt == FORMAT_MSL ? \"--msl\" : \"--hlsl --shader-model 60\") + extraArgs; if (result == 0) NGFX_LOG(\"converted file: %s to %s\", inFileName.c_str(), outFileName.c_str()); else NGFX_ERR(\"cannot convert file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } bool ShaderTools::findMetalReflectData( const vector<RegexUtil::Match> &metalReflectData, const string &name, RegexUtil::Match &match) { for (const RegexUtil::Match &data : metalReflectData) { if (data.s[2] == name) { match = data; return true; } else if (strstr(data.s[1].c_str(), name.c_str())) { match = data; return true; } } return false; } int ShaderTools::patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect) { auto glslReflectJson = json::parse(glslReflect); MetalReflectData metalReflectData; if (ext == \".vert\") { metalReflectData.attributes = RegexUtil::findAll(regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[\" \"attribute\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); } metalReflectData.buffers = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[buffer\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); metalReflectData.textures = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[texture\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); uint32_t numDescriptors = (textures ? textures->size() : 0) + (images ? images->size() : 0) + (ubos ? ubos->size() : 0) + (ssbos ? ssbos->size() : 0); // update input bindings if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { RegexUtil::Match metalInputReflectData; bool foundMatch = findMetalReflectData( metalReflectData.attributes, input[\"name\"], metalInputReflectData); if (!foundMatch) { return 1; } input[\"location\"] = stoi(metalInputReflectData.s[3]) + numDescriptors; } } // update descriptor bindings if (textures) for (json &descriptor : *textures) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } if (ubos) for (json &descriptor : *ubos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (ssbos) for (json &descriptor : *ssbos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (images) for (json &descriptor : *images) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } mslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect) { auto glslReflectJson = json::parse(glslReflect); HLSLReflectData hlslReflectData; // parse semantics if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { regex p(input[\"name\"].get<string>() + \"\\\\s*:\\\\s*([^;]*);\"); vector<RegexUtil::Match> hlslReflectData = RegexUtil::findAll(p, hlsl); input[\"semantic\"] = hlslReflectData[0].s[1]; } } // get descriptors json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); map<int, json *> descriptors; if (textures) for (auto &desc : *textures) descriptors[desc[\"set\"].get<int>()] = &desc; if (ubos) for (auto &desc : *ubos) descriptors[desc[\"set\"].get<int>()] = &desc; if (ssbos) for (auto &desc : *ssbos) descriptors[desc[\"set\"].get<int>()] = &desc; if (images) for (auto &desc : *images) descriptors[desc[\"set\"].get<int>()] = &desc; // patch descriptor bindings set<int> sets; set<string> samplerTypes = {\"sampler2D\", \"sampler3D\", \"samplerCube\"}; for (const auto &kv : descriptors) { uint32_t set = kv.first; json &desc = *kv.second; while (sets.find(set) != sets.end()) set += 1; desc[\"set\"] = set; sets.insert(set); if (samplerTypes.find(desc[\"type\"]) != samplerTypes.end()) sets.insert(set + 1); } hlslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::genShaderReflectionGLSL(const string &, const string &ext, const string &spv, string &glslMap) { spirv_cross::CompilerReflection compilerReflection( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto reflectOutput = compilerReflection.compile(); glslMap = json::parse(reflectOutput).dump(4); return 0; } int ShaderTools::genShaderReflectionMSL(const string &msl, const string &ext, const string &spv, string &mslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataMSL(glslReflect, ext, msl, mslMap); } int ShaderTools::genShaderReflectionHLSL(const string &hlsl, const string &ext, const string &spv, string &hlslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataHLSL(glslReflect, ext, hlsl, hlslMap); } string ShaderTools::parseReflectionData(const json &reflectData, string ext) { string contents = \"\"; if (ext == \".vert\") { json *inputs = getEntry(reflectData, \"inputs\"); contents += \"INPUT_ATTRIBUTES \" + to_string(inputs->size()) + \"\\n\"; for (const json &input : *inputs) { string inputName = input[\"name\"]; string inputSemantic = \"\"; string inputNameLower = toLower(inputName); inputSemantic = \"UNDEFINED\"; if (input.find(\"semantic\") != input.end()) inputSemantic = input[\"semantic\"]; map<string, string> inputTypeMap = { {\"float\", \"VERTEXFORMAT_FLOAT\"}, {\"vec2\", \"VERTEXFORMAT_FLOAT2\"}, {\"vec3\", \"VERTEXFORMAT_FLOAT3\"}, {\"vec4\", \"VERTEXFORMAT_FLOAT4\"}, {\"ivec2\", \"VERTEXFORMAT_INT2\"}, {\"ivec3\", \"VERTEXFORMAT_INT3\"}, {\"ivec4\", \"VERTEXFORMAT_INT4\"}, {\"mat2\", \"VERTEXFORMAT_MAT2\"}, {\"mat3\", \"VERTEXFORMAT_MAT3\"}, {\"mat4\", \"VERTEXFORMAT_MAT4\"}}; string inputType = inputTypeMap[input[\"type\"]]; contents += \"\\t\" + inputName + \" \" + inputSemantic + \" \" + to_string(input[\"location\"].get<int>()) + \" \" + inputType + \"\\n\"; } } json *textures = getEntry(reflectData, \"textures\"), *ubos = getEntry(reflectData, \"ubos\"), *ssbos = getEntry(reflectData, \"ssbos\"), *images = getEntry(reflectData, \"images\"), *types = getEntry(reflectData, \"types\"); json uniformBufferInfos; json shaderStorageBufferInfos; std::function<void(const json &, json &, uint32_t, string)> parseMembers = [&](const json &membersData, json &members, uint32_t baseOffset = 0, string baseName = \"\") { for (const json &memberData : membersData) { const map<string, int> typeSizeMap = { {\"int\", 4}, {\"uint\", 4}, {\"float\", 4}, {\"vec2\", 8}, {\"vec3\", 12}, {\"vec4\", 16}, {\"ivec2\", 8}, {\"ivec3\", 12}, {\"ivec4\", 16}, {\"uvec2\", 8}, {\"uvec3\", 12}, {\"uvec4\", 16}, {\"mat2\", 16}, {\"mat3\", 36}, {\"mat4\", 64}}; string memberType = memberData[\"type\"]; if (typeSizeMap.find(memberType) != typeSizeMap.end()) { json member = memberData; member[\"name\"] = baseName + member[\"name\"].get<string>(); member[\"size\"] = typeSizeMap.at(memberType); member[\"offset\"] = member[\"offset\"].get<int>() + baseOffset; member[\"array_count\"] = (member.find(\"array\") != member.end()) ? member[\"array\"][0].get<int>() : 0; member[\"array_stride\"] = (member.find(\"array_stride\") != member.end()) ? member[\"array_stride\"].get<int>() : 0; members.push_back(member); } else if (types->find(memberType) != types->end()) { const json &type = (*types)[memberType]; parseMembers(type[\"members\"], members, baseOffset + memberData[\"offset\"].get<int>(), baseName + memberData[\"name\"].get<string>() + \".\"); } else NGFX_ERR(\"unrecognized type: {memberType}\"); } }; auto parseBuffers = [&](const json &buffers, json &bufferInfos) { for (const json &buffer : buffers) { const json &bufferType = (*types)[buffer[\"type\"].get<string>()]; json bufferMembers = {}; parseMembers(bufferType[\"members\"], bufferMembers, 0, \"\"); json bufferInfo = {{\"name\", buffer[\"name\"].get<string>()}, {\"set\", buffer[\"set\"].get<int>()}, {\"binding\", buffer[\"binding\"].get<int>()}, {\"members\", bufferMembers}}; bufferInfos.push_back(bufferInfo); } }; if (ubos) parseBuffers(*ubos, uniformBufferInfos); if (ssbos) parseBuffers(*ssbos, shaderStorageBufferInfos); json textureDescriptors = {}; json bufferDescriptors = {}; if (textures) for (const json &texture : *textures) { textureDescriptors[to_string(texture[\"set\"].get<int>())] = { {\"type\", texture[\"type\"]}, {\"name\", texture[\"name\"]}, {\"set\", texture[\"set\"]}, {\"binding\", texture[\"binding\"]}}; } if (images) for (const json &image : *images) { textureDescriptors[to_string(image[\"set\"].get<int>())] = { {\"type\", image[\"type\"]}, {\"name\", image[\"name\"]}, {\"set\", image[\"set\"]}, {\"binding\", image[\"binding\"]}}; } if (ubos) for (const json &ubo : *ubos) { bufferDescriptors[to_string(ubo[\"set\"].get<int>())] = { {\"type\", \"uniformBuffer\"}, {\"name\", ubo[\"name\"]}, {\"set\", ubo[\"set\"]}, {\"binding\", ubo[\"binding\"]}}; } if (ssbos) for (const json &ssbo : *ssbos) { bufferDescriptors[to_string(ssbo[\"set\"].get<int>())] = { {\"type\", \"shaderStorageBuffer\"}, {\"name\", ssbo[\"name\"]}, {\"set\", ssbo[\"set\"]}, {\"binding\", ssbo[\"binding\"]}}; } contents += \"DESCRIPTORS \" + to_string(textureDescriptors.size() + bufferDescriptors.size()) + \"\\n\"; map<string, string> descriptorTypeMap = { {\"sampler2D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"sampler3D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"samplerCube\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"image2D\", \"DESCRIPTOR_TYPE_STORAGE_IMAGE\"}, {\"uniformBuffer\", \"DESCRIPTOR_TYPE_UNIFORM_BUFFER\"}, {\"shaderStorageBuffer\", \"DESCRIPTOR_TYPE_STORAGE_BUFFER\"}}; for (auto &[key, val] : textureDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } for (auto &[key, val] : bufferDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } auto processBufferInfos = [&](const json &bufferInfo) -> string { string contents = \"\"; const json &memberInfos = bufferInfo[\"members\"]; contents += bufferInfo[\"name\"].get<string>() + \" \" + to_string(bufferInfo[\"set\"].get<int>()) + \" \" + to_string(memberInfos.size()) + \"\\n\"; for (const json &m : memberInfos) { contents += m[\"name\"].get<string>() + \" \" + to_string(m[\"offset\"].get<int>()) + \" \" + to_string(m[\"size\"].get<int>()) + \" \" + to_string(m[\"array_count\"].get<int>()) + \" \" + to_string(m[\"array_stride\"].get<int>()) + \"\\n\"; } return contents; }; contents += \"UNIFORM_BUFFER_INFOS \" + to_string(uniformBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : uniformBufferInfos) { contents += processBufferInfos(bufferInfo); } contents += \"SHADER_STORAGE_BUFFER_INFOS \" + to_string(shaderStorageBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : shaderStorageBufferInfos) { contents += processBufferInfos(bufferInfo); } return contents; } int ShaderTools::generateShaderMapGLSL(const string &file, string outDir, vector<string> &outFiles) { string filename = fs::path(file).filename().string(); string ext = FileUtil::splitExt(filename)[1]; string glslFileName = fs::path(outDir + \"/\" + filename).make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); string glslMapFileName = fs::path(outDir + \"/\" + filename + \".map\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(glslFileName, glslMapFileName)) { outFiles.push_back(glslMapFileName); return 0; } string glsl = \"\", spv = readFile(spvFileName), glslReflect; genShaderReflectionGLSL(glsl, ext, spv, glslReflect); auto glslReflectJson = json::parse(glslReflect); string glslMap = parseReflectionData(glslReflectJson, ext); writeFile(glslMapFileName, glslMap); outFiles.push_back(glslMapFileName); return 0; } int ShaderTools::generateShaderMapMSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string mslFileName = fs::path(outDir + \"/\" + glslFilename + \".metal\") .make_preferred() .string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string mslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".metal.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(mslFileName, mslMapFileName)) { outFiles.push_back(mslMapFileName); return 0; } string msl = readFile(mslFileName), spv = readFile(spvFileName), mslReflect; genShaderReflectionMSL(msl, ext, spv, mslReflect); auto mslReflectJson = json::parse(mslReflect); string mslMap = parseReflectionData(mslReflectJson, ext); writeFile(mslMapFileName, mslMap); outFiles.push_back(mslMapFileName); return 0; } int ShaderTools::generateShaderMapHLSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string hlslFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl\").make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string hlslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(hlslFileName, hlslMapFileName)) { outFiles.push_back(hlslMapFileName); return 0; } string hlsl = readFile(hlslFileName), spv = readFile(spvFileName), hlslReflect; genShaderReflectionHLSL(hlsl, ext, spv, hlslReflect); auto hlslReflectJson = json::parse(hlslReflect); string hlslMap = parseReflectionData(hlslReflectJson, ext); writeFile(hlslMapFileName, hlslMap); outFiles.push_back(hlslMapFileName); return 0; } vector<string> ShaderTools::convertShaders(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) convertShader(file, \"\", outDir, fmt, outFiles); return outFiles; } vector<string> ShaderTools::compileShaders(const vector<string> &files, string outDir, Format fmt, const MacroDefinitions &defines, int flags) { #ifdef GRAPHICS_BACKEND_VULKAN defines += \" -DGRAPHICS_BACKEND_VULKAN=1\"; #endif vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) compileShaderGLSL(file, defines, outDir, outFiles, flags); else if (fmt == FORMAT_MSL) compileShaderMSL(file, defines, outDir, outFiles); else if (fmt == FORMAT_HLSL) compileShaderHLSL(file, defines, outDir, outFiles); } return outFiles; } void ShaderTools::applyPatches(const vector<string> &patchFiles, string outDir) { for (const string &patchFile : patchFiles) { string filename = FileUtil::splitExt(fs::path(patchFile).string())[0]; NGFX_LOG(\"filename: %s\", filename.c_str()); string outFile = fs::path(outDir + \"/\" + filename).make_preferred().string(); if (fs::exists(outFile)) { NGFX_LOG(\"applying patch: {patchFile}\"); string cmdStr = PATCH + \" -N -u \" + outFile + \" -i \" + patchFile; cmd(cmdStr); } } } vector<string> ShaderTools::generateShaderMaps(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) generateShaderMapGLSL(file, outDir, outFiles); else if (fmt == FORMAT_MSL) generateShaderMapMSL(file, outDir, outFiles); else if (fmt == FORMAT_HLSL) generateShaderMapHLSL(file, outDir, outFiles); } return outFiles; } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/ShaderTools.cpp"},{"location":"api/Files/ShaderTools_8cpp/#srcngfxgraphicsshadertoolscpp","text":"","title":"src/ngfx/graphics/ShaderTools.cpp"},{"location":"api/Files/ShaderTools_8cpp/#functions","text":"Name string getEnv (const string & name) json * getEntry (const json & data, const string & key) shaderc_shader_kind toShaderKind (const string & ext)","title":"Functions"},{"location":"api/Files/ShaderTools_8cpp/#attributes","text":"Name auto readFile auto writeFile auto toLower","title":"Attributes"},{"location":"api/Files/ShaderTools_8cpp/#defines","text":"Name V (func) PATCH","title":"Defines"},{"location":"api/Files/ShaderTools_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/ShaderTools_8cpp/#function-getenv","text":"static string getEnv( const string & name )","title":"function getEnv"},{"location":"api/Files/ShaderTools_8cpp/#function-getentry","text":"static json * getEntry( const json & data, const string & key )","title":"function getEntry"},{"location":"api/Files/ShaderTools_8cpp/#function-toshaderkind","text":"static shaderc_shader_kind toShaderKind( const string & ext )","title":"function toShaderKind"},{"location":"api/Files/ShaderTools_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/ShaderTools_8cpp/#variable-readfile","text":"auto readFile = FileUtil::readFile;","title":"variable readFile"},{"location":"api/Files/ShaderTools_8cpp/#variable-writefile","text":"auto writeFile = FileUtil::writeFile;","title":"variable writeFile"},{"location":"api/Files/ShaderTools_8cpp/#variable-tolower","text":"auto toLower = StringUtil::toLower;","title":"variable toLower"},{"location":"api/Files/ShaderTools_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/ShaderTools_8cpp/#define-v","text":"#define V( func ) { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ }","title":"define V"},{"location":"api/Files/ShaderTools_8cpp/#define-patch","text":"#define PATCH string(\"patch\")","title":"define PATCH"},{"location":"api/Files/ShaderTools_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ShaderTools.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/FileUtil.h\" #include \"ngfx/core/StringUtil.h\" #include <cctype> #include <filesystem> #include <fstream> #include <regex> #include <set> #include <spirv_cross/spirv_glsl.hpp> #include <spirv_cross/spirv_hlsl.hpp> #include <spirv_cross/spirv_msl.hpp> #include <spirv_cross/spirv_reflect.hpp> #include <sstream> using namespace std; using namespace ngfx; auto readFile = FileUtil::readFile; auto writeFile = FileUtil::writeFile; auto toLower = StringUtil::toLower; namespace fs = std::filesystem; #define V(func) \\ { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ } #ifdef _WIN32 #define PATCH string(\"patch.exe\") #else #define PATCH string(\"patch\") #endif static string getEnv(const string &name) { char *value = getenv(name.c_str()); return (value ? value : \"\"); } static json *getEntry(const json &data, const string &key) { auto it = data.find(key); if (it == data.end()) return nullptr; return (json *)&it.value(); } ShaderTools::ShaderTools(bool verbose) : verbose(verbose) { defaultIncludePaths = {\"ngfx/data/shaders\", \"nodegl/data/shaders\"}; } int ShaderTools::cmd(string str) { if (verbose) { NGFX_LOG(\">> %s\", str.c_str()); } else str += \" >> /dev/null 2>&1\"; return system(str.c_str()); } bool ShaderTools::findIncludeFile(const string &includeFilename, const vector<string> &includePaths, string &includeFile) { for (const string &includePath : includePaths) { fs::path filename = includePath / fs::path(includeFilename); if (fs::exists(filename)) { includeFile = filename.string(); return true; } } return false; } int ShaderTools::preprocess(const string &src, const string &dataPath, string &dst) { dst = \"\"; vector<string> includePaths = defaultIncludePaths; includePaths.push_back(dataPath); istringstream sstream(src); string line; while (std::getline(sstream, line)) { smatch matchIncludeGroups; bool matchInclude = regex_search(line, matchIncludeGroups, regex(\"#include \\\"([^\\\"]*)\")); if (matchInclude) { string includeFilename = matchIncludeGroups[1]; string includeFilePath; findIncludeFile(includeFilename, includePaths, includeFilePath); dst += readFile(includeFilePath); } else { dst += line + \"\\n\"; } } return 0; } int ShaderTools::compileShaderGLSL( const string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, string &spv, bool verbose, shaderc_optimization_level optimizationLevel) { shaderc::Compiler compiler; shaderc::CompileOptions compileOptions; for (const MacroDefinition &define : defines) { compileOptions.AddMacroDefinition(define.name, define.value); } compileOptions.SetOptimizationLevel(optimizationLevel); compileOptions.SetGenerateDebugInfo(); auto result = compiler.CompileGlslToSpv(src, shaderKind, \"\", compileOptions); if (result.GetCompilationStatus() != shaderc_compilation_status_success) { NGFX_ERR(\"cannot compile file: %s\", result.GetErrorMessage().c_str()); return 1; } spv = string((const char *)result.cbegin(), sizeof(uint32_t) * (result.cend() - result.cbegin())); return 0; } int ShaderTools::removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst) { int ret = 0; string spv; V(compileShaderGLSL(src, shaderKind, defines, spv, false)); spirv_cross::CompilerGLSL compilerGLSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto activeVariables = compilerGLSL.get_active_interface_variables(); compilerGLSL.get_shader_resources(activeVariables); compilerGLSL.set_enabled_interface_variables(move(activeVariables)); spirv_cross::CompilerGLSL::Options opts; opts.vulkan_semantics = true; compilerGLSL.set_common_options(opts); dst = compilerGLSL.compile(); return 0; } int ShaderTools::patchShaderLayoutsGLSL(const string &src, string &dst) { dst = \"\"; istringstream sstream(src); string line; while (std::getline(sstream, line)) { // Patch GLSL shader layouts smatch g; bool matchLayout = regex_search(line, g, regex(\"^(.*)\" \"layout\\\\s*\\\\(\" \"([^)]*)\" \"binding[\\\\s]*=[\\\\s]*\" \"([\\\\d]+)\" \"([^)]*)\" \"\\\\)\" \"(.*)\\r*$\")); if (matchLayout) { dst += g[1].str() + \"layout(\" + g[2].str() + \"set = \" + g[3].str() + \", binding = 0\" + g[4].str() + \")\" + g[5].str() + \"\\n\"; } else { dst += line + \"\\n\"; } } return 0; } static shaderc_shader_kind toShaderKind(const string &ext) { static const map<string, shaderc_shader_kind> shaderKindMap = { {\".vert\", shaderc_vertex_shader}, {\".frag\", shaderc_fragment_shader}, {\".comp\", shaderc_compute_shader}}; return shaderKindMap.at(ext); } int ShaderTools::compileShaderGLSL(string filename, const MacroDefinitions &defines, const string &outDir, vector<string> &outFiles, int flags) { string parentPath = fs::path(filename).parent_path().string(); filename = fs::path(filename).filename().string(); string inFileName = fs::path(parentPath + \"/\" + filename).make_preferred().string(); string outFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string src, dst; int ret = 0; src = FileUtil::readFile(inFileName); string ext = FileUtil::splitExt(inFileName)[1]; shaderc_shader_kind shaderKind = toShaderKind(ext); if (flags & REMOVE_UNUSED_VARIABLES) { V(removeUnusedVariablesGLSL(src, shaderKind, defines, dst)); src = move(dst); } if (flags & PATCH_SHADER_LAYOUTS_GLSL) { V(patchShaderLayoutsGLSL(src, dst)); src = move(dst); } V(compileShaderGLSL(src, shaderKind, defines, dst)); writeFile(outFileName, dst); outFiles.push_back(outFileName); return 0; } int ShaderTools::compileShaderMSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".metal\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".metallib\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string debugFlags = \"-gline-tables-only -MO\"; int result = cmd(\"xcrun -sdk macosx metal \" + debugFlags + \" -c \" + inFileName + \" -o \" + outDir + \"/\" + strippedFilename + \".air && \" \"xcrun -sdk macosx metallib \" + outDir + \"/\" + strippedFilename + \".air -o \" + outFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::compileShaderHLSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".hlsl\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".dxc\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string shaderModel = \"\"; if (strstr(inFileName.c_str(), \".vert\")) shaderModel = \"vs_5_0\"; else if (strstr(inFileName.c_str(), \".frag\")) shaderModel = \"ps_5_0\"; else if (strstr(inFileName.c_str(), \".comp\")) shaderModel = \"cs_5_0\"; int result = cmd(\"dxc.exe /T \" + shaderModel + \" /Fo \" + outFileName + \" \" + inFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::convertSPVToMSL(const string &spv, shaderc_shader_kind shaderKind, string &msl) { spirv_cross::CompilerMSL compilerMSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); msl = compilerMSL.compile(); return 0; } int ShaderTools::convertSPVToHLSL(const string &spv, shaderc_shader_kind shaderKind, string &hlsl, uint32_t shaderModel) { spirv_cross::CompilerHLSL compilerHLSL((const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto options = compilerHLSL.get_hlsl_options(); options.shader_model = shaderModel; compilerHLSL.set_hlsl_options(options); hlsl = compilerHLSL.compile(); return 0; } int ShaderTools::convertShader(const string &file, const string &extraArgs, string outDir, Format fmt, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string strippedFilename = splitFilename[0]; string ext = FileUtil::splitExt(strippedFilename)[1]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".spv\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + (fmt == FORMAT_MSL ? \".metal\" : \".hlsl\")) .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string spv = FileUtil::readFile(inFileName), dst; int result; if (fmt == FORMAT_MSL) { result = convertSPVToMSL(spv, toShaderKind(ext), dst); } else { result = convertSPVToHLSL(spv, toShaderKind(ext), dst); } FileUtil::writeFile(outFileName, dst); string args = (fmt == FORMAT_MSL ? \"--msl\" : \"--hlsl --shader-model 60\") + extraArgs; if (result == 0) NGFX_LOG(\"converted file: %s to %s\", inFileName.c_str(), outFileName.c_str()); else NGFX_ERR(\"cannot convert file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } bool ShaderTools::findMetalReflectData( const vector<RegexUtil::Match> &metalReflectData, const string &name, RegexUtil::Match &match) { for (const RegexUtil::Match &data : metalReflectData) { if (data.s[2] == name) { match = data; return true; } else if (strstr(data.s[1].c_str(), name.c_str())) { match = data; return true; } } return false; } int ShaderTools::patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect) { auto glslReflectJson = json::parse(glslReflect); MetalReflectData metalReflectData; if (ext == \".vert\") { metalReflectData.attributes = RegexUtil::findAll(regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[\" \"attribute\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); } metalReflectData.buffers = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[buffer\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); metalReflectData.textures = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[texture\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); uint32_t numDescriptors = (textures ? textures->size() : 0) + (images ? images->size() : 0) + (ubos ? ubos->size() : 0) + (ssbos ? ssbos->size() : 0); // update input bindings if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { RegexUtil::Match metalInputReflectData; bool foundMatch = findMetalReflectData( metalReflectData.attributes, input[\"name\"], metalInputReflectData); if (!foundMatch) { return 1; } input[\"location\"] = stoi(metalInputReflectData.s[3]) + numDescriptors; } } // update descriptor bindings if (textures) for (json &descriptor : *textures) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } if (ubos) for (json &descriptor : *ubos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (ssbos) for (json &descriptor : *ssbos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (images) for (json &descriptor : *images) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } mslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect) { auto glslReflectJson = json::parse(glslReflect); HLSLReflectData hlslReflectData; // parse semantics if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { regex p(input[\"name\"].get<string>() + \"\\\\s*:\\\\s*([^;]*);\"); vector<RegexUtil::Match> hlslReflectData = RegexUtil::findAll(p, hlsl); input[\"semantic\"] = hlslReflectData[0].s[1]; } } // get descriptors json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); map<int, json *> descriptors; if (textures) for (auto &desc : *textures) descriptors[desc[\"set\"].get<int>()] = &desc; if (ubos) for (auto &desc : *ubos) descriptors[desc[\"set\"].get<int>()] = &desc; if (ssbos) for (auto &desc : *ssbos) descriptors[desc[\"set\"].get<int>()] = &desc; if (images) for (auto &desc : *images) descriptors[desc[\"set\"].get<int>()] = &desc; // patch descriptor bindings set<int> sets; set<string> samplerTypes = {\"sampler2D\", \"sampler3D\", \"samplerCube\"}; for (const auto &kv : descriptors) { uint32_t set = kv.first; json &desc = *kv.second; while (sets.find(set) != sets.end()) set += 1; desc[\"set\"] = set; sets.insert(set); if (samplerTypes.find(desc[\"type\"]) != samplerTypes.end()) sets.insert(set + 1); } hlslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::genShaderReflectionGLSL(const string &, const string &ext, const string &spv, string &glslMap) { spirv_cross::CompilerReflection compilerReflection( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto reflectOutput = compilerReflection.compile(); glslMap = json::parse(reflectOutput).dump(4); return 0; } int ShaderTools::genShaderReflectionMSL(const string &msl, const string &ext, const string &spv, string &mslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataMSL(glslReflect, ext, msl, mslMap); } int ShaderTools::genShaderReflectionHLSL(const string &hlsl, const string &ext, const string &spv, string &hlslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataHLSL(glslReflect, ext, hlsl, hlslMap); } string ShaderTools::parseReflectionData(const json &reflectData, string ext) { string contents = \"\"; if (ext == \".vert\") { json *inputs = getEntry(reflectData, \"inputs\"); contents += \"INPUT_ATTRIBUTES \" + to_string(inputs->size()) + \"\\n\"; for (const json &input : *inputs) { string inputName = input[\"name\"]; string inputSemantic = \"\"; string inputNameLower = toLower(inputName); inputSemantic = \"UNDEFINED\"; if (input.find(\"semantic\") != input.end()) inputSemantic = input[\"semantic\"]; map<string, string> inputTypeMap = { {\"float\", \"VERTEXFORMAT_FLOAT\"}, {\"vec2\", \"VERTEXFORMAT_FLOAT2\"}, {\"vec3\", \"VERTEXFORMAT_FLOAT3\"}, {\"vec4\", \"VERTEXFORMAT_FLOAT4\"}, {\"ivec2\", \"VERTEXFORMAT_INT2\"}, {\"ivec3\", \"VERTEXFORMAT_INT3\"}, {\"ivec4\", \"VERTEXFORMAT_INT4\"}, {\"mat2\", \"VERTEXFORMAT_MAT2\"}, {\"mat3\", \"VERTEXFORMAT_MAT3\"}, {\"mat4\", \"VERTEXFORMAT_MAT4\"}}; string inputType = inputTypeMap[input[\"type\"]]; contents += \"\\t\" + inputName + \" \" + inputSemantic + \" \" + to_string(input[\"location\"].get<int>()) + \" \" + inputType + \"\\n\"; } } json *textures = getEntry(reflectData, \"textures\"), *ubos = getEntry(reflectData, \"ubos\"), *ssbos = getEntry(reflectData, \"ssbos\"), *images = getEntry(reflectData, \"images\"), *types = getEntry(reflectData, \"types\"); json uniformBufferInfos; json shaderStorageBufferInfos; std::function<void(const json &, json &, uint32_t, string)> parseMembers = [&](const json &membersData, json &members, uint32_t baseOffset = 0, string baseName = \"\") { for (const json &memberData : membersData) { const map<string, int> typeSizeMap = { {\"int\", 4}, {\"uint\", 4}, {\"float\", 4}, {\"vec2\", 8}, {\"vec3\", 12}, {\"vec4\", 16}, {\"ivec2\", 8}, {\"ivec3\", 12}, {\"ivec4\", 16}, {\"uvec2\", 8}, {\"uvec3\", 12}, {\"uvec4\", 16}, {\"mat2\", 16}, {\"mat3\", 36}, {\"mat4\", 64}}; string memberType = memberData[\"type\"]; if (typeSizeMap.find(memberType) != typeSizeMap.end()) { json member = memberData; member[\"name\"] = baseName + member[\"name\"].get<string>(); member[\"size\"] = typeSizeMap.at(memberType); member[\"offset\"] = member[\"offset\"].get<int>() + baseOffset; member[\"array_count\"] = (member.find(\"array\") != member.end()) ? member[\"array\"][0].get<int>() : 0; member[\"array_stride\"] = (member.find(\"array_stride\") != member.end()) ? member[\"array_stride\"].get<int>() : 0; members.push_back(member); } else if (types->find(memberType) != types->end()) { const json &type = (*types)[memberType]; parseMembers(type[\"members\"], members, baseOffset + memberData[\"offset\"].get<int>(), baseName + memberData[\"name\"].get<string>() + \".\"); } else NGFX_ERR(\"unrecognized type: {memberType}\"); } }; auto parseBuffers = [&](const json &buffers, json &bufferInfos) { for (const json &buffer : buffers) { const json &bufferType = (*types)[buffer[\"type\"].get<string>()]; json bufferMembers = {}; parseMembers(bufferType[\"members\"], bufferMembers, 0, \"\"); json bufferInfo = {{\"name\", buffer[\"name\"].get<string>()}, {\"set\", buffer[\"set\"].get<int>()}, {\"binding\", buffer[\"binding\"].get<int>()}, {\"members\", bufferMembers}}; bufferInfos.push_back(bufferInfo); } }; if (ubos) parseBuffers(*ubos, uniformBufferInfos); if (ssbos) parseBuffers(*ssbos, shaderStorageBufferInfos); json textureDescriptors = {}; json bufferDescriptors = {}; if (textures) for (const json &texture : *textures) { textureDescriptors[to_string(texture[\"set\"].get<int>())] = { {\"type\", texture[\"type\"]}, {\"name\", texture[\"name\"]}, {\"set\", texture[\"set\"]}, {\"binding\", texture[\"binding\"]}}; } if (images) for (const json &image : *images) { textureDescriptors[to_string(image[\"set\"].get<int>())] = { {\"type\", image[\"type\"]}, {\"name\", image[\"name\"]}, {\"set\", image[\"set\"]}, {\"binding\", image[\"binding\"]}}; } if (ubos) for (const json &ubo : *ubos) { bufferDescriptors[to_string(ubo[\"set\"].get<int>())] = { {\"type\", \"uniformBuffer\"}, {\"name\", ubo[\"name\"]}, {\"set\", ubo[\"set\"]}, {\"binding\", ubo[\"binding\"]}}; } if (ssbos) for (const json &ssbo : *ssbos) { bufferDescriptors[to_string(ssbo[\"set\"].get<int>())] = { {\"type\", \"shaderStorageBuffer\"}, {\"name\", ssbo[\"name\"]}, {\"set\", ssbo[\"set\"]}, {\"binding\", ssbo[\"binding\"]}}; } contents += \"DESCRIPTORS \" + to_string(textureDescriptors.size() + bufferDescriptors.size()) + \"\\n\"; map<string, string> descriptorTypeMap = { {\"sampler2D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"sampler3D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"samplerCube\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"image2D\", \"DESCRIPTOR_TYPE_STORAGE_IMAGE\"}, {\"uniformBuffer\", \"DESCRIPTOR_TYPE_UNIFORM_BUFFER\"}, {\"shaderStorageBuffer\", \"DESCRIPTOR_TYPE_STORAGE_BUFFER\"}}; for (auto &[key, val] : textureDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } for (auto &[key, val] : bufferDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } auto processBufferInfos = [&](const json &bufferInfo) -> string { string contents = \"\"; const json &memberInfos = bufferInfo[\"members\"]; contents += bufferInfo[\"name\"].get<string>() + \" \" + to_string(bufferInfo[\"set\"].get<int>()) + \" \" + to_string(memberInfos.size()) + \"\\n\"; for (const json &m : memberInfos) { contents += m[\"name\"].get<string>() + \" \" + to_string(m[\"offset\"].get<int>()) + \" \" + to_string(m[\"size\"].get<int>()) + \" \" + to_string(m[\"array_count\"].get<int>()) + \" \" + to_string(m[\"array_stride\"].get<int>()) + \"\\n\"; } return contents; }; contents += \"UNIFORM_BUFFER_INFOS \" + to_string(uniformBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : uniformBufferInfos) { contents += processBufferInfos(bufferInfo); } contents += \"SHADER_STORAGE_BUFFER_INFOS \" + to_string(shaderStorageBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : shaderStorageBufferInfos) { contents += processBufferInfos(bufferInfo); } return contents; } int ShaderTools::generateShaderMapGLSL(const string &file, string outDir, vector<string> &outFiles) { string filename = fs::path(file).filename().string(); string ext = FileUtil::splitExt(filename)[1]; string glslFileName = fs::path(outDir + \"/\" + filename).make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); string glslMapFileName = fs::path(outDir + \"/\" + filename + \".map\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(glslFileName, glslMapFileName)) { outFiles.push_back(glslMapFileName); return 0; } string glsl = \"\", spv = readFile(spvFileName), glslReflect; genShaderReflectionGLSL(glsl, ext, spv, glslReflect); auto glslReflectJson = json::parse(glslReflect); string glslMap = parseReflectionData(glslReflectJson, ext); writeFile(glslMapFileName, glslMap); outFiles.push_back(glslMapFileName); return 0; } int ShaderTools::generateShaderMapMSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string mslFileName = fs::path(outDir + \"/\" + glslFilename + \".metal\") .make_preferred() .string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string mslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".metal.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(mslFileName, mslMapFileName)) { outFiles.push_back(mslMapFileName); return 0; } string msl = readFile(mslFileName), spv = readFile(spvFileName), mslReflect; genShaderReflectionMSL(msl, ext, spv, mslReflect); auto mslReflectJson = json::parse(mslReflect); string mslMap = parseReflectionData(mslReflectJson, ext); writeFile(mslMapFileName, mslMap); outFiles.push_back(mslMapFileName); return 0; } int ShaderTools::generateShaderMapHLSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string hlslFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl\").make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string hlslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(hlslFileName, hlslMapFileName)) { outFiles.push_back(hlslMapFileName); return 0; } string hlsl = readFile(hlslFileName), spv = readFile(spvFileName), hlslReflect; genShaderReflectionHLSL(hlsl, ext, spv, hlslReflect); auto hlslReflectJson = json::parse(hlslReflect); string hlslMap = parseReflectionData(hlslReflectJson, ext); writeFile(hlslMapFileName, hlslMap); outFiles.push_back(hlslMapFileName); return 0; } vector<string> ShaderTools::convertShaders(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) convertShader(file, \"\", outDir, fmt, outFiles); return outFiles; } vector<string> ShaderTools::compileShaders(const vector<string> &files, string outDir, Format fmt, const MacroDefinitions &defines, int flags) { #ifdef GRAPHICS_BACKEND_VULKAN defines += \" -DGRAPHICS_BACKEND_VULKAN=1\"; #endif vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) compileShaderGLSL(file, defines, outDir, outFiles, flags); else if (fmt == FORMAT_MSL) compileShaderMSL(file, defines, outDir, outFiles); else if (fmt == FORMAT_HLSL) compileShaderHLSL(file, defines, outDir, outFiles); } return outFiles; } void ShaderTools::applyPatches(const vector<string> &patchFiles, string outDir) { for (const string &patchFile : patchFiles) { string filename = FileUtil::splitExt(fs::path(patchFile).string())[0]; NGFX_LOG(\"filename: %s\", filename.c_str()); string outFile = fs::path(outDir + \"/\" + filename).make_preferred().string(); if (fs::exists(outFile)) { NGFX_LOG(\"applying patch: {patchFile}\"); string cmdStr = PATCH + \" -N -u \" + outFile + \" -i \" + patchFile; cmd(cmdStr); } } } vector<string> ShaderTools::generateShaderMaps(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) generateShaderMapGLSL(file, outDir, outFiles); else if (fmt == FORMAT_MSL) generateShaderMapMSL(file, outDir, outFiles); else if (fmt == FORMAT_HLSL) generateShaderMapHLSL(file, outDir, outFiles); } return outFiles; } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/ShaderTools_8h/","text":"src/ngfx/graphics/ShaderTools.h Namespaces Name ngfx Classes Name class ngfx::ShaderTools struct ngfx::ShaderTools::MacroDefinition Types Name using nlohmann::json json Types Documentation using json using json = nlohmann::json; Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/regex/RegexUtil.h\" #include <ctime> #include <json.hpp> #include <map> #include <regex> #include <shaderc/shaderc.hpp> #include <string> #include <vector> using json = nlohmann::json; namespace ngfx { class ShaderTools { public: ShaderTools(bool verbose = false); enum { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2 }; enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL }; struct MacroDefinition { std::string name, value; }; typedef std::vector<MacroDefinition> MacroDefinitions; std::vector<std::string> compileShaders(const std::vector<std::string> &files, std::string outDir, Format fmt = FORMAT_GLSL, const MacroDefinitions &defines = {}, int flags = 0); std::vector<std::string> convertShaders(const std::vector<std::string> &files, std::string outDir, Format fmt); std::vector<std::string> generateShaderMaps(const std::vector<std::string> &files, std::string outDir, Format fmt); private: void applyPatches(const std::vector<std::string> &patchFiles, std::string outDir); int cmd(std::string str); int compileShaderGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &spv, bool verbose = true, shaderc_optimization_level optimizationLevel = shaderc_optimization_level_performance); int compileShaderGLSL(std::string filename, const MacroDefinitions &defines, const std::string &outDir, std::vector<std::string> &outFiles, int flags = 0); int compileShaderHLSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int compileShaderMSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int convertSPVToHLSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &hlsl, uint32_t shaderModel = 60); int convertSPVToMSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &msl); int convertShader(const std::string &file, const std::string &extraArgs, std::string outDir, Format fmt, std::vector<std::string> &outFiles); bool findIncludeFile(const std::string &includeFilename, const std::vector<std::string> &includePaths, std::string &includeFile); struct MetalReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; struct HLSLReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; bool findMetalReflectData(const std::vector<RegexUtil::Match> &metalReflectData, const std::string &name, RegexUtil::Match &match); int genShaderReflectionGLSL(const std::string &glsl, const std::string &ext, const std::string &spv, std::string &glslMap); int genShaderReflectionHLSL(const std::string &hlsl, const std::string &ext, const std::string &spv, std::string &hlslMap); int genShaderReflectionMSL(const std::string &msl, const std::string &ext, const std::string &spv, std::string &mslMap); int generateShaderMapGLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapHLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapMSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); std::string parseReflectionData(const json &reflectData, std::string ext); int patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect); int patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect); int patchShaderLayoutsGLSL(const std::string &src, std::string &dst); int preprocess(const std::string &src, const std::string &dataPath, std::string &dst); int removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst); bool verbose = false; std::vector<std::string> defaultIncludePaths; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/ShaderTools.h"},{"location":"api/Files/ShaderTools_8h/#srcngfxgraphicsshadertoolsh","text":"","title":"src/ngfx/graphics/ShaderTools.h"},{"location":"api/Files/ShaderTools_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ShaderTools_8h/#classes","text":"Name class ngfx::ShaderTools struct ngfx::ShaderTools::MacroDefinition","title":"Classes"},{"location":"api/Files/ShaderTools_8h/#types","text":"Name using nlohmann::json json","title":"Types"},{"location":"api/Files/ShaderTools_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Files/ShaderTools_8h/#using-json","text":"using json = nlohmann::json;","title":"using json"},{"location":"api/Files/ShaderTools_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/regex/RegexUtil.h\" #include <ctime> #include <json.hpp> #include <map> #include <regex> #include <shaderc/shaderc.hpp> #include <string> #include <vector> using json = nlohmann::json; namespace ngfx { class ShaderTools { public: ShaderTools(bool verbose = false); enum { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2 }; enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL }; struct MacroDefinition { std::string name, value; }; typedef std::vector<MacroDefinition> MacroDefinitions; std::vector<std::string> compileShaders(const std::vector<std::string> &files, std::string outDir, Format fmt = FORMAT_GLSL, const MacroDefinitions &defines = {}, int flags = 0); std::vector<std::string> convertShaders(const std::vector<std::string> &files, std::string outDir, Format fmt); std::vector<std::string> generateShaderMaps(const std::vector<std::string> &files, std::string outDir, Format fmt); private: void applyPatches(const std::vector<std::string> &patchFiles, std::string outDir); int cmd(std::string str); int compileShaderGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &spv, bool verbose = true, shaderc_optimization_level optimizationLevel = shaderc_optimization_level_performance); int compileShaderGLSL(std::string filename, const MacroDefinitions &defines, const std::string &outDir, std::vector<std::string> &outFiles, int flags = 0); int compileShaderHLSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int compileShaderMSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int convertSPVToHLSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &hlsl, uint32_t shaderModel = 60); int convertSPVToMSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &msl); int convertShader(const std::string &file, const std::string &extraArgs, std::string outDir, Format fmt, std::vector<std::string> &outFiles); bool findIncludeFile(const std::string &includeFilename, const std::vector<std::string> &includePaths, std::string &includeFile); struct MetalReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; struct HLSLReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; bool findMetalReflectData(const std::vector<RegexUtil::Match> &metalReflectData, const std::string &name, RegexUtil::Match &match); int genShaderReflectionGLSL(const std::string &glsl, const std::string &ext, const std::string &spv, std::string &glslMap); int genShaderReflectionHLSL(const std::string &hlsl, const std::string &ext, const std::string &spv, std::string &hlslMap); int genShaderReflectionMSL(const std::string &msl, const std::string &ext, const std::string &spv, std::string &mslMap); int generateShaderMapGLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapHLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapMSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); std::string parseReflectionData(const json &reflectData, std::string ext); int patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect); int patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect); int patchShaderLayoutsGLSL(const std::string &src, std::string &dst); int preprocess(const std::string &src, const std::string &dataPath, std::string &dst); int removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst); bool verbose = false; std::vector<std::string> defaultIncludePaths; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Surface_8h/","text":"src/ngfx/graphics/Surface.h Namespaces Name ngfx Classes Name class ngfx::Surface Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> namespace ngfx { class Surface { public: Surface() {} Surface(uint32_t w, uint32_t h, bool offscreen = false) : w(w), h(h), offscreen(offscreen) {} virtual ~Surface() {} uint32_t w = 0, h = 0; bool offscreen = false; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Surface.h"},{"location":"api/Files/Surface_8h/#srcngfxgraphicssurfaceh","text":"","title":"src/ngfx/graphics/Surface.h"},{"location":"api/Files/Surface_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Surface_8h/#classes","text":"Name class ngfx::Surface","title":"Classes"},{"location":"api/Files/Surface_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> namespace ngfx { class Surface { public: Surface() {} Surface(uint32_t w, uint32_t h, bool offscreen = false) : w(w), h(h), offscreen(offscreen) {} virtual ~Surface() {} uint32_t w = 0, h = 0; bool offscreen = false; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Swapchain_8h/","text":"src/ngfx/graphics/Swapchain.h Namespaces Name ngfx Classes Name class ngfx::Swapchain Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Semaphore.h\" #include <cstdint> namespace ngfx { class Swapchain { public: virtual ~Swapchain() {} virtual void acquireNextImage() = 0; uint32_t numImages; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Swapchain.h"},{"location":"api/Files/Swapchain_8h/#srcngfxgraphicsswapchainh","text":"","title":"src/ngfx/graphics/Swapchain.h"},{"location":"api/Files/Swapchain_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Swapchain_8h/#classes","text":"Name class ngfx::Swapchain","title":"Classes"},{"location":"api/Files/Swapchain_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Semaphore.h\" #include <cstdint> namespace ngfx { class Swapchain { public: virtual ~Swapchain() {} virtual void acquireNextImage() = 0; uint32_t numImages; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Texture_8cpp/","text":"src/ngfx/graphics/Texture.cpp Defines Name STB_IMAGE_IMPLEMENTATION Macro Documentation define STB_IMAGE_IMPLEMENTATION #define STB_IMAGE_IMPLEMENTATION Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Texture.h\" #define STB_IMAGE_IMPLEMENTATION #include <memory> #include <stb_image.h> using namespace ngfx; Texture *Texture::create(GraphicsContext *ctx, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { int w, h, channels; std::unique_ptr<stbi_uc> data(stbi_load(filename, &w, &h, &channels, 4)); assert(data); Texture *texture = create(ctx, graphics, data.get(), PIXELFORMAT_RGBA8_UNORM, w * h * 4, w, h, 1, 1, imageUsageFlags, textureType, genMipmaps, minFilter, magFilter, mipFilter, numSamples); return texture; } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Texture.cpp"},{"location":"api/Files/Texture_8cpp/#srcngfxgraphicstexturecpp","text":"","title":"src/ngfx/graphics/Texture.cpp"},{"location":"api/Files/Texture_8cpp/#defines","text":"Name STB_IMAGE_IMPLEMENTATION","title":"Defines"},{"location":"api/Files/Texture_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/Texture_8cpp/#define-stb_image_implementation","text":"#define STB_IMAGE_IMPLEMENTATION","title":"define STB_IMAGE_IMPLEMENTATION"},{"location":"api/Files/Texture_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Texture.h\" #define STB_IMAGE_IMPLEMENTATION #include <memory> #include <stb_image.h> using namespace ngfx; Texture *Texture::create(GraphicsContext *ctx, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { int w, h, channels; std::unique_ptr<stbi_uc> data(stbi_load(filename, &w, &h, &channels, 4)); assert(data); Texture *texture = create(ctx, graphics, data.get(), PIXELFORMAT_RGBA8_UNORM, w * h * 4, w, h, 1, 1, imageUsageFlags, textureType, genMipmaps, minFilter, magFilter, mipFilter, numSamples); return texture; } Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Texture_8h/","text":"src/ngfx/graphics/Texture.h Namespaces Name ngfx Classes Name class ngfx::Texture Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" namespace ngfx { class Graphics; class GraphicsContext; class Texture { public: static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, void *data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); virtual ~Texture() {} virtual void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) = 0; virtual void generateMipmaps(CommandBuffer *commandBuffer) = 0; PixelFormat format; uint32_t w = 0, h = 0, d = 1, arrayLayers = 1, mipLevels = 1, numSamples = 1; ImageUsageFlags imageUsageFlags; TextureType textureType; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Texture.h"},{"location":"api/Files/Texture_8h/#srcngfxgraphicstextureh","text":"","title":"src/ngfx/graphics/Texture.h"},{"location":"api/Files/Texture_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Texture_8h/#classes","text":"Name class ngfx::Texture","title":"Classes"},{"location":"api/Files/Texture_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" namespace ngfx { class Graphics; class GraphicsContext; class Texture { public: static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, void *data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); virtual ~Texture() {} virtual void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) = 0; virtual void generateMipmaps(CommandBuffer *commandBuffer) = 0; PixelFormat format; uint32_t w = 0, h = 0, d = 1, arrayLayers = 1, mipLevels = 1, numSamples = 1; ImageUsageFlags imageUsageFlags; TextureType textureType; }; } // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/Window_8h/","text":"src/ngfx/graphics/Window.h Namespaces Name ngfx Classes Name class ngfx::Window Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/input/InputMap.h\" #include <functional> namespace ngfx { class GraphicsContext; class Window { public: static Window *create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w = DISPLAY_WIDTH, int h = DISPLAY_HEIGHT); virtual ~Window() {} virtual bool shouldClose() = 0; virtual void pollEvents() = 0; enum { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1 }; int w, h; Surface *surface = nullptr; std::function<void()> onUpdate = nullptr, onPaint = nullptr; std::function<void(KeyCode code, InputAction action)> onKey = nullptr; std::function<void(double xoffset, double yoffset)> onScroll = nullptr; std::function<void(double x, double y)> onCursorPos = nullptr; std::function<void(MouseButton button, InputAction action)> onMouseButton = nullptr; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics/Window.h"},{"location":"api/Files/Window_8h/#srcngfxgraphicswindowh","text":"","title":"src/ngfx/graphics/Window.h"},{"location":"api/Files/Window_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Window_8h/#classes","text":"Name class ngfx::Window","title":"Classes"},{"location":"api/Files/Window_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/input/InputMap.h\" #include <functional> namespace ngfx { class GraphicsContext; class Window { public: static Window *create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w = DISPLAY_WIDTH, int h = DISPLAY_HEIGHT); virtual ~Window() {} virtual bool shouldClose() = 0; virtual void pollEvents() = 0; enum { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1 }; int w, h; Surface *surface = nullptr; std::function<void()> onUpdate = nullptr, onPaint = nullptr; std::function<void(KeyCode code, InputAction action)> onKey = nullptr; std::function<void(double xoffset, double yoffset)> onScroll = nullptr; std::function<void(double x, double y)> onCursorPos = nullptr; std::function<void(MouseButton button, InputAction action)> onMouseButton = nullptr; }; }; // namespace ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Source code"},{"location":"api/Files/dir_61819f5050c989815f217f007bce688d/","text":"src/ngfx/graphics Files Name src/ngfx/graphics/Buffer.h src/ngfx/graphics/BufferUtil.h src/ngfx/graphics/Camera.cpp src/ngfx/graphics/Camera.h src/ngfx/graphics/CommandBuffer.h src/ngfx/graphics/Config.h src/ngfx/graphics/Device.h src/ngfx/graphics/DrawOp.h src/ngfx/graphics/Fence.h src/ngfx/graphics/FilterOp.cpp src/ngfx/graphics/FilterOp.h src/ngfx/graphics/Framebuffer.h src/ngfx/graphics/Graphics.h src/ngfx/graphics/GraphicsContext.h src/ngfx/graphics/GraphicsCore.h src/ngfx/graphics/GraphicsPipeline.cpp src/ngfx/graphics/GraphicsPipeline.h src/ngfx/graphics/MeshData.h src/ngfx/graphics/MeshUtil.cpp src/ngfx/graphics/MeshUtil.h src/ngfx/graphics/Pipeline.h src/ngfx/graphics/PipelineCache.cpp src/ngfx/graphics/PipelineCache.h src/ngfx/graphics/Queue.h src/ngfx/graphics/RenderPass.h src/ngfx/graphics/Semaphore.h src/ngfx/graphics/ShaderModule.cpp src/ngfx/graphics/ShaderModule.h src/ngfx/graphics/ShaderTools.cpp src/ngfx/graphics/ShaderTools.h src/ngfx/graphics/Surface.h src/ngfx/graphics/Swapchain.h src/ngfx/graphics/Texture.cpp src/ngfx/graphics/Texture.h src/ngfx/graphics/Window.h Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx/graphics"},{"location":"api/Files/dir_61819f5050c989815f217f007bce688d/#srcngfxgraphics","text":"","title":"src/ngfx/graphics"},{"location":"api/Files/dir_61819f5050c989815f217f007bce688d/#files","text":"Name src/ngfx/graphics/Buffer.h src/ngfx/graphics/BufferUtil.h src/ngfx/graphics/Camera.cpp src/ngfx/graphics/Camera.h src/ngfx/graphics/CommandBuffer.h src/ngfx/graphics/Config.h src/ngfx/graphics/Device.h src/ngfx/graphics/DrawOp.h src/ngfx/graphics/Fence.h src/ngfx/graphics/FilterOp.cpp src/ngfx/graphics/FilterOp.h src/ngfx/graphics/Framebuffer.h src/ngfx/graphics/Graphics.h src/ngfx/graphics/GraphicsContext.h src/ngfx/graphics/GraphicsCore.h src/ngfx/graphics/GraphicsPipeline.cpp src/ngfx/graphics/GraphicsPipeline.h src/ngfx/graphics/MeshData.h src/ngfx/graphics/MeshUtil.cpp src/ngfx/graphics/MeshUtil.h src/ngfx/graphics/Pipeline.h src/ngfx/graphics/PipelineCache.cpp src/ngfx/graphics/PipelineCache.h src/ngfx/graphics/Queue.h src/ngfx/graphics/RenderPass.h src/ngfx/graphics/Semaphore.h src/ngfx/graphics/ShaderModule.cpp src/ngfx/graphics/ShaderModule.h src/ngfx/graphics/ShaderTools.cpp src/ngfx/graphics/ShaderTools.h src/ngfx/graphics/Surface.h src/ngfx/graphics/Swapchain.h src/ngfx/graphics/Texture.cpp src/ngfx/graphics/Texture.h src/ngfx/graphics/Window.h Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Files"},{"location":"api/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"src Directories Name src/ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src"},{"location":"api/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#src","text":"","title":"src"},{"location":"api/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Name src/ngfx Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Directories"},{"location":"api/Files/dir_bf4520687725fcb8943bc560a06cbd17/","text":"src/ngfx Directories Name src/ngfx/graphics Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"src/ngfx"},{"location":"api/Files/dir_bf4520687725fcb8943bc560a06cbd17/#srcngfx","text":"","title":"src/ngfx"},{"location":"api/Files/dir_bf4520687725fcb8943bc560a06cbd17/#directories","text":"Name src/ngfx/graphics Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Directories"},{"location":"api/Modules/","text":"Modules Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Modules"},{"location":"api/Modules/#modules","text":"Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Modules"},{"location":"api/Namespaces/","text":"Namespaces namespace glm namespace ngfx namespace std Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Namespaces"},{"location":"api/Namespaces/#namespaces","text":"namespace glm namespace ngfx namespace std Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Namespaces"},{"location":"api/Namespaces/namespaceglm/","text":"glm Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"glm"},{"location":"api/Namespaces/namespaceglm/#glm","text":"Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"glm"},{"location":"api/Namespaces/namespacengfx/","text":"ngfx Classes Name class ngfx::Buffer class ngfx::Camera class ngfx::CommandBuffer class ngfx::ComputeShaderModule class ngfx::Device class ngfx::DrawOp class ngfx::Fence class ngfx::FilterOp class ngfx::FragmentShaderModule class ngfx::Framebuffer class ngfx::Graphics class ngfx::GraphicsContext class ngfx::GraphicsPipeline struct ngfx::MeshData struct ngfx::MeshUtil class ngfx::Pipeline class ngfx::PipelineCache class ngfx::Queue struct ngfx::Rect2D class ngfx::RenderPass class ngfx::Semaphore class ngfx::ShaderModule class ngfx::ShaderTools class ngfx::Surface class ngfx::Swapchain class ngfx::Texture class ngfx::VertexShaderModule class ngfx::Window Types Name typedef uint32_t Flags typedef Flags PipelineStageFlags typedef Flags ShaderStageFlags typedef Flags FenceCreateFlags typedef Flags ImageUsageFlags typedef Flags ColorComponentFlags typedef Flags BufferUsageFlags Functions Name Buffer * createVertexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) template <typename T > Buffer * createVertexBuffer ( GraphicsContext * ctx, const std::vector< T > & v) Buffer * createIndexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t)) template <typename T > Buffer * createIndexBuffer ( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t)) Buffer * createUniformBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) Buffer * createStorageBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) Types Documentation typedef Flags typedef uint32_t ngfx::Flags; typedef PipelineStageFlags typedef Flags ngfx::PipelineStageFlags; typedef ShaderStageFlags typedef Flags ngfx::ShaderStageFlags; typedef FenceCreateFlags typedef Flags ngfx::FenceCreateFlags; typedef ImageUsageFlags typedef Flags ngfx::ImageUsageFlags; typedef ColorComponentFlags typedef Flags ngfx::ColorComponentFlags; typedef BufferUsageFlags typedef Flags ngfx::BufferUsageFlags; Functions Documentation function createVertexBuffer static Buffer * createVertexBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) Create a vertex buffer function createVertexBuffer template <typename T > static inline Buffer * createVertexBuffer( GraphicsContext * ctx, const std::vector< T > & v ) Parameters : ctx The graphics context v The buffer data Create a vertex buffer function createIndexBuffer static Buffer * createIndexBuffer( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) stride The stride of the input data (in bytes) Create an index buffer function createIndexBuffer template <typename T > static inline Buffer * createIndexBuffer( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context v The buffer data stride The stride of the input data (in bytes) Create an index buffer function createUniformBuffer static Buffer * createUniformBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a uniform buffer function createStorageBuffer static Buffer * createStorageBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a storage buffer Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"ngfx"},{"location":"api/Namespaces/namespacengfx/#ngfx","text":"","title":"ngfx"},{"location":"api/Namespaces/namespacengfx/#classes","text":"Name class ngfx::Buffer class ngfx::Camera class ngfx::CommandBuffer class ngfx::ComputeShaderModule class ngfx::Device class ngfx::DrawOp class ngfx::Fence class ngfx::FilterOp class ngfx::FragmentShaderModule class ngfx::Framebuffer class ngfx::Graphics class ngfx::GraphicsContext class ngfx::GraphicsPipeline struct ngfx::MeshData struct ngfx::MeshUtil class ngfx::Pipeline class ngfx::PipelineCache class ngfx::Queue struct ngfx::Rect2D class ngfx::RenderPass class ngfx::Semaphore class ngfx::ShaderModule class ngfx::ShaderTools class ngfx::Surface class ngfx::Swapchain class ngfx::Texture class ngfx::VertexShaderModule class ngfx::Window","title":"Classes"},{"location":"api/Namespaces/namespacengfx/#types","text":"Name typedef uint32_t Flags typedef Flags PipelineStageFlags typedef Flags ShaderStageFlags typedef Flags FenceCreateFlags typedef Flags ImageUsageFlags typedef Flags ColorComponentFlags typedef Flags BufferUsageFlags","title":"Types"},{"location":"api/Namespaces/namespacengfx/#functions","text":"Name Buffer * createVertexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) template <typename T > Buffer * createVertexBuffer ( GraphicsContext * ctx, const std::vector< T > & v) Buffer * createIndexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t)) template <typename T > Buffer * createIndexBuffer ( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t)) Buffer * createUniformBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) Buffer * createStorageBuffer ( GraphicsContext * ctx, const void * data, uint32_t size)","title":"Functions"},{"location":"api/Namespaces/namespacengfx/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Namespaces/namespacengfx/#typedef-flags","text":"typedef uint32_t ngfx::Flags;","title":"typedef Flags"},{"location":"api/Namespaces/namespacengfx/#typedef-pipelinestageflags","text":"typedef Flags ngfx::PipelineStageFlags;","title":"typedef PipelineStageFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-shaderstageflags","text":"typedef Flags ngfx::ShaderStageFlags;","title":"typedef ShaderStageFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-fencecreateflags","text":"typedef Flags ngfx::FenceCreateFlags;","title":"typedef FenceCreateFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-imageusageflags","text":"typedef Flags ngfx::ImageUsageFlags;","title":"typedef ImageUsageFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-colorcomponentflags","text":"typedef Flags ngfx::ColorComponentFlags;","title":"typedef ColorComponentFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-bufferusageflags","text":"typedef Flags ngfx::BufferUsageFlags;","title":"typedef BufferUsageFlags"},{"location":"api/Namespaces/namespacengfx/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Namespaces/namespacengfx/#function-createvertexbuffer","text":"static Buffer * createVertexBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) Create a vertex buffer","title":"function createVertexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createvertexbuffer_1","text":"template <typename T > static inline Buffer * createVertexBuffer( GraphicsContext * ctx, const std::vector< T > & v ) Parameters : ctx The graphics context v The buffer data Create a vertex buffer","title":"function createVertexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createindexbuffer","text":"static Buffer * createIndexBuffer( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) stride The stride of the input data (in bytes) Create an index buffer","title":"function createIndexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createindexbuffer_1","text":"template <typename T > static inline Buffer * createIndexBuffer( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context v The buffer data stride The stride of the input data (in bytes) Create an index buffer","title":"function createIndexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createuniformbuffer","text":"static Buffer * createUniformBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a uniform buffer","title":"function createUniformBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createstoragebuffer","text":"static Buffer * createStorageBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a storage buffer Updated on 14 March 2021 at 11:27:44 Pacific Daylight Time","title":"function createStorageBuffer"},{"location":"api/Namespaces/namespacestd/","text":"std Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"std"},{"location":"api/Namespaces/namespacestd/#std","text":"Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"std"},{"location":"api/Pages/","text":"Pages Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Pages"},{"location":"api/Pages/#pages","text":"Updated on 14 March 2021 at 11:27:45 Pacific Daylight Time","title":"Pages"}]}