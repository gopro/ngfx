{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NGFX Graphics Framework NGFX is a low level graphics framework, providing an abstraction API on top of Vulkan, DirectX12, and Metal. It exposes the benefits of next-generation graphics technology via a common platform abstraction API. It also supports optional access to the backend data structures, enabling platform specific optimizations. Source Code https://github.com/gopro/ngfx High Level Architecture Low Level Architecture The ngfx graphics classes provide high-level abstractions on top of various graphics objects, including Buffer, Texture, Renderpass, Swapchain, Surface, CommandBuffer, etc. Each backend (Vulkan, Metal, DirectX12) is responsible for implementing the high-level abstraction interface via a subclass. The user can construct 3D graphics commands using these high-level abstractions. Optionally, the user can access the backend-specific data by casting the high-level object to a backend-specific subclass. For example: Buffer *buffer = Buffer::create(...); VKBuffer *vkBuffer = (VKBuffer*)buffer; From there, the user can access platform specific data, including the underlying Vulkan buffer object, etc. This provides a high degree of flexibility, where the user can primarily use platform-agnostic code, while still being able to use platform-specific code for high-performance optimizations, and for achieving optimal interaction with the platform. Build Instructions 1) Install Dependencies 1.1) Install Platform-Specific Dependencies On Windows 10 (or newer): Install Microsoft Visual Studio 2019 (or newer) Install Windows Subsystem for Linux (Ubuntu 20.04.1 LTS or newer) - Note: Git Bash or MSYS2 should work too On Linux (Ubuntu 20.04.1 or newer, other Linux distros should work too): Install GNU Toolchain (apt install build-essential) On Mac: Install XCode 1.2) Install Common System Dependencies Install CMake 3.19.1 (or newer) 1.3) Install Third-Party Dependencies ngfx has the following dependencies: nlohmann/json 3.9.1 (or newer) stb_image 2.26 (or newer) glm 0.9.9.8 (or newer) RenderDoc 1.11_64 (or newer, on Windows and Linux) d3dx12.h v10.0.17763.0 (or newer, on Windows) glfw 3.3.2 (or newer, on Windows and Linux) shaderc v2020.4 (or newer) spirv-cross 2021-01-15 (or newer) vulkan sdk 1.2.162.1 (or newer, if using Vulkan backend) We provide a helper script to help install 3rd-party dependencies bash build_scripts/sync_deps.sh platform - platform : Windows, Linux, or Darwin (Mac OS) 2) Configure cmake.exe -H. -B build_folder -DCMAKE_BUILD_TYPE= build_type -D ngfx_graphics_backend =ON -G cmake_generator - build_folder : the build output folder (e.g. cmake-build-debug, or cmake-build-release) - build type : Debug or Release - ngfx_graphics_backend : the graphics backend (NGFX_GRAPHICS_BACKEND_VULKAN, NGFX_GRAPHICS_BACKEND_METAL, or NGFX_GRAPHICS_BACKEND_DIRECT3D12) - cmake_generator : CMake generator (e.g. Visual Studio 16 2019) Example: cmake.exe -H. -Bcmake-build-debug -DCMAKE_BUILD_TYPE=Debug -DNGFX_GRAPHICS_BACKEND_DIRECT3D12=ON 3) Build From command line: cmake.exe --build build_folder Alternatively, can build from IDE 4) Install cmake.exe --install build_folder --config build_type --prefix install_prefix - install_prefix : The install prefix API Documentation API Documentation Contributing Coding Style Guidelines We use clang-format to automatically enforce coding style. We use llvm coding style (the default option in clang-format). To automatically apply formatting: run build_scripts/clang_format.sh The LLVM coding style can be referenced here: See https://llvm.org/docs/CodingStandards.html We use doxygen, with JavaDoc-style annotations to generate API documentation.","title":"NGFX Graphics Framework"},{"location":"#ngfx-graphics-framework","text":"NGFX is a low level graphics framework, providing an abstraction API on top of Vulkan, DirectX12, and Metal. It exposes the benefits of next-generation graphics technology via a common platform abstraction API. It also supports optional access to the backend data structures, enabling platform specific optimizations.","title":"NGFX Graphics Framework"},{"location":"#source-code","text":"https://github.com/gopro/ngfx","title":"Source Code"},{"location":"#high-level-architecture","text":"","title":"High Level Architecture"},{"location":"#low-level-architecture","text":"The ngfx graphics classes provide high-level abstractions on top of various graphics objects, including Buffer, Texture, Renderpass, Swapchain, Surface, CommandBuffer, etc. Each backend (Vulkan, Metal, DirectX12) is responsible for implementing the high-level abstraction interface via a subclass. The user can construct 3D graphics commands using these high-level abstractions. Optionally, the user can access the backend-specific data by casting the high-level object to a backend-specific subclass. For example: Buffer *buffer = Buffer::create(...); VKBuffer *vkBuffer = (VKBuffer*)buffer; From there, the user can access platform specific data, including the underlying Vulkan buffer object, etc. This provides a high degree of flexibility, where the user can primarily use platform-agnostic code, while still being able to use platform-specific code for high-performance optimizations, and for achieving optimal interaction with the platform.","title":"Low Level Architecture"},{"location":"#build-instructions","text":"","title":"Build Instructions"},{"location":"#1-install-dependencies","text":"","title":"1) Install Dependencies"},{"location":"#11-install-platform-specific-dependencies","text":"On Windows 10 (or newer): Install Microsoft Visual Studio 2019 (or newer) Install Windows Subsystem for Linux (Ubuntu 20.04.1 LTS or newer) - Note: Git Bash or MSYS2 should work too On Linux (Ubuntu 20.04.1 or newer, other Linux distros should work too): Install GNU Toolchain (apt install build-essential) On Mac: Install XCode","title":"1.1) Install Platform-Specific Dependencies"},{"location":"#12-install-common-system-dependencies","text":"Install CMake 3.19.1 (or newer)","title":"1.2) Install Common System Dependencies"},{"location":"#13-install-third-party-dependencies","text":"ngfx has the following dependencies: nlohmann/json 3.9.1 (or newer) stb_image 2.26 (or newer) glm 0.9.9.8 (or newer) RenderDoc 1.11_64 (or newer, on Windows and Linux) d3dx12.h v10.0.17763.0 (or newer, on Windows) glfw 3.3.2 (or newer, on Windows and Linux) shaderc v2020.4 (or newer) spirv-cross 2021-01-15 (or newer) vulkan sdk 1.2.162.1 (or newer, if using Vulkan backend) We provide a helper script to help install 3rd-party dependencies bash build_scripts/sync_deps.sh platform - platform : Windows, Linux, or Darwin (Mac OS)","title":"1.3) Install Third-Party Dependencies"},{"location":"#2-configure","text":"cmake.exe -H. -B build_folder -DCMAKE_BUILD_TYPE= build_type -D ngfx_graphics_backend =ON -G cmake_generator - build_folder : the build output folder (e.g. cmake-build-debug, or cmake-build-release) - build type : Debug or Release - ngfx_graphics_backend : the graphics backend (NGFX_GRAPHICS_BACKEND_VULKAN, NGFX_GRAPHICS_BACKEND_METAL, or NGFX_GRAPHICS_BACKEND_DIRECT3D12) - cmake_generator : CMake generator (e.g. Visual Studio 16 2019) Example: cmake.exe -H. -Bcmake-build-debug -DCMAKE_BUILD_TYPE=Debug -DNGFX_GRAPHICS_BACKEND_DIRECT3D12=ON","title":"2) Configure"},{"location":"#3-build","text":"From command line: cmake.exe --build build_folder Alternatively, can build from IDE","title":"3) Build"},{"location":"#4-install","text":"cmake.exe --install build_folder --config build_type --prefix install_prefix - install_prefix : The install prefix","title":"4) Install"},{"location":"#api-documentation","text":"API Documentation","title":"API Documentation"},{"location":"#contributing","text":"","title":"Contributing"},{"location":"#coding-style-guidelines","text":"We use clang-format to automatically enforce coding style. We use llvm coding style (the default option in clang-format). To automatically apply formatting: run build_scripts/clang_format.sh The LLVM coding style can be referenced here: See https://llvm.org/docs/CodingStandards.html We use doxygen, with JavaDoc-style annotations to generate API documentation.","title":"Coding Style Guidelines"},{"location":"api/Classes/","text":"Classes class AppDelegate class BufferUtil class Camera class CommandBuffer struct DebugUtil class Device class DrawOp class Fence class FilterOp class Framebuffer struct MTLGraphicsUtil class MTLViewDelegate struct VertexFormatInfo class ViewController namespace glm namespace ngfx class BaseApplication class Buffer class Camera class CommandBuffer class ComputeApplication class ComputeOp class ComputePass class ComputePipeline class ComputeShaderModule class D3DBlitOp struct UBOData class D3DBuffer class D3DCommandList class D3DCommandQueue class D3DComputePass class D3DComputePipeline class D3DComputeShaderModule class D3DDescriptorHandle class D3DDescriptorHeap class D3DDevice class D3DFence class D3DFragmentShaderModule class D3DFramebuffer struct D3DAttachment class D3DGraphics class D3DGraphicsContext struct D3DRenderPassData class D3DGraphicsPipeline struct Shaders struct State class D3DPipeline class D3DPipelineCache struct D3DPipelineUtil class D3DReadbackBuffer class D3DRenderPass struct D3DSamplerDesc class D3DShaderModule class D3DSurface class D3DSwapchain class D3DTexture struct GenMipmapData struct RtvData struct SamplerData struct SrvData class D3DVertexShaderModule class D3DWindow class Device class DrawColorOp class DrawMeshOp struct LightData struct UBO_FS_Data struct UBO_VS_Data class DrawOp class DrawTextureOp class FPSCounter class Fence class File class FileUtil struct Lock class FilterOp class FragmentShaderModule class Framebuffer struct Attachment class GLFWWindow class Graphics class GraphicsContext struct AttachmentDescription struct RenderPassConfig class GraphicsPipeline struct Descriptor struct State class InputListener class MTLApplication class MTLBuffer class MTLCommandBuffer class MTLCommandEncoder class MTLComputeCommandEncoder class MTLComputePipeline class MTLComputeShaderModule class MTLDepthStencilTexture class MTLDevice class MTLFragmentShaderModule class MTLFramebuffer class MTLGraphics class MTLGraphicsContext struct MTLRenderPassData class MTLGraphicsPipeline struct Shaders class MTLPipelineCache struct MTLPipelineUtil class MTLRenderCommandEncoder class MTLRenderPass class MTLShaderModule class MTLSurface class MTLTexture class MTLVertexShaderModule class MTLWindow class MatrixMultiplyCPUOp class MatrixMultiplyGPUOp struct UboData class MatrixMultiplyOp struct MatrixParam struct MeshData struct MeshUtil class Pipeline class PipelineCache class ProcessUtil class Queue struct Rect2D class RegexUtil struct Match struct Region class RenderPass class Semaphore class ShaderModule struct BufferInfo struct BufferMemberInfo struct DescriptorInfo class ShaderTools struct HLSLReflectData struct MacroDefinition struct MetalReflectData class StringUtil class Surface class Swapchain class Texture class Timer class Util struct VKBlit struct Region class VKBuffer class VKCommandBuffer class VKCommandPool class VKComputePipeline class VKComputeShaderModule class VKDebugMessenger class VKDescriptorSetLayoutCache struct VKDescriptorSetLayoutData class VKDevice class VKFence class VKFragmentShaderModule class VKFramebuffer struct VKAttachmentDescriptor struct VKAttachmentInfo class VKGraphics class VKGraphicsContext struct VKRenderPassData class VKGraphicsPipeline struct State class VKImage struct VKImageCreateInfo class VKImageView struct VKImageViewCreateInfo class VKInstance class VKPhysicalDevice class VKPipeline struct Descriptor struct ShaderStage class VKPipelineCache struct VKPipelineUtil class VKQueue class VKRenderPass struct VKSamplerCreateInfo class VKSemaphore class VKShaderModule class VKSurface class VKSwapchain struct queueFamilyProperties class VKTexture class VKVertexShaderModule class VKWindow class VertexShaderModule struct AttributeDescription class WWindow struct Monitor struct VideoMode class Window namespace std namespace std::chrono namespace std::placeholders Updated on 3 April 2021 at 20:21:52 PDT","title":"Classes"},{"location":"api/Classes/#classes","text":"class AppDelegate class BufferUtil class Camera class CommandBuffer struct DebugUtil class Device class DrawOp class Fence class FilterOp class Framebuffer struct MTLGraphicsUtil class MTLViewDelegate struct VertexFormatInfo class ViewController namespace glm namespace ngfx class BaseApplication class Buffer class Camera class CommandBuffer class ComputeApplication class ComputeOp class ComputePass class ComputePipeline class ComputeShaderModule class D3DBlitOp struct UBOData class D3DBuffer class D3DCommandList class D3DCommandQueue class D3DComputePass class D3DComputePipeline class D3DComputeShaderModule class D3DDescriptorHandle class D3DDescriptorHeap class D3DDevice class D3DFence class D3DFragmentShaderModule class D3DFramebuffer struct D3DAttachment class D3DGraphics class D3DGraphicsContext struct D3DRenderPassData class D3DGraphicsPipeline struct Shaders struct State class D3DPipeline class D3DPipelineCache struct D3DPipelineUtil class D3DReadbackBuffer class D3DRenderPass struct D3DSamplerDesc class D3DShaderModule class D3DSurface class D3DSwapchain class D3DTexture struct GenMipmapData struct RtvData struct SamplerData struct SrvData class D3DVertexShaderModule class D3DWindow class Device class DrawColorOp class DrawMeshOp struct LightData struct UBO_FS_Data struct UBO_VS_Data class DrawOp class DrawTextureOp class FPSCounter class Fence class File class FileUtil struct Lock class FilterOp class FragmentShaderModule class Framebuffer struct Attachment class GLFWWindow class Graphics class GraphicsContext struct AttachmentDescription struct RenderPassConfig class GraphicsPipeline struct Descriptor struct State class InputListener class MTLApplication class MTLBuffer class MTLCommandBuffer class MTLCommandEncoder class MTLComputeCommandEncoder class MTLComputePipeline class MTLComputeShaderModule class MTLDepthStencilTexture class MTLDevice class MTLFragmentShaderModule class MTLFramebuffer class MTLGraphics class MTLGraphicsContext struct MTLRenderPassData class MTLGraphicsPipeline struct Shaders class MTLPipelineCache struct MTLPipelineUtil class MTLRenderCommandEncoder class MTLRenderPass class MTLShaderModule class MTLSurface class MTLTexture class MTLVertexShaderModule class MTLWindow class MatrixMultiplyCPUOp class MatrixMultiplyGPUOp struct UboData class MatrixMultiplyOp struct MatrixParam struct MeshData struct MeshUtil class Pipeline class PipelineCache class ProcessUtil class Queue struct Rect2D class RegexUtil struct Match struct Region class RenderPass class Semaphore class ShaderModule struct BufferInfo struct BufferMemberInfo struct DescriptorInfo class ShaderTools struct HLSLReflectData struct MacroDefinition struct MetalReflectData class StringUtil class Surface class Swapchain class Texture class Timer class Util struct VKBlit struct Region class VKBuffer class VKCommandBuffer class VKCommandPool class VKComputePipeline class VKComputeShaderModule class VKDebugMessenger class VKDescriptorSetLayoutCache struct VKDescriptorSetLayoutData class VKDevice class VKFence class VKFragmentShaderModule class VKFramebuffer struct VKAttachmentDescriptor struct VKAttachmentInfo class VKGraphics class VKGraphicsContext struct VKRenderPassData class VKGraphicsPipeline struct State class VKImage struct VKImageCreateInfo class VKImageView struct VKImageViewCreateInfo class VKInstance class VKPhysicalDevice class VKPipeline struct Descriptor struct ShaderStage class VKPipelineCache struct VKPipelineUtil class VKQueue class VKRenderPass struct VKSamplerCreateInfo class VKSemaphore class VKShaderModule class VKSurface class VKSwapchain struct queueFamilyProperties class VKTexture class VKVertexShaderModule class VKWindow class VertexShaderModule struct AttributeDescription class WWindow struct Monitor struct VideoMode class Window namespace std namespace std::chrono namespace std::placeholders Updated on 3 April 2021 at 20:21:52 PDT","title":"Classes"},{"location":"api/Classes/classBufferUtil/","text":"BufferUtil More... #include <BufferUtil.h> Detailed Description class BufferUtil; This utility module provides helper functions for creating various types of specialized GPU buffers Updated on 3 April 2021 at 20:21:51 PDT","title":"BufferUtil"},{"location":"api/Classes/classBufferUtil/#bufferutil","text":"More... #include <BufferUtil.h>","title":"BufferUtil"},{"location":"api/Classes/classBufferUtil/#detailed-description","text":"class BufferUtil; This utility module provides helper functions for creating various types of specialized GPU buffers Updated on 3 April 2021 at 20:21:51 PDT","title":"Detailed Description"},{"location":"api/Classes/classCamera/","text":"Camera More... #include <Camera.h> Detailed Description class Camera; This class supports 2D and 3D camera operations. It supports, panning, zooming, and rotation. It also supports user input via keyboard, mouse, and touch events. Updated on 3 April 2021 at 20:21:51 PDT","title":"Camera"},{"location":"api/Classes/classCamera/#camera","text":"More... #include <Camera.h>","title":"Camera"},{"location":"api/Classes/classCamera/#detailed-description","text":"class Camera; This class supports 2D and 3D camera operations. It supports, panning, zooming, and rotation. It also supports user input via keyboard, mouse, and touch events. Updated on 3 April 2021 at 20:21:51 PDT","title":"Detailed Description"},{"location":"api/Classes/classCommandBuffer/","text":"CommandBuffer More... #include <CommandBuffer.h> Detailed Description class CommandBuffer; This class supports GPU command buffer operations, including recording draw commands and submitting them to the GPU. It supports primary and secondary command buffers. Secondary command buffers can be recorded in parallel, using multiple threads, and can be added to a primary command buffer. Updated on 3 April 2021 at 20:21:51 PDT","title":"CommandBuffer"},{"location":"api/Classes/classCommandBuffer/#commandbuffer","text":"More... #include <CommandBuffer.h>","title":"CommandBuffer"},{"location":"api/Classes/classCommandBuffer/#detailed-description","text":"class CommandBuffer; This class supports GPU command buffer operations, including recording draw commands and submitting them to the GPU. It supports primary and secondary command buffers. Secondary command buffers can be recorded in parallel, using multiple threads, and can be added to a primary command buffer. Updated on 3 April 2021 at 20:21:51 PDT","title":"Detailed Description"},{"location":"api/Classes/classDevice/","text":"Device More... #include <Device.h> Detailed Description class Device; This is the base class for a GPU device abstraction Updated on 3 April 2021 at 20:21:51 PDT","title":"Device"},{"location":"api/Classes/classDevice/#device","text":"More... #include <Device.h>","title":"Device"},{"location":"api/Classes/classDevice/#detailed-description","text":"class Device; This is the base class for a GPU device abstraction Updated on 3 April 2021 at 20:21:51 PDT","title":"Detailed Description"},{"location":"api/Classes/classDrawOp/","text":"DrawOp More... #include <DrawOp.h> Detailed Description class DrawOp; This class defines the interface for draw operations. Updated on 3 April 2021 at 20:21:51 PDT","title":"DrawOp"},{"location":"api/Classes/classDrawOp/#drawop","text":"More... #include <DrawOp.h>","title":"DrawOp"},{"location":"api/Classes/classDrawOp/#detailed-description","text":"class DrawOp; This class defines the interface for draw operations. Updated on 3 April 2021 at 20:21:51 PDT","title":"Detailed Description"},{"location":"api/Classes/classFence/","text":"Fence More... #include <Fence.h> Detailed Description class Fence; This class implements a fence synchronization mechanism. The CPU waits for the fence to be signaled by the GPU when an operation is completed. Updated on 3 April 2021 at 20:21:51 PDT","title":"Fence"},{"location":"api/Classes/classFence/#fence","text":"More... #include <Fence.h>","title":"Fence"},{"location":"api/Classes/classFence/#detailed-description","text":"class Fence; This class implements a fence synchronization mechanism. The CPU waits for the fence to be signaled by the GPU when an operation is completed. Updated on 3 April 2021 at 20:21:51 PDT","title":"Detailed Description"},{"location":"api/Classes/classFilterOp/","text":"FilterOp More... #include <FilterOp.h> Detailed Description class FilterOp; This is the base class for filter operations. A filter can output to a texture or to a framebuffer. TODO: support chained filters. Updated on 3 April 2021 at 20:21:51 PDT","title":"FilterOp"},{"location":"api/Classes/classFilterOp/#filterop","text":"More... #include <FilterOp.h>","title":"FilterOp"},{"location":"api/Classes/classFilterOp/#detailed-description","text":"class FilterOp; This is the base class for filter operations. A filter can output to a texture or to a framebuffer. TODO: support chained filters. Updated on 3 April 2021 at 20:21:51 PDT","title":"Detailed Description"},{"location":"api/Classes/classFramebuffer/","text":"Framebuffer More... #include <Framebuffer.h> Detailed Description class Framebuffer; This class defines the interface for a framebuffer object. It supports rendering to a destination surface, such as a texture or a window surface. Updated on 3 April 2021 at 20:21:51 PDT","title":"Framebuffer"},{"location":"api/Classes/classFramebuffer/#framebuffer","text":"More... #include <Framebuffer.h>","title":"Framebuffer"},{"location":"api/Classes/classFramebuffer/#detailed-description","text":"class Framebuffer; This class defines the interface for a framebuffer object. It supports rendering to a destination surface, such as a texture or a window surface. Updated on 3 April 2021 at 20:21:51 PDT","title":"Detailed Description"},{"location":"api/Classes/classngfx_1_1BaseApplication/","text":"ngfx::BaseApplication Inherits from ngfx::InputListener Inherited by ngfx::MTLApplication Public Functions Name BaseApplication (const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false) virtual ~BaseApplication () virtual void init () virtual void createWindow () virtual void paint () virtual void recordCommandBuffers () virtual void close () virtual void onInit () virtual void onRecordCommandBuffer ( CommandBuffer * commandBuffer) =0 virtual void onUpdate () virtual void onPaint () virtual void run () virtual void drawFrame () Public Attributes Name std::unique_ptr< Graphics > graphics std::unique_ptr< Window > window std::unique_ptr< GraphicsContext > graphicsContext std::string appName int w int h bool enableDepthStencil bool offscreen bool persistentCommandBuffers Protected Attributes Name bool initOnce std::unique_ptr< ngfx::Texture > outputTexture std::unique_ptr< ngfx::Texture > depthTexture std::unique_ptr< Framebuffer > outputFramebuffer Additional inherited members Public Functions inherited from ngfx::InputListener Name virtual void onKey (KeyCode code, InputAction action) virtual void onScroll (double xoffset, double yoffset) virtual void onCursorPos (double x, double y) virtual void onMouseButton (MouseButton button, InputAction action) Public Functions Documentation function BaseApplication BaseApplication( const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false ) function ~BaseApplication inline virtual ~BaseApplication() function init virtual void init() Reimplemented by : ngfx::MTLApplication::init function createWindow virtual void createWindow() function paint virtual void paint() Reimplemented by : ngfx::MTLApplication::paint function recordCommandBuffers virtual void recordCommandBuffers() function close virtual void close() function onInit inline virtual void onInit() function onRecordCommandBuffer virtual void onRecordCommandBuffer( CommandBuffer * commandBuffer ) =0 function onUpdate inline virtual void onUpdate() function onPaint virtual void onPaint() function run virtual void run() Reimplemented by : ngfx::MTLApplication::run function drawFrame virtual void drawFrame() Public Attributes Documentation variable graphics std::unique_ptr< Graphics > graphics; variable window std::unique_ptr< Window > window; variable graphicsContext std::unique_ptr< GraphicsContext > graphicsContext; variable appName std::string appName; variable w int w; variable h int h; variable enableDepthStencil bool enableDepthStencil = false; variable offscreen bool offscreen = false; variable persistentCommandBuffers bool persistentCommandBuffers = true; Protected Attributes Documentation variable initOnce bool initOnce = true; variable outputTexture std::unique_ptr< ngfx::Texture > outputTexture; variable depthTexture std::unique_ptr< ngfx::Texture > depthTexture; variable outputFramebuffer std::unique_ptr< Framebuffer > outputFramebuffer; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::BaseApplication"},{"location":"api/Classes/classngfx_1_1BaseApplication/#ngfxbaseapplication","text":"Inherits from ngfx::InputListener Inherited by ngfx::MTLApplication","title":"ngfx::BaseApplication"},{"location":"api/Classes/classngfx_1_1BaseApplication/#public-functions","text":"Name BaseApplication (const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false) virtual ~BaseApplication () virtual void init () virtual void createWindow () virtual void paint () virtual void recordCommandBuffers () virtual void close () virtual void onInit () virtual void onRecordCommandBuffer ( CommandBuffer * commandBuffer) =0 virtual void onUpdate () virtual void onPaint () virtual void run () virtual void drawFrame ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1BaseApplication/#public-attributes","text":"Name std::unique_ptr< Graphics > graphics std::unique_ptr< Window > window std::unique_ptr< GraphicsContext > graphicsContext std::string appName int w int h bool enableDepthStencil bool offscreen bool persistentCommandBuffers","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1BaseApplication/#protected-attributes","text":"Name bool initOnce std::unique_ptr< ngfx::Texture > outputTexture std::unique_ptr< ngfx::Texture > depthTexture std::unique_ptr< Framebuffer > outputFramebuffer","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1BaseApplication/#additional-inherited-members","text":"Public Functions inherited from ngfx::InputListener Name virtual void onKey (KeyCode code, InputAction action) virtual void onScroll (double xoffset, double yoffset) virtual void onCursorPos (double x, double y) virtual void onMouseButton (MouseButton button, InputAction action)","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1BaseApplication/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-baseapplication","text":"BaseApplication( const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false )","title":"function BaseApplication"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-baseapplication_1","text":"inline virtual ~BaseApplication()","title":"function ~BaseApplication"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-init","text":"virtual void init() Reimplemented by : ngfx::MTLApplication::init","title":"function init"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-createwindow","text":"virtual void createWindow()","title":"function createWindow"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-paint","text":"virtual void paint() Reimplemented by : ngfx::MTLApplication::paint","title":"function paint"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-recordcommandbuffers","text":"virtual void recordCommandBuffers()","title":"function recordCommandBuffers"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-close","text":"virtual void close()","title":"function close"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-oninit","text":"inline virtual void onInit()","title":"function onInit"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-onrecordcommandbuffer","text":"virtual void onRecordCommandBuffer( CommandBuffer * commandBuffer ) =0","title":"function onRecordCommandBuffer"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-onupdate","text":"inline virtual void onUpdate()","title":"function onUpdate"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-onpaint","text":"virtual void onPaint()","title":"function onPaint"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-run","text":"virtual void run() Reimplemented by : ngfx::MTLApplication::run","title":"function run"},{"location":"api/Classes/classngfx_1_1BaseApplication/#function-drawframe","text":"virtual void drawFrame()","title":"function drawFrame"},{"location":"api/Classes/classngfx_1_1BaseApplication/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-graphics","text":"std::unique_ptr< Graphics > graphics;","title":"variable graphics"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-window","text":"std::unique_ptr< Window > window;","title":"variable window"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-graphicscontext","text":"std::unique_ptr< GraphicsContext > graphicsContext;","title":"variable graphicsContext"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-appname","text":"std::string appName;","title":"variable appName"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-w","text":"int w;","title":"variable w"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-h","text":"int h;","title":"variable h"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-enabledepthstencil","text":"bool enableDepthStencil = false;","title":"variable enableDepthStencil"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-offscreen","text":"bool offscreen = false;","title":"variable offscreen"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-persistentcommandbuffers","text":"bool persistentCommandBuffers = true;","title":"variable persistentCommandBuffers"},{"location":"api/Classes/classngfx_1_1BaseApplication/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-initonce","text":"bool initOnce = true;","title":"variable initOnce"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-outputtexture","text":"std::unique_ptr< ngfx::Texture > outputTexture;","title":"variable outputTexture"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-depthtexture","text":"std::unique_ptr< ngfx::Texture > depthTexture;","title":"variable depthTexture"},{"location":"api/Classes/classngfx_1_1BaseApplication/#variable-outputframebuffer","text":"std::unique_ptr< Framebuffer > outputFramebuffer; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable outputFramebuffer"},{"location":"api/Classes/classngfx_1_1Buffer/","text":"ngfx::Buffer More... #include <Buffer.h> Inherited by ngfx::D3DBuffer , ngfx::MTLBuffer , ngfx::VKBuffer Public Functions Name Buffer * create ( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags) template <typename T > Buffer * create ( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags) virtual ~Buffer () virtual void * map () =0 virtual void unmap () =0 virtual void upload (const void * data, uint32_t size, uint32_t offset =0) =0 virtual void download (void * data, uint32_t size, uint32_t offset =0) =0 Detailed Description class ngfx::Buffer; This class defines the interface for a graphics buffer. Each backend is responsible for implementing this interface via a subclass. The same buffer object can support multiple usage scenarios, including storing uniform data, vertex buffer data, index buffer data, etc. In addition, on shared memory architectures, it supports shared CPU/GPU access. Public Functions Documentation function create static Buffer * create( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) usageFlags The buffer usage flags Create a graphics buffer function create template <typename T > static inline Buffer * create( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags ) function ~Buffer inline virtual ~Buffer() Destroy the buffer function map virtual void * map() =0 Reimplemented by : ngfx::MTLBuffer::map , ngfx::VKBuffer::map , ngfx::D3DBuffer::map Map the buffer contents for CPU read/write access function unmap virtual void unmap() =0 Reimplemented by : ngfx::MTLBuffer::unmap , ngfx::VKBuffer::unmap , ngfx::D3DBuffer::unmap Unmap the buffer function upload virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Reimplemented by : ngfx::MTLBuffer::upload , ngfx::VKBuffer::upload , ngfx::D3DBuffer::upload Upload the CPU data to the GPU buffer function download virtual void download( void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Reimplemented by : ngfx::MTLBuffer::download , ngfx::VKBuffer::download , ngfx::D3DBuffer::download Download the GPU data to CPU-accessible memory Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Buffer"},{"location":"api/Classes/classngfx_1_1Buffer/#ngfxbuffer","text":"More... #include <Buffer.h> Inherited by ngfx::D3DBuffer , ngfx::MTLBuffer , ngfx::VKBuffer","title":"ngfx::Buffer"},{"location":"api/Classes/classngfx_1_1Buffer/#public-functions","text":"Name Buffer * create ( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags) template <typename T > Buffer * create ( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags) virtual ~Buffer () virtual void * map () =0 virtual void unmap () =0 virtual void upload (const void * data, uint32_t size, uint32_t offset =0) =0 virtual void download (void * data, uint32_t size, uint32_t offset =0) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Buffer/#detailed-description","text":"class ngfx::Buffer; This class defines the interface for a graphics buffer. Each backend is responsible for implementing this interface via a subclass. The same buffer object can support multiple usage scenarios, including storing uniform data, vertex buffer data, index buffer data, etc. In addition, on shared memory architectures, it supports shared CPU/GPU access.","title":"Detailed Description"},{"location":"api/Classes/classngfx_1_1Buffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Buffer/#function-create","text":"static Buffer * create( GraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags usageFlags ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) usageFlags The buffer usage flags Create a graphics buffer","title":"function create"},{"location":"api/Classes/classngfx_1_1Buffer/#function-create_1","text":"template <typename T > static inline Buffer * create( GraphicsContext * ctx, const std::vector< T > & v, BufferUsageFlags usageFlags )","title":"function create"},{"location":"api/Classes/classngfx_1_1Buffer/#function-buffer","text":"inline virtual ~Buffer() Destroy the buffer","title":"function ~Buffer"},{"location":"api/Classes/classngfx_1_1Buffer/#function-map","text":"virtual void * map() =0 Reimplemented by : ngfx::MTLBuffer::map , ngfx::VKBuffer::map , ngfx::D3DBuffer::map Map the buffer contents for CPU read/write access","title":"function map"},{"location":"api/Classes/classngfx_1_1Buffer/#function-unmap","text":"virtual void unmap() =0 Reimplemented by : ngfx::MTLBuffer::unmap , ngfx::VKBuffer::unmap , ngfx::D3DBuffer::unmap Unmap the buffer","title":"function unmap"},{"location":"api/Classes/classngfx_1_1Buffer/#function-upload","text":"virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Reimplemented by : ngfx::MTLBuffer::upload , ngfx::VKBuffer::upload , ngfx::D3DBuffer::upload Upload the CPU data to the GPU buffer","title":"function upload"},{"location":"api/Classes/classngfx_1_1Buffer/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t offset =0 ) =0 Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Reimplemented by : ngfx::MTLBuffer::download , ngfx::VKBuffer::download , ngfx::D3DBuffer::download Download the GPU data to CPU-accessible memory Updated on 3 April 2021 at 20:21:51 PDT","title":"function download"},{"location":"api/Classes/classngfx_1_1Camera/","text":"ngfx::Camera Inherits from ngfx::InputListener Public Functions Name virtual ~Camera () virtual void onKey (KeyCode keyCode, InputAction keyAction) override virtual void onScroll (double xoffset, double yoffset) override virtual void onCursorPos (double x, double y) override virtual void onMouseButton (MouseButton button, InputAction action) override void update () Public Attributes Name float panX float panY float zoom float yaw float pitch float roll mat4 viewMat uint32_t state double x double y Public Functions Documentation function ~Camera inline virtual ~Camera() Destroy the camera function onKey virtual void onKey( KeyCode keyCode, InputAction keyAction ) override Parameters : keyCode The key code keyAction The key action Reimplements : ngfx::InputListener::onKey Handle key press input event function onScroll virtual void onScroll( double xoffset, double yoffset ) override Parameters : xoffset The relative x offset yoffset The relative y offset Reimplements : ngfx::InputListener::onScroll Handle scroll input event function onCursorPos virtual void onCursorPos( double x, double y ) override Parameters : x The relative x movement y The relative y movement Reimplements : ngfx::InputListener::onCursorPos Handle cursor move event function onMouseButton virtual void onMouseButton( MouseButton button, InputAction action ) override Parameters : button The mouse button action The mouse button event Reimplements : ngfx::InputListener::onMouseButton Handle mouse button event function update void update() Update camera parameters This function is called once per frame Public Attributes Documentation variable panX float panX = 0.0f; The camera pan along the x axis variable panY float panY = 0.0f; The camera pan along the y axis variable zoom float zoom = 0.0f; The camera zoom variable yaw float yaw = 0.0f; The camera yaw (radians) variable pitch float pitch = 0.0f; The camera pitch (radians) variable roll float roll = 0.0f; The camera roll (radians) The camera view matrix variable viewMat mat4 viewMat; variable state uint32_t state = 0; variable x double x = -1.0; variable y double y = -1.0; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Camera"},{"location":"api/Classes/classngfx_1_1Camera/#ngfxcamera","text":"Inherits from ngfx::InputListener","title":"ngfx::Camera"},{"location":"api/Classes/classngfx_1_1Camera/#public-functions","text":"Name virtual ~Camera () virtual void onKey (KeyCode keyCode, InputAction keyAction) override virtual void onScroll (double xoffset, double yoffset) override virtual void onCursorPos (double x, double y) override virtual void onMouseButton (MouseButton button, InputAction action) override void update ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Camera/#public-attributes","text":"Name float panX float panY float zoom float yaw float pitch float roll mat4 viewMat uint32_t state double x double y","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Camera/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Camera/#function-camera","text":"inline virtual ~Camera() Destroy the camera","title":"function ~Camera"},{"location":"api/Classes/classngfx_1_1Camera/#function-onkey","text":"virtual void onKey( KeyCode keyCode, InputAction keyAction ) override Parameters : keyCode The key code keyAction The key action Reimplements : ngfx::InputListener::onKey Handle key press input event","title":"function onKey"},{"location":"api/Classes/classngfx_1_1Camera/#function-onscroll","text":"virtual void onScroll( double xoffset, double yoffset ) override Parameters : xoffset The relative x offset yoffset The relative y offset Reimplements : ngfx::InputListener::onScroll Handle scroll input event","title":"function onScroll"},{"location":"api/Classes/classngfx_1_1Camera/#function-oncursorpos","text":"virtual void onCursorPos( double x, double y ) override Parameters : x The relative x movement y The relative y movement Reimplements : ngfx::InputListener::onCursorPos Handle cursor move event","title":"function onCursorPos"},{"location":"api/Classes/classngfx_1_1Camera/#function-onmousebutton","text":"virtual void onMouseButton( MouseButton button, InputAction action ) override Parameters : button The mouse button action The mouse button event Reimplements : ngfx::InputListener::onMouseButton Handle mouse button event","title":"function onMouseButton"},{"location":"api/Classes/classngfx_1_1Camera/#function-update","text":"void update() Update camera parameters This function is called once per frame","title":"function update"},{"location":"api/Classes/classngfx_1_1Camera/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Camera/#variable-panx","text":"float panX = 0.0f; The camera pan along the x axis","title":"variable panX"},{"location":"api/Classes/classngfx_1_1Camera/#variable-pany","text":"float panY = 0.0f; The camera pan along the y axis","title":"variable panY"},{"location":"api/Classes/classngfx_1_1Camera/#variable-zoom","text":"float zoom = 0.0f; The camera zoom","title":"variable zoom"},{"location":"api/Classes/classngfx_1_1Camera/#variable-yaw","text":"float yaw = 0.0f; The camera yaw (radians)","title":"variable yaw"},{"location":"api/Classes/classngfx_1_1Camera/#variable-pitch","text":"float pitch = 0.0f; The camera pitch (radians)","title":"variable pitch"},{"location":"api/Classes/classngfx_1_1Camera/#variable-roll","text":"float roll = 0.0f; The camera roll (radians) The camera view matrix","title":"variable roll"},{"location":"api/Classes/classngfx_1_1Camera/#variable-viewmat","text":"mat4 viewMat;","title":"variable viewMat"},{"location":"api/Classes/classngfx_1_1Camera/#variable-state","text":"uint32_t state = 0;","title":"variable state"},{"location":"api/Classes/classngfx_1_1Camera/#variable-x","text":"double x = -1.0;","title":"variable x"},{"location":"api/Classes/classngfx_1_1Camera/#variable-y","text":"double y = -1.0; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable y"},{"location":"api/Classes/classngfx_1_1CommandBuffer/","text":"ngfx::CommandBuffer Inherited by ngfx::D3DCommandList , ngfx::MTLCommandBuffer , ngfx::VKCommandBuffer Public Functions Name CommandBuffer * create ( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY) virtual ~CommandBuffer () virtual void begin () =0 virtual void end () =0 Public Functions Documentation function create static CommandBuffer * create( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY ) Parameters : ctx The graphics context level The command buffer level Create the command buffer function ~CommandBuffer inline virtual ~CommandBuffer() Destroy the command buffer function begin virtual void begin() =0 Reimplemented by : ngfx::VKCommandBuffer::begin , ngfx::MTLCommandBuffer::begin , ngfx::D3DCommandList::begin Begin recording function end virtual void end() =0 Reimplemented by : ngfx::VKCommandBuffer::end , ngfx::MTLCommandBuffer::end , ngfx::D3DCommandList::end End recording Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::CommandBuffer"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#ngfxcommandbuffer","text":"Inherited by ngfx::D3DCommandList , ngfx::MTLCommandBuffer , ngfx::VKCommandBuffer","title":"ngfx::CommandBuffer"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#public-functions","text":"Name CommandBuffer * create ( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY) virtual ~CommandBuffer () virtual void begin () =0 virtual void end () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-create","text":"static CommandBuffer * create( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY ) Parameters : ctx The graphics context level The command buffer level Create the command buffer","title":"function create"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-commandbuffer","text":"inline virtual ~CommandBuffer() Destroy the command buffer","title":"function ~CommandBuffer"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-begin","text":"virtual void begin() =0 Reimplemented by : ngfx::VKCommandBuffer::begin , ngfx::MTLCommandBuffer::begin , ngfx::D3DCommandList::begin Begin recording","title":"function begin"},{"location":"api/Classes/classngfx_1_1CommandBuffer/#function-end","text":"virtual void end() =0 Reimplemented by : ngfx::VKCommandBuffer::end , ngfx::MTLCommandBuffer::end , ngfx::D3DCommandList::end End recording Updated on 3 April 2021 at 20:21:51 PDT","title":"function end"},{"location":"api/Classes/classngfx_1_1ComputeApplication/","text":"ngfx::ComputeApplication Public Functions Name ComputeApplication (const std::string & name, int w =0, int h =0) virtual ~ComputeApplication () virtual void onInit () virtual void onRecordCommandBuffer ( CommandBuffer * commandBuffer) virtual void onUpdate () virtual void run () Protected Functions Name virtual void init () virtual void close () virtual void doCompute ( CommandBuffer * commandBuffer) virtual void onComputeFinished () virtual void recordCommandBuffer ( CommandBuffer * commandBuffer) Protected Attributes Name std::unique_ptr< Graphics > graphics std::unique_ptr< Window > window std::unique_ptr< GraphicsContext > graphicsContext std::string appName int w int h Public Functions Documentation function ComputeApplication ComputeApplication( const std::string & name, int w =0, int h =0 ) function ~ComputeApplication inline virtual ~ComputeApplication() function onInit inline virtual void onInit() function onRecordCommandBuffer inline virtual void onRecordCommandBuffer( CommandBuffer * commandBuffer ) function onUpdate inline virtual void onUpdate() function run virtual void run() Protected Functions Documentation function init virtual void init() function close virtual void close() function doCompute virtual void doCompute( CommandBuffer * commandBuffer ) function onComputeFinished inline virtual void onComputeFinished() function recordCommandBuffer virtual void recordCommandBuffer( CommandBuffer * commandBuffer ) Protected Attributes Documentation variable graphics std::unique_ptr< Graphics > graphics; variable window std::unique_ptr< Window > window; variable graphicsContext std::unique_ptr< GraphicsContext > graphicsContext; variable appName std::string appName; variable w int w; variable h int h; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ComputeApplication"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#ngfxcomputeapplication","text":"","title":"ngfx::ComputeApplication"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#public-functions","text":"Name ComputeApplication (const std::string & name, int w =0, int h =0) virtual ~ComputeApplication () virtual void onInit () virtual void onRecordCommandBuffer ( CommandBuffer * commandBuffer) virtual void onUpdate () virtual void run ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#protected-functions","text":"Name virtual void init () virtual void close () virtual void doCompute ( CommandBuffer * commandBuffer) virtual void onComputeFinished () virtual void recordCommandBuffer ( CommandBuffer * commandBuffer)","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#protected-attributes","text":"Name std::unique_ptr< Graphics > graphics std::unique_ptr< Window > window std::unique_ptr< GraphicsContext > graphicsContext std::string appName int w int h","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-computeapplication","text":"ComputeApplication( const std::string & name, int w =0, int h =0 )","title":"function ComputeApplication"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-computeapplication_1","text":"inline virtual ~ComputeApplication()","title":"function ~ComputeApplication"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-oninit","text":"inline virtual void onInit()","title":"function onInit"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-onrecordcommandbuffer","text":"inline virtual void onRecordCommandBuffer( CommandBuffer * commandBuffer )","title":"function onRecordCommandBuffer"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-onupdate","text":"inline virtual void onUpdate()","title":"function onUpdate"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-run","text":"virtual void run()","title":"function run"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-init","text":"virtual void init()","title":"function init"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-close","text":"virtual void close()","title":"function close"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-docompute","text":"virtual void doCompute( CommandBuffer * commandBuffer )","title":"function doCompute"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-oncomputefinished","text":"inline virtual void onComputeFinished()","title":"function onComputeFinished"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#function-recordcommandbuffer","text":"virtual void recordCommandBuffer( CommandBuffer * commandBuffer )","title":"function recordCommandBuffer"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-graphics","text":"std::unique_ptr< Graphics > graphics;","title":"variable graphics"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-window","text":"std::unique_ptr< Window > window;","title":"variable window"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-graphicscontext","text":"std::unique_ptr< GraphicsContext > graphicsContext;","title":"variable graphicsContext"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-appname","text":"std::string appName;","title":"variable appName"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-w","text":"int w;","title":"variable w"},{"location":"api/Classes/classngfx_1_1ComputeApplication/#variable-h","text":"int h; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable h"},{"location":"api/Classes/classngfx_1_1ComputeOp/","text":"ngfx::ComputeOp Inherited by ngfx::MatrixMultiplyOp Public Functions Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) =0 Protected Attributes Name GraphicsContext * ctx Public Functions Documentation function ComputeOp inline ComputeOp( GraphicsContext * ctx ) function ~ComputeOp inline virtual ~ComputeOp() function apply virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) =0 Reimplemented by : ngfx::MatrixMultiplyGPUOp::apply , ngfx::MatrixMultiplyCPUOp::apply , ngfx::MatrixMultiplyOp::apply Protected Attributes Documentation variable ctx GraphicsContext * ctx; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ComputeOp"},{"location":"api/Classes/classngfx_1_1ComputeOp/#ngfxcomputeop","text":"Inherited by ngfx::MatrixMultiplyOp","title":"ngfx::ComputeOp"},{"location":"api/Classes/classngfx_1_1ComputeOp/#public-functions","text":"Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputeOp/#protected-attributes","text":"Name GraphicsContext * ctx","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1ComputeOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputeOp/#function-computeop","text":"inline ComputeOp( GraphicsContext * ctx )","title":"function ComputeOp"},{"location":"api/Classes/classngfx_1_1ComputeOp/#function-computeop_1","text":"inline virtual ~ComputeOp()","title":"function ~ComputeOp"},{"location":"api/Classes/classngfx_1_1ComputeOp/#function-apply","text":"virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) =0 Reimplemented by : ngfx::MatrixMultiplyGPUOp::apply , ngfx::MatrixMultiplyCPUOp::apply , ngfx::MatrixMultiplyOp::apply","title":"function apply"},{"location":"api/Classes/classngfx_1_1ComputeOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1ComputeOp/#variable-ctx","text":"GraphicsContext * ctx; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1ComputePass/","text":"ngfx::ComputePass Inherited by ngfx::D3DComputePass Public Functions Name virtual ~ComputePass () virtual void begin ( GraphicsContext * ctx, CommandBuffer * commandBuffer) virtual void end ( CommandBuffer * commandBuffer) Public Functions Documentation function ~ComputePass inline virtual ~ComputePass() function begin inline virtual void begin( GraphicsContext * ctx, CommandBuffer * commandBuffer ) function end inline virtual void end( CommandBuffer * commandBuffer ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ComputePass"},{"location":"api/Classes/classngfx_1_1ComputePass/#ngfxcomputepass","text":"Inherited by ngfx::D3DComputePass","title":"ngfx::ComputePass"},{"location":"api/Classes/classngfx_1_1ComputePass/#public-functions","text":"Name virtual ~ComputePass () virtual void begin ( GraphicsContext * ctx, CommandBuffer * commandBuffer) virtual void end ( CommandBuffer * commandBuffer)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputePass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputePass/#function-computepass","text":"inline virtual ~ComputePass()","title":"function ~ComputePass"},{"location":"api/Classes/classngfx_1_1ComputePass/#function-begin","text":"inline virtual void begin( GraphicsContext * ctx, CommandBuffer * commandBuffer )","title":"function begin"},{"location":"api/Classes/classngfx_1_1ComputePass/#function-end","text":"inline virtual void end( CommandBuffer * commandBuffer ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function end"},{"location":"api/Classes/classngfx_1_1ComputePipeline/","text":"ngfx::ComputePipeline Inherits from ngfx::Pipeline Inherited by ngfx::D3DComputePipeline , ngfx::MTLComputePipeline , ngfx::VKComputePipeline Public Functions Name ComputePipeline * create ( GraphicsContext * graphicsContext, ComputeShaderModule * cs) virtual ~ComputePipeline () Public Attributes Name std::vector< uint32_t > descriptorBindings Additional inherited members Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create static ComputePipeline * create( GraphicsContext * graphicsContext, ComputeShaderModule * cs ) function ~ComputePipeline inline virtual ~ComputePipeline() Public Attributes Documentation variable descriptorBindings std::vector< uint32_t > descriptorBindings; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ComputePipeline"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#ngfxcomputepipeline","text":"Inherits from ngfx::Pipeline Inherited by ngfx::D3DComputePipeline , ngfx::MTLComputePipeline , ngfx::VKComputePipeline","title":"ngfx::ComputePipeline"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#public-functions","text":"Name ComputePipeline * create ( GraphicsContext * graphicsContext, ComputeShaderModule * cs) virtual ~ComputePipeline ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#public-attributes","text":"Name std::vector< uint32_t > descriptorBindings","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#additional-inherited-members","text":"Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#function-create","text":"static ComputePipeline * create( GraphicsContext * graphicsContext, ComputeShaderModule * cs )","title":"function create"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#function-computepipeline","text":"inline virtual ~ComputePipeline()","title":"function ~ComputePipeline"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1ComputePipeline/#variable-descriptorbindings","text":"std::vector< uint32_t > descriptorBindings; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable descriptorBindings"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/","text":"ngfx::ComputeShaderModule Inherits from ngfx::ShaderModule Inherited by ngfx::D3DComputeShaderModule , ngfx::MTLComputeShaderModule , ngfx::VKComputeShaderModule Public Functions Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename) Additional inherited members Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function create static std::unique_ptr< ComputeShaderModule > create( Device * device, const std::string & filename ) function ~ComputeShaderModule inline virtual ~ComputeShaderModule() function initBindings inline void initBindings( const std::string & filename ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ComputeShaderModule"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#ngfxcomputeshadermodule","text":"Inherits from ngfx::ShaderModule Inherited by ngfx::D3DComputeShaderModule , ngfx::MTLComputeShaderModule , ngfx::VKComputeShaderModule","title":"ngfx::ComputeShaderModule"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#public-functions","text":"Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#function-create","text":"static std::unique_ptr< ComputeShaderModule > create( Device * device, const std::string & filename )","title":"function create"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#function-computeshadermodule","text":"inline virtual ~ComputeShaderModule()","title":"function ~ComputeShaderModule"},{"location":"api/Classes/classngfx_1_1ComputeShaderModule/#function-initbindings","text":"inline void initBindings( const std::string & filename ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/","text":"ngfx::D3DBlitOp Protected Classes Name struct UBOData Public Functions Name D3DBlitOp ( D3DGraphicsContext * ctx, D3DTexture * srcTexture, uint32_t srcLevel, D3DTexture * dstTexture, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer =0, uint32_t srcLayerCount =1, uint32_t dstBaseLayer =0, uint32_t dstLayerCount =1) void apply ( D3DGraphicsContext * ctx, D3DCommandList * cmdList, D3DGraphics * graphics) void draw ( D3DCommandList * cmdList, D3DGraphics * graphics) Protected Functions Name virtual void createPipeline () Public Attributes Name std::unique_ptr< D3DFramebuffer > outputFramebuffer std::unique_ptr< D3DBuffer > bPos std::unique_ptr< D3DBuffer > bTexCoord std::unique_ptr< D3DBuffer > bUbo D3DTexture * srcTexture D3DTexture * dstTexture uint32_t srcLevel uint32_t dstLevel Region srcRegion Region dstRegion uint32_t srcBaseLayer uint32_t srcLayerCount uint32_t dstBaseLayer uint32_t dstLayerCount Protected Attributes Name D3DGraphicsPipeline * graphicsPipeline uint32_t numVerts uint32_t B_POS uint32_t B_TEXCOORD uint32_t U_UBO uint32_t U_TEXTURE D3DGraphicsContext * ctx Public Functions Documentation function D3DBlitOp D3DBlitOp( D3DGraphicsContext * ctx, D3DTexture * srcTexture, uint32_t srcLevel, D3DTexture * dstTexture, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer =0, uint32_t srcLayerCount =1, uint32_t dstBaseLayer =0, uint32_t dstLayerCount =1 ) function apply void apply( D3DGraphicsContext * ctx, D3DCommandList * cmdList, D3DGraphics * graphics ) function draw void draw( D3DCommandList * cmdList, D3DGraphics * graphics ) Protected Functions Documentation function createPipeline virtual void createPipeline() Public Attributes Documentation variable outputFramebuffer std::unique_ptr< D3DFramebuffer > outputFramebuffer; variable bPos std::unique_ptr< D3DBuffer > bPos; variable bTexCoord std::unique_ptr< D3DBuffer > bTexCoord; variable bUbo std::unique_ptr< D3DBuffer > bUbo; variable srcTexture D3DTexture * srcTexture; variable dstTexture D3DTexture * dstTexture; variable srcLevel uint32_t srcLevel; variable dstLevel uint32_t dstLevel; variable srcRegion Region srcRegion; variable dstRegion Region dstRegion; variable srcBaseLayer uint32_t srcBaseLayer; variable srcLayerCount uint32_t srcLayerCount; variable dstBaseLayer uint32_t dstBaseLayer; variable dstLayerCount uint32_t dstLayerCount; Protected Attributes Documentation variable graphicsPipeline D3DGraphicsPipeline * graphicsPipeline; variable numVerts uint32_t numVerts; variable B_POS uint32_t B_POS; variable B_TEXCOORD uint32_t B_TEXCOORD; variable U_UBO uint32_t U_UBO; variable U_TEXTURE uint32_t U_TEXTURE; variable ctx D3DGraphicsContext * ctx; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DBlitOp"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#ngfxd3dblitop","text":"","title":"ngfx::D3DBlitOp"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#protected-classes","text":"Name struct UBOData","title":"Protected Classes"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#public-functions","text":"Name D3DBlitOp ( D3DGraphicsContext * ctx, D3DTexture * srcTexture, uint32_t srcLevel, D3DTexture * dstTexture, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer =0, uint32_t srcLayerCount =1, uint32_t dstBaseLayer =0, uint32_t dstLayerCount =1) void apply ( D3DGraphicsContext * ctx, D3DCommandList * cmdList, D3DGraphics * graphics) void draw ( D3DCommandList * cmdList, D3DGraphics * graphics)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#protected-functions","text":"Name virtual void createPipeline ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#public-attributes","text":"Name std::unique_ptr< D3DFramebuffer > outputFramebuffer std::unique_ptr< D3DBuffer > bPos std::unique_ptr< D3DBuffer > bTexCoord std::unique_ptr< D3DBuffer > bUbo D3DTexture * srcTexture D3DTexture * dstTexture uint32_t srcLevel uint32_t dstLevel Region srcRegion Region dstRegion uint32_t srcBaseLayer uint32_t srcLayerCount uint32_t dstBaseLayer uint32_t dstLayerCount","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#protected-attributes","text":"Name D3DGraphicsPipeline * graphicsPipeline uint32_t numVerts uint32_t B_POS uint32_t B_TEXCOORD uint32_t U_UBO uint32_t U_TEXTURE D3DGraphicsContext * ctx","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#function-d3dblitop","text":"D3DBlitOp( D3DGraphicsContext * ctx, D3DTexture * srcTexture, uint32_t srcLevel, D3DTexture * dstTexture, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer =0, uint32_t srcLayerCount =1, uint32_t dstBaseLayer =0, uint32_t dstLayerCount =1 )","title":"function D3DBlitOp"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#function-apply","text":"void apply( D3DGraphicsContext * ctx, D3DCommandList * cmdList, D3DGraphics * graphics )","title":"function apply"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#function-draw","text":"void draw( D3DCommandList * cmdList, D3DGraphics * graphics )","title":"function draw"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#function-createpipeline","text":"virtual void createPipeline()","title":"function createPipeline"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-outputframebuffer","text":"std::unique_ptr< D3DFramebuffer > outputFramebuffer;","title":"variable outputFramebuffer"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-bpos","text":"std::unique_ptr< D3DBuffer > bPos;","title":"variable bPos"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-btexcoord","text":"std::unique_ptr< D3DBuffer > bTexCoord;","title":"variable bTexCoord"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-bubo","text":"std::unique_ptr< D3DBuffer > bUbo;","title":"variable bUbo"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-srctexture","text":"D3DTexture * srcTexture;","title":"variable srcTexture"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-dsttexture","text":"D3DTexture * dstTexture;","title":"variable dstTexture"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-srclevel","text":"uint32_t srcLevel;","title":"variable srcLevel"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-dstlevel","text":"uint32_t dstLevel;","title":"variable dstLevel"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-srcregion","text":"Region srcRegion;","title":"variable srcRegion"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-dstregion","text":"Region dstRegion;","title":"variable dstRegion"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-srcbaselayer","text":"uint32_t srcBaseLayer;","title":"variable srcBaseLayer"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-srclayercount","text":"uint32_t srcLayerCount;","title":"variable srcLayerCount"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-dstbaselayer","text":"uint32_t dstBaseLayer;","title":"variable dstBaseLayer"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-dstlayercount","text":"uint32_t dstLayerCount;","title":"variable dstLayerCount"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-graphicspipeline","text":"D3DGraphicsPipeline * graphicsPipeline;","title":"variable graphicsPipeline"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-numverts","text":"uint32_t numVerts;","title":"variable numVerts"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-b_pos","text":"uint32_t B_POS;","title":"variable B_POS"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-b_texcoord","text":"uint32_t B_TEXCOORD;","title":"variable B_TEXCOORD"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-u_ubo","text":"uint32_t U_UBO;","title":"variable U_UBO"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-u_texture","text":"uint32_t U_TEXTURE;","title":"variable U_TEXTURE"},{"location":"api/Classes/classngfx_1_1D3DBlitOp/#variable-ctx","text":"D3DGraphicsContext * ctx; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1D3DBuffer/","text":"ngfx::D3DBuffer Inherits from ngfx::Buffer Inherited by ngfx::D3DReadbackBuffer Public Functions Name void create ( D3DGraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags bufferUsageFlags) void create ( D3DGraphicsContext * ctx, const void * data, uint32_t size, D3D12_HEAP_TYPE heapType =D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_FLAGS resourceFlags =D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATES initialResourceState =D3D12_RESOURCE_STATE_GENERIC_READ) virtual ~D3DBuffer () virtual void * map () override virtual void unmap () override virtual void upload (const void * data, uint32_t size, uint32_t offset =0) override virtual void download (void * data, uint32_t size, uint32_t offset =0) override Public Attributes Name uint32_t size ComPtr< ID3D12Resource > v Protected Attributes Name D3DGraphicsContext * ctx D3D12_HEAP_TYPE heapType D3D12_RESOURCE_STATES initialResourceState D3D12_RESOURCE_STATES currentResourceState D3DReadbackBuffer * d3dReadbackBuffer void * d3dReadBackBufferPtr Additional inherited members Public Functions inherited from ngfx::Buffer Name virtual ~Buffer () Public Functions Documentation function create void create( D3DGraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags bufferUsageFlags ) function create void create( D3DGraphicsContext * ctx, const void * data, uint32_t size, D3D12_HEAP_TYPE heapType =D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_FLAGS resourceFlags =D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATES initialResourceState =D3D12_RESOURCE_STATE_GENERIC_READ ) function ~D3DBuffer virtual ~D3DBuffer() function map virtual void * map() override Reimplements : ngfx::Buffer::map Map the buffer contents for CPU read/write access function unmap virtual void unmap() override Reimplements : ngfx::Buffer::unmap Unmap the buffer function upload virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::upload Upload the CPU data to the GPU buffer function download inline virtual void download( void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::download Download the GPU data to CPU-accessible memory Public Attributes Documentation variable size uint32_t size; variable v ComPtr< ID3D12Resource > v; Protected Attributes Documentation variable ctx D3DGraphicsContext * ctx; variable heapType D3D12_HEAP_TYPE heapType; variable initialResourceState D3D12_RESOURCE_STATES initialResourceState; variable currentResourceState D3D12_RESOURCE_STATES currentResourceState; variable d3dReadbackBuffer D3DReadbackBuffer * d3dReadbackBuffer = nullptr; variable d3dReadBackBufferPtr void * d3dReadBackBufferPtr = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DBuffer"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#ngfxd3dbuffer","text":"Inherits from ngfx::Buffer Inherited by ngfx::D3DReadbackBuffer","title":"ngfx::D3DBuffer"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#public-functions","text":"Name void create ( D3DGraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags bufferUsageFlags) void create ( D3DGraphicsContext * ctx, const void * data, uint32_t size, D3D12_HEAP_TYPE heapType =D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_FLAGS resourceFlags =D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATES initialResourceState =D3D12_RESOURCE_STATE_GENERIC_READ) virtual ~D3DBuffer () virtual void * map () override virtual void unmap () override virtual void upload (const void * data, uint32_t size, uint32_t offset =0) override virtual void download (void * data, uint32_t size, uint32_t offset =0) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#public-attributes","text":"Name uint32_t size ComPtr< ID3D12Resource > v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#protected-attributes","text":"Name D3DGraphicsContext * ctx D3D12_HEAP_TYPE heapType D3D12_RESOURCE_STATES initialResourceState D3D12_RESOURCE_STATES currentResourceState D3DReadbackBuffer * d3dReadbackBuffer void * d3dReadBackBufferPtr","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#additional-inherited-members","text":"Public Functions inherited from ngfx::Buffer Name virtual ~Buffer ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#function-create","text":"void create( D3DGraphicsContext * ctx, const void * data, uint32_t size, BufferUsageFlags bufferUsageFlags )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#function-create_1","text":"void create( D3DGraphicsContext * ctx, const void * data, uint32_t size, D3D12_HEAP_TYPE heapType =D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_FLAGS resourceFlags =D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATES initialResourceState =D3D12_RESOURCE_STATE_GENERIC_READ )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#function-d3dbuffer","text":"virtual ~D3DBuffer()","title":"function ~D3DBuffer"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#function-map","text":"virtual void * map() override Reimplements : ngfx::Buffer::map Map the buffer contents for CPU read/write access","title":"function map"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#function-unmap","text":"virtual void unmap() override Reimplements : ngfx::Buffer::unmap Unmap the buffer","title":"function unmap"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#function-upload","text":"virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::upload Upload the CPU data to the GPU buffer","title":"function upload"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#function-download","text":"inline virtual void download( void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::download Download the GPU data to CPU-accessible memory","title":"function download"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#variable-size","text":"uint32_t size;","title":"variable size"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#variable-v","text":"ComPtr< ID3D12Resource > v;","title":"variable v"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#variable-ctx","text":"D3DGraphicsContext * ctx;","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#variable-heaptype","text":"D3D12_HEAP_TYPE heapType;","title":"variable heapType"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#variable-initialresourcestate","text":"D3D12_RESOURCE_STATES initialResourceState;","title":"variable initialResourceState"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#variable-currentresourcestate","text":"D3D12_RESOURCE_STATES currentResourceState;","title":"variable currentResourceState"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#variable-d3dreadbackbuffer","text":"D3DReadbackBuffer * d3dReadbackBuffer = nullptr;","title":"variable d3dReadbackBuffer"},{"location":"api/Classes/classngfx_1_1D3DBuffer/#variable-d3dreadbackbufferptr","text":"void * d3dReadBackBufferPtr = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable d3dReadBackBufferPtr"},{"location":"api/Classes/classngfx_1_1D3DCommandList/","text":"ngfx::D3DCommandList Inherits from ngfx::CommandBuffer Public Functions Name void create (ID3D12Device * device, D3D12_COMMAND_LIST_TYPE type =D3D12_COMMAND_LIST_TYPE_DIRECT) virtual ~D3DCommandList () virtual void begin () override virtual void end () override Public Attributes Name ComPtr< ID3D12GraphicsCommandList > v Additional inherited members Public Functions inherited from ngfx::CommandBuffer Name virtual ~CommandBuffer () Public Functions Documentation function create void create( ID3D12Device * device, D3D12_COMMAND_LIST_TYPE type =D3D12_COMMAND_LIST_TYPE_DIRECT ) function ~D3DCommandList inline virtual ~D3DCommandList() function begin virtual void begin() override Reimplements : ngfx::CommandBuffer::begin Begin recording function end virtual void end() override Reimplements : ngfx::CommandBuffer::end End recording Public Attributes Documentation variable v ComPtr< ID3D12GraphicsCommandList > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DCommandList"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#ngfxd3dcommandlist","text":"Inherits from ngfx::CommandBuffer","title":"ngfx::D3DCommandList"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#public-functions","text":"Name void create (ID3D12Device * device, D3D12_COMMAND_LIST_TYPE type =D3D12_COMMAND_LIST_TYPE_DIRECT) virtual ~D3DCommandList () virtual void begin () override virtual void end () override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#public-attributes","text":"Name ComPtr< ID3D12GraphicsCommandList > v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#additional-inherited-members","text":"Public Functions inherited from ngfx::CommandBuffer Name virtual ~CommandBuffer ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#function-create","text":"void create( ID3D12Device * device, D3D12_COMMAND_LIST_TYPE type =D3D12_COMMAND_LIST_TYPE_DIRECT )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#function-d3dcommandlist","text":"inline virtual ~D3DCommandList()","title":"function ~D3DCommandList"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#function-begin","text":"virtual void begin() override Reimplements : ngfx::CommandBuffer::begin Begin recording","title":"function begin"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#function-end","text":"virtual void end() override Reimplements : ngfx::CommandBuffer::end End recording","title":"function end"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DCommandList/#variable-v","text":"ComPtr< ID3D12GraphicsCommandList > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/","text":"ngfx::D3DCommandQueue Inherits from ngfx::Queue Public Functions Name void create ( D3DGraphicsContext * ctx) virtual ~D3DCommandQueue () virtual void present () override virtual void submit ( CommandBuffer * commandBuffer) override void submit (ID3D12CommandList * commandList, ID3D12Fence * fence) virtual void waitIdle () override Public Attributes Name ComPtr< ID3D12CommandQueue > v Additional inherited members Public Functions inherited from ngfx::Queue Name virtual ~Queue () Public Functions Documentation function create void create( D3DGraphicsContext * ctx ) function ~D3DCommandQueue inline virtual ~D3DCommandQueue() function present virtual void present() override Reimplements : ngfx::Queue::present function submit virtual void submit( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Queue::submit function submit void submit( ID3D12CommandList * commandList, ID3D12Fence * fence ) function waitIdle virtual void waitIdle() override Reimplements : ngfx::Queue::waitIdle Public Attributes Documentation variable v ComPtr< ID3D12CommandQueue > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DCommandQueue"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#ngfxd3dcommandqueue","text":"Inherits from ngfx::Queue","title":"ngfx::D3DCommandQueue"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#public-functions","text":"Name void create ( D3DGraphicsContext * ctx) virtual ~D3DCommandQueue () virtual void present () override virtual void submit ( CommandBuffer * commandBuffer) override void submit (ID3D12CommandList * commandList, ID3D12Fence * fence) virtual void waitIdle () override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#public-attributes","text":"Name ComPtr< ID3D12CommandQueue > v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#additional-inherited-members","text":"Public Functions inherited from ngfx::Queue Name virtual ~Queue ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#function-create","text":"void create( D3DGraphicsContext * ctx )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#function-d3dcommandqueue","text":"inline virtual ~D3DCommandQueue()","title":"function ~D3DCommandQueue"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#function-present","text":"virtual void present() override Reimplements : ngfx::Queue::present","title":"function present"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#function-submit","text":"virtual void submit( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Queue::submit","title":"function submit"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#function-submit_1","text":"void submit( ID3D12CommandList * commandList, ID3D12Fence * fence )","title":"function submit"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#function-waitidle","text":"virtual void waitIdle() override Reimplements : ngfx::Queue::waitIdle","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DCommandQueue/#variable-v","text":"ComPtr< ID3D12CommandQueue > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1D3DComputePass/","text":"ngfx::D3DComputePass Inherits from ngfx::ComputePass Public Functions Name virtual ~D3DComputePass () Additional inherited members Public Functions inherited from ngfx::ComputePass Name virtual ~ComputePass () virtual void begin ( GraphicsContext * ctx, CommandBuffer * commandBuffer) virtual void end ( CommandBuffer * commandBuffer) Public Functions Documentation function ~D3DComputePass inline virtual ~D3DComputePass() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DComputePass"},{"location":"api/Classes/classngfx_1_1D3DComputePass/#ngfxd3dcomputepass","text":"Inherits from ngfx::ComputePass","title":"ngfx::D3DComputePass"},{"location":"api/Classes/classngfx_1_1D3DComputePass/#public-functions","text":"Name virtual ~D3DComputePass ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DComputePass/#additional-inherited-members","text":"Public Functions inherited from ngfx::ComputePass Name virtual ~ComputePass () virtual void begin ( GraphicsContext * ctx, CommandBuffer * commandBuffer) virtual void end ( CommandBuffer * commandBuffer)","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DComputePass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DComputePass/#function-d3dcomputepass","text":"inline virtual ~D3DComputePass() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~D3DComputePass"},{"location":"api/Classes/classngfx_1_1D3DComputePipeline/","text":"ngfx::D3DComputePipeline Inherits from ngfx::ComputePipeline , ngfx::D3DPipeline , ngfx::Pipeline Public Functions Name void create ( D3DGraphicsContext * ctx, const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_SHADER_BYTECODE shaderByteCode) Public Attributes Name ComPtr< ID3D12PipelineState > d3dPipelineState Additional inherited members Public Functions inherited from ngfx::ComputePipeline Name virtual ~ComputePipeline () Public Attributes inherited from ngfx::ComputePipeline Name std::vector< uint32_t > descriptorBindings Public Functions inherited from ngfx::D3DPipeline Name virtual ~D3DPipeline () Protected Functions inherited from ngfx::D3DPipeline Name void createRootSignature (const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =D3D12_ROOT_SIGNATURE_FLAG_NONE) Public Attributes inherited from ngfx::D3DPipeline Name ComPtr< ID3D12RootSignature > d3dRootSignature Protected Attributes inherited from ngfx::D3DPipeline Name D3DGraphicsContext * ctx Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create void create( D3DGraphicsContext * ctx, const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_SHADER_BYTECODE shaderByteCode ) Public Attributes Documentation variable d3dPipelineState ComPtr< ID3D12PipelineState > d3dPipelineState; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DComputePipeline"},{"location":"api/Classes/classngfx_1_1D3DComputePipeline/#ngfxd3dcomputepipeline","text":"Inherits from ngfx::ComputePipeline , ngfx::D3DPipeline , ngfx::Pipeline","title":"ngfx::D3DComputePipeline"},{"location":"api/Classes/classngfx_1_1D3DComputePipeline/#public-functions","text":"Name void create ( D3DGraphicsContext * ctx, const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_SHADER_BYTECODE shaderByteCode)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DComputePipeline/#public-attributes","text":"Name ComPtr< ID3D12PipelineState > d3dPipelineState","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DComputePipeline/#additional-inherited-members","text":"Public Functions inherited from ngfx::ComputePipeline Name virtual ~ComputePipeline () Public Attributes inherited from ngfx::ComputePipeline Name std::vector< uint32_t > descriptorBindings Public Functions inherited from ngfx::D3DPipeline Name virtual ~D3DPipeline () Protected Functions inherited from ngfx::D3DPipeline Name void createRootSignature (const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =D3D12_ROOT_SIGNATURE_FLAG_NONE) Public Attributes inherited from ngfx::D3DPipeline Name ComPtr< ID3D12RootSignature > d3dRootSignature Protected Attributes inherited from ngfx::D3DPipeline Name D3DGraphicsContext * ctx Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DComputePipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DComputePipeline/#function-create","text":"void create( D3DGraphicsContext * ctx, const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_SHADER_BYTECODE shaderByteCode )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DComputePipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DComputePipeline/#variable-d3dpipelinestate","text":"ComPtr< ID3D12PipelineState > d3dPipelineState; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable d3dPipelineState"},{"location":"api/Classes/classngfx_1_1D3DComputeShaderModule/","text":"ngfx::D3DComputeShaderModule Inherits from ngfx::ComputeShaderModule , ngfx::D3DShaderModule , ngfx::ShaderModule Public Functions Name virtual ~D3DComputeShaderModule () Additional inherited members Public Functions inherited from ngfx::ComputeShaderModule Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::D3DShaderModule Name void initFromFile (const std::string & filename) virtual ~D3DShaderModule () void initFromByteCode (void * bytecodeData, uint32_t bytecodeSize) void compile (const std::string & filename) Public Attributes inherited from ngfx::D3DShaderModule Name D3D12_SHADER_BYTECODE d3dShaderByteCode Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function ~D3DComputeShaderModule inline virtual ~D3DComputeShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DComputeShaderModule"},{"location":"api/Classes/classngfx_1_1D3DComputeShaderModule/#ngfxd3dcomputeshadermodule","text":"Inherits from ngfx::ComputeShaderModule , ngfx::D3DShaderModule , ngfx::ShaderModule","title":"ngfx::D3DComputeShaderModule"},{"location":"api/Classes/classngfx_1_1D3DComputeShaderModule/#public-functions","text":"Name virtual ~D3DComputeShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DComputeShaderModule/#additional-inherited-members","text":"Public Functions inherited from ngfx::ComputeShaderModule Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::D3DShaderModule Name void initFromFile (const std::string & filename) virtual ~D3DShaderModule () void initFromByteCode (void * bytecodeData, uint32_t bytecodeSize) void compile (const std::string & filename) Public Attributes inherited from ngfx::D3DShaderModule Name D3D12_SHADER_BYTECODE d3dShaderByteCode Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DComputeShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DComputeShaderModule/#function-d3dcomputeshadermodule","text":"inline virtual ~D3DComputeShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~D3DComputeShaderModule"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/","text":"ngfx::D3DDescriptorHandle Public Functions Name D3DDescriptorHandle () D3DDescriptorHandle (uint32_t descriptorSize) D3DDescriptorHandle & operator++ () Public Attributes Name D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle uint32_t descriptorSize Public Functions Documentation function D3DDescriptorHandle inline D3DDescriptorHandle() function D3DDescriptorHandle D3DDescriptorHandle( uint32_t descriptorSize ) function operator++ D3DDescriptorHandle & operator++() Public Attributes Documentation variable cpuHandle D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle {}; variable gpuHandle D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle {}; variable descriptorSize uint32_t descriptorSize = 0; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DDescriptorHandle"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#ngfxd3ddescriptorhandle","text":"","title":"ngfx::D3DDescriptorHandle"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#public-functions","text":"Name D3DDescriptorHandle () D3DDescriptorHandle (uint32_t descriptorSize) D3DDescriptorHandle & operator++ ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#public-attributes","text":"Name D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle uint32_t descriptorSize","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#function-d3ddescriptorhandle","text":"inline D3DDescriptorHandle()","title":"function D3DDescriptorHandle"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#function-d3ddescriptorhandle_1","text":"D3DDescriptorHandle( uint32_t descriptorSize )","title":"function D3DDescriptorHandle"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#function-operator","text":"D3DDescriptorHandle & operator++()","title":"function operator++"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#variable-cpuhandle","text":"D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle {};","title":"variable cpuHandle"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#variable-gpuhandle","text":"D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle {};","title":"variable gpuHandle"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHandle/#variable-descriptorsize","text":"uint32_t descriptorSize = 0; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable descriptorSize"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/","text":"ngfx::D3DDescriptorHeap Public Functions Name void create (ID3D12Device * d3dDevice, D3D12_DESCRIPTOR_HEAP_TYPE type, UINT maxDescriptors, D3D12_DESCRIPTOR_HEAP_FLAGS flags) Public Attributes Name D3DDescriptorHandle handle UINT maxDescriptors D3D12_DESCRIPTOR_HEAP_TYPE type ComPtr< ID3D12DescriptorHeap > v Public Functions Documentation function create void create( ID3D12Device * d3dDevice, D3D12_DESCRIPTOR_HEAP_TYPE type, UINT maxDescriptors, D3D12_DESCRIPTOR_HEAP_FLAGS flags ) Public Attributes Documentation variable handle D3DDescriptorHandle handle; variable maxDescriptors UINT maxDescriptors; variable type D3D12_DESCRIPTOR_HEAP_TYPE type; variable v ComPtr< ID3D12DescriptorHeap > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DDescriptorHeap"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/#ngfxd3ddescriptorheap","text":"","title":"ngfx::D3DDescriptorHeap"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/#public-functions","text":"Name void create (ID3D12Device * d3dDevice, D3D12_DESCRIPTOR_HEAP_TYPE type, UINT maxDescriptors, D3D12_DESCRIPTOR_HEAP_FLAGS flags)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/#public-attributes","text":"Name D3DDescriptorHandle handle UINT maxDescriptors D3D12_DESCRIPTOR_HEAP_TYPE type ComPtr< ID3D12DescriptorHeap > v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/#function-create","text":"void create( ID3D12Device * d3dDevice, D3D12_DESCRIPTOR_HEAP_TYPE type, UINT maxDescriptors, D3D12_DESCRIPTOR_HEAP_FLAGS flags )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/#variable-handle","text":"D3DDescriptorHandle handle;","title":"variable handle"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/#variable-maxdescriptors","text":"UINT maxDescriptors;","title":"variable maxDescriptors"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/#variable-type","text":"D3D12_DESCRIPTOR_HEAP_TYPE type;","title":"variable type"},{"location":"api/Classes/classngfx_1_1D3DDescriptorHeap/#variable-v","text":"ComPtr< ID3D12DescriptorHeap > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1D3DDevice/","text":"ngfx::D3DDevice Inherits from ngfx::Device Public Functions Name void create ( D3DGraphicsContext * ctx) void waitIdle () Public Attributes Name ComPtr< IDXGIAdapter1 > hardwareAdapter ComPtr< ID3D12Device > v Public Functions Documentation function create void create( D3DGraphicsContext * ctx ) function waitIdle void waitIdle() Public Attributes Documentation variable hardwareAdapter ComPtr< IDXGIAdapter1 > hardwareAdapter; variable v ComPtr< ID3D12Device > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DDevice"},{"location":"api/Classes/classngfx_1_1D3DDevice/#ngfxd3ddevice","text":"Inherits from ngfx::Device","title":"ngfx::D3DDevice"},{"location":"api/Classes/classngfx_1_1D3DDevice/#public-functions","text":"Name void create ( D3DGraphicsContext * ctx) void waitIdle ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DDevice/#public-attributes","text":"Name ComPtr< IDXGIAdapter1 > hardwareAdapter ComPtr< ID3D12Device > v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DDevice/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DDevice/#function-create","text":"void create( D3DGraphicsContext * ctx )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DDevice/#function-waitidle","text":"void waitIdle()","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1D3DDevice/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DDevice/#variable-hardwareadapter","text":"ComPtr< IDXGIAdapter1 > hardwareAdapter;","title":"variable hardwareAdapter"},{"location":"api/Classes/classngfx_1_1D3DDevice/#variable-v","text":"ComPtr< ID3D12Device > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1D3DFence/","text":"ngfx::D3DFence Inherits from ngfx::Fence Public Types Name enum Value { UNSIGNALED, SIGNALED} Public Functions Name void create (ID3D12Device * device, Value initialValue =UNSIGNALED) virtual ~D3DFence () virtual void wait () override virtual void reset () override Public Attributes Name ComPtr< ID3D12Fence > v HANDLE fenceEvent Additional inherited members Public Functions inherited from ngfx::Fence Name virtual ~Fence () Public Types Documentation enum Value Enumerator Value Description UNSIGNALED SIGNALED Public Functions Documentation function create void create( ID3D12Device * device, Value initialValue =UNSIGNALED ) function ~D3DFence inline virtual ~D3DFence() function wait virtual void wait() override Reimplements : ngfx::Fence::wait Wait for the fence to be signaled by the GPU function reset virtual void reset() override Reimplements : ngfx::Fence::reset Reset the fence Public Attributes Documentation variable v ComPtr< ID3D12Fence > v; variable fenceEvent HANDLE fenceEvent; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DFence"},{"location":"api/Classes/classngfx_1_1D3DFence/#ngfxd3dfence","text":"Inherits from ngfx::Fence","title":"ngfx::D3DFence"},{"location":"api/Classes/classngfx_1_1D3DFence/#public-types","text":"Name enum Value { UNSIGNALED, SIGNALED}","title":"Public Types"},{"location":"api/Classes/classngfx_1_1D3DFence/#public-functions","text":"Name void create (ID3D12Device * device, Value initialValue =UNSIGNALED) virtual ~D3DFence () virtual void wait () override virtual void reset () override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DFence/#public-attributes","text":"Name ComPtr< ID3D12Fence > v HANDLE fenceEvent","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DFence/#additional-inherited-members","text":"Public Functions inherited from ngfx::Fence Name virtual ~Fence ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DFence/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1D3DFence/#enum-value","text":"Enumerator Value Description UNSIGNALED SIGNALED","title":"enum Value"},{"location":"api/Classes/classngfx_1_1D3DFence/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DFence/#function-create","text":"void create( ID3D12Device * device, Value initialValue =UNSIGNALED )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DFence/#function-d3dfence","text":"inline virtual ~D3DFence()","title":"function ~D3DFence"},{"location":"api/Classes/classngfx_1_1D3DFence/#function-wait","text":"virtual void wait() override Reimplements : ngfx::Fence::wait Wait for the fence to be signaled by the GPU","title":"function wait"},{"location":"api/Classes/classngfx_1_1D3DFence/#function-reset","text":"virtual void reset() override Reimplements : ngfx::Fence::reset Reset the fence","title":"function reset"},{"location":"api/Classes/classngfx_1_1D3DFence/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DFence/#variable-v","text":"ComPtr< ID3D12Fence > v;","title":"variable v"},{"location":"api/Classes/classngfx_1_1D3DFence/#variable-fenceevent","text":"HANDLE fenceEvent; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable fenceEvent"},{"location":"api/Classes/classngfx_1_1D3DFragmentShaderModule/","text":"ngfx::D3DFragmentShaderModule Inherits from ngfx::FragmentShaderModule , ngfx::D3DShaderModule , ngfx::ShaderModule Public Functions Name virtual ~D3DFragmentShaderModule () Additional inherited members Public Functions inherited from ngfx::FragmentShaderModule Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::D3DShaderModule Name void initFromFile (const std::string & filename) virtual ~D3DShaderModule () void initFromByteCode (void * bytecodeData, uint32_t bytecodeSize) void compile (const std::string & filename) Public Attributes inherited from ngfx::D3DShaderModule Name D3D12_SHADER_BYTECODE d3dShaderByteCode Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function ~D3DFragmentShaderModule inline virtual ~D3DFragmentShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DFragmentShaderModule"},{"location":"api/Classes/classngfx_1_1D3DFragmentShaderModule/#ngfxd3dfragmentshadermodule","text":"Inherits from ngfx::FragmentShaderModule , ngfx::D3DShaderModule , ngfx::ShaderModule","title":"ngfx::D3DFragmentShaderModule"},{"location":"api/Classes/classngfx_1_1D3DFragmentShaderModule/#public-functions","text":"Name virtual ~D3DFragmentShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DFragmentShaderModule/#additional-inherited-members","text":"Public Functions inherited from ngfx::FragmentShaderModule Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::D3DShaderModule Name void initFromFile (const std::string & filename) virtual ~D3DShaderModule () void initFromByteCode (void * bytecodeData, uint32_t bytecodeSize) void compile (const std::string & filename) Public Attributes inherited from ngfx::D3DShaderModule Name D3D12_SHADER_BYTECODE d3dShaderByteCode Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DFragmentShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DFragmentShaderModule/#function-d3dfragmentshadermodule","text":"inline virtual ~D3DFragmentShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~D3DFragmentShaderModule"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/","text":"ngfx::D3DFramebuffer Inherits from ngfx::Framebuffer Public Classes Name struct D3DAttachment Public Functions Name void create (std::vector< D3DAttachment > & attachments, int32_t w, uint32_t h, uint32_t layers =1) virtual ~D3DFramebuffer () Public Attributes Name std::vector< D3DAttachment > d3dAttachments std::vector< D3DAttachment * > colorAttachments std::vector< D3DAttachment * > resolveAttachments D3DAttachment * depthStencilAttachment D3DAttachment * depthResolve Additional inherited members Public Classes inherited from ngfx::Framebuffer Name struct Attachment Public Functions inherited from ngfx::Framebuffer Name virtual ~Framebuffer () Public Attributes inherited from ngfx::Framebuffer Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments Public Functions Documentation function create void create( std::vector< D3DAttachment > & attachments, int32_t w, uint32_t h, uint32_t layers =1 ) function ~D3DFramebuffer inline virtual ~D3DFramebuffer() Public Attributes Documentation variable d3dAttachments std::vector< D3DAttachment > d3dAttachments; variable colorAttachments std::vector< D3DAttachment * > colorAttachments; variable resolveAttachments std::vector< D3DAttachment * > resolveAttachments; variable depthStencilAttachment D3DAttachment * depthStencilAttachment = nullptr; variable depthResolve D3DAttachment * depthResolve = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DFramebuffer"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#ngfxd3dframebuffer","text":"Inherits from ngfx::Framebuffer","title":"ngfx::D3DFramebuffer"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#public-classes","text":"Name struct D3DAttachment","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#public-functions","text":"Name void create (std::vector< D3DAttachment > & attachments, int32_t w, uint32_t h, uint32_t layers =1) virtual ~D3DFramebuffer ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#public-attributes","text":"Name std::vector< D3DAttachment > d3dAttachments std::vector< D3DAttachment * > colorAttachments std::vector< D3DAttachment * > resolveAttachments D3DAttachment * depthStencilAttachment D3DAttachment * depthResolve","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#additional-inherited-members","text":"Public Classes inherited from ngfx::Framebuffer Name struct Attachment Public Functions inherited from ngfx::Framebuffer Name virtual ~Framebuffer () Public Attributes inherited from ngfx::Framebuffer Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#function-create","text":"void create( std::vector< D3DAttachment > & attachments, int32_t w, uint32_t h, uint32_t layers =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#function-d3dframebuffer","text":"inline virtual ~D3DFramebuffer()","title":"function ~D3DFramebuffer"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#variable-d3dattachments","text":"std::vector< D3DAttachment > d3dAttachments;","title":"variable d3dAttachments"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#variable-colorattachments","text":"std::vector< D3DAttachment * > colorAttachments;","title":"variable colorAttachments"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#variable-resolveattachments","text":"std::vector< D3DAttachment * > resolveAttachments;","title":"variable resolveAttachments"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#variable-depthstencilattachment","text":"D3DAttachment * depthStencilAttachment = nullptr;","title":"variable depthStencilAttachment"},{"location":"api/Classes/classngfx_1_1D3DFramebuffer/#variable-depthresolve","text":"D3DAttachment * depthResolve = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable depthResolve"},{"location":"api/Classes/classngfx_1_1D3DGraphics/","text":"ngfx::D3DGraphics Inherits from ngfx::Graphics Public Functions Name void create () virtual ~D3DGraphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) override virtual void endComputePass ( CommandBuffer * commandBuffer) override virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) override virtual void endRenderPass ( CommandBuffer * commandBuffer) override virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) override virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32) override virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) override virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) override virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) override virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) override virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) override virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void waitIdle ( CommandBuffer * cmdBuffer) override Additional inherited members Public Functions inherited from ngfx::Graphics Name virtual ~Graphics () Public Attributes inherited from ngfx::Graphics Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer Protected Attributes inherited from ngfx::Graphics Name GraphicsContext * ctx Public Functions Documentation function create inline void create() function ~D3DGraphics inline virtual ~D3DGraphics() function beginComputePass inline virtual void beginComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::beginComputePass function endComputePass inline virtual void endComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endComputePass function beginRenderPass virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) override Reimplements : ngfx::Graphics::beginRenderPass function endRenderPass virtual void endRenderPass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endRenderPass function bindVertexBuffer virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) override Reimplements : ngfx::Graphics::bindVertexBuffer function bindIndexBuffer virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32 ) override Reimplements : ngfx::Graphics::bindIndexBuffer function bindUniformBuffer virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindUniformBuffer function bindStorageBuffer virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindStorageBuffer function bindComputePipeline virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) override Reimplements : ngfx::Graphics::bindComputePipeline function bindGraphicsPipeline virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) override Reimplements : ngfx::Graphics::bindGraphicsPipeline function bindTexture virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) override Reimplements : ngfx::Graphics::bindTexture function draw virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::draw function drawIndexed virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::drawIndexed function dispatch virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) override Reimplements : ngfx::Graphics::dispatch function setViewport virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setViewport function setScissor virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setScissor function waitIdle inline virtual void waitIdle( CommandBuffer * cmdBuffer ) override Reimplements : ngfx::Graphics::waitIdle Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DGraphics"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#ngfxd3dgraphics","text":"Inherits from ngfx::Graphics","title":"ngfx::D3DGraphics"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#public-functions","text":"Name void create () virtual ~D3DGraphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) override virtual void endComputePass ( CommandBuffer * commandBuffer) override virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) override virtual void endRenderPass ( CommandBuffer * commandBuffer) override virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) override virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32) override virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) override virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) override virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) override virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) override virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) override virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void waitIdle ( CommandBuffer * cmdBuffer) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#additional-inherited-members","text":"Public Functions inherited from ngfx::Graphics Name virtual ~Graphics () Public Attributes inherited from ngfx::Graphics Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer Protected Attributes inherited from ngfx::Graphics Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-create","text":"inline void create()","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-d3dgraphics","text":"inline virtual ~D3DGraphics()","title":"function ~D3DGraphics"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-begincomputepass","text":"inline virtual void beginComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::beginComputePass","title":"function beginComputePass"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-endcomputepass","text":"inline virtual void endComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endComputePass","title":"function endComputePass"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-beginrenderpass","text":"virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) override Reimplements : ngfx::Graphics::beginRenderPass","title":"function beginRenderPass"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-endrenderpass","text":"virtual void endRenderPass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endRenderPass","title":"function endRenderPass"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-bindvertexbuffer","text":"virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) override Reimplements : ngfx::Graphics::bindVertexBuffer","title":"function bindVertexBuffer"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-bindindexbuffer","text":"virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32 ) override Reimplements : ngfx::Graphics::bindIndexBuffer","title":"function bindIndexBuffer"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-binduniformbuffer","text":"virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindUniformBuffer","title":"function bindUniformBuffer"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-bindstoragebuffer","text":"virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindStorageBuffer","title":"function bindStorageBuffer"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-bindcomputepipeline","text":"virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) override Reimplements : ngfx::Graphics::bindComputePipeline","title":"function bindComputePipeline"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-bindgraphicspipeline","text":"virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) override Reimplements : ngfx::Graphics::bindGraphicsPipeline","title":"function bindGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-bindtexture","text":"virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) override Reimplements : ngfx::Graphics::bindTexture","title":"function bindTexture"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-draw","text":"virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::draw","title":"function draw"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-drawindexed","text":"virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::drawIndexed","title":"function drawIndexed"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-dispatch","text":"virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) override Reimplements : ngfx::Graphics::dispatch","title":"function dispatch"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-setviewport","text":"virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setViewport","title":"function setViewport"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-setscissor","text":"virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setScissor","title":"function setScissor"},{"location":"api/Classes/classngfx_1_1D3DGraphics/#function-waitidle","text":"inline virtual void waitIdle( CommandBuffer * cmdBuffer ) override Reimplements : ngfx::Graphics::waitIdle Updated on 3 April 2021 at 20:21:51 PDT","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/","text":"ngfx::D3DGraphicsContext Inherits from ngfx::GraphicsContext Public Classes Name struct D3DRenderPassData Public Functions Name void create (const char * appName, bool enableDepthStencil, bool debug) virtual ~D3DGraphicsContext () virtual void setSurface ( Surface * surface) override virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) override virtual CommandBuffer * copyCommandBuffer () override virtual CommandBuffer * computeCommandBuffer () override virtual RenderPass * getRenderPass ( RenderPassConfig config) override Public Attributes Name std::vector< std::unique_ptr< D3DRenderPassData > > d3dRenderPassCache ComPtr< IDXGIFactory4 > d3dFactory D3DDevice d3dDevice D3DCommandQueue d3dCommandQueue D3DDescriptorHeap d3dRtvDescriptorHeap D3DDescriptorHeap d3dCbvSrvUavDescriptorHeap D3DDescriptorHeap d3dSamplerDescriptorHeap D3DDescriptorHeap d3dDsvDescriptorHeap D3DPipelineCache d3dPipelineCache D3DSwapchain d3dSwapchain std::vector< D3DCommandList > d3dDrawCommandLists D3DCommandList d3dCopyCommandList D3DCommandList d3dComputeCommandList D3DRenderPass * d3dDefaultRenderPass D3DRenderPass * d3dDefaultOffscreenRenderPass std::vector< D3DFramebuffer > d3dSwapchainFramebuffers std::vector< D3DFence > d3dWaitFences D3DFence d3dComputeFence D3DComputePass d3dComputePass std::unique_ptr< D3DTexture > d3dDepthStencilView bool offscreen uint32_t numSamples Additional inherited members Public Classes inherited from ngfx::GraphicsContext Name struct AttachmentDescription struct RenderPassConfig Public Functions inherited from ngfx::GraphicsContext Name virtual ~GraphicsContext () virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void submit ( CommandBuffer * commandBuffer) Public Attributes inherited from ngfx::GraphicsContext Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor Protected Attributes inherited from ngfx::GraphicsContext Name bool debug bool enableDepthStencil Public Functions Documentation function create void create( const char * appName, bool enableDepthStencil, bool debug ) function ~D3DGraphicsContext inline virtual ~D3DGraphicsContext() function setSurface virtual void setSurface( Surface * surface ) override Reimplements : ngfx::GraphicsContext::setSurface function drawCommandBuffer virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) override Reimplements : ngfx::GraphicsContext::drawCommandBuffer function copyCommandBuffer virtual CommandBuffer * copyCommandBuffer() override Reimplements : ngfx::GraphicsContext::copyCommandBuffer function computeCommandBuffer virtual CommandBuffer * computeCommandBuffer() override Reimplements : ngfx::GraphicsContext::computeCommandBuffer function getRenderPass virtual RenderPass * getRenderPass( RenderPassConfig config ) override Reimplements : ngfx::GraphicsContext::getRenderPass Public Attributes Documentation variable d3dRenderPassCache std::vector< std::unique_ptr< D3DRenderPassData > > d3dRenderPassCache; variable d3dFactory ComPtr< IDXGIFactory4 > d3dFactory; variable d3dDevice D3DDevice d3dDevice; variable d3dCommandQueue D3DCommandQueue d3dCommandQueue; variable d3dRtvDescriptorHeap D3DDescriptorHeap d3dRtvDescriptorHeap; variable d3dCbvSrvUavDescriptorHeap D3DDescriptorHeap d3dCbvSrvUavDescriptorHeap; variable d3dSamplerDescriptorHeap D3DDescriptorHeap d3dSamplerDescriptorHeap; variable d3dDsvDescriptorHeap D3DDescriptorHeap d3dDsvDescriptorHeap; variable d3dPipelineCache D3DPipelineCache d3dPipelineCache; variable d3dSwapchain D3DSwapchain d3dSwapchain; variable d3dDrawCommandLists std::vector< D3DCommandList > d3dDrawCommandLists; variable d3dCopyCommandList D3DCommandList d3dCopyCommandList; variable d3dComputeCommandList D3DCommandList d3dComputeCommandList; variable d3dDefaultRenderPass D3DRenderPass * d3dDefaultRenderPass = nullptr; variable d3dDefaultOffscreenRenderPass D3DRenderPass * d3dDefaultOffscreenRenderPass = nullptr; variable d3dSwapchainFramebuffers std::vector< D3DFramebuffer > d3dSwapchainFramebuffers; variable d3dWaitFences std::vector< D3DFence > d3dWaitFences; variable d3dComputeFence D3DFence d3dComputeFence; variable d3dComputePass D3DComputePass d3dComputePass; variable d3dDepthStencilView std::unique_ptr< D3DTexture > d3dDepthStencilView; variable offscreen bool offscreen = true; variable numSamples uint32_t numSamples = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DGraphicsContext"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#ngfxd3dgraphicscontext","text":"Inherits from ngfx::GraphicsContext","title":"ngfx::D3DGraphicsContext"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#public-classes","text":"Name struct D3DRenderPassData","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#public-functions","text":"Name void create (const char * appName, bool enableDepthStencil, bool debug) virtual ~D3DGraphicsContext () virtual void setSurface ( Surface * surface) override virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) override virtual CommandBuffer * copyCommandBuffer () override virtual CommandBuffer * computeCommandBuffer () override virtual RenderPass * getRenderPass ( RenderPassConfig config) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#public-attributes","text":"Name std::vector< std::unique_ptr< D3DRenderPassData > > d3dRenderPassCache ComPtr< IDXGIFactory4 > d3dFactory D3DDevice d3dDevice D3DCommandQueue d3dCommandQueue D3DDescriptorHeap d3dRtvDescriptorHeap D3DDescriptorHeap d3dCbvSrvUavDescriptorHeap D3DDescriptorHeap d3dSamplerDescriptorHeap D3DDescriptorHeap d3dDsvDescriptorHeap D3DPipelineCache d3dPipelineCache D3DSwapchain d3dSwapchain std::vector< D3DCommandList > d3dDrawCommandLists D3DCommandList d3dCopyCommandList D3DCommandList d3dComputeCommandList D3DRenderPass * d3dDefaultRenderPass D3DRenderPass * d3dDefaultOffscreenRenderPass std::vector< D3DFramebuffer > d3dSwapchainFramebuffers std::vector< D3DFence > d3dWaitFences D3DFence d3dComputeFence D3DComputePass d3dComputePass std::unique_ptr< D3DTexture > d3dDepthStencilView bool offscreen uint32_t numSamples","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#additional-inherited-members","text":"Public Classes inherited from ngfx::GraphicsContext Name struct AttachmentDescription struct RenderPassConfig Public Functions inherited from ngfx::GraphicsContext Name virtual ~GraphicsContext () virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void submit ( CommandBuffer * commandBuffer) Public Attributes inherited from ngfx::GraphicsContext Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor Protected Attributes inherited from ngfx::GraphicsContext Name bool debug bool enableDepthStencil","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#function-create","text":"void create( const char * appName, bool enableDepthStencil, bool debug )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#function-d3dgraphicscontext","text":"inline virtual ~D3DGraphicsContext()","title":"function ~D3DGraphicsContext"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#function-setsurface","text":"virtual void setSurface( Surface * surface ) override Reimplements : ngfx::GraphicsContext::setSurface","title":"function setSurface"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#function-drawcommandbuffer","text":"virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) override Reimplements : ngfx::GraphicsContext::drawCommandBuffer","title":"function drawCommandBuffer"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#function-copycommandbuffer","text":"virtual CommandBuffer * copyCommandBuffer() override Reimplements : ngfx::GraphicsContext::copyCommandBuffer","title":"function copyCommandBuffer"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#function-computecommandbuffer","text":"virtual CommandBuffer * computeCommandBuffer() override Reimplements : ngfx::GraphicsContext::computeCommandBuffer","title":"function computeCommandBuffer"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#function-getrenderpass","text":"virtual RenderPass * getRenderPass( RenderPassConfig config ) override Reimplements : ngfx::GraphicsContext::getRenderPass","title":"function getRenderPass"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3drenderpasscache","text":"std::vector< std::unique_ptr< D3DRenderPassData > > d3dRenderPassCache;","title":"variable d3dRenderPassCache"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dfactory","text":"ComPtr< IDXGIFactory4 > d3dFactory;","title":"variable d3dFactory"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3ddevice","text":"D3DDevice d3dDevice;","title":"variable d3dDevice"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dcommandqueue","text":"D3DCommandQueue d3dCommandQueue;","title":"variable d3dCommandQueue"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3drtvdescriptorheap","text":"D3DDescriptorHeap d3dRtvDescriptorHeap;","title":"variable d3dRtvDescriptorHeap"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dcbvsrvuavdescriptorheap","text":"D3DDescriptorHeap d3dCbvSrvUavDescriptorHeap;","title":"variable d3dCbvSrvUavDescriptorHeap"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dsamplerdescriptorheap","text":"D3DDescriptorHeap d3dSamplerDescriptorHeap;","title":"variable d3dSamplerDescriptorHeap"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3ddsvdescriptorheap","text":"D3DDescriptorHeap d3dDsvDescriptorHeap;","title":"variable d3dDsvDescriptorHeap"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dpipelinecache","text":"D3DPipelineCache d3dPipelineCache;","title":"variable d3dPipelineCache"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dswapchain","text":"D3DSwapchain d3dSwapchain;","title":"variable d3dSwapchain"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3ddrawcommandlists","text":"std::vector< D3DCommandList > d3dDrawCommandLists;","title":"variable d3dDrawCommandLists"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dcopycommandlist","text":"D3DCommandList d3dCopyCommandList;","title":"variable d3dCopyCommandList"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dcomputecommandlist","text":"D3DCommandList d3dComputeCommandList;","title":"variable d3dComputeCommandList"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3ddefaultrenderpass","text":"D3DRenderPass * d3dDefaultRenderPass = nullptr;","title":"variable d3dDefaultRenderPass"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3ddefaultoffscreenrenderpass","text":"D3DRenderPass * d3dDefaultOffscreenRenderPass = nullptr;","title":"variable d3dDefaultOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dswapchainframebuffers","text":"std::vector< D3DFramebuffer > d3dSwapchainFramebuffers;","title":"variable d3dSwapchainFramebuffers"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dwaitfences","text":"std::vector< D3DFence > d3dWaitFences;","title":"variable d3dWaitFences"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dcomputefence","text":"D3DFence d3dComputeFence;","title":"variable d3dComputeFence"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3dcomputepass","text":"D3DComputePass d3dComputePass;","title":"variable d3dComputePass"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-d3ddepthstencilview","text":"std::unique_ptr< D3DTexture > d3dDepthStencilView;","title":"variable d3dDepthStencilView"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-offscreen","text":"bool offscreen = true;","title":"variable offscreen"},{"location":"api/Classes/classngfx_1_1D3DGraphicsContext/#variable-numsamples","text":"uint32_t numSamples = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable numSamples"},{"location":"api/Classes/classngfx_1_1D3DGraphicsPipeline/","text":"ngfx::D3DGraphicsPipeline Inherits from ngfx::GraphicsPipeline , ngfx::D3DPipeline , ngfx::Pipeline Public Classes Name struct Shaders struct State Public Functions Name void create ( D3DGraphicsContext * ctx, const State & state, const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, const std::vector< D3D12_INPUT_ELEMENT_DESC > & inputElements, const Shaders & shaders, DXGI_FORMAT colorFormat, DXGI_FORMAT depthFormat) Public Attributes Name D3D_PRIMITIVE_TOPOLOGY d3dPrimitiveTopology Additional inherited members Public Classes inherited from ngfx::GraphicsPipeline Name struct Descriptor struct State Public Functions inherited from ngfx::GraphicsPipeline Name virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings) Public Attributes inherited from ngfx::GraphicsPipeline Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings Public Functions inherited from ngfx::D3DPipeline Name virtual ~D3DPipeline () Protected Functions inherited from ngfx::D3DPipeline Name void createRootSignature (const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =D3D12_ROOT_SIGNATURE_FLAG_NONE) Public Attributes inherited from ngfx::D3DPipeline Name ComPtr< ID3D12PipelineState > d3dPipelineState ComPtr< ID3D12RootSignature > d3dRootSignature Protected Attributes inherited from ngfx::D3DPipeline Name D3DGraphicsContext * ctx Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create void create( D3DGraphicsContext * ctx, const State & state, const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, const std::vector< D3D12_INPUT_ELEMENT_DESC > & inputElements, const Shaders & shaders, DXGI_FORMAT colorFormat, DXGI_FORMAT depthFormat ) Public Attributes Documentation variable d3dPrimitiveTopology D3D_PRIMITIVE_TOPOLOGY d3dPrimitiveTopology; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1D3DGraphicsPipeline/#ngfxd3dgraphicspipeline","text":"Inherits from ngfx::GraphicsPipeline , ngfx::D3DPipeline , ngfx::Pipeline","title":"ngfx::D3DGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1D3DGraphicsPipeline/#public-classes","text":"Name struct Shaders struct State","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1D3DGraphicsPipeline/#public-functions","text":"Name void create ( D3DGraphicsContext * ctx, const State & state, const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, const std::vector< D3D12_INPUT_ELEMENT_DESC > & inputElements, const Shaders & shaders, DXGI_FORMAT colorFormat, DXGI_FORMAT depthFormat)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DGraphicsPipeline/#public-attributes","text":"Name D3D_PRIMITIVE_TOPOLOGY d3dPrimitiveTopology","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DGraphicsPipeline/#additional-inherited-members","text":"Public Classes inherited from ngfx::GraphicsPipeline Name struct Descriptor struct State Public Functions inherited from ngfx::GraphicsPipeline Name virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings) Public Attributes inherited from ngfx::GraphicsPipeline Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings Public Functions inherited from ngfx::D3DPipeline Name virtual ~D3DPipeline () Protected Functions inherited from ngfx::D3DPipeline Name void createRootSignature (const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =D3D12_ROOT_SIGNATURE_FLAG_NONE) Public Attributes inherited from ngfx::D3DPipeline Name ComPtr< ID3D12PipelineState > d3dPipelineState ComPtr< ID3D12RootSignature > d3dRootSignature Protected Attributes inherited from ngfx::D3DPipeline Name D3DGraphicsContext * ctx Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DGraphicsPipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DGraphicsPipeline/#function-create","text":"void create( D3DGraphicsContext * ctx, const State & state, const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, const std::vector< D3D12_INPUT_ELEMENT_DESC > & inputElements, const Shaders & shaders, DXGI_FORMAT colorFormat, DXGI_FORMAT depthFormat )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DGraphicsPipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DGraphicsPipeline/#variable-d3dprimitivetopology","text":"D3D_PRIMITIVE_TOPOLOGY d3dPrimitiveTopology; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable d3dPrimitiveTopology"},{"location":"api/Classes/classngfx_1_1D3DPipeline/","text":"ngfx::D3DPipeline Inherited by ngfx::D3DComputePipeline , ngfx::D3DGraphicsPipeline Public Functions Name void create ( D3DGraphicsContext * ctx) virtual ~D3DPipeline () Protected Functions Name void createRootSignature (const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =D3D12_ROOT_SIGNATURE_FLAG_NONE) Public Attributes Name ComPtr< ID3D12PipelineState > d3dPipelineState ComPtr< ID3D12RootSignature > d3dRootSignature Protected Attributes Name D3DGraphicsContext * ctx Public Functions Documentation function create void create( D3DGraphicsContext * ctx ) function ~D3DPipeline inline virtual ~D3DPipeline() Protected Functions Documentation function createRootSignature void createRootSignature( const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =D3D12_ROOT_SIGNATURE_FLAG_NONE ) Public Attributes Documentation variable d3dPipelineState ComPtr< ID3D12PipelineState > d3dPipelineState; variable d3dRootSignature ComPtr< ID3D12RootSignature > d3dRootSignature; Protected Attributes Documentation variable ctx D3DGraphicsContext * ctx; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DPipeline"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#ngfxd3dpipeline","text":"Inherited by ngfx::D3DComputePipeline , ngfx::D3DGraphicsPipeline","title":"ngfx::D3DPipeline"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#public-functions","text":"Name void create ( D3DGraphicsContext * ctx) virtual ~D3DPipeline ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#protected-functions","text":"Name void createRootSignature (const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =D3D12_ROOT_SIGNATURE_FLAG_NONE)","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#public-attributes","text":"Name ComPtr< ID3D12PipelineState > d3dPipelineState ComPtr< ID3D12RootSignature > d3dRootSignature","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#protected-attributes","text":"Name D3DGraphicsContext * ctx","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#function-create","text":"void create( D3DGraphicsContext * ctx )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#function-d3dpipeline","text":"inline virtual ~D3DPipeline()","title":"function ~D3DPipeline"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#function-createrootsignature","text":"void createRootSignature( const std::vector< CD3DX12_ROOT_PARAMETER1 > & rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags =D3D12_ROOT_SIGNATURE_FLAG_NONE )","title":"function createRootSignature"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#variable-d3dpipelinestate","text":"ComPtr< ID3D12PipelineState > d3dPipelineState;","title":"variable d3dPipelineState"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#variable-d3drootsignature","text":"ComPtr< ID3D12RootSignature > d3dRootSignature;","title":"variable d3dRootSignature"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DPipeline/#variable-ctx","text":"D3DGraphicsContext * ctx; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1D3DPipelineCache/","text":"ngfx::D3DPipelineCache Inherits from ngfx::PipelineCache Public Functions Name virtual ~D3DPipelineCache () Additional inherited members Public Functions inherited from ngfx::PipelineCache Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value) Public Functions Documentation function ~D3DPipelineCache inline virtual ~D3DPipelineCache() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DPipelineCache"},{"location":"api/Classes/classngfx_1_1D3DPipelineCache/#ngfxd3dpipelinecache","text":"Inherits from ngfx::PipelineCache","title":"ngfx::D3DPipelineCache"},{"location":"api/Classes/classngfx_1_1D3DPipelineCache/#public-functions","text":"Name virtual ~D3DPipelineCache ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DPipelineCache/#additional-inherited-members","text":"Public Functions inherited from ngfx::PipelineCache Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value)","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DPipelineCache/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DPipelineCache/#function-d3dpipelinecache","text":"inline virtual ~D3DPipelineCache() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~D3DPipelineCache"},{"location":"api/Classes/classngfx_1_1D3DReadbackBuffer/","text":"ngfx::D3DReadbackBuffer Inherits from ngfx::D3DBuffer , ngfx::Buffer Public Functions Name void create ( D3DGraphicsContext * ctx, uint32_t size) virtual ~D3DReadbackBuffer () Public Attributes Name D3D12_CPU_DESCRIPTOR_HANDLE descriptor Additional inherited members Public Functions inherited from ngfx::D3DBuffer Name virtual ~D3DBuffer () virtual void * map () override virtual void unmap () override virtual void upload (const void * data, uint32_t size, uint32_t offset =0) override virtual void download (void * data, uint32_t size, uint32_t offset =0) override Public Attributes inherited from ngfx::D3DBuffer Name uint32_t size ComPtr< ID3D12Resource > v Protected Attributes inherited from ngfx::D3DBuffer Name D3D12_HEAP_TYPE heapType D3D12_RESOURCE_STATES initialResourceState D3D12_RESOURCE_STATES currentResourceState D3DReadbackBuffer * d3dReadbackBuffer void * d3dReadBackBufferPtr Public Functions inherited from ngfx::Buffer Name virtual ~Buffer () virtual void * map () =0 virtual void unmap () =0 virtual void upload (const void * data, uint32_t size, uint32_t offset =0) =0 virtual void download (void * data, uint32_t size, uint32_t offset =0) =0 Public Functions Documentation function create void create( D3DGraphicsContext * ctx, uint32_t size ) function ~D3DReadbackBuffer inline virtual ~D3DReadbackBuffer() Public Attributes Documentation variable descriptor D3D12_CPU_DESCRIPTOR_HANDLE descriptor; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DReadbackBuffer"},{"location":"api/Classes/classngfx_1_1D3DReadbackBuffer/#ngfxd3dreadbackbuffer","text":"Inherits from ngfx::D3DBuffer , ngfx::Buffer","title":"ngfx::D3DReadbackBuffer"},{"location":"api/Classes/classngfx_1_1D3DReadbackBuffer/#public-functions","text":"Name void create ( D3DGraphicsContext * ctx, uint32_t size) virtual ~D3DReadbackBuffer ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DReadbackBuffer/#public-attributes","text":"Name D3D12_CPU_DESCRIPTOR_HANDLE descriptor","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DReadbackBuffer/#additional-inherited-members","text":"Public Functions inherited from ngfx::D3DBuffer Name virtual ~D3DBuffer () virtual void * map () override virtual void unmap () override virtual void upload (const void * data, uint32_t size, uint32_t offset =0) override virtual void download (void * data, uint32_t size, uint32_t offset =0) override Public Attributes inherited from ngfx::D3DBuffer Name uint32_t size ComPtr< ID3D12Resource > v Protected Attributes inherited from ngfx::D3DBuffer Name D3D12_HEAP_TYPE heapType D3D12_RESOURCE_STATES initialResourceState D3D12_RESOURCE_STATES currentResourceState D3DReadbackBuffer * d3dReadbackBuffer void * d3dReadBackBufferPtr Public Functions inherited from ngfx::Buffer Name virtual ~Buffer () virtual void * map () =0 virtual void unmap () =0 virtual void upload (const void * data, uint32_t size, uint32_t offset =0) =0 virtual void download (void * data, uint32_t size, uint32_t offset =0) =0","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DReadbackBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DReadbackBuffer/#function-create","text":"void create( D3DGraphicsContext * ctx, uint32_t size )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DReadbackBuffer/#function-d3dreadbackbuffer","text":"inline virtual ~D3DReadbackBuffer()","title":"function ~D3DReadbackBuffer"},{"location":"api/Classes/classngfx_1_1D3DReadbackBuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DReadbackBuffer/#variable-descriptor","text":"D3D12_CPU_DESCRIPTOR_HANDLE descriptor; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable descriptor"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/","text":"ngfx::D3DRenderPass Inherits from ngfx::RenderPass Public Functions Name void create ( D3DGraphicsContext * ctx, D3D12_RESOURCE_STATES initialResourceState, D3D12_RESOURCE_STATES finalResourceState) virtual ~D3DRenderPass () Public Attributes Name D3D12_RESOURCE_STATES initialResourceState D3D12_RESOURCE_STATES finalResourceState Additional inherited members Public Functions inherited from ngfx::RenderPass Name virtual ~RenderPass () Public Functions Documentation function create void create( D3DGraphicsContext * ctx, D3D12_RESOURCE_STATES initialResourceState, D3D12_RESOURCE_STATES finalResourceState ) function ~D3DRenderPass inline virtual ~D3DRenderPass() Public Attributes Documentation variable initialResourceState D3D12_RESOURCE_STATES initialResourceState; variable finalResourceState D3D12_RESOURCE_STATES finalResourceState; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DRenderPass"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/#ngfxd3drenderpass","text":"Inherits from ngfx::RenderPass","title":"ngfx::D3DRenderPass"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/#public-functions","text":"Name void create ( D3DGraphicsContext * ctx, D3D12_RESOURCE_STATES initialResourceState, D3D12_RESOURCE_STATES finalResourceState) virtual ~D3DRenderPass ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/#public-attributes","text":"Name D3D12_RESOURCE_STATES initialResourceState D3D12_RESOURCE_STATES finalResourceState","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/#additional-inherited-members","text":"Public Functions inherited from ngfx::RenderPass Name virtual ~RenderPass ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/#function-create","text":"void create( D3DGraphicsContext * ctx, D3D12_RESOURCE_STATES initialResourceState, D3D12_RESOURCE_STATES finalResourceState )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/#function-d3drenderpass","text":"inline virtual ~D3DRenderPass()","title":"function ~D3DRenderPass"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/#variable-initialresourcestate","text":"D3D12_RESOURCE_STATES initialResourceState;","title":"variable initialResourceState"},{"location":"api/Classes/classngfx_1_1D3DRenderPass/#variable-finalresourcestate","text":"D3D12_RESOURCE_STATES finalResourceState; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable finalResourceState"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/","text":"ngfx::D3DShaderModule Inherited by ngfx::D3DComputeShaderModule , ngfx::D3DFragmentShaderModule , ngfx::D3DVertexShaderModule Public Functions Name void initFromFile (const std::string & filename) virtual ~D3DShaderModule () void initFromByteCode (void * bytecodeData, uint32_t bytecodeSize) void compile (const std::string & filename) Public Attributes Name D3D12_SHADER_BYTECODE d3dShaderByteCode Public Functions Documentation function initFromFile void initFromFile( const std::string & filename ) function ~D3DShaderModule virtual ~D3DShaderModule() function initFromByteCode void initFromByteCode( void * bytecodeData, uint32_t bytecodeSize ) function compile void compile( const std::string & filename ) Public Attributes Documentation variable d3dShaderByteCode D3D12_SHADER_BYTECODE d3dShaderByteCode {}; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DShaderModule"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/#ngfxd3dshadermodule","text":"Inherited by ngfx::D3DComputeShaderModule , ngfx::D3DFragmentShaderModule , ngfx::D3DVertexShaderModule","title":"ngfx::D3DShaderModule"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/#public-functions","text":"Name void initFromFile (const std::string & filename) virtual ~D3DShaderModule () void initFromByteCode (void * bytecodeData, uint32_t bytecodeSize) void compile (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/#public-attributes","text":"Name D3D12_SHADER_BYTECODE d3dShaderByteCode","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/#function-initfromfile","text":"void initFromFile( const std::string & filename )","title":"function initFromFile"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/#function-d3dshadermodule","text":"virtual ~D3DShaderModule()","title":"function ~D3DShaderModule"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/#function-initfrombytecode","text":"void initFromByteCode( void * bytecodeData, uint32_t bytecodeSize )","title":"function initFromByteCode"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/#function-compile","text":"void compile( const std::string & filename )","title":"function compile"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DShaderModule/#variable-d3dshaderbytecode","text":"D3D12_SHADER_BYTECODE d3dShaderByteCode {}; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable d3dShaderByteCode"},{"location":"api/Classes/classngfx_1_1D3DSurface/","text":"ngfx::D3DSurface Inherits from ngfx::Surface Public Functions Name virtual ~D3DSurface () void destroy () Public Attributes Name HWND v Additional inherited members Public Functions inherited from ngfx::Surface Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface () Public Attributes inherited from ngfx::Surface Name uint32_t w uint32_t h bool offscreen Public Functions Documentation function ~D3DSurface inline virtual ~D3DSurface() function destroy void destroy() Public Attributes Documentation variable v HWND v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DSurface"},{"location":"api/Classes/classngfx_1_1D3DSurface/#ngfxd3dsurface","text":"Inherits from ngfx::Surface","title":"ngfx::D3DSurface"},{"location":"api/Classes/classngfx_1_1D3DSurface/#public-functions","text":"Name virtual ~D3DSurface () void destroy ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DSurface/#public-attributes","text":"Name HWND v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DSurface/#additional-inherited-members","text":"Public Functions inherited from ngfx::Surface Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface () Public Attributes inherited from ngfx::Surface Name uint32_t w uint32_t h bool offscreen","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DSurface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DSurface/#function-d3dsurface","text":"inline virtual ~D3DSurface()","title":"function ~D3DSurface"},{"location":"api/Classes/classngfx_1_1D3DSurface/#function-destroy","text":"void destroy()","title":"function destroy"},{"location":"api/Classes/classngfx_1_1D3DSurface/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DSurface/#variable-v","text":"HWND v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/","text":"ngfx::D3DSwapchain Inherits from ngfx::Swapchain Public Functions Name void create ( D3DGraphicsContext * ctx, D3DSurface * surface) virtual ~D3DSwapchain () virtual void acquireNextImage () override void present () Public Attributes Name ComPtr< IDXGISwapChain3 > v std::vector< ComPtr< ID3D12Resource > > renderTargets std::vector< D3DDescriptorHandle > renderTargetDescriptors Additional inherited members Public Functions inherited from ngfx::Swapchain Name virtual ~Swapchain () Public Attributes inherited from ngfx::Swapchain Name uint32_t numImages Public Functions Documentation function create void create( D3DGraphicsContext * ctx, D3DSurface * surface ) function ~D3DSwapchain inline virtual ~D3DSwapchain() function acquireNextImage virtual void acquireNextImage() override Reimplements : ngfx::Swapchain::acquireNextImage function present void present() Public Attributes Documentation variable v ComPtr< IDXGISwapChain3 > v; variable renderTargets std::vector< ComPtr< ID3D12Resource > > renderTargets; variable renderTargetDescriptors std::vector< D3DDescriptorHandle > renderTargetDescriptors; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DSwapchain"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#ngfxd3dswapchain","text":"Inherits from ngfx::Swapchain","title":"ngfx::D3DSwapchain"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#public-functions","text":"Name void create ( D3DGraphicsContext * ctx, D3DSurface * surface) virtual ~D3DSwapchain () virtual void acquireNextImage () override void present ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#public-attributes","text":"Name ComPtr< IDXGISwapChain3 > v std::vector< ComPtr< ID3D12Resource > > renderTargets std::vector< D3DDescriptorHandle > renderTargetDescriptors","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#additional-inherited-members","text":"Public Functions inherited from ngfx::Swapchain Name virtual ~Swapchain () Public Attributes inherited from ngfx::Swapchain Name uint32_t numImages","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#function-create","text":"void create( D3DGraphicsContext * ctx, D3DSurface * surface )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#function-d3dswapchain","text":"inline virtual ~D3DSwapchain()","title":"function ~D3DSwapchain"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#function-acquirenextimage","text":"virtual void acquireNextImage() override Reimplements : ngfx::Swapchain::acquireNextImage","title":"function acquireNextImage"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#function-present","text":"void present()","title":"function present"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#variable-v","text":"ComPtr< IDXGISwapChain3 > v;","title":"variable v"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#variable-rendertargets","text":"std::vector< ComPtr< ID3D12Resource > > renderTargets;","title":"variable renderTargets"},{"location":"api/Classes/classngfx_1_1D3DSwapchain/#variable-rendertargetdescriptors","text":"std::vector< D3DDescriptorHandle > renderTargetDescriptors; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable renderTargetDescriptors"},{"location":"api/Classes/classngfx_1_1D3DTexture/","text":"ngfx::D3DTexture Inherits from ngfx::Texture Public Classes Name struct RtvData struct SamplerData struct SrvData Public Functions Name void create ( D3DGraphicsContext * ctx, D3DGraphics * graphics, void * data, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, DXGI_FORMAT format, ImageUsageFlags usageFlags, TextureType textureType, bool genMipmaps, uint32_t numSamples, const D3DSamplerDesc & samplerDesc) virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) override void resourceBarrier ( D3DCommandList * cmdList, D3D12_RESOURCE_STATES newState, UINT subresource =D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES) virtual void generateMipmaps ( CommandBuffer * commandBuffer) override D3DDescriptorHandle getRtvDescriptor (uint32_t level =0, uint32_t baseLayer =0, uint32_t layerCount =1) D3DDescriptorHandle getSamplerDescriptor (D3D12_FILTER filter =D3D12_FILTER_MIN_MAG_MIP_POINT) D3DDescriptorHandle getSrvDescriptor (uint32_t baseMipLevel, uint32_t numMipLevels) Public Attributes Name ComPtr< ID3D12Resource > v std::vector< RtvData > rtvDescriptorCache std::vector< SamplerData > samplerDescriptorCache D3DDescriptorHandle defaultSrvDescriptor D3DDescriptorHandle defaultRtvDescriptor D3DDescriptorHandle dsvDescriptor D3DDescriptorHandle defaultSamplerDescriptor std::vector< SrvData > srvDescriptorCache D3D12_RESOURCE_DESC resourceDesc Additional inherited members Public Functions inherited from ngfx::Texture Name virtual ~Texture () Public Attributes inherited from ngfx::Texture Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType Public Functions Documentation function create void create( D3DGraphicsContext * ctx, D3DGraphics * graphics, void * data, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, DXGI_FORMAT format, ImageUsageFlags usageFlags, TextureType textureType, bool genMipmaps, uint32_t numSamples, const D3DSamplerDesc & samplerDesc ) function upload virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::upload function download virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::download function changeLayout virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) override Reimplements : ngfx::Texture::changeLayout function resourceBarrier void resourceBarrier( D3DCommandList * cmdList, D3D12_RESOURCE_STATES newState, UINT subresource =D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES ) function generateMipmaps virtual void generateMipmaps( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Texture::generateMipmaps function getRtvDescriptor D3DDescriptorHandle getRtvDescriptor( uint32_t level =0, uint32_t baseLayer =0, uint32_t layerCount =1 ) function getSamplerDescriptor D3DDescriptorHandle getSamplerDescriptor( D3D12_FILTER filter =D3D12_FILTER_MIN_MAG_MIP_POINT ) function getSrvDescriptor D3DDescriptorHandle getSrvDescriptor( uint32_t baseMipLevel, uint32_t numMipLevels ) Public Attributes Documentation variable v ComPtr< ID3D12Resource > v; variable rtvDescriptorCache std::vector< RtvData > rtvDescriptorCache; variable samplerDescriptorCache std::vector< SamplerData > samplerDescriptorCache; variable defaultSrvDescriptor D3DDescriptorHandle defaultSrvDescriptor {}; variable defaultRtvDescriptor D3DDescriptorHandle defaultRtvDescriptor {}; variable dsvDescriptor D3DDescriptorHandle dsvDescriptor {}; variable defaultSamplerDescriptor D3DDescriptorHandle defaultSamplerDescriptor {}; variable srvDescriptorCache std::vector< SrvData > srvDescriptorCache; variable resourceDesc D3D12_RESOURCE_DESC resourceDesc; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DTexture"},{"location":"api/Classes/classngfx_1_1D3DTexture/#ngfxd3dtexture","text":"Inherits from ngfx::Texture","title":"ngfx::D3DTexture"},{"location":"api/Classes/classngfx_1_1D3DTexture/#public-classes","text":"Name struct RtvData struct SamplerData struct SrvData","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1D3DTexture/#public-functions","text":"Name void create ( D3DGraphicsContext * ctx, D3DGraphics * graphics, void * data, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, DXGI_FORMAT format, ImageUsageFlags usageFlags, TextureType textureType, bool genMipmaps, uint32_t numSamples, const D3DSamplerDesc & samplerDesc) virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) override void resourceBarrier ( D3DCommandList * cmdList, D3D12_RESOURCE_STATES newState, UINT subresource =D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES) virtual void generateMipmaps ( CommandBuffer * commandBuffer) override D3DDescriptorHandle getRtvDescriptor (uint32_t level =0, uint32_t baseLayer =0, uint32_t layerCount =1) D3DDescriptorHandle getSamplerDescriptor (D3D12_FILTER filter =D3D12_FILTER_MIN_MAG_MIP_POINT) D3DDescriptorHandle getSrvDescriptor (uint32_t baseMipLevel, uint32_t numMipLevels)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DTexture/#public-attributes","text":"Name ComPtr< ID3D12Resource > v std::vector< RtvData > rtvDescriptorCache std::vector< SamplerData > samplerDescriptorCache D3DDescriptorHandle defaultSrvDescriptor D3DDescriptorHandle defaultRtvDescriptor D3DDescriptorHandle dsvDescriptor D3DDescriptorHandle defaultSamplerDescriptor std::vector< SrvData > srvDescriptorCache D3D12_RESOURCE_DESC resourceDesc","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DTexture/#additional-inherited-members","text":"Public Functions inherited from ngfx::Texture Name virtual ~Texture () Public Attributes inherited from ngfx::Texture Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DTexture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DTexture/#function-create","text":"void create( D3DGraphicsContext * ctx, D3DGraphics * graphics, void * data, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, DXGI_FORMAT format, ImageUsageFlags usageFlags, TextureType textureType, bool genMipmaps, uint32_t numSamples, const D3DSamplerDesc & samplerDesc )","title":"function create"},{"location":"api/Classes/classngfx_1_1D3DTexture/#function-upload","text":"virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::upload","title":"function upload"},{"location":"api/Classes/classngfx_1_1D3DTexture/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::download","title":"function download"},{"location":"api/Classes/classngfx_1_1D3DTexture/#function-changelayout","text":"virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) override Reimplements : ngfx::Texture::changeLayout","title":"function changeLayout"},{"location":"api/Classes/classngfx_1_1D3DTexture/#function-resourcebarrier","text":"void resourceBarrier( D3DCommandList * cmdList, D3D12_RESOURCE_STATES newState, UINT subresource =D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES )","title":"function resourceBarrier"},{"location":"api/Classes/classngfx_1_1D3DTexture/#function-generatemipmaps","text":"virtual void generateMipmaps( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Texture::generateMipmaps","title":"function generateMipmaps"},{"location":"api/Classes/classngfx_1_1D3DTexture/#function-getrtvdescriptor","text":"D3DDescriptorHandle getRtvDescriptor( uint32_t level =0, uint32_t baseLayer =0, uint32_t layerCount =1 )","title":"function getRtvDescriptor"},{"location":"api/Classes/classngfx_1_1D3DTexture/#function-getsamplerdescriptor","text":"D3DDescriptorHandle getSamplerDescriptor( D3D12_FILTER filter =D3D12_FILTER_MIN_MAG_MIP_POINT )","title":"function getSamplerDescriptor"},{"location":"api/Classes/classngfx_1_1D3DTexture/#function-getsrvdescriptor","text":"D3DDescriptorHandle getSrvDescriptor( uint32_t baseMipLevel, uint32_t numMipLevels )","title":"function getSrvDescriptor"},{"location":"api/Classes/classngfx_1_1D3DTexture/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DTexture/#variable-v","text":"ComPtr< ID3D12Resource > v;","title":"variable v"},{"location":"api/Classes/classngfx_1_1D3DTexture/#variable-rtvdescriptorcache","text":"std::vector< RtvData > rtvDescriptorCache;","title":"variable rtvDescriptorCache"},{"location":"api/Classes/classngfx_1_1D3DTexture/#variable-samplerdescriptorcache","text":"std::vector< SamplerData > samplerDescriptorCache;","title":"variable samplerDescriptorCache"},{"location":"api/Classes/classngfx_1_1D3DTexture/#variable-defaultsrvdescriptor","text":"D3DDescriptorHandle defaultSrvDescriptor {};","title":"variable defaultSrvDescriptor"},{"location":"api/Classes/classngfx_1_1D3DTexture/#variable-defaultrtvdescriptor","text":"D3DDescriptorHandle defaultRtvDescriptor {};","title":"variable defaultRtvDescriptor"},{"location":"api/Classes/classngfx_1_1D3DTexture/#variable-dsvdescriptor","text":"D3DDescriptorHandle dsvDescriptor {};","title":"variable dsvDescriptor"},{"location":"api/Classes/classngfx_1_1D3DTexture/#variable-defaultsamplerdescriptor","text":"D3DDescriptorHandle defaultSamplerDescriptor {};","title":"variable defaultSamplerDescriptor"},{"location":"api/Classes/classngfx_1_1D3DTexture/#variable-srvdescriptorcache","text":"std::vector< SrvData > srvDescriptorCache;","title":"variable srvDescriptorCache"},{"location":"api/Classes/classngfx_1_1D3DTexture/#variable-resourcedesc","text":"D3D12_RESOURCE_DESC resourceDesc; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable resourceDesc"},{"location":"api/Classes/classngfx_1_1D3DVertexShaderModule/","text":"ngfx::D3DVertexShaderModule Inherits from ngfx::VertexShaderModule , ngfx::D3DShaderModule , ngfx::ShaderModule Public Functions Name virtual ~D3DVertexShaderModule () Additional inherited members Public Classes inherited from ngfx::VertexShaderModule Name struct AttributeDescription Public Functions inherited from ngfx::VertexShaderModule Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename) Public Attributes inherited from ngfx::VertexShaderModule Name std::vector< AttributeDescription > attributes Public Functions inherited from ngfx::D3DShaderModule Name void initFromFile (const std::string & filename) virtual ~D3DShaderModule () void initFromByteCode (void * bytecodeData, uint32_t bytecodeSize) void compile (const std::string & filename) Public Attributes inherited from ngfx::D3DShaderModule Name D3D12_SHADER_BYTECODE d3dShaderByteCode Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function ~D3DVertexShaderModule inline virtual ~D3DVertexShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DVertexShaderModule"},{"location":"api/Classes/classngfx_1_1D3DVertexShaderModule/#ngfxd3dvertexshadermodule","text":"Inherits from ngfx::VertexShaderModule , ngfx::D3DShaderModule , ngfx::ShaderModule","title":"ngfx::D3DVertexShaderModule"},{"location":"api/Classes/classngfx_1_1D3DVertexShaderModule/#public-functions","text":"Name virtual ~D3DVertexShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DVertexShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::VertexShaderModule Name struct AttributeDescription Public Functions inherited from ngfx::VertexShaderModule Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename) Public Attributes inherited from ngfx::VertexShaderModule Name std::vector< AttributeDescription > attributes Public Functions inherited from ngfx::D3DShaderModule Name void initFromFile (const std::string & filename) virtual ~D3DShaderModule () void initFromByteCode (void * bytecodeData, uint32_t bytecodeSize) void compile (const std::string & filename) Public Attributes inherited from ngfx::D3DShaderModule Name D3D12_SHADER_BYTECODE d3dShaderByteCode Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DVertexShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DVertexShaderModule/#function-d3dvertexshadermodule","text":"inline virtual ~D3DVertexShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~D3DVertexShaderModule"},{"location":"api/Classes/classngfx_1_1D3DWindow/","text":"ngfx::D3DWindow Inherits from ngfx::Window Inherited by ngfx::WWindow Public Functions Name virtual ~D3DWindow () Public Attributes Name D3DSurface d3dSurface Additional inherited members Public Types inherited from ngfx::Window Name enum @2 { DISPLAY_WIDTH, DISPLAY_HEIGHT} Public Functions inherited from ngfx::Window Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () virtual bool shouldClose () =0 virtual void pollEvents () =0 Public Attributes inherited from ngfx::Window Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton Public Functions Documentation function ~D3DWindow inline virtual ~D3DWindow() Public Attributes Documentation variable d3dSurface D3DSurface d3dSurface; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DWindow"},{"location":"api/Classes/classngfx_1_1D3DWindow/#ngfxd3dwindow","text":"Inherits from ngfx::Window Inherited by ngfx::WWindow","title":"ngfx::D3DWindow"},{"location":"api/Classes/classngfx_1_1D3DWindow/#public-functions","text":"Name virtual ~D3DWindow ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1D3DWindow/#public-attributes","text":"Name D3DSurface d3dSurface","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1D3DWindow/#additional-inherited-members","text":"Public Types inherited from ngfx::Window Name enum @2 { DISPLAY_WIDTH, DISPLAY_HEIGHT} Public Functions inherited from ngfx::Window Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () virtual bool shouldClose () =0 virtual void pollEvents () =0 Public Attributes inherited from ngfx::Window Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1D3DWindow/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1D3DWindow/#function-d3dwindow","text":"inline virtual ~D3DWindow()","title":"function ~D3DWindow"},{"location":"api/Classes/classngfx_1_1D3DWindow/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1D3DWindow/#variable-d3dsurface","text":"D3DSurface d3dSurface; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable d3dSurface"},{"location":"api/Classes/classngfx_1_1Device/","text":"ngfx::Device Inherited by ngfx::D3DDevice , ngfx::MTLDevice , ngfx::VKDevice Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Device"},{"location":"api/Classes/classngfx_1_1Device/#ngfxdevice","text":"Inherited by ngfx::D3DDevice , ngfx::MTLDevice , ngfx::VKDevice Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Device"},{"location":"api/Classes/classngfx_1_1DrawColorOp/","text":"ngfx::DrawColorOp Inherits from ngfx::DrawOp Public Functions Name DrawColorOp ( GraphicsContext * ctx, const std::vector< glm::vec2 > & pos, const glm::vec4 & color) virtual ~DrawColorOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override Protected Functions Name virtual void createPipeline () Public Attributes Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bUbo Protected Attributes Name GraphicsPipeline * graphicsPipeline uint32_t B_POS uint32_t U_UBO uint32_t numVerts Additional inherited members Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx Public Functions Documentation function DrawColorOp DrawColorOp( GraphicsContext * ctx, const std::vector< glm::vec2 > & pos, const glm::vec4 & color ) function ~DrawColorOp inline virtual ~DrawColorOp() function draw virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer. Protected Functions Documentation function createPipeline virtual void createPipeline() Public Attributes Documentation variable bPos std::unique_ptr< Buffer > bPos; variable bUbo std::unique_ptr< Buffer > bUbo; Protected Attributes Documentation variable graphicsPipeline GraphicsPipeline * graphicsPipeline; variable B_POS uint32_t B_POS; variable U_UBO uint32_t U_UBO; variable numVerts uint32_t numVerts; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::DrawColorOp"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#ngfxdrawcolorop","text":"Inherits from ngfx::DrawOp","title":"ngfx::DrawColorOp"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#public-functions","text":"Name DrawColorOp ( GraphicsContext * ctx, const std::vector< glm::vec2 > & pos, const glm::vec4 & color) virtual ~DrawColorOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#protected-functions","text":"Name virtual void createPipeline ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#public-attributes","text":"Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bUbo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#protected-attributes","text":"Name GraphicsPipeline * graphicsPipeline uint32_t B_POS uint32_t U_UBO uint32_t numVerts","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#function-drawcolorop","text":"DrawColorOp( GraphicsContext * ctx, const std::vector< glm::vec2 > & pos, const glm::vec4 & color )","title":"function DrawColorOp"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#function-drawcolorop_1","text":"inline virtual ~DrawColorOp()","title":"function ~DrawColorOp"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#function-draw","text":"virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer.","title":"function draw"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#function-createpipeline","text":"virtual void createPipeline()","title":"function createPipeline"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-bpos","text":"std::unique_ptr< Buffer > bPos;","title":"variable bPos"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-bubo","text":"std::unique_ptr< Buffer > bUbo;","title":"variable bUbo"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-graphicspipeline","text":"GraphicsPipeline * graphicsPipeline;","title":"variable graphicsPipeline"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-b_pos","text":"uint32_t B_POS;","title":"variable B_POS"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-u_ubo","text":"uint32_t U_UBO;","title":"variable U_UBO"},{"location":"api/Classes/classngfx_1_1DrawColorOp/#variable-numverts","text":"uint32_t numVerts; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable numVerts"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/","text":"ngfx::DrawMeshOp Inherits from ngfx::DrawOp Public Classes Name struct LightData Protected Classes Name struct UBO_FS_Data struct UBO_VS_Data Public Functions Name DrawMeshOp ( GraphicsContext * ctx, MeshData & meshData) virtual ~DrawMeshOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override virtual void update (mat4 & modelView, mat4 & modelViewInverseTranspose, mat4 & modelViewProj, LightData & lightData) Protected Functions Name virtual void createPipeline () Public Attributes Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bNormals std::unique_ptr< Buffer > bFaces std::unique_ptr< Buffer > bUboVS std::unique_ptr< Buffer > bUboFS Protected Attributes Name GraphicsPipeline * graphicsPipeline uint32_t B_POS uint32_t B_NORMALS uint32_t U_UBO_VS uint32_t U_UBO_FS uint32_t numVerts uint32_t numNormals uint32_t numFaces Additional inherited members Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx Public Functions Documentation function DrawMeshOp DrawMeshOp( GraphicsContext * ctx, MeshData & meshData ) function ~DrawMeshOp inline virtual ~DrawMeshOp() function draw virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer. function update virtual void update( mat4 & modelView, mat4 & modelViewInverseTranspose, mat4 & modelViewProj, LightData & lightData ) Protected Functions Documentation function createPipeline virtual void createPipeline() Public Attributes Documentation variable bPos std::unique_ptr< Buffer > bPos; variable bNormals std::unique_ptr< Buffer > bNormals; variable bFaces std::unique_ptr< Buffer > bFaces; variable bUboVS std::unique_ptr< Buffer > bUboVS; variable bUboFS std::unique_ptr< Buffer > bUboFS; Protected Attributes Documentation variable graphicsPipeline GraphicsPipeline * graphicsPipeline; variable B_POS uint32_t B_POS; variable B_NORMALS uint32_t B_NORMALS; variable U_UBO_VS uint32_t U_UBO_VS; variable U_UBO_FS uint32_t U_UBO_FS; variable numVerts uint32_t numVerts; variable numNormals uint32_t numNormals; variable numFaces uint32_t numFaces; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::DrawMeshOp"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#ngfxdrawmeshop","text":"Inherits from ngfx::DrawOp","title":"ngfx::DrawMeshOp"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#public-classes","text":"Name struct LightData","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#protected-classes","text":"Name struct UBO_FS_Data struct UBO_VS_Data","title":"Protected Classes"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#public-functions","text":"Name DrawMeshOp ( GraphicsContext * ctx, MeshData & meshData) virtual ~DrawMeshOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override virtual void update (mat4 & modelView, mat4 & modelViewInverseTranspose, mat4 & modelViewProj, LightData & lightData)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#protected-functions","text":"Name virtual void createPipeline ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#public-attributes","text":"Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bNormals std::unique_ptr< Buffer > bFaces std::unique_ptr< Buffer > bUboVS std::unique_ptr< Buffer > bUboFS","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#protected-attributes","text":"Name GraphicsPipeline * graphicsPipeline uint32_t B_POS uint32_t B_NORMALS uint32_t U_UBO_VS uint32_t U_UBO_FS uint32_t numVerts uint32_t numNormals uint32_t numFaces","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#function-drawmeshop","text":"DrawMeshOp( GraphicsContext * ctx, MeshData & meshData )","title":"function DrawMeshOp"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#function-drawmeshop_1","text":"inline virtual ~DrawMeshOp()","title":"function ~DrawMeshOp"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#function-draw","text":"virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer.","title":"function draw"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#function-update","text":"virtual void update( mat4 & modelView, mat4 & modelViewInverseTranspose, mat4 & modelViewProj, LightData & lightData )","title":"function update"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#function-createpipeline","text":"virtual void createPipeline()","title":"function createPipeline"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-bpos","text":"std::unique_ptr< Buffer > bPos;","title":"variable bPos"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-bnormals","text":"std::unique_ptr< Buffer > bNormals;","title":"variable bNormals"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-bfaces","text":"std::unique_ptr< Buffer > bFaces;","title":"variable bFaces"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-bubovs","text":"std::unique_ptr< Buffer > bUboVS;","title":"variable bUboVS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-bubofs","text":"std::unique_ptr< Buffer > bUboFS;","title":"variable bUboFS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-graphicspipeline","text":"GraphicsPipeline * graphicsPipeline;","title":"variable graphicsPipeline"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-b_pos","text":"uint32_t B_POS;","title":"variable B_POS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-b_normals","text":"uint32_t B_NORMALS;","title":"variable B_NORMALS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-u_ubo_vs","text":"uint32_t U_UBO_VS;","title":"variable U_UBO_VS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-u_ubo_fs","text":"uint32_t U_UBO_FS;","title":"variable U_UBO_FS"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-numverts","text":"uint32_t numVerts;","title":"variable numVerts"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-numnormals","text":"uint32_t numNormals;","title":"variable numNormals"},{"location":"api/Classes/classngfx_1_1DrawMeshOp/#variable-numfaces","text":"uint32_t numFaces; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable numFaces"},{"location":"api/Classes/classngfx_1_1DrawOp/","text":"ngfx::DrawOp Inherited by ngfx::DrawColorOp , ngfx::DrawMeshOp , ngfx::DrawTextureOp , ngfx::FilterOp Public Functions Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0 Protected Attributes Name GraphicsContext * ctx Public Functions Documentation function DrawOp inline DrawOp( GraphicsContext * ctx ) Parameters : ctx The graphics context Create the draw operation function ~DrawOp inline virtual ~DrawOp() Destroy the draw op function draw virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) =0 Parameters : commandBuffer The command buffer graphics The graphics object Reimplemented by : ngfx::DrawMeshOp::draw , ngfx::DrawColorOp::draw , ngfx::DrawTextureOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer. Protected Attributes Documentation variable ctx GraphicsContext * ctx; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#ngfxdrawop","text":"Inherited by ngfx::DrawColorOp , ngfx::DrawMeshOp , ngfx::DrawTextureOp , ngfx::FilterOp","title":"ngfx::DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#public-functions","text":"Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1DrawOp/#protected-attributes","text":"Name GraphicsContext * ctx","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1DrawOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawOp/#function-drawop","text":"inline DrawOp( GraphicsContext * ctx ) Parameters : ctx The graphics context Create the draw operation","title":"function DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#function-drawop_1","text":"inline virtual ~DrawOp() Destroy the draw op","title":"function ~DrawOp"},{"location":"api/Classes/classngfx_1_1DrawOp/#function-draw","text":"virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) =0 Parameters : commandBuffer The command buffer graphics The graphics object Reimplemented by : ngfx::DrawMeshOp::draw , ngfx::DrawColorOp::draw , ngfx::DrawTextureOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer.","title":"function draw"},{"location":"api/Classes/classngfx_1_1DrawOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawOp/#variable-ctx","text":"GraphicsContext * ctx; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/","text":"ngfx::DrawTextureOp Inherits from ngfx::DrawOp Public Functions Name DrawTextureOp ( GraphicsContext * ctx, Texture * texture) DrawTextureOp ( GraphicsContext * ctx, Texture * texture, const std::vector< glm::vec2 > & pos, const std::vector< glm::vec2 > & texCoord) virtual ~DrawTextureOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override Protected Functions Name virtual void createPipeline () Public Attributes Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bTexCoord Texture * texture Protected Attributes Name GraphicsPipeline * graphicsPipeline uint32_t numVerts uint32_t B_POS uint32_t B_TEXCOORD uint32_t U_TEXTURE Additional inherited members Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx Public Functions Documentation function DrawTextureOp inline DrawTextureOp( GraphicsContext * ctx, Texture * texture ) function DrawTextureOp DrawTextureOp( GraphicsContext * ctx, Texture * texture, const std::vector< glm::vec2 > & pos, const std::vector< glm::vec2 > & texCoord ) function ~DrawTextureOp inline virtual ~DrawTextureOp() function draw virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer. Protected Functions Documentation function createPipeline virtual void createPipeline() Public Attributes Documentation variable bPos std::unique_ptr< Buffer > bPos; variable bTexCoord std::unique_ptr< Buffer > bTexCoord; variable texture Texture * texture; Protected Attributes Documentation variable graphicsPipeline GraphicsPipeline * graphicsPipeline; variable numVerts uint32_t numVerts; variable B_POS uint32_t B_POS; variable B_TEXCOORD uint32_t B_TEXCOORD; variable U_TEXTURE uint32_t U_TEXTURE; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::DrawTextureOp"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#ngfxdrawtextureop","text":"Inherits from ngfx::DrawOp","title":"ngfx::DrawTextureOp"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#public-functions","text":"Name DrawTextureOp ( GraphicsContext * ctx, Texture * texture) DrawTextureOp ( GraphicsContext * ctx, Texture * texture, const std::vector< glm::vec2 > & pos, const std::vector< glm::vec2 > & texCoord) virtual ~DrawTextureOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#protected-functions","text":"Name virtual void createPipeline ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#public-attributes","text":"Name std::unique_ptr< Buffer > bPos std::unique_ptr< Buffer > bTexCoord Texture * texture","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#protected-attributes","text":"Name GraphicsPipeline * graphicsPipeline uint32_t numVerts uint32_t B_POS uint32_t B_TEXCOORD uint32_t U_TEXTURE","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#function-drawtextureop","text":"inline DrawTextureOp( GraphicsContext * ctx, Texture * texture )","title":"function DrawTextureOp"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#function-drawtextureop_1","text":"DrawTextureOp( GraphicsContext * ctx, Texture * texture, const std::vector< glm::vec2 > & pos, const std::vector< glm::vec2 > & texCoord )","title":"function DrawTextureOp"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#function-drawtextureop_2","text":"inline virtual ~DrawTextureOp()","title":"function ~DrawTextureOp"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#function-draw","text":"virtual void draw( CommandBuffer * commandBuffer, Graphics * graphics ) override Parameters : commandBuffer The command buffer graphics The graphics object Reimplements : ngfx::DrawOp::draw Draw function. This function is called when the scene is redrawn. It records the draw calls to the command buffer.","title":"function draw"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#function-createpipeline","text":"virtual void createPipeline()","title":"function createPipeline"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-bpos","text":"std::unique_ptr< Buffer > bPos;","title":"variable bPos"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-btexcoord","text":"std::unique_ptr< Buffer > bTexCoord;","title":"variable bTexCoord"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-texture","text":"Texture * texture;","title":"variable texture"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-graphicspipeline","text":"GraphicsPipeline * graphicsPipeline;","title":"variable graphicsPipeline"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-numverts","text":"uint32_t numVerts;","title":"variable numVerts"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-b_pos","text":"uint32_t B_POS;","title":"variable B_POS"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-b_texcoord","text":"uint32_t B_TEXCOORD;","title":"variable B_TEXCOORD"},{"location":"api/Classes/classngfx_1_1DrawTextureOp/#variable-u_texture","text":"uint32_t U_TEXTURE; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable U_TEXTURE"},{"location":"api/Classes/classngfx_1_1FPSCounter/","text":"ngfx::FPSCounter Public Functions Name FPSCounter () void update () Public Attributes Name float fps Public Functions Documentation function FPSCounter inline FPSCounter() function update void update() Public Attributes Documentation variable fps float fps = 0.0f; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::FPSCounter"},{"location":"api/Classes/classngfx_1_1FPSCounter/#ngfxfpscounter","text":"","title":"ngfx::FPSCounter"},{"location":"api/Classes/classngfx_1_1FPSCounter/#public-functions","text":"Name FPSCounter () void update ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1FPSCounter/#public-attributes","text":"Name float fps","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1FPSCounter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1FPSCounter/#function-fpscounter","text":"inline FPSCounter()","title":"function FPSCounter"},{"location":"api/Classes/classngfx_1_1FPSCounter/#function-update","text":"void update()","title":"function update"},{"location":"api/Classes/classngfx_1_1FPSCounter/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1FPSCounter/#variable-fps","text":"float fps = 0.0f; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable fps"},{"location":"api/Classes/classngfx_1_1Fence/","text":"ngfx::Fence Inherited by ngfx::D3DFence , ngfx::VKFence Public Functions Name Fence * create ( Device * device, FenceCreateFlags flags =0) virtual ~Fence () virtual void wait () =0 virtual void reset () =0 Public Functions Documentation function create static Fence * create( Device * device, FenceCreateFlags flags =0 ) Parameters : device The GPU device handle flags Additional fence create flags (optional) Create the fence object function ~Fence inline virtual ~Fence() Destroy the fence object function wait virtual void wait() =0 Reimplemented by : ngfx::VKFence::wait , ngfx::D3DFence::wait Wait for the fence to be signaled by the GPU function reset virtual void reset() =0 Reimplemented by : ngfx::VKFence::reset , ngfx::D3DFence::reset Reset the fence Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Fence"},{"location":"api/Classes/classngfx_1_1Fence/#ngfxfence","text":"Inherited by ngfx::D3DFence , ngfx::VKFence","title":"ngfx::Fence"},{"location":"api/Classes/classngfx_1_1Fence/#public-functions","text":"Name Fence * create ( Device * device, FenceCreateFlags flags =0) virtual ~Fence () virtual void wait () =0 virtual void reset () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Fence/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Fence/#function-create","text":"static Fence * create( Device * device, FenceCreateFlags flags =0 ) Parameters : device The GPU device handle flags Additional fence create flags (optional) Create the fence object","title":"function create"},{"location":"api/Classes/classngfx_1_1Fence/#function-fence","text":"inline virtual ~Fence() Destroy the fence object","title":"function ~Fence"},{"location":"api/Classes/classngfx_1_1Fence/#function-wait","text":"virtual void wait() =0 Reimplemented by : ngfx::VKFence::wait , ngfx::D3DFence::wait Wait for the fence to be signaled by the GPU","title":"function wait"},{"location":"api/Classes/classngfx_1_1Fence/#function-reset","text":"virtual void reset() =0 Reimplemented by : ngfx::VKFence::reset , ngfx::D3DFence::reset Reset the fence Updated on 3 April 2021 at 20:21:51 PDT","title":"function reset"},{"location":"api/Classes/classngfx_1_1File/","text":"ngfx::File Public Functions Name void read (const std::string & filename) Public Attributes Name std::unique_ptr< char[]> data int size Public Functions Documentation function read void read( const std::string & filename ) Public Attributes Documentation variable data std::unique_ptr< char[]> data; variable size int size; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::File"},{"location":"api/Classes/classngfx_1_1File/#ngfxfile","text":"","title":"ngfx::File"},{"location":"api/Classes/classngfx_1_1File/#public-functions","text":"Name void read (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1File/#public-attributes","text":"Name std::unique_ptr< char[]> data int size","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1File/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1File/#function-read","text":"void read( const std::string & filename )","title":"function read"},{"location":"api/Classes/classngfx_1_1File/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1File/#variable-data","text":"std::unique_ptr< char[]> data;","title":"variable data"},{"location":"api/Classes/classngfx_1_1File/#variable-size","text":"int size; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable size"},{"location":"api/Classes/classngfx_1_1FileUtil/","text":"ngfx::FileUtil Public Classes Name struct Lock Public Functions Name bool getmtime (const std::string & filename, std::filesystem::file_time_type & mtime) bool srcFileNewerThanOutFile (const std::string & srcFileName, const std::string & targetFileName) std::string tempDir () std::string readFile (const std::string & path) void writeFile (const std::string & path, const std::string & contents) std::vector< std::string > splitExt (const std::string & filename) std::vector< std::string > findFiles (const std::string & path) std::vector< std::string > findFiles (const std::string & path, const std::string & ext) std::vector< std::string > filterFiles (const std::vector< std::string > & files, const std::string & fileFilter) std::vector< std::string > findFiles (const std::vector< std::string > & paths, const std::vector< std::string > & extensions) Public Functions Documentation function getmtime static bool getmtime( const std::string & filename, std::filesystem::file_time_type & mtime ) function srcFileNewerThanOutFile static bool srcFileNewerThanOutFile( const std::string & srcFileName, const std::string & targetFileName ) function tempDir static std::string tempDir() function readFile static std::string readFile( const std::string & path ) function writeFile static void writeFile( const std::string & path, const std::string & contents ) function splitExt static std::vector< std::string > splitExt( const std::string & filename ) function findFiles static std::vector< std::string > findFiles( const std::string & path ) function findFiles static std::vector< std::string > findFiles( const std::string & path, const std::string & ext ) function filterFiles static std::vector< std::string > filterFiles( const std::vector< std::string > & files, const std::string & fileFilter ) function findFiles static std::vector< std::string > findFiles( const std::vector< std::string > & paths, const std::vector< std::string > & extensions ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::FileUtil"},{"location":"api/Classes/classngfx_1_1FileUtil/#ngfxfileutil","text":"","title":"ngfx::FileUtil"},{"location":"api/Classes/classngfx_1_1FileUtil/#public-classes","text":"Name struct Lock","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1FileUtil/#public-functions","text":"Name bool getmtime (const std::string & filename, std::filesystem::file_time_type & mtime) bool srcFileNewerThanOutFile (const std::string & srcFileName, const std::string & targetFileName) std::string tempDir () std::string readFile (const std::string & path) void writeFile (const std::string & path, const std::string & contents) std::vector< std::string > splitExt (const std::string & filename) std::vector< std::string > findFiles (const std::string & path) std::vector< std::string > findFiles (const std::string & path, const std::string & ext) std::vector< std::string > filterFiles (const std::vector< std::string > & files, const std::string & fileFilter) std::vector< std::string > findFiles (const std::vector< std::string > & paths, const std::vector< std::string > & extensions)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1FileUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-getmtime","text":"static bool getmtime( const std::string & filename, std::filesystem::file_time_type & mtime )","title":"function getmtime"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-srcfilenewerthanoutfile","text":"static bool srcFileNewerThanOutFile( const std::string & srcFileName, const std::string & targetFileName )","title":"function srcFileNewerThanOutFile"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-tempdir","text":"static std::string tempDir()","title":"function tempDir"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-readfile","text":"static std::string readFile( const std::string & path )","title":"function readFile"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-writefile","text":"static void writeFile( const std::string & path, const std::string & contents )","title":"function writeFile"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-splitext","text":"static std::vector< std::string > splitExt( const std::string & filename )","title":"function splitExt"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-findfiles","text":"static std::vector< std::string > findFiles( const std::string & path )","title":"function findFiles"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-findfiles_1","text":"static std::vector< std::string > findFiles( const std::string & path, const std::string & ext )","title":"function findFiles"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-filterfiles","text":"static std::vector< std::string > filterFiles( const std::vector< std::string > & files, const std::string & fileFilter )","title":"function filterFiles"},{"location":"api/Classes/classngfx_1_1FileUtil/#function-findfiles_2","text":"static std::vector< std::string > findFiles( const std::vector< std::string > & paths, const std::vector< std::string > & extensions ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function findFiles"},{"location":"api/Classes/classngfx_1_1FilterOp/","text":"ngfx::FilterOp Inherits from ngfx::DrawOp Public Functions Name FilterOp ( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight) virtual ~FilterOp () void apply ( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics) Public Attributes Name std::unique_ptr< Texture > outputTexture std::unique_ptr< Framebuffer > outputFramebuffer Additional inherited members Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0 Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx Public Functions Documentation function FilterOp FilterOp( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight ) Parameters : ctx The graphics context graphics The graphics interface dstWidth The destination width dstHeight The destination height Create a filter operation function ~FilterOp inline virtual ~FilterOp() Destroy the filter operation function apply void apply( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics ) Parameters : ctx The graphics context commandBuffer The command buffer graphics The graphics interface Apply the filter Public Attributes Documentation variable outputTexture std::unique_ptr< Texture > outputTexture; The output texture variable outputFramebuffer std::unique_ptr< Framebuffer > outputFramebuffer; The output framebuffer Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#ngfxfilterop","text":"Inherits from ngfx::DrawOp","title":"ngfx::FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-functions","text":"Name FilterOp ( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight) virtual ~FilterOp () void apply ( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-attributes","text":"Name std::unique_ptr< Texture > outputTexture std::unique_ptr< Framebuffer > outputFramebuffer","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1FilterOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::DrawOp Name DrawOp ( GraphicsContext * ctx) virtual ~DrawOp () virtual void draw ( CommandBuffer * commandBuffer, Graphics * graphics) =0 Protected Attributes inherited from ngfx::DrawOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1FilterOp/#function-filterop","text":"FilterOp( GraphicsContext * ctx, Graphics * graphics, uint32_t dstWidth, uint32_t dstHeight ) Parameters : ctx The graphics context graphics The graphics interface dstWidth The destination width dstHeight The destination height Create a filter operation","title":"function FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#function-filterop_1","text":"inline virtual ~FilterOp() Destroy the filter operation","title":"function ~FilterOp"},{"location":"api/Classes/classngfx_1_1FilterOp/#function-apply","text":"void apply( GraphicsContext * ctx, CommandBuffer * commandBuffer, Graphics * graphics ) Parameters : ctx The graphics context commandBuffer The command buffer graphics The graphics interface Apply the filter","title":"function apply"},{"location":"api/Classes/classngfx_1_1FilterOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1FilterOp/#variable-outputtexture","text":"std::unique_ptr< Texture > outputTexture; The output texture","title":"variable outputTexture"},{"location":"api/Classes/classngfx_1_1FilterOp/#variable-outputframebuffer","text":"std::unique_ptr< Framebuffer > outputFramebuffer; The output framebuffer Updated on 3 April 2021 at 20:21:51 PDT","title":"variable outputFramebuffer"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/","text":"ngfx::FragmentShaderModule Inherits from ngfx::ShaderModule Inherited by ngfx::D3DFragmentShaderModule , ngfx::MTLFragmentShaderModule , ngfx::VKFragmentShaderModule Public Functions Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename) Additional inherited members Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function create static std::unique_ptr< FragmentShaderModule > create( Device * device, const std::string & filename ) function ~FragmentShaderModule inline virtual ~FragmentShaderModule() function initBindings inline void initBindings( const std::string & filename ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::FragmentShaderModule"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#ngfxfragmentshadermodule","text":"Inherits from ngfx::ShaderModule Inherited by ngfx::D3DFragmentShaderModule , ngfx::MTLFragmentShaderModule , ngfx::VKFragmentShaderModule","title":"ngfx::FragmentShaderModule"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#public-functions","text":"Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#function-create","text":"static std::unique_ptr< FragmentShaderModule > create( Device * device, const std::string & filename )","title":"function create"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#function-fragmentshadermodule","text":"inline virtual ~FragmentShaderModule()","title":"function ~FragmentShaderModule"},{"location":"api/Classes/classngfx_1_1FragmentShaderModule/#function-initbindings","text":"inline void initBindings( const std::string & filename ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1Framebuffer/","text":"ngfx::Framebuffer Inherited by ngfx::D3DFramebuffer , ngfx::MTLFramebuffer , ngfx::VKFramebuffer Public Classes Name struct Attachment Public Functions Name Framebuffer * create ( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1) virtual ~Framebuffer () Public Attributes Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments Public Functions Documentation function create static Framebuffer * create( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1 ) Parameters : device The graphics device renderPass The renderPass object attachments The output attachments w The destination width h The destination height layers The number of output layers Create a framebuffer object function ~Framebuffer inline virtual ~Framebuffer() Destroy the framebuffer Public Attributes Documentation variable w uint32_t w; The output width variable h uint32_t h; The output height variable layers uint32_t layers; The number of output layers variable numAttachments uint32_t numAttachments; The number of attachments variable attachments std::vector< Attachment > attachments; The vector of output attachments Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Framebuffer"},{"location":"api/Classes/classngfx_1_1Framebuffer/#ngfxframebuffer","text":"Inherited by ngfx::D3DFramebuffer , ngfx::MTLFramebuffer , ngfx::VKFramebuffer","title":"ngfx::Framebuffer"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-classes","text":"Name struct Attachment","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-functions","text":"Name Framebuffer * create ( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1) virtual ~Framebuffer ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-attributes","text":"Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Framebuffer/#function-create","text":"static Framebuffer * create( Device * device, RenderPass * renderPass, const std::vector< Attachment > & attachments, uint32_t w, uint32_t h, uint32_t layers =1 ) Parameters : device The graphics device renderPass The renderPass object attachments The output attachments w The destination width h The destination height layers The number of output layers Create a framebuffer object","title":"function create"},{"location":"api/Classes/classngfx_1_1Framebuffer/#function-framebuffer","text":"inline virtual ~Framebuffer() Destroy the framebuffer","title":"function ~Framebuffer"},{"location":"api/Classes/classngfx_1_1Framebuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-w","text":"uint32_t w; The output width","title":"variable w"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-h","text":"uint32_t h; The output height","title":"variable h"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-layers","text":"uint32_t layers; The number of output layers","title":"variable layers"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-numattachments","text":"uint32_t numAttachments; The number of attachments","title":"variable numAttachments"},{"location":"api/Classes/classngfx_1_1Framebuffer/#variable-attachments","text":"std::vector< Attachment > attachments; The vector of output attachments Updated on 3 April 2021 at 20:21:51 PDT","title":"variable attachments"},{"location":"api/Classes/classngfx_1_1GLFWWindow/","text":"ngfx::GLFWWindow Public Functions Name void create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> setWindow, int w, int h) virtual bool shouldClose () virtual void pollEvents () virtual ~GLFWWindow () Public Attributes Name GLFWwindow * v Public Functions Documentation function create void create( GraphicsContext * graphicsContext, const char * title, std::function< void(Window *thiz)> setWindow, int w, int h ) function shouldClose virtual bool shouldClose() function pollEvents virtual void pollEvents() function ~GLFWWindow virtual ~GLFWWindow() Public Attributes Documentation variable v GLFWwindow * v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::GLFWWindow"},{"location":"api/Classes/classngfx_1_1GLFWWindow/#ngfxglfwwindow","text":"","title":"ngfx::GLFWWindow"},{"location":"api/Classes/classngfx_1_1GLFWWindow/#public-functions","text":"Name void create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> setWindow, int w, int h) virtual bool shouldClose () virtual void pollEvents () virtual ~GLFWWindow ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1GLFWWindow/#public-attributes","text":"Name GLFWwindow * v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1GLFWWindow/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1GLFWWindow/#function-create","text":"void create( GraphicsContext * graphicsContext, const char * title, std::function< void(Window *thiz)> setWindow, int w, int h )","title":"function create"},{"location":"api/Classes/classngfx_1_1GLFWWindow/#function-shouldclose","text":"virtual bool shouldClose()","title":"function shouldClose"},{"location":"api/Classes/classngfx_1_1GLFWWindow/#function-pollevents","text":"virtual void pollEvents()","title":"function pollEvents"},{"location":"api/Classes/classngfx_1_1GLFWWindow/#function-glfwwindow","text":"virtual ~GLFWWindow()","title":"function ~GLFWWindow"},{"location":"api/Classes/classngfx_1_1GLFWWindow/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1GLFWWindow/#variable-v","text":"GLFWwindow * v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1Graphics/","text":"ngfx::Graphics Inherited by ngfx::D3DGraphics , ngfx::MTLGraphics , ngfx::VKGraphics Public Functions Name Graphics * create ( GraphicsContext * ctx) virtual ~Graphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) =0 virtual void endComputePass ( CommandBuffer * commandBuffer) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) =0 virtual void endRenderPass ( CommandBuffer * commandBuffer) =0 virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) =0 virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32) =0 virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) =0 virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) =0 virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) =0 virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) =0 virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) =0 virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) =0 virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void waitIdle ( CommandBuffer * cmdBuffer) =0 Public Attributes Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer Protected Attributes Name GraphicsContext * ctx Public Functions Documentation function create static Graphics * create( GraphicsContext * ctx ) function ~Graphics inline virtual ~Graphics() function beginComputePass virtual void beginComputePass( CommandBuffer * commandBuffer ) =0 Reimplemented by : ngfx::VKGraphics::beginComputePass , ngfx::D3DGraphics::beginComputePass , ngfx::MTLGraphics::beginComputePass function endComputePass virtual void endComputePass( CommandBuffer * commandBuffer ) =0 Reimplemented by : ngfx::VKGraphics::endComputePass , ngfx::D3DGraphics::endComputePass , ngfx::MTLGraphics::endComputePass function beginRenderPass virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) =0 Reimplemented by : ngfx::VKGraphics::beginRenderPass , ngfx::D3DGraphics::beginRenderPass , ngfx::MTLGraphics::beginRenderPass function endRenderPass virtual void endRenderPass( CommandBuffer * commandBuffer ) =0 Reimplemented by : ngfx::VKGraphics::endRenderPass , ngfx::D3DGraphics::endRenderPass , ngfx::MTLGraphics::endRenderPass function bindVertexBuffer virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) =0 Reimplemented by : ngfx::VKGraphics::bindVertexBuffer , ngfx::D3DGraphics::bindVertexBuffer , ngfx::MTLGraphics::bindVertexBuffer function bindIndexBuffer virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32 ) =0 Reimplemented by : ngfx::VKGraphics::bindIndexBuffer , ngfx::D3DGraphics::bindIndexBuffer , ngfx::MTLGraphics::bindIndexBuffer function bindUniformBuffer virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0 Reimplemented by : ngfx::VKGraphics::bindUniformBuffer , ngfx::D3DGraphics::bindUniformBuffer , ngfx::MTLGraphics::bindUniformBuffer function bindStorageBuffer virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0 Reimplemented by : ngfx::VKGraphics::bindStorageBuffer , ngfx::D3DGraphics::bindStorageBuffer , ngfx::MTLGraphics::bindStorageBuffer function bindComputePipeline virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) =0 Reimplemented by : ngfx::VKGraphics::bindComputePipeline , ngfx::D3DGraphics::bindComputePipeline , ngfx::MTLGraphics::bindComputePipeline function bindGraphicsPipeline virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) =0 Reimplemented by : ngfx::VKGraphics::bindGraphicsPipeline , ngfx::D3DGraphics::bindGraphicsPipeline , ngfx::MTLGraphics::bindGraphicsPipeline function bindTexture virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) =0 Reimplemented by : ngfx::VKGraphics::bindTexture , ngfx::D3DGraphics::bindTexture , ngfx::MTLGraphics::bindTexture function draw virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) =0 Reimplemented by : ngfx::VKGraphics::draw , ngfx::D3DGraphics::draw , ngfx::MTLGraphics::draw function drawIndexed virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) =0 Reimplemented by : ngfx::VKGraphics::drawIndexed , ngfx::D3DGraphics::drawIndexed , ngfx::MTLGraphics::drawIndexed function dispatch virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) =0 Reimplemented by : ngfx::VKGraphics::dispatch , ngfx::MTLGraphics::dispatch , ngfx::D3DGraphics::dispatch function setViewport virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) =0 Reimplemented by : ngfx::VKGraphics::setViewport , ngfx::MTLGraphics::setViewport , ngfx::D3DGraphics::setViewport function setScissor virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) =0 Reimplemented by : ngfx::VKGraphics::setScissor , ngfx::MTLGraphics::setScissor , ngfx::D3DGraphics::setScissor function waitIdle virtual void waitIdle( CommandBuffer * cmdBuffer ) =0 Reimplemented by : ngfx::VKGraphics::waitIdle , ngfx::MTLGraphics::waitIdle , ngfx::D3DGraphics::waitIdle Public Attributes Documentation variable scissorRect Rect2D scissorRect; variable viewport Rect2D viewport; variable currentPipeline Pipeline * currentPipeline = nullptr; variable currentRenderPass RenderPass * currentRenderPass = nullptr; variable currentFramebuffer Framebuffer * currentFramebuffer = nullptr; Protected Attributes Documentation variable ctx GraphicsContext * ctx; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Graphics"},{"location":"api/Classes/classngfx_1_1Graphics/#ngfxgraphics","text":"Inherited by ngfx::D3DGraphics , ngfx::MTLGraphics , ngfx::VKGraphics","title":"ngfx::Graphics"},{"location":"api/Classes/classngfx_1_1Graphics/#public-functions","text":"Name Graphics * create ( GraphicsContext * ctx) virtual ~Graphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) =0 virtual void endComputePass ( CommandBuffer * commandBuffer) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) =0 virtual void endRenderPass ( CommandBuffer * commandBuffer) =0 virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) =0 virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32) =0 virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) =0 virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) =0 virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) =0 virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) =0 virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) =0 virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) =0 virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) =0 virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) =0 virtual void waitIdle ( CommandBuffer * cmdBuffer) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Graphics/#public-attributes","text":"Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Graphics/#protected-attributes","text":"Name GraphicsContext * ctx","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1Graphics/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Graphics/#function-create","text":"static Graphics * create( GraphicsContext * ctx )","title":"function create"},{"location":"api/Classes/classngfx_1_1Graphics/#function-graphics","text":"inline virtual ~Graphics()","title":"function ~Graphics"},{"location":"api/Classes/classngfx_1_1Graphics/#function-begincomputepass","text":"virtual void beginComputePass( CommandBuffer * commandBuffer ) =0 Reimplemented by : ngfx::VKGraphics::beginComputePass , ngfx::D3DGraphics::beginComputePass , ngfx::MTLGraphics::beginComputePass","title":"function beginComputePass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-endcomputepass","text":"virtual void endComputePass( CommandBuffer * commandBuffer ) =0 Reimplemented by : ngfx::VKGraphics::endComputePass , ngfx::D3DGraphics::endComputePass , ngfx::MTLGraphics::endComputePass","title":"function endComputePass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-beginrenderpass","text":"virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) =0 Reimplemented by : ngfx::VKGraphics::beginRenderPass , ngfx::D3DGraphics::beginRenderPass , ngfx::MTLGraphics::beginRenderPass","title":"function beginRenderPass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-endrenderpass","text":"virtual void endRenderPass( CommandBuffer * commandBuffer ) =0 Reimplemented by : ngfx::VKGraphics::endRenderPass , ngfx::D3DGraphics::endRenderPass , ngfx::MTLGraphics::endRenderPass","title":"function endRenderPass"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindvertexbuffer","text":"virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) =0 Reimplemented by : ngfx::VKGraphics::bindVertexBuffer , ngfx::D3DGraphics::bindVertexBuffer , ngfx::MTLGraphics::bindVertexBuffer","title":"function bindVertexBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindindexbuffer","text":"virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32 ) =0 Reimplemented by : ngfx::VKGraphics::bindIndexBuffer , ngfx::D3DGraphics::bindIndexBuffer , ngfx::MTLGraphics::bindIndexBuffer","title":"function bindIndexBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-binduniformbuffer","text":"virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0 Reimplemented by : ngfx::VKGraphics::bindUniformBuffer , ngfx::D3DGraphics::bindUniformBuffer , ngfx::MTLGraphics::bindUniformBuffer","title":"function bindUniformBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindstoragebuffer","text":"virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) =0 Reimplemented by : ngfx::VKGraphics::bindStorageBuffer , ngfx::D3DGraphics::bindStorageBuffer , ngfx::MTLGraphics::bindStorageBuffer","title":"function bindStorageBuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindcomputepipeline","text":"virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) =0 Reimplemented by : ngfx::VKGraphics::bindComputePipeline , ngfx::D3DGraphics::bindComputePipeline , ngfx::MTLGraphics::bindComputePipeline","title":"function bindComputePipeline"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindgraphicspipeline","text":"virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) =0 Reimplemented by : ngfx::VKGraphics::bindGraphicsPipeline , ngfx::D3DGraphics::bindGraphicsPipeline , ngfx::MTLGraphics::bindGraphicsPipeline","title":"function bindGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1Graphics/#function-bindtexture","text":"virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) =0 Reimplemented by : ngfx::VKGraphics::bindTexture , ngfx::D3DGraphics::bindTexture , ngfx::MTLGraphics::bindTexture","title":"function bindTexture"},{"location":"api/Classes/classngfx_1_1Graphics/#function-draw","text":"virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) =0 Reimplemented by : ngfx::VKGraphics::draw , ngfx::D3DGraphics::draw , ngfx::MTLGraphics::draw","title":"function draw"},{"location":"api/Classes/classngfx_1_1Graphics/#function-drawindexed","text":"virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) =0 Reimplemented by : ngfx::VKGraphics::drawIndexed , ngfx::D3DGraphics::drawIndexed , ngfx::MTLGraphics::drawIndexed","title":"function drawIndexed"},{"location":"api/Classes/classngfx_1_1Graphics/#function-dispatch","text":"virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) =0 Reimplemented by : ngfx::VKGraphics::dispatch , ngfx::MTLGraphics::dispatch , ngfx::D3DGraphics::dispatch","title":"function dispatch"},{"location":"api/Classes/classngfx_1_1Graphics/#function-setviewport","text":"virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) =0 Reimplemented by : ngfx::VKGraphics::setViewport , ngfx::MTLGraphics::setViewport , ngfx::D3DGraphics::setViewport","title":"function setViewport"},{"location":"api/Classes/classngfx_1_1Graphics/#function-setscissor","text":"virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) =0 Reimplemented by : ngfx::VKGraphics::setScissor , ngfx::MTLGraphics::setScissor , ngfx::D3DGraphics::setScissor","title":"function setScissor"},{"location":"api/Classes/classngfx_1_1Graphics/#function-waitidle","text":"virtual void waitIdle( CommandBuffer * cmdBuffer ) =0 Reimplemented by : ngfx::VKGraphics::waitIdle , ngfx::MTLGraphics::waitIdle , ngfx::D3DGraphics::waitIdle","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1Graphics/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-scissorrect","text":"Rect2D scissorRect;","title":"variable scissorRect"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-viewport","text":"Rect2D viewport;","title":"variable viewport"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-currentpipeline","text":"Pipeline * currentPipeline = nullptr;","title":"variable currentPipeline"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-currentrenderpass","text":"RenderPass * currentRenderPass = nullptr;","title":"variable currentRenderPass"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-currentframebuffer","text":"Framebuffer * currentFramebuffer = nullptr;","title":"variable currentFramebuffer"},{"location":"api/Classes/classngfx_1_1Graphics/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Graphics/#variable-ctx","text":"GraphicsContext * ctx; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1GraphicsContext/","text":"ngfx::GraphicsContext Inherited by ngfx::D3DGraphicsContext , ngfx::MTLGraphicsContext , ngfx::VKGraphicsContext Public Classes Name struct AttachmentDescription struct RenderPassConfig Public Functions Name GraphicsContext * create (const char * appName, bool enableDepthStencil =false, bool debug =true) virtual ~GraphicsContext () virtual void setSurface ( Surface * surface) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void submit ( CommandBuffer * commandBuffer) virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) =0 virtual CommandBuffer * copyCommandBuffer () =0 virtual CommandBuffer * computeCommandBuffer () =0 virtual RenderPass * getRenderPass ( RenderPassConfig config) =0 Public Attributes Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor Protected Attributes Name bool debug bool enableDepthStencil Public Functions Documentation function create static GraphicsContext * create( const char * appName, bool enableDepthStencil =false, bool debug =true ) function ~GraphicsContext inline virtual ~GraphicsContext() function setSurface virtual void setSurface( Surface * surface ) =0 Reimplemented by : ngfx::MTLGraphicsContext::setSurface , ngfx::D3DGraphicsContext::setSurface , ngfx::VKGraphicsContext::setSurface function beginRenderPass inline virtual void beginRenderPass( CommandBuffer * commandBuffer, Graphics * graphics ) function beginOffscreenRenderPass inline virtual void beginOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer ) function endRenderPass inline virtual void endRenderPass( CommandBuffer * commandBuffer, Graphics * graphics ) function endOffscreenRenderPass inline virtual void endOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics ) function submit inline virtual void submit( CommandBuffer * commandBuffer ) Reimplemented by : ngfx::MTLGraphicsContext::submit function drawCommandBuffer virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) =0 Reimplemented by : ngfx::MTLGraphicsContext::drawCommandBuffer , ngfx::D3DGraphicsContext::drawCommandBuffer , ngfx::VKGraphicsContext::drawCommandBuffer function copyCommandBuffer virtual CommandBuffer * copyCommandBuffer() =0 Reimplemented by : ngfx::MTLGraphicsContext::copyCommandBuffer , ngfx::D3DGraphicsContext::copyCommandBuffer , ngfx::VKGraphicsContext::copyCommandBuffer function computeCommandBuffer virtual CommandBuffer * computeCommandBuffer() =0 Reimplemented by : ngfx::MTLGraphicsContext::computeCommandBuffer , ngfx::D3DGraphicsContext::computeCommandBuffer , ngfx::VKGraphicsContext::computeCommandBuffer function getRenderPass virtual RenderPass * getRenderPass( RenderPassConfig config ) =0 Reimplemented by : ngfx::MTLGraphicsContext::getRenderPass , ngfx::D3DGraphicsContext::getRenderPass , ngfx::VKGraphicsContext::getRenderPass Public Attributes Documentation variable device Device * device; variable numDrawCommandBuffers uint32_t numDrawCommandBuffers = 0; variable swapchainFramebuffers std::vector< Framebuffer * > swapchainFramebuffers; variable queue Queue * queue = nullptr; variable defaultRenderPass RenderPass * defaultRenderPass = nullptr; variable defaultOffscreenRenderPass RenderPass * defaultOffscreenRenderPass = nullptr; variable swapchain Swapchain * swapchain = nullptr; variable surface Surface * surface = nullptr; variable currentImageIndex uint32_t currentImageIndex = 0; variable frameFences std::vector< Fence * > frameFences; variable computeFence Fence * computeFence = nullptr; variable presentCompleteSemaphore Semaphore * presentCompleteSemaphore = nullptr; variable renderCompleteSemaphore Semaphore * renderCompleteSemaphore = nullptr; variable pipelineCache PipelineCache * pipelineCache = nullptr; variable surfaceFormat PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED; variable defaultOffscreenSurfaceFormat PixelFormat defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED; variable depthFormat PixelFormat depthFormat = PIXELFORMAT_UNDEFINED; variable clearColor glm::vec4 clearColor = glm::vec4(0.0f); Protected Attributes Documentation variable debug bool debug = false; variable enableDepthStencil bool enableDepthStencil = false; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::GraphicsContext"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#ngfxgraphicscontext","text":"Inherited by ngfx::D3DGraphicsContext , ngfx::MTLGraphicsContext , ngfx::VKGraphicsContext","title":"ngfx::GraphicsContext"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-classes","text":"Name struct AttachmentDescription struct RenderPassConfig","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-functions","text":"Name GraphicsContext * create (const char * appName, bool enableDepthStencil =false, bool debug =true) virtual ~GraphicsContext () virtual void setSurface ( Surface * surface) =0 virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void submit ( CommandBuffer * commandBuffer) virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) =0 virtual CommandBuffer * copyCommandBuffer () =0 virtual CommandBuffer * computeCommandBuffer () =0 virtual RenderPass * getRenderPass ( RenderPassConfig config) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-attributes","text":"Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#protected-attributes","text":"Name bool debug bool enableDepthStencil","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-create","text":"static GraphicsContext * create( const char * appName, bool enableDepthStencil =false, bool debug =true )","title":"function create"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-graphicscontext","text":"inline virtual ~GraphicsContext()","title":"function ~GraphicsContext"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-setsurface","text":"virtual void setSurface( Surface * surface ) =0 Reimplemented by : ngfx::MTLGraphicsContext::setSurface , ngfx::D3DGraphicsContext::setSurface , ngfx::VKGraphicsContext::setSurface","title":"function setSurface"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-beginrenderpass","text":"inline virtual void beginRenderPass( CommandBuffer * commandBuffer, Graphics * graphics )","title":"function beginRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-beginoffscreenrenderpass","text":"inline virtual void beginOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer )","title":"function beginOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-endrenderpass","text":"inline virtual void endRenderPass( CommandBuffer * commandBuffer, Graphics * graphics )","title":"function endRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-endoffscreenrenderpass","text":"inline virtual void endOffscreenRenderPass( CommandBuffer * commandBuffer, Graphics * graphics )","title":"function endOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-submit","text":"inline virtual void submit( CommandBuffer * commandBuffer ) Reimplemented by : ngfx::MTLGraphicsContext::submit","title":"function submit"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-drawcommandbuffer","text":"virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) =0 Reimplemented by : ngfx::MTLGraphicsContext::drawCommandBuffer , ngfx::D3DGraphicsContext::drawCommandBuffer , ngfx::VKGraphicsContext::drawCommandBuffer","title":"function drawCommandBuffer"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-copycommandbuffer","text":"virtual CommandBuffer * copyCommandBuffer() =0 Reimplemented by : ngfx::MTLGraphicsContext::copyCommandBuffer , ngfx::D3DGraphicsContext::copyCommandBuffer , ngfx::VKGraphicsContext::copyCommandBuffer","title":"function copyCommandBuffer"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-computecommandbuffer","text":"virtual CommandBuffer * computeCommandBuffer() =0 Reimplemented by : ngfx::MTLGraphicsContext::computeCommandBuffer , ngfx::D3DGraphicsContext::computeCommandBuffer , ngfx::VKGraphicsContext::computeCommandBuffer","title":"function computeCommandBuffer"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#function-getrenderpass","text":"virtual RenderPass * getRenderPass( RenderPassConfig config ) =0 Reimplemented by : ngfx::MTLGraphicsContext::getRenderPass , ngfx::D3DGraphicsContext::getRenderPass , ngfx::VKGraphicsContext::getRenderPass","title":"function getRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-device","text":"Device * device;","title":"variable device"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-numdrawcommandbuffers","text":"uint32_t numDrawCommandBuffers = 0;","title":"variable numDrawCommandBuffers"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-swapchainframebuffers","text":"std::vector< Framebuffer * > swapchainFramebuffers;","title":"variable swapchainFramebuffers"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-queue","text":"Queue * queue = nullptr;","title":"variable queue"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-defaultrenderpass","text":"RenderPass * defaultRenderPass = nullptr;","title":"variable defaultRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-defaultoffscreenrenderpass","text":"RenderPass * defaultOffscreenRenderPass = nullptr;","title":"variable defaultOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-swapchain","text":"Swapchain * swapchain = nullptr;","title":"variable swapchain"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-surface","text":"Surface * surface = nullptr;","title":"variable surface"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-currentimageindex","text":"uint32_t currentImageIndex = 0;","title":"variable currentImageIndex"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-framefences","text":"std::vector< Fence * > frameFences;","title":"variable frameFences"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-computefence","text":"Fence * computeFence = nullptr;","title":"variable computeFence"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-presentcompletesemaphore","text":"Semaphore * presentCompleteSemaphore = nullptr;","title":"variable presentCompleteSemaphore"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-rendercompletesemaphore","text":"Semaphore * renderCompleteSemaphore = nullptr;","title":"variable renderCompleteSemaphore"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-pipelinecache","text":"PipelineCache * pipelineCache = nullptr;","title":"variable pipelineCache"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-surfaceformat","text":"PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED;","title":"variable surfaceFormat"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-defaultoffscreensurfaceformat","text":"PixelFormat defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED;","title":"variable defaultOffscreenSurfaceFormat"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-depthformat","text":"PixelFormat depthFormat = PIXELFORMAT_UNDEFINED;","title":"variable depthFormat"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-clearcolor","text":"glm::vec4 clearColor = glm::vec4(0.0f);","title":"variable clearColor"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-debug","text":"bool debug = false;","title":"variable debug"},{"location":"api/Classes/classngfx_1_1GraphicsContext/#variable-enabledepthstencil","text":"bool enableDepthStencil = false; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable enableDepthStencil"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/","text":"ngfx::GraphicsPipeline Inherits from ngfx::Pipeline Inherited by ngfx::D3DGraphicsPipeline , ngfx::MTLGraphicsPipeline , ngfx::VKGraphicsPipeline Public Classes Name struct Descriptor struct State Public Functions Name GraphicsPipeline * create ( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={}) virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings) Public Attributes Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings Additional inherited members Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create static GraphicsPipeline * create( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={} ) function ~GraphicsPipeline inline virtual ~GraphicsPipeline() function getBindings void getBindings( std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings ) Public Attributes Documentation variable descriptorBindings std::vector< uint32_t > descriptorBindings; variable vertexAttributeBindings std::vector< uint32_t > vertexAttributeBindings; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::GraphicsPipeline"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#ngfxgraphicspipeline","text":"Inherits from ngfx::Pipeline Inherited by ngfx::D3DGraphicsPipeline , ngfx::MTLGraphicsPipeline , ngfx::VKGraphicsPipeline","title":"ngfx::GraphicsPipeline"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-classes","text":"Name struct Descriptor struct State","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-functions","text":"Name GraphicsPipeline * create ( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={}) virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-attributes","text":"Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#additional-inherited-members","text":"Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#function-create","text":"static GraphicsPipeline * create( GraphicsContext * graphicsContext, const State & state, VertexShaderModule * vs, FragmentShaderModule * fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set< std::string > instanceAttributes ={} )","title":"function create"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#function-graphicspipeline","text":"inline virtual ~GraphicsPipeline()","title":"function ~GraphicsPipeline"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#function-getbindings","text":"void getBindings( std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings )","title":"function getBindings"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#variable-descriptorbindings","text":"std::vector< uint32_t > descriptorBindings;","title":"variable descriptorBindings"},{"location":"api/Classes/classngfx_1_1GraphicsPipeline/#variable-vertexattributebindings","text":"std::vector< uint32_t > vertexAttributeBindings; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable vertexAttributeBindings"},{"location":"api/Classes/classngfx_1_1InputListener/","text":"ngfx::InputListener Inherited by ngfx::BaseApplication , ngfx::Camera Public Functions Name virtual void onKey (KeyCode code, InputAction action) virtual void onScroll (double xoffset, double yoffset) virtual void onCursorPos (double x, double y) virtual void onMouseButton (MouseButton button, InputAction action) Public Functions Documentation function onKey inline virtual void onKey( KeyCode code, InputAction action ) Reimplemented by : ngfx::Camera::onKey function onScroll inline virtual void onScroll( double xoffset, double yoffset ) Reimplemented by : ngfx::Camera::onScroll function onCursorPos inline virtual void onCursorPos( double x, double y ) Reimplemented by : ngfx::Camera::onCursorPos function onMouseButton inline virtual void onMouseButton( MouseButton button, InputAction action ) Reimplemented by : ngfx::Camera::onMouseButton Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::InputListener"},{"location":"api/Classes/classngfx_1_1InputListener/#ngfxinputlistener","text":"Inherited by ngfx::BaseApplication , ngfx::Camera","title":"ngfx::InputListener"},{"location":"api/Classes/classngfx_1_1InputListener/#public-functions","text":"Name virtual void onKey (KeyCode code, InputAction action) virtual void onScroll (double xoffset, double yoffset) virtual void onCursorPos (double x, double y) virtual void onMouseButton (MouseButton button, InputAction action)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1InputListener/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1InputListener/#function-onkey","text":"inline virtual void onKey( KeyCode code, InputAction action ) Reimplemented by : ngfx::Camera::onKey","title":"function onKey"},{"location":"api/Classes/classngfx_1_1InputListener/#function-onscroll","text":"inline virtual void onScroll( double xoffset, double yoffset ) Reimplemented by : ngfx::Camera::onScroll","title":"function onScroll"},{"location":"api/Classes/classngfx_1_1InputListener/#function-oncursorpos","text":"inline virtual void onCursorPos( double x, double y ) Reimplemented by : ngfx::Camera::onCursorPos","title":"function onCursorPos"},{"location":"api/Classes/classngfx_1_1InputListener/#function-onmousebutton","text":"inline virtual void onMouseButton( MouseButton button, InputAction action ) Reimplemented by : ngfx::Camera::onMouseButton Updated on 3 April 2021 at 20:21:51 PDT","title":"function onMouseButton"},{"location":"api/Classes/classngfx_1_1MTLApplication/","text":"ngfx::MTLApplication Inherits from ngfx::BaseApplication , ngfx::InputListener Public Functions Name MTLApplication (const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false) virtual ~MTLApplication () virtual void init () override virtual void run () override Protected Functions Name virtual void paint () override Additional inherited members Public Functions inherited from ngfx::BaseApplication Name BaseApplication (const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false) virtual ~BaseApplication () virtual void createWindow () virtual void recordCommandBuffers () virtual void close () virtual void onInit () virtual void onRecordCommandBuffer ( CommandBuffer * commandBuffer) =0 virtual void onUpdate () virtual void onPaint () virtual void drawFrame () Public Attributes inherited from ngfx::BaseApplication Name std::unique_ptr< Graphics > graphics std::unique_ptr< Window > window std::unique_ptr< GraphicsContext > graphicsContext int w int h bool enableDepthStencil bool offscreen bool persistentCommandBuffers Protected Attributes inherited from ngfx::BaseApplication Name bool initOnce std::unique_ptr< ngfx::Texture > outputTexture std::unique_ptr< ngfx::Texture > depthTexture std::unique_ptr< Framebuffer > outputFramebuffer Public Functions inherited from ngfx::InputListener Name virtual void onKey (KeyCode code, InputAction action) virtual void onScroll (double xoffset, double yoffset) virtual void onCursorPos (double x, double y) virtual void onMouseButton (MouseButton button, InputAction action) Public Functions Documentation function MTLApplication MTLApplication( const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false ) function ~MTLApplication inline virtual ~MTLApplication() function init virtual void init() override Reimplements : ngfx::BaseApplication::init function run virtual void run() override Reimplements : ngfx::BaseApplication::run Protected Functions Documentation function paint virtual void paint() override Reimplements : ngfx::BaseApplication::paint Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLApplication"},{"location":"api/Classes/classngfx_1_1MTLApplication/#ngfxmtlapplication","text":"Inherits from ngfx::BaseApplication , ngfx::InputListener","title":"ngfx::MTLApplication"},{"location":"api/Classes/classngfx_1_1MTLApplication/#public-functions","text":"Name MTLApplication (const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false) virtual ~MTLApplication () virtual void init () override virtual void run () override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLApplication/#protected-functions","text":"Name virtual void paint () override","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1MTLApplication/#additional-inherited-members","text":"Public Functions inherited from ngfx::BaseApplication Name BaseApplication (const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false) virtual ~BaseApplication () virtual void createWindow () virtual void recordCommandBuffers () virtual void close () virtual void onInit () virtual void onRecordCommandBuffer ( CommandBuffer * commandBuffer) =0 virtual void onUpdate () virtual void onPaint () virtual void drawFrame () Public Attributes inherited from ngfx::BaseApplication Name std::unique_ptr< Graphics > graphics std::unique_ptr< Window > window std::unique_ptr< GraphicsContext > graphicsContext int w int h bool enableDepthStencil bool offscreen bool persistentCommandBuffers Protected Attributes inherited from ngfx::BaseApplication Name bool initOnce std::unique_ptr< ngfx::Texture > outputTexture std::unique_ptr< ngfx::Texture > depthTexture std::unique_ptr< Framebuffer > outputFramebuffer Public Functions inherited from ngfx::InputListener Name virtual void onKey (KeyCode code, InputAction action) virtual void onScroll (double xoffset, double yoffset) virtual void onCursorPos (double x, double y) virtual void onMouseButton (MouseButton button, InputAction action)","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLApplication/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLApplication/#function-mtlapplication","text":"MTLApplication( const std::string & appName, int w =Window::DISPLAY_WIDTH, int h =Window::DISPLAY_HEIGHT, bool enableDepthStencil =false, bool offscreen =false )","title":"function MTLApplication"},{"location":"api/Classes/classngfx_1_1MTLApplication/#function-mtlapplication_1","text":"inline virtual ~MTLApplication()","title":"function ~MTLApplication"},{"location":"api/Classes/classngfx_1_1MTLApplication/#function-init","text":"virtual void init() override Reimplements : ngfx::BaseApplication::init","title":"function init"},{"location":"api/Classes/classngfx_1_1MTLApplication/#function-run","text":"virtual void run() override Reimplements : ngfx::BaseApplication::run","title":"function run"},{"location":"api/Classes/classngfx_1_1MTLApplication/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLApplication/#function-paint","text":"virtual void paint() override Reimplements : ngfx::BaseApplication::paint Updated on 3 April 2021 at 20:21:51 PDT","title":"function paint"},{"location":"api/Classes/classngfx_1_1MTLBuffer/","text":"ngfx::MTLBuffer Inherits from ngfx::Buffer Public Functions Name void create ( MTLGraphicsContext * ctx, const void * data, uint32_t size, MTLResourceOptions resourceOptions) virtual ~MTLBuffer () virtual void * map () override virtual void unmap () override virtual void upload (const void * data, uint32_t size, uint32_t offset =0) override virtual void download (void * data, uint32_t size, uint32_t offset =0) override Public Attributes Name id< MTLBuffer > v Additional inherited members Public Functions inherited from ngfx::Buffer Name virtual ~Buffer () Public Functions Documentation function create void create( MTLGraphicsContext * ctx, const void * data, uint32_t size, MTLResourceOptions resourceOptions ) function ~MTLBuffer inline virtual ~MTLBuffer() function map virtual void * map() override Reimplements : ngfx::Buffer::map Map the buffer contents for CPU read/write access function unmap virtual void unmap() override Reimplements : ngfx::Buffer::unmap Unmap the buffer function upload virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::upload Upload the CPU data to the GPU buffer function download virtual void download( void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::download Download the GPU data to CPU-accessible memory Public Attributes Documentation variable v id< MTLBuffer > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLBuffer"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#ngfxmtlbuffer","text":"Inherits from ngfx::Buffer","title":"ngfx::MTLBuffer"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#public-functions","text":"Name void create ( MTLGraphicsContext * ctx, const void * data, uint32_t size, MTLResourceOptions resourceOptions) virtual ~MTLBuffer () virtual void * map () override virtual void unmap () override virtual void upload (const void * data, uint32_t size, uint32_t offset =0) override virtual void download (void * data, uint32_t size, uint32_t offset =0) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#public-attributes","text":"Name id< MTLBuffer > v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#additional-inherited-members","text":"Public Functions inherited from ngfx::Buffer Name virtual ~Buffer ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#function-create","text":"void create( MTLGraphicsContext * ctx, const void * data, uint32_t size, MTLResourceOptions resourceOptions )","title":"function create"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#function-mtlbuffer","text":"inline virtual ~MTLBuffer()","title":"function ~MTLBuffer"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#function-map","text":"virtual void * map() override Reimplements : ngfx::Buffer::map Map the buffer contents for CPU read/write access","title":"function map"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#function-unmap","text":"virtual void unmap() override Reimplements : ngfx::Buffer::unmap Unmap the buffer","title":"function unmap"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#function-upload","text":"virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::upload Upload the CPU data to the GPU buffer","title":"function upload"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::download Download the GPU data to CPU-accessible memory","title":"function download"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLBuffer/#variable-v","text":"id< MTLBuffer > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/","text":"ngfx::MTLCommandBuffer Inherits from ngfx::CommandBuffer Public Functions Name virtual ~MTLCommandBuffer () virtual void begin () override virtual void end () override void commit () void waitUntilCompleted () Public Attributes Name id< MTLCommandBuffer > v Additional inherited members Public Functions inherited from ngfx::CommandBuffer Name CommandBuffer * create ( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY) virtual ~CommandBuffer () Public Functions Documentation function ~MTLCommandBuffer inline virtual ~MTLCommandBuffer() function begin inline virtual void begin() override Reimplements : ngfx::CommandBuffer::begin Begin recording function end inline virtual void end() override Reimplements : ngfx::CommandBuffer::end End recording function commit void commit() function waitUntilCompleted void waitUntilCompleted() Public Attributes Documentation variable v id< MTLCommandBuffer > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLCommandBuffer"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#ngfxmtlcommandbuffer","text":"Inherits from ngfx::CommandBuffer","title":"ngfx::MTLCommandBuffer"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#public-functions","text":"Name virtual ~MTLCommandBuffer () virtual void begin () override virtual void end () override void commit () void waitUntilCompleted ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#public-attributes","text":"Name id< MTLCommandBuffer > v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#additional-inherited-members","text":"Public Functions inherited from ngfx::CommandBuffer Name CommandBuffer * create ( GraphicsContext * ctx, CommandBufferLevel level =COMMAND_BUFFER_LEVEL_PRIMARY) virtual ~CommandBuffer ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#function-mtlcommandbuffer","text":"inline virtual ~MTLCommandBuffer()","title":"function ~MTLCommandBuffer"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#function-begin","text":"inline virtual void begin() override Reimplements : ngfx::CommandBuffer::begin Begin recording","title":"function begin"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#function-end","text":"inline virtual void end() override Reimplements : ngfx::CommandBuffer::end End recording","title":"function end"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#function-commit","text":"void commit()","title":"function commit"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#function-waituntilcompleted","text":"void waitUntilCompleted()","title":"function waitUntilCompleted"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLCommandBuffer/#variable-v","text":"id< MTLCommandBuffer > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1MTLCommandEncoder/","text":"ngfx::MTLCommandEncoder Inherited by ngfx::MTLComputeCommandEncoder , ngfx::MTLRenderCommandEncoder Public Functions Name virtual ~MTLCommandEncoder () Public Functions Documentation function ~MTLCommandEncoder inline virtual ~MTLCommandEncoder() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLCommandEncoder/#ngfxmtlcommandencoder","text":"Inherited by ngfx::MTLComputeCommandEncoder , ngfx::MTLRenderCommandEncoder","title":"ngfx::MTLCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLCommandEncoder/#public-functions","text":"Name virtual ~MTLCommandEncoder ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLCommandEncoder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLCommandEncoder/#function-mtlcommandencoder","text":"inline virtual ~MTLCommandEncoder() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~MTLCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLComputeCommandEncoder/","text":"ngfx::MTLComputeCommandEncoder Inherits from ngfx::MTLCommandEncoder Public Functions Name virtual ~MTLComputeCommandEncoder () Public Attributes Name id< MTLComputeCommandEncoder > v Additional inherited members Public Functions inherited from ngfx::MTLCommandEncoder Name virtual ~MTLCommandEncoder () Public Functions Documentation function ~MTLComputeCommandEncoder inline virtual ~MTLComputeCommandEncoder() Public Attributes Documentation variable v id< MTLComputeCommandEncoder > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLComputeCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLComputeCommandEncoder/#ngfxmtlcomputecommandencoder","text":"Inherits from ngfx::MTLCommandEncoder","title":"ngfx::MTLComputeCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLComputeCommandEncoder/#public-functions","text":"Name virtual ~MTLComputeCommandEncoder ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLComputeCommandEncoder/#public-attributes","text":"Name id< MTLComputeCommandEncoder > v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLComputeCommandEncoder/#additional-inherited-members","text":"Public Functions inherited from ngfx::MTLCommandEncoder Name virtual ~MTLCommandEncoder ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLComputeCommandEncoder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLComputeCommandEncoder/#function-mtlcomputecommandencoder","text":"inline virtual ~MTLComputeCommandEncoder()","title":"function ~MTLComputeCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLComputeCommandEncoder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLComputeCommandEncoder/#variable-v","text":"id< MTLComputeCommandEncoder > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1MTLComputePipeline/","text":"ngfx::MTLComputePipeline Inherits from ngfx::ComputePipeline , ngfx::Pipeline Public Functions Name void create ( MTLGraphicsContext * ctx, id< MTLFunction > computeFunction) virtual ~MTLComputePipeline () Public Attributes Name id< MTLComputePipelineState > mtlPipelineState Additional inherited members Public Functions inherited from ngfx::ComputePipeline Name virtual ~ComputePipeline () Public Attributes inherited from ngfx::ComputePipeline Name std::vector< uint32_t > descriptorBindings Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create void create( MTLGraphicsContext * ctx, id< MTLFunction > computeFunction ) function ~MTLComputePipeline inline virtual ~MTLComputePipeline() Public Attributes Documentation variable mtlPipelineState id< MTLComputePipelineState > mtlPipelineState; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLComputePipeline"},{"location":"api/Classes/classngfx_1_1MTLComputePipeline/#ngfxmtlcomputepipeline","text":"Inherits from ngfx::ComputePipeline , ngfx::Pipeline","title":"ngfx::MTLComputePipeline"},{"location":"api/Classes/classngfx_1_1MTLComputePipeline/#public-functions","text":"Name void create ( MTLGraphicsContext * ctx, id< MTLFunction > computeFunction) virtual ~MTLComputePipeline ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLComputePipeline/#public-attributes","text":"Name id< MTLComputePipelineState > mtlPipelineState","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLComputePipeline/#additional-inherited-members","text":"Public Functions inherited from ngfx::ComputePipeline Name virtual ~ComputePipeline () Public Attributes inherited from ngfx::ComputePipeline Name std::vector< uint32_t > descriptorBindings Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLComputePipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLComputePipeline/#function-create","text":"void create( MTLGraphicsContext * ctx, id< MTLFunction > computeFunction )","title":"function create"},{"location":"api/Classes/classngfx_1_1MTLComputePipeline/#function-mtlcomputepipeline","text":"inline virtual ~MTLComputePipeline()","title":"function ~MTLComputePipeline"},{"location":"api/Classes/classngfx_1_1MTLComputePipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLComputePipeline/#variable-mtlpipelinestate","text":"id< MTLComputePipelineState > mtlPipelineState; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable mtlPipelineState"},{"location":"api/Classes/classngfx_1_1MTLComputeShaderModule/","text":"ngfx::MTLComputeShaderModule Inherits from ngfx::ComputeShaderModule , ngfx::MTLShaderModule , ngfx::ShaderModule Public Functions Name virtual ~MTLComputeShaderModule () Additional inherited members Public Functions inherited from ngfx::ComputeShaderModule Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::MTLShaderModule Name virtual void initFromFile (id< MTLDevice > device, const std::string & filename) virtual ~MTLShaderModule () Protected Functions inherited from ngfx::MTLShaderModule Name virtual void initFromByteCode (id< MTLDevice > device, void * data, uint32_t size) Public Attributes inherited from ngfx::MTLShaderModule Name id< MTLLibrary > mtlLibrary id< MTLFunction > mtlFunction Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function ~MTLComputeShaderModule inline virtual ~MTLComputeShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLComputeShaderModule"},{"location":"api/Classes/classngfx_1_1MTLComputeShaderModule/#ngfxmtlcomputeshadermodule","text":"Inherits from ngfx::ComputeShaderModule , ngfx::MTLShaderModule , ngfx::ShaderModule","title":"ngfx::MTLComputeShaderModule"},{"location":"api/Classes/classngfx_1_1MTLComputeShaderModule/#public-functions","text":"Name virtual ~MTLComputeShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLComputeShaderModule/#additional-inherited-members","text":"Public Functions inherited from ngfx::ComputeShaderModule Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::MTLShaderModule Name virtual void initFromFile (id< MTLDevice > device, const std::string & filename) virtual ~MTLShaderModule () Protected Functions inherited from ngfx::MTLShaderModule Name virtual void initFromByteCode (id< MTLDevice > device, void * data, uint32_t size) Public Attributes inherited from ngfx::MTLShaderModule Name id< MTLLibrary > mtlLibrary id< MTLFunction > mtlFunction Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLComputeShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLComputeShaderModule/#function-mtlcomputeshadermodule","text":"inline virtual ~MTLComputeShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~MTLComputeShaderModule"},{"location":"api/Classes/classngfx_1_1MTLDepthStencilTexture/","text":"ngfx::MTLDepthStencilTexture Public Functions Name void create ( MTLGraphicsContext * ctx, uint32_t w, uint32_t h, ::MTLPixelFormat fmt =::MTLPixelFormatDepth24Unorm_Stencil8) Public Attributes Name id< MTLTexture > v ::MTLPixelFormat format Public Functions Documentation function create void create( MTLGraphicsContext * ctx, uint32_t w, uint32_t h, ::MTLPixelFormat fmt =::MTLPixelFormatDepth24Unorm_Stencil8 ) Public Attributes Documentation variable v id< MTLTexture > v; variable format ::MTLPixelFormat format; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLDepthStencilTexture"},{"location":"api/Classes/classngfx_1_1MTLDepthStencilTexture/#ngfxmtldepthstenciltexture","text":"","title":"ngfx::MTLDepthStencilTexture"},{"location":"api/Classes/classngfx_1_1MTLDepthStencilTexture/#public-functions","text":"Name void create ( MTLGraphicsContext * ctx, uint32_t w, uint32_t h, ::MTLPixelFormat fmt =::MTLPixelFormatDepth24Unorm_Stencil8)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLDepthStencilTexture/#public-attributes","text":"Name id< MTLTexture > v ::MTLPixelFormat format","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLDepthStencilTexture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLDepthStencilTexture/#function-create","text":"void create( MTLGraphicsContext * ctx, uint32_t w, uint32_t h, ::MTLPixelFormat fmt =::MTLPixelFormatDepth24Unorm_Stencil8 )","title":"function create"},{"location":"api/Classes/classngfx_1_1MTLDepthStencilTexture/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLDepthStencilTexture/#variable-v","text":"id< MTLTexture > v;","title":"variable v"},{"location":"api/Classes/classngfx_1_1MTLDepthStencilTexture/#variable-format","text":"::MTLPixelFormat format; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable format"},{"location":"api/Classes/classngfx_1_1MTLDevice/","text":"ngfx::MTLDevice Inherits from ngfx::Device Public Functions Name void create () Public Attributes Name id< MTLDevice > v Public Functions Documentation function create void create() Public Attributes Documentation variable v id< MTLDevice > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLDevice"},{"location":"api/Classes/classngfx_1_1MTLDevice/#ngfxmtldevice","text":"Inherits from ngfx::Device","title":"ngfx::MTLDevice"},{"location":"api/Classes/classngfx_1_1MTLDevice/#public-functions","text":"Name void create ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLDevice/#public-attributes","text":"Name id< MTLDevice > v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLDevice/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLDevice/#function-create","text":"void create()","title":"function create"},{"location":"api/Classes/classngfx_1_1MTLDevice/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLDevice/#variable-v","text":"id< MTLDevice > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1MTLFragmentShaderModule/","text":"ngfx::MTLFragmentShaderModule Inherits from ngfx::FragmentShaderModule , ngfx::MTLShaderModule , ngfx::ShaderModule Public Functions Name virtual ~MTLFragmentShaderModule () Additional inherited members Public Functions inherited from ngfx::FragmentShaderModule Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::MTLShaderModule Name virtual void initFromFile (id< MTLDevice > device, const std::string & filename) virtual ~MTLShaderModule () Protected Functions inherited from ngfx::MTLShaderModule Name virtual void initFromByteCode (id< MTLDevice > device, void * data, uint32_t size) Public Attributes inherited from ngfx::MTLShaderModule Name id< MTLLibrary > mtlLibrary id< MTLFunction > mtlFunction Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function ~MTLFragmentShaderModule inline virtual ~MTLFragmentShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLFragmentShaderModule"},{"location":"api/Classes/classngfx_1_1MTLFragmentShaderModule/#ngfxmtlfragmentshadermodule","text":"Inherits from ngfx::FragmentShaderModule , ngfx::MTLShaderModule , ngfx::ShaderModule","title":"ngfx::MTLFragmentShaderModule"},{"location":"api/Classes/classngfx_1_1MTLFragmentShaderModule/#public-functions","text":"Name virtual ~MTLFragmentShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLFragmentShaderModule/#additional-inherited-members","text":"Public Functions inherited from ngfx::FragmentShaderModule Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::MTLShaderModule Name virtual void initFromFile (id< MTLDevice > device, const std::string & filename) virtual ~MTLShaderModule () Protected Functions inherited from ngfx::MTLShaderModule Name virtual void initFromByteCode (id< MTLDevice > device, void * data, uint32_t size) Public Attributes inherited from ngfx::MTLShaderModule Name id< MTLLibrary > mtlLibrary id< MTLFunction > mtlFunction Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLFragmentShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLFragmentShaderModule/#function-mtlfragmentshadermodule","text":"inline virtual ~MTLFragmentShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~MTLFragmentShaderModule"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/","text":"ngfx::MTLFramebuffer Inherits from ngfx::Framebuffer Public Types Name typedef std::vector< MTLRenderPassColorAttachmentDescriptor * > ColorAttachments Public Functions Name void create (uint32_t w, uint32_t h, const ColorAttachments & colorAttachments, MTLRenderPassDepthAttachmentDescriptor * depthAttachment =nullptr, MTLRenderPassStencilAttachmentDescriptor * stencilAttachment =nullptr) virtual ~MTLFramebuffer () Public Attributes Name ColorAttachments colorAttachments MTLRenderPassDepthAttachmentDescriptor * depthAttachment MTLRenderPassStencilAttachmentDescriptor * stencilAttachment Additional inherited members Public Classes inherited from ngfx::Framebuffer Name struct Attachment Public Functions inherited from ngfx::Framebuffer Name virtual ~Framebuffer () Public Attributes inherited from ngfx::Framebuffer Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments Public Types Documentation typedef ColorAttachments typedef std::vector<MTLRenderPassColorAttachmentDescriptor *> ngfx::MTLFramebuffer::ColorAttachments; Public Functions Documentation function create void create( uint32_t w, uint32_t h, const ColorAttachments & colorAttachments, MTLRenderPassDepthAttachmentDescriptor * depthAttachment =nullptr, MTLRenderPassStencilAttachmentDescriptor * stencilAttachment =nullptr ) function ~MTLFramebuffer virtual ~MTLFramebuffer() Public Attributes Documentation variable colorAttachments ColorAttachments colorAttachments; variable depthAttachment MTLRenderPassDepthAttachmentDescriptor * depthAttachment = nullptr; variable stencilAttachment MTLRenderPassStencilAttachmentDescriptor * stencilAttachment = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLFramebuffer"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#ngfxmtlframebuffer","text":"Inherits from ngfx::Framebuffer","title":"ngfx::MTLFramebuffer"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#public-types","text":"Name typedef std::vector< MTLRenderPassColorAttachmentDescriptor * > ColorAttachments","title":"Public Types"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#public-functions","text":"Name void create (uint32_t w, uint32_t h, const ColorAttachments & colorAttachments, MTLRenderPassDepthAttachmentDescriptor * depthAttachment =nullptr, MTLRenderPassStencilAttachmentDescriptor * stencilAttachment =nullptr) virtual ~MTLFramebuffer ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#public-attributes","text":"Name ColorAttachments colorAttachments MTLRenderPassDepthAttachmentDescriptor * depthAttachment MTLRenderPassStencilAttachmentDescriptor * stencilAttachment","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#additional-inherited-members","text":"Public Classes inherited from ngfx::Framebuffer Name struct Attachment Public Functions inherited from ngfx::Framebuffer Name virtual ~Framebuffer () Public Attributes inherited from ngfx::Framebuffer Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#typedef-colorattachments","text":"typedef std::vector<MTLRenderPassColorAttachmentDescriptor *> ngfx::MTLFramebuffer::ColorAttachments;","title":"typedef ColorAttachments"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#function-create","text":"void create( uint32_t w, uint32_t h, const ColorAttachments & colorAttachments, MTLRenderPassDepthAttachmentDescriptor * depthAttachment =nullptr, MTLRenderPassStencilAttachmentDescriptor * stencilAttachment =nullptr )","title":"function create"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#function-mtlframebuffer","text":"virtual ~MTLFramebuffer()","title":"function ~MTLFramebuffer"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#variable-colorattachments","text":"ColorAttachments colorAttachments;","title":"variable colorAttachments"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#variable-depthattachment","text":"MTLRenderPassDepthAttachmentDescriptor * depthAttachment = nullptr;","title":"variable depthAttachment"},{"location":"api/Classes/classngfx_1_1MTLFramebuffer/#variable-stencilattachment","text":"MTLRenderPassStencilAttachmentDescriptor * stencilAttachment = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable stencilAttachment"},{"location":"api/Classes/classngfx_1_1MTLGraphics/","text":"ngfx::MTLGraphics Inherits from ngfx::Graphics Public Functions Name void create () virtual ~MTLGraphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) override virtual void endComputePass ( CommandBuffer * commandBuffer) override virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) override virtual void endRenderPass ( CommandBuffer * commandBuffer) override virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) override virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32) override virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) override virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) override virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) override virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) override virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) override virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void waitIdle ( CommandBuffer * cmdBuffer) override Public Attributes Name MTLComputeCommandEncoder currentComputeCommandEncoder MTLRenderCommandEncoder currentRenderCommandEncoder MTLCommandEncoder * currentCommandEncoder ::MTLPrimitiveType currentPrimitiveType MTLBuffer * currentIndexBuffer IndexFormat currentIndexFormat Additional inherited members Public Functions inherited from ngfx::Graphics Name virtual ~Graphics () Public Attributes inherited from ngfx::Graphics Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer Protected Attributes inherited from ngfx::Graphics Name GraphicsContext * ctx Public Functions Documentation function create void create() function ~MTLGraphics inline virtual ~MTLGraphics() function beginComputePass virtual void beginComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::beginComputePass function endComputePass virtual void endComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endComputePass function beginRenderPass virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) override Reimplements : ngfx::Graphics::beginRenderPass function endRenderPass virtual void endRenderPass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endRenderPass function bindVertexBuffer virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) override Reimplements : ngfx::Graphics::bindVertexBuffer function bindIndexBuffer virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32 ) override Reimplements : ngfx::Graphics::bindIndexBuffer function bindUniformBuffer virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindUniformBuffer function bindStorageBuffer virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindStorageBuffer function bindComputePipeline virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) override Reimplements : ngfx::Graphics::bindComputePipeline function bindGraphicsPipeline virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) override Reimplements : ngfx::Graphics::bindGraphicsPipeline function bindTexture virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) override Reimplements : ngfx::Graphics::bindTexture function dispatch virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) override Reimplements : ngfx::Graphics::dispatch function draw virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::draw function drawIndexed virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::drawIndexed function setViewport virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setViewport function setScissor virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setScissor function waitIdle virtual void waitIdle( CommandBuffer * cmdBuffer ) override Reimplements : ngfx::Graphics::waitIdle Public Attributes Documentation variable currentComputeCommandEncoder MTLComputeCommandEncoder currentComputeCommandEncoder; variable currentRenderCommandEncoder MTLRenderCommandEncoder currentRenderCommandEncoder; variable currentCommandEncoder MTLCommandEncoder * currentCommandEncoder = nullptr; variable currentPrimitiveType ::MTLPrimitiveType currentPrimitiveType; variable currentIndexBuffer MTLBuffer * currentIndexBuffer = nullptr; variable currentIndexFormat IndexFormat currentIndexFormat; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLGraphics"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#ngfxmtlgraphics","text":"Inherits from ngfx::Graphics","title":"ngfx::MTLGraphics"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#public-functions","text":"Name void create () virtual ~MTLGraphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) override virtual void endComputePass ( CommandBuffer * commandBuffer) override virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) override virtual void endRenderPass ( CommandBuffer * commandBuffer) override virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) override virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32) override virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) override virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) override virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) override virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) override virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) override virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void waitIdle ( CommandBuffer * cmdBuffer) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#public-attributes","text":"Name MTLComputeCommandEncoder currentComputeCommandEncoder MTLRenderCommandEncoder currentRenderCommandEncoder MTLCommandEncoder * currentCommandEncoder ::MTLPrimitiveType currentPrimitiveType MTLBuffer * currentIndexBuffer IndexFormat currentIndexFormat","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#additional-inherited-members","text":"Public Functions inherited from ngfx::Graphics Name virtual ~Graphics () Public Attributes inherited from ngfx::Graphics Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer Protected Attributes inherited from ngfx::Graphics Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-create","text":"void create()","title":"function create"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-mtlgraphics","text":"inline virtual ~MTLGraphics()","title":"function ~MTLGraphics"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-begincomputepass","text":"virtual void beginComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::beginComputePass","title":"function beginComputePass"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-endcomputepass","text":"virtual void endComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endComputePass","title":"function endComputePass"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-beginrenderpass","text":"virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) override Reimplements : ngfx::Graphics::beginRenderPass","title":"function beginRenderPass"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-endrenderpass","text":"virtual void endRenderPass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endRenderPass","title":"function endRenderPass"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-bindvertexbuffer","text":"virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) override Reimplements : ngfx::Graphics::bindVertexBuffer","title":"function bindVertexBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-bindindexbuffer","text":"virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat =INDEXFORMAT_UINT32 ) override Reimplements : ngfx::Graphics::bindIndexBuffer","title":"function bindIndexBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-binduniformbuffer","text":"virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindUniformBuffer","title":"function bindUniformBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-bindstoragebuffer","text":"virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindStorageBuffer","title":"function bindStorageBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-bindcomputepipeline","text":"virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) override Reimplements : ngfx::Graphics::bindComputePipeline","title":"function bindComputePipeline"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-bindgraphicspipeline","text":"virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) override Reimplements : ngfx::Graphics::bindGraphicsPipeline","title":"function bindGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-bindtexture","text":"virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) override Reimplements : ngfx::Graphics::bindTexture","title":"function bindTexture"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-dispatch","text":"virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) override Reimplements : ngfx::Graphics::dispatch","title":"function dispatch"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-draw","text":"virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::draw","title":"function draw"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-drawindexed","text":"virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::drawIndexed","title":"function drawIndexed"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-setviewport","text":"virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setViewport","title":"function setViewport"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-setscissor","text":"virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setScissor","title":"function setScissor"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#function-waitidle","text":"virtual void waitIdle( CommandBuffer * cmdBuffer ) override Reimplements : ngfx::Graphics::waitIdle","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#variable-currentcomputecommandencoder","text":"MTLComputeCommandEncoder currentComputeCommandEncoder;","title":"variable currentComputeCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#variable-currentrendercommandencoder","text":"MTLRenderCommandEncoder currentRenderCommandEncoder;","title":"variable currentRenderCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#variable-currentcommandencoder","text":"MTLCommandEncoder * currentCommandEncoder = nullptr;","title":"variable currentCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#variable-currentprimitivetype","text":"::MTLPrimitiveType currentPrimitiveType;","title":"variable currentPrimitiveType"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#variable-currentindexbuffer","text":"MTLBuffer * currentIndexBuffer = nullptr;","title":"variable currentIndexBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphics/#variable-currentindexformat","text":"IndexFormat currentIndexFormat; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable currentIndexFormat"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/","text":"ngfx::MTLGraphicsContext Inherits from ngfx::GraphicsContext Public Classes Name struct MTLRenderPassData Public Functions Name void create (const char * appName, bool enableDepthStencil, bool debug) virtual ~MTLGraphicsContext () virtual void setSurface ( Surface * surface) override virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) override virtual CommandBuffer * copyCommandBuffer () override virtual CommandBuffer * computeCommandBuffer () override virtual void submit ( CommandBuffer * commandBuffer) override virtual RenderPass * getRenderPass ( RenderPassConfig config) override Public Attributes Name std::vector< std::unique_ptr< MTLRenderPassData > > mtlRenderPassCache MTLCommandBuffer mtlDrawCommandBuffer MTLCommandBuffer mtlCopyCommandBuffer MTLCommandBuffer mtlComputeCommandBuffer MTLDevice mtlDevice id< MTLCommandQueue > mtlCommandQueue MTLPipelineCache mtlPipelineCache ::MTLPixelFormat mtlSurfaceFormat uint32_t numSwapchainImages std::vector< MTLFramebuffer > mtlSwapchainFramebuffers MTLRenderPass * mtlDefaultRenderPass MTLRenderPass * mtlDefaultOffscreenRenderPass bool offscreen uint32_t numSamples Additional inherited members Public Classes inherited from ngfx::GraphicsContext Name struct AttachmentDescription struct RenderPassConfig Public Functions inherited from ngfx::GraphicsContext Name virtual ~GraphicsContext () virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) Public Attributes inherited from ngfx::GraphicsContext Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor Protected Attributes inherited from ngfx::GraphicsContext Name bool debug bool enableDepthStencil Public Functions Documentation function create void create( const char * appName, bool enableDepthStencil, bool debug ) function ~MTLGraphicsContext virtual ~MTLGraphicsContext() function setSurface virtual void setSurface( Surface * surface ) override Reimplements : ngfx::GraphicsContext::setSurface function drawCommandBuffer virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) override Reimplements : ngfx::GraphicsContext::drawCommandBuffer function copyCommandBuffer virtual CommandBuffer * copyCommandBuffer() override Reimplements : ngfx::GraphicsContext::copyCommandBuffer function computeCommandBuffer virtual CommandBuffer * computeCommandBuffer() override Reimplements : ngfx::GraphicsContext::computeCommandBuffer function submit virtual void submit( CommandBuffer * commandBuffer ) override Reimplements : ngfx::GraphicsContext::submit function getRenderPass virtual RenderPass * getRenderPass( RenderPassConfig config ) override Reimplements : ngfx::GraphicsContext::getRenderPass Public Attributes Documentation variable mtlRenderPassCache std::vector< std::unique_ptr< MTLRenderPassData > > mtlRenderPassCache; variable mtlDrawCommandBuffer MTLCommandBuffer mtlDrawCommandBuffer; variable mtlCopyCommandBuffer MTLCommandBuffer mtlCopyCommandBuffer; variable mtlComputeCommandBuffer MTLCommandBuffer mtlComputeCommandBuffer; variable mtlDevice MTLDevice mtlDevice; variable mtlCommandQueue id< MTLCommandQueue > mtlCommandQueue; variable mtlPipelineCache MTLPipelineCache mtlPipelineCache; variable mtlSurfaceFormat ::MTLPixelFormat mtlSurfaceFormat; variable numSwapchainImages uint32_t numSwapchainImages; variable mtlSwapchainFramebuffers std::vector< MTLFramebuffer > mtlSwapchainFramebuffers; variable mtlDefaultRenderPass MTLRenderPass * mtlDefaultRenderPass = nullptr; variable mtlDefaultOffscreenRenderPass MTLRenderPass * mtlDefaultOffscreenRenderPass = nullptr; variable offscreen bool offscreen = true; variable numSamples uint32_t numSamples = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLGraphicsContext"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#ngfxmtlgraphicscontext","text":"Inherits from ngfx::GraphicsContext","title":"ngfx::MTLGraphicsContext"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#public-classes","text":"Name struct MTLRenderPassData","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#public-functions","text":"Name void create (const char * appName, bool enableDepthStencil, bool debug) virtual ~MTLGraphicsContext () virtual void setSurface ( Surface * surface) override virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) override virtual CommandBuffer * copyCommandBuffer () override virtual CommandBuffer * computeCommandBuffer () override virtual void submit ( CommandBuffer * commandBuffer) override virtual RenderPass * getRenderPass ( RenderPassConfig config) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#public-attributes","text":"Name std::vector< std::unique_ptr< MTLRenderPassData > > mtlRenderPassCache MTLCommandBuffer mtlDrawCommandBuffer MTLCommandBuffer mtlCopyCommandBuffer MTLCommandBuffer mtlComputeCommandBuffer MTLDevice mtlDevice id< MTLCommandQueue > mtlCommandQueue MTLPipelineCache mtlPipelineCache ::MTLPixelFormat mtlSurfaceFormat uint32_t numSwapchainImages std::vector< MTLFramebuffer > mtlSwapchainFramebuffers MTLRenderPass * mtlDefaultRenderPass MTLRenderPass * mtlDefaultOffscreenRenderPass bool offscreen uint32_t numSamples","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#additional-inherited-members","text":"Public Classes inherited from ngfx::GraphicsContext Name struct AttachmentDescription struct RenderPassConfig Public Functions inherited from ngfx::GraphicsContext Name virtual ~GraphicsContext () virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) Public Attributes inherited from ngfx::GraphicsContext Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor Protected Attributes inherited from ngfx::GraphicsContext Name bool debug bool enableDepthStencil","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#function-create","text":"void create( const char * appName, bool enableDepthStencil, bool debug )","title":"function create"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#function-mtlgraphicscontext","text":"virtual ~MTLGraphicsContext()","title":"function ~MTLGraphicsContext"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#function-setsurface","text":"virtual void setSurface( Surface * surface ) override Reimplements : ngfx::GraphicsContext::setSurface","title":"function setSurface"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#function-drawcommandbuffer","text":"virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) override Reimplements : ngfx::GraphicsContext::drawCommandBuffer","title":"function drawCommandBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#function-copycommandbuffer","text":"virtual CommandBuffer * copyCommandBuffer() override Reimplements : ngfx::GraphicsContext::copyCommandBuffer","title":"function copyCommandBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#function-computecommandbuffer","text":"virtual CommandBuffer * computeCommandBuffer() override Reimplements : ngfx::GraphicsContext::computeCommandBuffer","title":"function computeCommandBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#function-submit","text":"virtual void submit( CommandBuffer * commandBuffer ) override Reimplements : ngfx::GraphicsContext::submit","title":"function submit"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#function-getrenderpass","text":"virtual RenderPass * getRenderPass( RenderPassConfig config ) override Reimplements : ngfx::GraphicsContext::getRenderPass","title":"function getRenderPass"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtlrenderpasscache","text":"std::vector< std::unique_ptr< MTLRenderPassData > > mtlRenderPassCache;","title":"variable mtlRenderPassCache"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtldrawcommandbuffer","text":"MTLCommandBuffer mtlDrawCommandBuffer;","title":"variable mtlDrawCommandBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtlcopycommandbuffer","text":"MTLCommandBuffer mtlCopyCommandBuffer;","title":"variable mtlCopyCommandBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtlcomputecommandbuffer","text":"MTLCommandBuffer mtlComputeCommandBuffer;","title":"variable mtlComputeCommandBuffer"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtldevice","text":"MTLDevice mtlDevice;","title":"variable mtlDevice"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtlcommandqueue","text":"id< MTLCommandQueue > mtlCommandQueue;","title":"variable mtlCommandQueue"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtlpipelinecache","text":"MTLPipelineCache mtlPipelineCache;","title":"variable mtlPipelineCache"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtlsurfaceformat","text":"::MTLPixelFormat mtlSurfaceFormat;","title":"variable mtlSurfaceFormat"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-numswapchainimages","text":"uint32_t numSwapchainImages;","title":"variable numSwapchainImages"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtlswapchainframebuffers","text":"std::vector< MTLFramebuffer > mtlSwapchainFramebuffers;","title":"variable mtlSwapchainFramebuffers"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtldefaultrenderpass","text":"MTLRenderPass * mtlDefaultRenderPass = nullptr;","title":"variable mtlDefaultRenderPass"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-mtldefaultoffscreenrenderpass","text":"MTLRenderPass * mtlDefaultOffscreenRenderPass = nullptr;","title":"variable mtlDefaultOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-offscreen","text":"bool offscreen = true;","title":"variable offscreen"},{"location":"api/Classes/classngfx_1_1MTLGraphicsContext/#variable-numsamples","text":"uint32_t numSamples = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable numSamples"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/","text":"ngfx::MTLGraphicsPipeline Inherits from ngfx::GraphicsPipeline , ngfx::Pipeline Public Classes Name struct Shaders Public Functions Name void create ( MTLGraphicsContext * ctx, const State & state, MTLVertexDescriptor * vertexDescriptor, const Shaders & shaders, ::MTLPixelFormat colorFormat, ::MTLPixelFormat depthFormat) virtual ~MTLGraphicsPipeline () Public Attributes Name id< MTLRenderPipelineState > mtlPipelineState id< MTLDepthStencilState > mtlDepthStencilState MTLRenderPipelineReflection * reflection ::MTLPrimitiveType mtlPrimitiveType ::MTLCullMode mtlCullMode ::MTLWinding mtlFrontFaceWinding Additional inherited members Public Classes inherited from ngfx::GraphicsPipeline Name struct Descriptor struct State Public Functions inherited from ngfx::GraphicsPipeline Name virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings) Public Attributes inherited from ngfx::GraphicsPipeline Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create void create( MTLGraphicsContext * ctx, const State & state, MTLVertexDescriptor * vertexDescriptor, const Shaders & shaders, ::MTLPixelFormat colorFormat, ::MTLPixelFormat depthFormat ) function ~MTLGraphicsPipeline inline virtual ~MTLGraphicsPipeline() Public Attributes Documentation variable mtlPipelineState id< MTLRenderPipelineState > mtlPipelineState; variable mtlDepthStencilState id< MTLDepthStencilState > mtlDepthStencilState; variable reflection MTLRenderPipelineReflection * reflection; variable mtlPrimitiveType ::MTLPrimitiveType mtlPrimitiveType; variable mtlCullMode ::MTLCullMode mtlCullMode; variable mtlFrontFaceWinding ::MTLWinding mtlFrontFaceWinding; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#ngfxmtlgraphicspipeline","text":"Inherits from ngfx::GraphicsPipeline , ngfx::Pipeline","title":"ngfx::MTLGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#public-classes","text":"Name struct Shaders","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#public-functions","text":"Name void create ( MTLGraphicsContext * ctx, const State & state, MTLVertexDescriptor * vertexDescriptor, const Shaders & shaders, ::MTLPixelFormat colorFormat, ::MTLPixelFormat depthFormat) virtual ~MTLGraphicsPipeline ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#public-attributes","text":"Name id< MTLRenderPipelineState > mtlPipelineState id< MTLDepthStencilState > mtlDepthStencilState MTLRenderPipelineReflection * reflection ::MTLPrimitiveType mtlPrimitiveType ::MTLCullMode mtlCullMode ::MTLWinding mtlFrontFaceWinding","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#additional-inherited-members","text":"Public Classes inherited from ngfx::GraphicsPipeline Name struct Descriptor struct State Public Functions inherited from ngfx::GraphicsPipeline Name virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings) Public Attributes inherited from ngfx::GraphicsPipeline Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#function-create","text":"void create( MTLGraphicsContext * ctx, const State & state, MTLVertexDescriptor * vertexDescriptor, const Shaders & shaders, ::MTLPixelFormat colorFormat, ::MTLPixelFormat depthFormat )","title":"function create"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#function-mtlgraphicspipeline","text":"inline virtual ~MTLGraphicsPipeline()","title":"function ~MTLGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#variable-mtlpipelinestate","text":"id< MTLRenderPipelineState > mtlPipelineState;","title":"variable mtlPipelineState"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#variable-mtldepthstencilstate","text":"id< MTLDepthStencilState > mtlDepthStencilState;","title":"variable mtlDepthStencilState"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#variable-reflection","text":"MTLRenderPipelineReflection * reflection;","title":"variable reflection"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#variable-mtlprimitivetype","text":"::MTLPrimitiveType mtlPrimitiveType;","title":"variable mtlPrimitiveType"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#variable-mtlcullmode","text":"::MTLCullMode mtlCullMode;","title":"variable mtlCullMode"},{"location":"api/Classes/classngfx_1_1MTLGraphicsPipeline/#variable-mtlfrontfacewinding","text":"::MTLWinding mtlFrontFaceWinding; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable mtlFrontFaceWinding"},{"location":"api/Classes/classngfx_1_1MTLPipelineCache/","text":"ngfx::MTLPipelineCache Inherits from ngfx::PipelineCache Public Functions Name virtual ~MTLPipelineCache () Additional inherited members Public Functions inherited from ngfx::PipelineCache Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value) Public Functions Documentation function ~MTLPipelineCache inline virtual ~MTLPipelineCache() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLPipelineCache"},{"location":"api/Classes/classngfx_1_1MTLPipelineCache/#ngfxmtlpipelinecache","text":"Inherits from ngfx::PipelineCache","title":"ngfx::MTLPipelineCache"},{"location":"api/Classes/classngfx_1_1MTLPipelineCache/#public-functions","text":"Name virtual ~MTLPipelineCache ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLPipelineCache/#additional-inherited-members","text":"Public Functions inherited from ngfx::PipelineCache Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value)","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLPipelineCache/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLPipelineCache/#function-mtlpipelinecache","text":"inline virtual ~MTLPipelineCache() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~MTLPipelineCache"},{"location":"api/Classes/classngfx_1_1MTLRenderCommandEncoder/","text":"ngfx::MTLRenderCommandEncoder Inherits from ngfx::MTLCommandEncoder Public Functions Name virtual ~MTLRenderCommandEncoder () Public Attributes Name id< MTLRenderCommandEncoder > v Additional inherited members Public Functions inherited from ngfx::MTLCommandEncoder Name virtual ~MTLCommandEncoder () Public Functions Documentation function ~MTLRenderCommandEncoder inline virtual ~MTLRenderCommandEncoder() Public Attributes Documentation variable v id< MTLRenderCommandEncoder > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLRenderCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLRenderCommandEncoder/#ngfxmtlrendercommandencoder","text":"Inherits from ngfx::MTLCommandEncoder","title":"ngfx::MTLRenderCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLRenderCommandEncoder/#public-functions","text":"Name virtual ~MTLRenderCommandEncoder ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLRenderCommandEncoder/#public-attributes","text":"Name id< MTLRenderCommandEncoder > v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLRenderCommandEncoder/#additional-inherited-members","text":"Public Functions inherited from ngfx::MTLCommandEncoder Name virtual ~MTLCommandEncoder ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLRenderCommandEncoder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLRenderCommandEncoder/#function-mtlrendercommandencoder","text":"inline virtual ~MTLRenderCommandEncoder()","title":"function ~MTLRenderCommandEncoder"},{"location":"api/Classes/classngfx_1_1MTLRenderCommandEncoder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLRenderCommandEncoder/#variable-v","text":"id< MTLRenderCommandEncoder > v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1MTLRenderPass/","text":"ngfx::MTLRenderPass Inherits from ngfx::RenderPass Public Functions Name virtual ~MTLRenderPass () MTLRenderPassDescriptor * getDescriptor ( MTLGraphicsContext * mtlCtx, MTLFramebuffer * mtlFramebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil) Additional inherited members Public Functions inherited from ngfx::RenderPass Name virtual ~RenderPass () Public Attributes inherited from ngfx::RenderPass Name Framebuffer * currentFramebuffer Public Functions Documentation function ~MTLRenderPass inline virtual ~MTLRenderPass() function getDescriptor MTLRenderPassDescriptor * getDescriptor( MTLGraphicsContext * mtlCtx, MTLFramebuffer * mtlFramebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLRenderPass"},{"location":"api/Classes/classngfx_1_1MTLRenderPass/#ngfxmtlrenderpass","text":"Inherits from ngfx::RenderPass","title":"ngfx::MTLRenderPass"},{"location":"api/Classes/classngfx_1_1MTLRenderPass/#public-functions","text":"Name virtual ~MTLRenderPass () MTLRenderPassDescriptor * getDescriptor ( MTLGraphicsContext * mtlCtx, MTLFramebuffer * mtlFramebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLRenderPass/#additional-inherited-members","text":"Public Functions inherited from ngfx::RenderPass Name virtual ~RenderPass () Public Attributes inherited from ngfx::RenderPass Name Framebuffer * currentFramebuffer","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLRenderPass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLRenderPass/#function-mtlrenderpass","text":"inline virtual ~MTLRenderPass()","title":"function ~MTLRenderPass"},{"location":"api/Classes/classngfx_1_1MTLRenderPass/#function-getdescriptor","text":"MTLRenderPassDescriptor * getDescriptor( MTLGraphicsContext * mtlCtx, MTLFramebuffer * mtlFramebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function getDescriptor"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/","text":"ngfx::MTLShaderModule Inherited by ngfx::MTLComputeShaderModule , ngfx::MTLFragmentShaderModule , ngfx::MTLVertexShaderModule Public Functions Name virtual void initFromFile (id< MTLDevice > device, const std::string & filename) virtual ~MTLShaderModule () Protected Functions Name virtual void initFromByteCode (id< MTLDevice > device, void * data, uint32_t size) Public Attributes Name id< MTLLibrary > mtlLibrary id< MTLFunction > mtlFunction Public Functions Documentation function initFromFile virtual void initFromFile( id< MTLDevice > device, const std::string & filename ) function ~MTLShaderModule inline virtual ~MTLShaderModule() Protected Functions Documentation function initFromByteCode virtual void initFromByteCode( id< MTLDevice > device, void * data, uint32_t size ) Public Attributes Documentation variable mtlLibrary id< MTLLibrary > mtlLibrary; variable mtlFunction id< MTLFunction > mtlFunction; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLShaderModule"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#ngfxmtlshadermodule","text":"Inherited by ngfx::MTLComputeShaderModule , ngfx::MTLFragmentShaderModule , ngfx::MTLVertexShaderModule","title":"ngfx::MTLShaderModule"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#public-functions","text":"Name virtual void initFromFile (id< MTLDevice > device, const std::string & filename) virtual ~MTLShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#protected-functions","text":"Name virtual void initFromByteCode (id< MTLDevice > device, void * data, uint32_t size)","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#public-attributes","text":"Name id< MTLLibrary > mtlLibrary id< MTLFunction > mtlFunction","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#function-initfromfile","text":"virtual void initFromFile( id< MTLDevice > device, const std::string & filename )","title":"function initFromFile"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#function-mtlshadermodule","text":"inline virtual ~MTLShaderModule()","title":"function ~MTLShaderModule"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#function-initfrombytecode","text":"virtual void initFromByteCode( id< MTLDevice > device, void * data, uint32_t size )","title":"function initFromByteCode"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#variable-mtllibrary","text":"id< MTLLibrary > mtlLibrary;","title":"variable mtlLibrary"},{"location":"api/Classes/classngfx_1_1MTLShaderModule/#variable-mtlfunction","text":"id< MTLFunction > mtlFunction; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable mtlFunction"},{"location":"api/Classes/classngfx_1_1MTLSurface/","text":"ngfx::MTLSurface Inherits from ngfx::Surface Public Functions Name virtual ~MTLSurface () CAMetalLayer * getMetalLayer () Public Attributes Name NSView * view id< CAMetalDrawable > drawable std::unique_ptr< MTLDepthStencilTexture > depthStencilTexture Additional inherited members Public Functions inherited from ngfx::Surface Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface () Public Attributes inherited from ngfx::Surface Name uint32_t w uint32_t h bool offscreen Public Functions Documentation function ~MTLSurface inline virtual ~MTLSurface() function getMetalLayer inline CAMetalLayer * getMetalLayer() Public Attributes Documentation variable view NSView * view = nullptr; variable drawable id< CAMetalDrawable > drawable; variable depthStencilTexture std::unique_ptr< MTLDepthStencilTexture > depthStencilTexture; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLSurface"},{"location":"api/Classes/classngfx_1_1MTLSurface/#ngfxmtlsurface","text":"Inherits from ngfx::Surface","title":"ngfx::MTLSurface"},{"location":"api/Classes/classngfx_1_1MTLSurface/#public-functions","text":"Name virtual ~MTLSurface () CAMetalLayer * getMetalLayer ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLSurface/#public-attributes","text":"Name NSView * view id< CAMetalDrawable > drawable std::unique_ptr< MTLDepthStencilTexture > depthStencilTexture","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLSurface/#additional-inherited-members","text":"Public Functions inherited from ngfx::Surface Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface () Public Attributes inherited from ngfx::Surface Name uint32_t w uint32_t h bool offscreen","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLSurface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLSurface/#function-mtlsurface","text":"inline virtual ~MTLSurface()","title":"function ~MTLSurface"},{"location":"api/Classes/classngfx_1_1MTLSurface/#function-getmetallayer","text":"inline CAMetalLayer * getMetalLayer()","title":"function getMetalLayer"},{"location":"api/Classes/classngfx_1_1MTLSurface/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLSurface/#variable-view","text":"NSView * view = nullptr;","title":"variable view"},{"location":"api/Classes/classngfx_1_1MTLSurface/#variable-drawable","text":"id< CAMetalDrawable > drawable;","title":"variable drawable"},{"location":"api/Classes/classngfx_1_1MTLSurface/#variable-depthstenciltexture","text":"std::unique_ptr< MTLDepthStencilTexture > depthStencilTexture; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable depthStencilTexture"},{"location":"api/Classes/classngfx_1_1MTLTexture/","text":"ngfx::MTLTexture Inherits from ngfx::Texture Public Functions Name void create ( MTLGraphicsContext * ctx, void * data, ::MTLPixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, MTLTextureUsage textureUsage, ::MTLTextureType textureType, bool genMipmaps, MTLSamplerDescriptor * samplerDescriptor, uint32_t numSamples) virtual ~MTLTexture () virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) override virtual void generateMipmaps ( CommandBuffer * commandBuffer) override Public Attributes Name MTLGraphicsContext * ctx id< MTLTexture > v id< MTLSamplerState > mtlSamplerState bool depthTexture bool stencilTexture Additional inherited members Public Functions inherited from ngfx::Texture Name virtual ~Texture () Public Attributes inherited from ngfx::Texture Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType Public Functions Documentation function create void create( MTLGraphicsContext * ctx, void * data, ::MTLPixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, MTLTextureUsage textureUsage, ::MTLTextureType textureType, bool genMipmaps, MTLSamplerDescriptor * samplerDescriptor, uint32_t numSamples ) function ~MTLTexture virtual ~MTLTexture() function upload virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::upload function download virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::download function changeLayout inline virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) override Reimplements : ngfx::Texture::changeLayout function generateMipmaps virtual void generateMipmaps( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Texture::generateMipmaps Public Attributes Documentation variable ctx MTLGraphicsContext * ctx = nullptr; variable v id< MTLTexture > v; variable mtlSamplerState id< MTLSamplerState > mtlSamplerState; variable depthTexture bool depthTexture = false; variable stencilTexture bool stencilTexture = false; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLTexture"},{"location":"api/Classes/classngfx_1_1MTLTexture/#ngfxmtltexture","text":"Inherits from ngfx::Texture","title":"ngfx::MTLTexture"},{"location":"api/Classes/classngfx_1_1MTLTexture/#public-functions","text":"Name void create ( MTLGraphicsContext * ctx, void * data, ::MTLPixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, MTLTextureUsage textureUsage, ::MTLTextureType textureType, bool genMipmaps, MTLSamplerDescriptor * samplerDescriptor, uint32_t numSamples) virtual ~MTLTexture () virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) override virtual void generateMipmaps ( CommandBuffer * commandBuffer) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLTexture/#public-attributes","text":"Name MTLGraphicsContext * ctx id< MTLTexture > v id< MTLSamplerState > mtlSamplerState bool depthTexture bool stencilTexture","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLTexture/#additional-inherited-members","text":"Public Functions inherited from ngfx::Texture Name virtual ~Texture () Public Attributes inherited from ngfx::Texture Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLTexture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLTexture/#function-create","text":"void create( MTLGraphicsContext * ctx, void * data, ::MTLPixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, MTLTextureUsage textureUsage, ::MTLTextureType textureType, bool genMipmaps, MTLSamplerDescriptor * samplerDescriptor, uint32_t numSamples )","title":"function create"},{"location":"api/Classes/classngfx_1_1MTLTexture/#function-mtltexture","text":"virtual ~MTLTexture()","title":"function ~MTLTexture"},{"location":"api/Classes/classngfx_1_1MTLTexture/#function-upload","text":"virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::upload","title":"function upload"},{"location":"api/Classes/classngfx_1_1MTLTexture/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::download","title":"function download"},{"location":"api/Classes/classngfx_1_1MTLTexture/#function-changelayout","text":"inline virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) override Reimplements : ngfx::Texture::changeLayout","title":"function changeLayout"},{"location":"api/Classes/classngfx_1_1MTLTexture/#function-generatemipmaps","text":"virtual void generateMipmaps( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Texture::generateMipmaps","title":"function generateMipmaps"},{"location":"api/Classes/classngfx_1_1MTLTexture/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLTexture/#variable-ctx","text":"MTLGraphicsContext * ctx = nullptr;","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1MTLTexture/#variable-v","text":"id< MTLTexture > v;","title":"variable v"},{"location":"api/Classes/classngfx_1_1MTLTexture/#variable-mtlsamplerstate","text":"id< MTLSamplerState > mtlSamplerState;","title":"variable mtlSamplerState"},{"location":"api/Classes/classngfx_1_1MTLTexture/#variable-depthtexture","text":"bool depthTexture = false;","title":"variable depthTexture"},{"location":"api/Classes/classngfx_1_1MTLTexture/#variable-stenciltexture","text":"bool stencilTexture = false; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable stencilTexture"},{"location":"api/Classes/classngfx_1_1MTLVertexShaderModule/","text":"ngfx::MTLVertexShaderModule Inherits from ngfx::VertexShaderModule , ngfx::MTLShaderModule , ngfx::ShaderModule Public Functions Name virtual ~MTLVertexShaderModule () Additional inherited members Public Classes inherited from ngfx::VertexShaderModule Name struct AttributeDescription Public Functions inherited from ngfx::VertexShaderModule Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename) Public Attributes inherited from ngfx::VertexShaderModule Name std::vector< AttributeDescription > attributes Public Functions inherited from ngfx::MTLShaderModule Name virtual void initFromFile (id< MTLDevice > device, const std::string & filename) virtual ~MTLShaderModule () Protected Functions inherited from ngfx::MTLShaderModule Name virtual void initFromByteCode (id< MTLDevice > device, void * data, uint32_t size) Public Attributes inherited from ngfx::MTLShaderModule Name id< MTLLibrary > mtlLibrary id< MTLFunction > mtlFunction Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function ~MTLVertexShaderModule inline virtual ~MTLVertexShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLVertexShaderModule"},{"location":"api/Classes/classngfx_1_1MTLVertexShaderModule/#ngfxmtlvertexshadermodule","text":"Inherits from ngfx::VertexShaderModule , ngfx::MTLShaderModule , ngfx::ShaderModule","title":"ngfx::MTLVertexShaderModule"},{"location":"api/Classes/classngfx_1_1MTLVertexShaderModule/#public-functions","text":"Name virtual ~MTLVertexShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLVertexShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::VertexShaderModule Name struct AttributeDescription Public Functions inherited from ngfx::VertexShaderModule Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename) Public Attributes inherited from ngfx::VertexShaderModule Name std::vector< AttributeDescription > attributes Public Functions inherited from ngfx::MTLShaderModule Name virtual void initFromFile (id< MTLDevice > device, const std::string & filename) virtual ~MTLShaderModule () Protected Functions inherited from ngfx::MTLShaderModule Name virtual void initFromByteCode (id< MTLDevice > device, void * data, uint32_t size) Public Attributes inherited from ngfx::MTLShaderModule Name id< MTLLibrary > mtlLibrary id< MTLFunction > mtlFunction Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLVertexShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLVertexShaderModule/#function-mtlvertexshadermodule","text":"inline virtual ~MTLVertexShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~MTLVertexShaderModule"},{"location":"api/Classes/classngfx_1_1MTLWindow/","text":"ngfx::MTLWindow Inherits from ngfx::Window Public Functions Name virtual ~MTLWindow () virtual bool shouldClose () override virtual void pollEvents () override Public Attributes Name MTLSurface mtlSurface Additional inherited members Public Types inherited from ngfx::Window Name enum @2 { DISPLAY_WIDTH, DISPLAY_HEIGHT} Public Functions inherited from ngfx::Window Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () Public Attributes inherited from ngfx::Window Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton Public Functions Documentation function ~MTLWindow inline virtual ~MTLWindow() function shouldClose virtual bool shouldClose() override Reimplements : ngfx::Window::shouldClose function pollEvents virtual void pollEvents() override Reimplements : ngfx::Window::pollEvents Public Attributes Documentation variable mtlSurface MTLSurface mtlSurface; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLWindow"},{"location":"api/Classes/classngfx_1_1MTLWindow/#ngfxmtlwindow","text":"Inherits from ngfx::Window","title":"ngfx::MTLWindow"},{"location":"api/Classes/classngfx_1_1MTLWindow/#public-functions","text":"Name virtual ~MTLWindow () virtual bool shouldClose () override virtual void pollEvents () override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MTLWindow/#public-attributes","text":"Name MTLSurface mtlSurface","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MTLWindow/#additional-inherited-members","text":"Public Types inherited from ngfx::Window Name enum @2 { DISPLAY_WIDTH, DISPLAY_HEIGHT} Public Functions inherited from ngfx::Window Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () Public Attributes inherited from ngfx::Window Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MTLWindow/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MTLWindow/#function-mtlwindow","text":"inline virtual ~MTLWindow()","title":"function ~MTLWindow"},{"location":"api/Classes/classngfx_1_1MTLWindow/#function-shouldclose","text":"virtual bool shouldClose() override Reimplements : ngfx::Window::shouldClose","title":"function shouldClose"},{"location":"api/Classes/classngfx_1_1MTLWindow/#function-pollevents","text":"virtual void pollEvents() override Reimplements : ngfx::Window::pollEvents","title":"function pollEvents"},{"location":"api/Classes/classngfx_1_1MTLWindow/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MTLWindow/#variable-mtlsurface","text":"MTLSurface mtlSurface; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable mtlSurface"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/","text":"ngfx::MatrixMultiplyCPUOp Inherits from ngfx::MatrixMultiplyOp , ngfx::ComputeOp Public Functions Name MatrixMultiplyCPUOp ( MatrixParam src0, MatrixParam src1, MatrixParam dst) virtual ~MatrixMultiplyCPUOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) override void update ( MatrixParam src0, MatrixParam src1) override void transpose ( MatrixParam & src, MatrixParam & dst) Protected Functions Name void matrixMultiply () Protected Attributes Name std::vector< float > src1t_data MatrixParam src0 MatrixParam src1 MatrixParam src1t MatrixParam dst Additional inherited members Public Classes inherited from ngfx::MatrixMultiplyOp Name struct MatrixParam Public Functions inherited from ngfx::MatrixMultiplyOp Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx Public Functions Documentation function MatrixMultiplyCPUOp MatrixMultiplyCPUOp( MatrixParam src0, MatrixParam src1, MatrixParam dst ) function ~MatrixMultiplyCPUOp virtual ~MatrixMultiplyCPUOp() function apply virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) override Reimplements : ngfx::MatrixMultiplyOp::apply function update void update( MatrixParam src0, MatrixParam src1 ) override function transpose static void transpose( MatrixParam & src, MatrixParam & dst ) Protected Functions Documentation function matrixMultiply void matrixMultiply() Protected Attributes Documentation variable src1t_data std::vector< float > src1t_data; variable src0 MatrixParam src0; variable src1 MatrixParam src1; variable src1t MatrixParam src1t; variable dst MatrixParam dst; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MatrixMultiplyCPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#ngfxmatrixmultiplycpuop","text":"Inherits from ngfx::MatrixMultiplyOp , ngfx::ComputeOp","title":"ngfx::MatrixMultiplyCPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#public-functions","text":"Name MatrixMultiplyCPUOp ( MatrixParam src0, MatrixParam src1, MatrixParam dst) virtual ~MatrixMultiplyCPUOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) override void update ( MatrixParam src0, MatrixParam src1) override void transpose ( MatrixParam & src, MatrixParam & dst)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#protected-functions","text":"Name void matrixMultiply ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#protected-attributes","text":"Name std::vector< float > src1t_data MatrixParam src0 MatrixParam src1 MatrixParam src1t MatrixParam dst","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#additional-inherited-members","text":"Public Classes inherited from ngfx::MatrixMultiplyOp Name struct MatrixParam Public Functions inherited from ngfx::MatrixMultiplyOp Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-matrixmultiplycpuop","text":"MatrixMultiplyCPUOp( MatrixParam src0, MatrixParam src1, MatrixParam dst )","title":"function MatrixMultiplyCPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-matrixmultiplycpuop_1","text":"virtual ~MatrixMultiplyCPUOp()","title":"function ~MatrixMultiplyCPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-apply","text":"virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) override Reimplements : ngfx::MatrixMultiplyOp::apply","title":"function apply"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-update","text":"void update( MatrixParam src0, MatrixParam src1 ) override","title":"function update"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-transpose","text":"static void transpose( MatrixParam & src, MatrixParam & dst )","title":"function transpose"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#function-matrixmultiply","text":"void matrixMultiply()","title":"function matrixMultiply"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#variable-src1t_data","text":"std::vector< float > src1t_data;","title":"variable src1t_data"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#variable-src0","text":"MatrixParam src0;","title":"variable src0"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#variable-src1","text":"MatrixParam src1;","title":"variable src1"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#variable-src1t","text":"MatrixParam src1t;","title":"variable src1t"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyCPUOp/#variable-dst","text":"MatrixParam dst; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable dst"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/","text":"ngfx::MatrixMultiplyGPUOp Inherits from ngfx::MatrixMultiplyOp , ngfx::ComputeOp Protected Classes Name struct UboData Public Functions Name MatrixMultiplyGPUOp ( GraphicsContext * ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst) virtual ~MatrixMultiplyGPUOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) virtual void update ( MatrixParam src0, MatrixParam src1) Protected Functions Name void createPipeline () Public Attributes Name std::unique_ptr< Buffer > bUbo std::unique_ptr< Buffer > bSrc0 std::unique_ptr< Buffer > bSrc1 std::unique_ptr< Buffer > bDst Protected Attributes Name ComputePipeline * computePipeline uint32_t U_UBO uint32_t SSBO_SRC0 uint32_t SSBO_SRC1 uint32_t SSBO_DST MatrixParam dst Additional inherited members Public Classes inherited from ngfx::MatrixMultiplyOp Name struct MatrixParam Public Functions inherited from ngfx::MatrixMultiplyOp Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx Public Functions Documentation function MatrixMultiplyGPUOp MatrixMultiplyGPUOp( GraphicsContext * ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst ) function ~MatrixMultiplyGPUOp virtual ~MatrixMultiplyGPUOp() function apply virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) Reimplements : ngfx::MatrixMultiplyOp::apply function update virtual void update( MatrixParam src0, MatrixParam src1 ) Reimplements : ngfx::MatrixMultiplyOp::update Protected Functions Documentation function createPipeline void createPipeline() Public Attributes Documentation variable bUbo std::unique_ptr< Buffer > bUbo; variable bSrc0 std::unique_ptr< Buffer > bSrc0; variable bSrc1 std::unique_ptr< Buffer > bSrc1; variable bDst std::unique_ptr< Buffer > bDst; Protected Attributes Documentation variable computePipeline ComputePipeline * computePipeline; variable U_UBO uint32_t U_UBO = 0; variable SSBO_SRC0 uint32_t SSBO_SRC0 = 1; variable SSBO_SRC1 uint32_t SSBO_SRC1 = 2; variable SSBO_DST uint32_t SSBO_DST = 3; variable dst MatrixParam dst; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MatrixMultiplyGPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#ngfxmatrixmultiplygpuop","text":"Inherits from ngfx::MatrixMultiplyOp , ngfx::ComputeOp","title":"ngfx::MatrixMultiplyGPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#protected-classes","text":"Name struct UboData","title":"Protected Classes"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#public-functions","text":"Name MatrixMultiplyGPUOp ( GraphicsContext * ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst) virtual ~MatrixMultiplyGPUOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) virtual void update ( MatrixParam src0, MatrixParam src1)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#protected-functions","text":"Name void createPipeline ()","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#public-attributes","text":"Name std::unique_ptr< Buffer > bUbo std::unique_ptr< Buffer > bSrc0 std::unique_ptr< Buffer > bSrc1 std::unique_ptr< Buffer > bDst","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#protected-attributes","text":"Name ComputePipeline * computePipeline uint32_t U_UBO uint32_t SSBO_SRC0 uint32_t SSBO_SRC1 uint32_t SSBO_DST MatrixParam dst","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#additional-inherited-members","text":"Public Classes inherited from ngfx::MatrixMultiplyOp Name struct MatrixParam Public Functions inherited from ngfx::MatrixMultiplyOp Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#function-matrixmultiplygpuop","text":"MatrixMultiplyGPUOp( GraphicsContext * ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst )","title":"function MatrixMultiplyGPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#function-matrixmultiplygpuop_1","text":"virtual ~MatrixMultiplyGPUOp()","title":"function ~MatrixMultiplyGPUOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#function-apply","text":"virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) Reimplements : ngfx::MatrixMultiplyOp::apply","title":"function apply"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#function-update","text":"virtual void update( MatrixParam src0, MatrixParam src1 ) Reimplements : ngfx::MatrixMultiplyOp::update","title":"function update"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#function-createpipeline","text":"void createPipeline()","title":"function createPipeline"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-bubo","text":"std::unique_ptr< Buffer > bUbo;","title":"variable bUbo"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-bsrc0","text":"std::unique_ptr< Buffer > bSrc0;","title":"variable bSrc0"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-bsrc1","text":"std::unique_ptr< Buffer > bSrc1;","title":"variable bSrc1"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-bdst","text":"std::unique_ptr< Buffer > bDst;","title":"variable bDst"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-computepipeline","text":"ComputePipeline * computePipeline;","title":"variable computePipeline"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-u_ubo","text":"uint32_t U_UBO = 0;","title":"variable U_UBO"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-ssbo_src0","text":"uint32_t SSBO_SRC0 = 1;","title":"variable SSBO_SRC0"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-ssbo_src1","text":"uint32_t SSBO_SRC1 = 2;","title":"variable SSBO_SRC1"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-ssbo_dst","text":"uint32_t SSBO_DST = 3;","title":"variable SSBO_DST"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyGPUOp/#variable-dst","text":"MatrixParam dst; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable dst"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/","text":"ngfx::MatrixMultiplyOp Inherits from ngfx::ComputeOp Inherited by ngfx::MatrixMultiplyCPUOp , ngfx::MatrixMultiplyGPUOp Public Classes Name struct MatrixParam Public Functions Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) override =0 virtual void update ( MatrixParam src0, MatrixParam src1) =0 Additional inherited members Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx Public Functions Documentation function MatrixMultiplyOp inline MatrixMultiplyOp( GraphicsContext * ctx ) function ~MatrixMultiplyOp inline virtual ~MatrixMultiplyOp() function apply virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) override =0 Reimplements : ngfx::ComputeOp::apply Reimplemented by : ngfx::MatrixMultiplyGPUOp::apply , ngfx::MatrixMultiplyCPUOp::apply function update virtual void update( MatrixParam src0, MatrixParam src1 ) =0 Reimplemented by : ngfx::MatrixMultiplyGPUOp::update Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MatrixMultiplyOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#ngfxmatrixmultiplyop","text":"Inherits from ngfx::ComputeOp Inherited by ngfx::MatrixMultiplyCPUOp , ngfx::MatrixMultiplyGPUOp","title":"ngfx::MatrixMultiplyOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#public-classes","text":"Name struct MatrixParam","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#public-functions","text":"Name MatrixMultiplyOp ( GraphicsContext * ctx) virtual ~MatrixMultiplyOp () virtual void apply ( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr) override =0 virtual void update ( MatrixParam src0, MatrixParam src1) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#additional-inherited-members","text":"Public Functions inherited from ngfx::ComputeOp Name ComputeOp ( GraphicsContext * ctx) virtual ~ComputeOp () Protected Attributes inherited from ngfx::ComputeOp Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#function-matrixmultiplyop","text":"inline MatrixMultiplyOp( GraphicsContext * ctx )","title":"function MatrixMultiplyOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#function-matrixmultiplyop_1","text":"inline virtual ~MatrixMultiplyOp()","title":"function ~MatrixMultiplyOp"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#function-apply","text":"virtual void apply( CommandBuffer * commandBuffer =nullptr, Graphics * graphics =nullptr ) override =0 Reimplements : ngfx::ComputeOp::apply Reimplemented by : ngfx::MatrixMultiplyGPUOp::apply , ngfx::MatrixMultiplyCPUOp::apply","title":"function apply"},{"location":"api/Classes/classngfx_1_1MatrixMultiplyOp/#function-update","text":"virtual void update( MatrixParam src0, MatrixParam src1 ) =0 Reimplemented by : ngfx::MatrixMultiplyGPUOp::update Updated on 3 April 2021 at 20:21:51 PDT","title":"function update"},{"location":"api/Classes/classngfx_1_1Pipeline/","text":"ngfx::Pipeline Inherited by ngfx::ComputePipeline , ngfx::GraphicsPipeline Public Functions Name virtual ~Pipeline () Public Functions Documentation function ~Pipeline inline virtual ~Pipeline() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Pipeline"},{"location":"api/Classes/classngfx_1_1Pipeline/#ngfxpipeline","text":"Inherited by ngfx::ComputePipeline , ngfx::GraphicsPipeline","title":"ngfx::Pipeline"},{"location":"api/Classes/classngfx_1_1Pipeline/#public-functions","text":"Name virtual ~Pipeline ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Pipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Pipeline/#function-pipeline","text":"inline virtual ~Pipeline() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~Pipeline"},{"location":"api/Classes/classngfx_1_1PipelineCache/","text":"ngfx::PipelineCache Inherited by ngfx::D3DPipelineCache , ngfx::MTLPipelineCache , ngfx::VKPipelineCache Public Functions Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value) Public Functions Documentation function ~PipelineCache inline virtual ~PipelineCache() function get virtual Pipeline * get( const std::string & key ) function add virtual void add( const std::string & key, Pipeline * value ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::PipelineCache"},{"location":"api/Classes/classngfx_1_1PipelineCache/#ngfxpipelinecache","text":"Inherited by ngfx::D3DPipelineCache , ngfx::MTLPipelineCache , ngfx::VKPipelineCache","title":"ngfx::PipelineCache"},{"location":"api/Classes/classngfx_1_1PipelineCache/#public-functions","text":"Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1PipelineCache/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1PipelineCache/#function-pipelinecache","text":"inline virtual ~PipelineCache()","title":"function ~PipelineCache"},{"location":"api/Classes/classngfx_1_1PipelineCache/#function-get","text":"virtual Pipeline * get( const std::string & key )","title":"function get"},{"location":"api/Classes/classngfx_1_1PipelineCache/#function-add","text":"virtual void add( const std::string & key, Pipeline * value ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function add"},{"location":"api/Classes/classngfx_1_1ProcessUtil/","text":"ngfx::ProcessUtil Public Functions Name int getPID () Public Functions Documentation function getPID static int getPID() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ProcessUtil"},{"location":"api/Classes/classngfx_1_1ProcessUtil/#ngfxprocessutil","text":"","title":"ngfx::ProcessUtil"},{"location":"api/Classes/classngfx_1_1ProcessUtil/#public-functions","text":"Name int getPID ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ProcessUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ProcessUtil/#function-getpid","text":"static int getPID() Updated on 3 April 2021 at 20:21:51 PDT","title":"function getPID"},{"location":"api/Classes/classngfx_1_1Queue/","text":"ngfx::Queue Inherited by ngfx::D3DCommandQueue , ngfx::VKQueue Public Functions Name virtual ~Queue () virtual void present () =0 virtual void submit ( CommandBuffer * commandBuffer) =0 virtual void waitIdle () =0 Public Functions Documentation function ~Queue inline virtual ~Queue() function present virtual void present() =0 Reimplemented by : ngfx::VKQueue::present , ngfx::D3DCommandQueue::present function submit virtual void submit( CommandBuffer * commandBuffer ) =0 Reimplemented by : ngfx::VKQueue::submit , ngfx::D3DCommandQueue::submit function waitIdle virtual void waitIdle() =0 Reimplemented by : ngfx::VKQueue::waitIdle , ngfx::D3DCommandQueue::waitIdle Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Queue"},{"location":"api/Classes/classngfx_1_1Queue/#ngfxqueue","text":"Inherited by ngfx::D3DCommandQueue , ngfx::VKQueue","title":"ngfx::Queue"},{"location":"api/Classes/classngfx_1_1Queue/#public-functions","text":"Name virtual ~Queue () virtual void present () =0 virtual void submit ( CommandBuffer * commandBuffer) =0 virtual void waitIdle () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Queue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Queue/#function-queue","text":"inline virtual ~Queue()","title":"function ~Queue"},{"location":"api/Classes/classngfx_1_1Queue/#function-present","text":"virtual void present() =0 Reimplemented by : ngfx::VKQueue::present , ngfx::D3DCommandQueue::present","title":"function present"},{"location":"api/Classes/classngfx_1_1Queue/#function-submit","text":"virtual void submit( CommandBuffer * commandBuffer ) =0 Reimplemented by : ngfx::VKQueue::submit , ngfx::D3DCommandQueue::submit","title":"function submit"},{"location":"api/Classes/classngfx_1_1Queue/#function-waitidle","text":"virtual void waitIdle() =0 Reimplemented by : ngfx::VKQueue::waitIdle , ngfx::D3DCommandQueue::waitIdle Updated on 3 April 2021 at 20:21:51 PDT","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1RegexUtil/","text":"ngfx::RegexUtil Public Classes Name struct Match Public Functions Name std::vector< Match > findAll (const std::regex & p, std::string contents) Public Functions Documentation function findAll static std::vector< Match > findAll( const std::regex & p, std::string contents ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::RegexUtil"},{"location":"api/Classes/classngfx_1_1RegexUtil/#ngfxregexutil","text":"","title":"ngfx::RegexUtil"},{"location":"api/Classes/classngfx_1_1RegexUtil/#public-classes","text":"Name struct Match","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1RegexUtil/#public-functions","text":"Name std::vector< Match > findAll (const std::regex & p, std::string contents)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1RegexUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1RegexUtil/#function-findall","text":"static std::vector< Match > findAll( const std::regex & p, std::string contents ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function findAll"},{"location":"api/Classes/classngfx_1_1RenderPass/","text":"ngfx::RenderPass Inherited by ngfx::D3DRenderPass , ngfx::MTLRenderPass , ngfx::VKRenderPass Public Functions Name virtual ~RenderPass () Public Attributes Name Framebuffer * currentFramebuffer Public Functions Documentation function ~RenderPass inline virtual ~RenderPass() Public Attributes Documentation variable currentFramebuffer Framebuffer * currentFramebuffer = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::RenderPass"},{"location":"api/Classes/classngfx_1_1RenderPass/#ngfxrenderpass","text":"Inherited by ngfx::D3DRenderPass , ngfx::MTLRenderPass , ngfx::VKRenderPass","title":"ngfx::RenderPass"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-functions","text":"Name virtual ~RenderPass ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-attributes","text":"Name Framebuffer * currentFramebuffer","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1RenderPass/#function-renderpass","text":"inline virtual ~RenderPass()","title":"function ~RenderPass"},{"location":"api/Classes/classngfx_1_1RenderPass/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1RenderPass/#variable-currentframebuffer","text":"Framebuffer * currentFramebuffer = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable currentFramebuffer"},{"location":"api/Classes/classngfx_1_1Semaphore/","text":"ngfx::Semaphore Inherited by ngfx::VKSemaphore Public Functions Name Semaphore * create ( Device * device) virtual ~Semaphore () virtual uint64_t wait () =0 virtual void signal (uint64_t value =1) =0 Public Functions Documentation function create static Semaphore * create( Device * device ) function ~Semaphore inline virtual ~Semaphore() function wait virtual uint64_t wait() =0 Reimplemented by : ngfx::VKSemaphore::wait function signal virtual void signal( uint64_t value =1 ) =0 Reimplemented by : ngfx::VKSemaphore::signal Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Semaphore"},{"location":"api/Classes/classngfx_1_1Semaphore/#ngfxsemaphore","text":"Inherited by ngfx::VKSemaphore","title":"ngfx::Semaphore"},{"location":"api/Classes/classngfx_1_1Semaphore/#public-functions","text":"Name Semaphore * create ( Device * device) virtual ~Semaphore () virtual uint64_t wait () =0 virtual void signal (uint64_t value =1) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Semaphore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-create","text":"static Semaphore * create( Device * device )","title":"function create"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-semaphore","text":"inline virtual ~Semaphore()","title":"function ~Semaphore"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-wait","text":"virtual uint64_t wait() =0 Reimplemented by : ngfx::VKSemaphore::wait","title":"function wait"},{"location":"api/Classes/classngfx_1_1Semaphore/#function-signal","text":"virtual void signal( uint64_t value =1 ) =0 Reimplemented by : ngfx::VKSemaphore::signal Updated on 3 April 2021 at 20:21:51 PDT","title":"function signal"},{"location":"api/Classes/classngfx_1_1ShaderModule/","text":"ngfx::ShaderModule Inherited by ngfx::ComputeShaderModule , ngfx::FragmentShaderModule , ngfx::VertexShaderModule Public Classes Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Types Documentation typedef DescriptorInfos typedef std::vector<DescriptorInfo> ngfx::ShaderModule::DescriptorInfos; typedef BufferMemberInfos typedef std::map<std::string, BufferMemberInfo> ngfx::ShaderModule::BufferMemberInfos; typedef BufferInfos typedef std::map<std::string, BufferInfo> ngfx::ShaderModule::BufferInfos; Public Functions Documentation function ~ShaderModule inline virtual ~ShaderModule() function findDescriptorInfo inline DescriptorInfo * findDescriptorInfo( const std::string & name ) function findUniformBufferInfo inline BufferInfo * findUniformBufferInfo( const std::string & name ) function findStorageBufferInfo inline BufferInfo * findStorageBufferInfo( const std::string & name ) function initBindings void initBindings( std::ifstream & in, ShaderStageFlags shaderStages ) function initBindings void initBindings( const std::string & filename, ShaderStageFlags shaderStages ) Public Attributes Documentation variable descriptors DescriptorInfos descriptors; variable uniformBufferInfos BufferInfos uniformBufferInfos; variable shaderStorageBufferInfos BufferInfos shaderStorageBufferInfos; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ShaderModule"},{"location":"api/Classes/classngfx_1_1ShaderModule/#ngfxshadermodule","text":"Inherited by ngfx::ComputeShaderModule , ngfx::FragmentShaderModule , ngfx::VertexShaderModule","title":"ngfx::ShaderModule"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-classes","text":"Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-types","text":"Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos","title":"Public Types"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-functions","text":"Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-attributes","text":"Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1ShaderModule/#typedef-descriptorinfos","text":"typedef std::vector<DescriptorInfo> ngfx::ShaderModule::DescriptorInfos;","title":"typedef DescriptorInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#typedef-buffermemberinfos","text":"typedef std::map<std::string, BufferMemberInfo> ngfx::ShaderModule::BufferMemberInfos;","title":"typedef BufferMemberInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#typedef-bufferinfos","text":"typedef std::map<std::string, BufferInfo> ngfx::ShaderModule::BufferInfos;","title":"typedef BufferInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-shadermodule","text":"inline virtual ~ShaderModule()","title":"function ~ShaderModule"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-finddescriptorinfo","text":"inline DescriptorInfo * findDescriptorInfo( const std::string & name )","title":"function findDescriptorInfo"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-finduniformbufferinfo","text":"inline BufferInfo * findUniformBufferInfo( const std::string & name )","title":"function findUniformBufferInfo"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-findstoragebufferinfo","text":"inline BufferInfo * findStorageBufferInfo( const std::string & name )","title":"function findStorageBufferInfo"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-initbindings","text":"void initBindings( std::ifstream & in, ShaderStageFlags shaderStages )","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1ShaderModule/#function-initbindings_1","text":"void initBindings( const std::string & filename, ShaderStageFlags shaderStages )","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1ShaderModule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1ShaderModule/#variable-descriptors","text":"DescriptorInfos descriptors;","title":"variable descriptors"},{"location":"api/Classes/classngfx_1_1ShaderModule/#variable-uniformbufferinfos","text":"BufferInfos uniformBufferInfos;","title":"variable uniformBufferInfos"},{"location":"api/Classes/classngfx_1_1ShaderModule/#variable-shaderstoragebufferinfos","text":"BufferInfos shaderStorageBufferInfos; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable shaderStorageBufferInfos"},{"location":"api/Classes/classngfx_1_1ShaderTools/","text":"ngfx::ShaderTools Public Classes Name struct MacroDefinition Public Types Name enum @1 { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2} enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL} typedef std::vector< MacroDefinition > MacroDefinitions Public Functions Name ShaderTools (bool verbose =false) std::vector< std::string > compileShaders (const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0) std::vector< std::string > convertShaders (const std::vector< std::string > & files, std::string outDir, Format fmt) std::vector< std::string > generateShaderMaps (const std::vector< std::string > & files, std::string outDir, Format fmt) Public Types Documentation enum @1 Enumerator Value Description PATCH_SHADER_LAYOUTS_GLSL 1 REMOVE_UNUSED_VARIABLES 2 enum Format Enumerator Value Description FORMAT_GLSL FORMAT_HLSL FORMAT_MSL typedef MacroDefinitions typedef std::vector<MacroDefinition> ngfx::ShaderTools::MacroDefinitions; Public Functions Documentation function ShaderTools ShaderTools( bool verbose =false ) function compileShaders std::vector< std::string > compileShaders( const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0 ) function convertShaders std::vector< std::string > convertShaders( const std::vector< std::string > & files, std::string outDir, Format fmt ) function generateShaderMaps std::vector< std::string > generateShaderMaps( const std::vector< std::string > & files, std::string outDir, Format fmt ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ShaderTools"},{"location":"api/Classes/classngfx_1_1ShaderTools/#ngfxshadertools","text":"","title":"ngfx::ShaderTools"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-classes","text":"Name struct MacroDefinition","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-types","text":"Name enum @1 { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2} enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL} typedef std::vector< MacroDefinition > MacroDefinitions","title":"Public Types"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-functions","text":"Name ShaderTools (bool verbose =false) std::vector< std::string > compileShaders (const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0) std::vector< std::string > convertShaders (const std::vector< std::string > & files, std::string outDir, Format fmt) std::vector< std::string > generateShaderMaps (const std::vector< std::string > & files, std::string outDir, Format fmt)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1ShaderTools/#enum-1","text":"Enumerator Value Description PATCH_SHADER_LAYOUTS_GLSL 1 REMOVE_UNUSED_VARIABLES 2","title":"enum @1"},{"location":"api/Classes/classngfx_1_1ShaderTools/#enum-format","text":"Enumerator Value Description FORMAT_GLSL FORMAT_HLSL FORMAT_MSL","title":"enum Format"},{"location":"api/Classes/classngfx_1_1ShaderTools/#typedef-macrodefinitions","text":"typedef std::vector<MacroDefinition> ngfx::ShaderTools::MacroDefinitions;","title":"typedef MacroDefinitions"},{"location":"api/Classes/classngfx_1_1ShaderTools/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-shadertools","text":"ShaderTools( bool verbose =false )","title":"function ShaderTools"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-compileshaders","text":"std::vector< std::string > compileShaders( const std::vector< std::string > & files, std::string outDir, Format fmt =FORMAT_GLSL, const MacroDefinitions & defines ={}, int flags =0 )","title":"function compileShaders"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-convertshaders","text":"std::vector< std::string > convertShaders( const std::vector< std::string > & files, std::string outDir, Format fmt )","title":"function convertShaders"},{"location":"api/Classes/classngfx_1_1ShaderTools/#function-generateshadermaps","text":"std::vector< std::string > generateShaderMaps( const std::vector< std::string > & files, std::string outDir, Format fmt ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function generateShaderMaps"},{"location":"api/Classes/classngfx_1_1StringUtil/","text":"ngfx::StringUtil Public Functions Name std::string toLower (const std::string & str) std::wstring toWString (const std::string & str) Public Functions Documentation function toLower static std::string toLower( const std::string & str ) function toWString static std::wstring toWString( const std::string & str ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::StringUtil"},{"location":"api/Classes/classngfx_1_1StringUtil/#ngfxstringutil","text":"","title":"ngfx::StringUtil"},{"location":"api/Classes/classngfx_1_1StringUtil/#public-functions","text":"Name std::string toLower (const std::string & str) std::wstring toWString (const std::string & str)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1StringUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1StringUtil/#function-tolower","text":"static std::string toLower( const std::string & str )","title":"function toLower"},{"location":"api/Classes/classngfx_1_1StringUtil/#function-towstring","text":"static std::wstring toWString( const std::string & str ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function toWString"},{"location":"api/Classes/classngfx_1_1Surface/","text":"ngfx::Surface Inherited by ngfx::D3DSurface , ngfx::MTLSurface , ngfx::VKSurface Public Functions Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface () Public Attributes Name uint32_t w uint32_t h bool offscreen Public Functions Documentation function Surface inline Surface() function Surface inline Surface( uint32_t w, uint32_t h, bool offscreen =false ) function ~Surface inline virtual ~Surface() Public Attributes Documentation variable w uint32_t w = 0; variable h uint32_t h = 0; variable offscreen bool offscreen = false; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Surface"},{"location":"api/Classes/classngfx_1_1Surface/#ngfxsurface","text":"Inherited by ngfx::D3DSurface , ngfx::MTLSurface , ngfx::VKSurface","title":"ngfx::Surface"},{"location":"api/Classes/classngfx_1_1Surface/#public-functions","text":"Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Surface/#public-attributes","text":"Name uint32_t w uint32_t h bool offscreen","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Surface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Surface/#function-surface","text":"inline Surface()","title":"function Surface"},{"location":"api/Classes/classngfx_1_1Surface/#function-surface_1","text":"inline Surface( uint32_t w, uint32_t h, bool offscreen =false )","title":"function Surface"},{"location":"api/Classes/classngfx_1_1Surface/#function-surface_2","text":"inline virtual ~Surface()","title":"function ~Surface"},{"location":"api/Classes/classngfx_1_1Surface/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Surface/#variable-w","text":"uint32_t w = 0;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Surface/#variable-h","text":"uint32_t h = 0;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Surface/#variable-offscreen","text":"bool offscreen = false; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable offscreen"},{"location":"api/Classes/classngfx_1_1Swapchain/","text":"ngfx::Swapchain Inherited by ngfx::D3DSwapchain , ngfx::VKSwapchain Public Functions Name virtual ~Swapchain () virtual void acquireNextImage () =0 Public Attributes Name uint32_t numImages Public Functions Documentation function ~Swapchain inline virtual ~Swapchain() function acquireNextImage virtual void acquireNextImage() =0 Reimplemented by : ngfx::VKSwapchain::acquireNextImage , ngfx::D3DSwapchain::acquireNextImage Public Attributes Documentation variable numImages uint32_t numImages; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Swapchain"},{"location":"api/Classes/classngfx_1_1Swapchain/#ngfxswapchain","text":"Inherited by ngfx::D3DSwapchain , ngfx::VKSwapchain","title":"ngfx::Swapchain"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-functions","text":"Name virtual ~Swapchain () virtual void acquireNextImage () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-attributes","text":"Name uint32_t numImages","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Swapchain/#function-swapchain","text":"inline virtual ~Swapchain()","title":"function ~Swapchain"},{"location":"api/Classes/classngfx_1_1Swapchain/#function-acquirenextimage","text":"virtual void acquireNextImage() =0 Reimplemented by : ngfx::VKSwapchain::acquireNextImage , ngfx::D3DSwapchain::acquireNextImage","title":"function acquireNextImage"},{"location":"api/Classes/classngfx_1_1Swapchain/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Swapchain/#variable-numimages","text":"uint32_t numImages; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable numImages"},{"location":"api/Classes/classngfx_1_1Texture/","text":"ngfx::Texture Inherited by ngfx::D3DTexture , ngfx::MTLTexture , ngfx::VKTexture Public Functions Name Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT virtual ~Texture () virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) =0 virtual void generateMipmaps ( CommandBuffer * commandBuffer) =0 Public Attributes Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType Public Functions Documentation function create static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 ) function create static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 ) function ~Texture inline virtual ~Texture() function upload virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0 Reimplemented by : ngfx::MTLTexture::upload , ngfx::VKTexture::upload , ngfx::D3DTexture::upload function download virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0 Reimplemented by : ngfx::MTLTexture::download , ngfx::VKTexture::download , ngfx::D3DTexture::download function changeLayout virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) =0 Reimplemented by : ngfx::MTLTexture::changeLayout , ngfx::VKTexture::changeLayout , ngfx::D3DTexture::changeLayout function generateMipmaps virtual void generateMipmaps( CommandBuffer * commandBuffer ) =0 Reimplemented by : ngfx::MTLTexture::generateMipmaps , ngfx::VKTexture::generateMipmaps , ngfx::D3DTexture::generateMipmaps Public Attributes Documentation variable format PixelFormat format; variable w uint32_t w = 0; variable h uint32_t h = 0; variable d uint32_t d = 1; variable arrayLayers uint32_t arrayLayers = 1; variable mipLevels uint32_t mipLevels = 1; variable numSamples uint32_t numSamples = 1; variable imageUsageFlags ImageUsageFlags imageUsageFlags; variable textureType TextureType textureType; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Texture"},{"location":"api/Classes/classngfx_1_1Texture/#ngfxtexture","text":"Inherited by ngfx::D3DTexture , ngfx::MTLTexture , ngfx::VKTexture","title":"ngfx::Texture"},{"location":"api/Classes/classngfx_1_1Texture/#public-functions","text":"Name Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT Texture * create ( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT virtual ~Texture () virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) =0 virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) =0 virtual void generateMipmaps ( CommandBuffer * commandBuffer) =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Texture/#public-attributes","text":"Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Texture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Texture/#function-create","text":"static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, const char * filename, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1Texture/#function-create_1","text":"static Texture * create( GraphicsContext * graphicsContext, Graphics * graphics, void * data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags =ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT|IMAGE_USAGE_TRANSFER_SRC_BIT|IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType =TEXTURE_TYPE_2D, bool genMipmaps =false, FilterMode minFilter =FILTER_NEAREST, FilterMode magFilter =FILTER_NEAREST, FilterMode mipFilter =FILTER_NEAREST, uint32_t numSamples =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1Texture/#function-texture","text":"inline virtual ~Texture()","title":"function ~Texture"},{"location":"api/Classes/classngfx_1_1Texture/#function-upload","text":"virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0 Reimplemented by : ngfx::MTLTexture::upload , ngfx::VKTexture::upload , ngfx::D3DTexture::upload","title":"function upload"},{"location":"api/Classes/classngfx_1_1Texture/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) =0 Reimplemented by : ngfx::MTLTexture::download , ngfx::VKTexture::download , ngfx::D3DTexture::download","title":"function download"},{"location":"api/Classes/classngfx_1_1Texture/#function-changelayout","text":"virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) =0 Reimplemented by : ngfx::MTLTexture::changeLayout , ngfx::VKTexture::changeLayout , ngfx::D3DTexture::changeLayout","title":"function changeLayout"},{"location":"api/Classes/classngfx_1_1Texture/#function-generatemipmaps","text":"virtual void generateMipmaps( CommandBuffer * commandBuffer ) =0 Reimplemented by : ngfx::MTLTexture::generateMipmaps , ngfx::VKTexture::generateMipmaps , ngfx::D3DTexture::generateMipmaps","title":"function generateMipmaps"},{"location":"api/Classes/classngfx_1_1Texture/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Texture/#variable-format","text":"PixelFormat format;","title":"variable format"},{"location":"api/Classes/classngfx_1_1Texture/#variable-w","text":"uint32_t w = 0;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Texture/#variable-h","text":"uint32_t h = 0;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Texture/#variable-d","text":"uint32_t d = 1;","title":"variable d"},{"location":"api/Classes/classngfx_1_1Texture/#variable-arraylayers","text":"uint32_t arrayLayers = 1;","title":"variable arrayLayers"},{"location":"api/Classes/classngfx_1_1Texture/#variable-miplevels","text":"uint32_t mipLevels = 1;","title":"variable mipLevels"},{"location":"api/Classes/classngfx_1_1Texture/#variable-numsamples","text":"uint32_t numSamples = 1;","title":"variable numSamples"},{"location":"api/Classes/classngfx_1_1Texture/#variable-imageusageflags","text":"ImageUsageFlags imageUsageFlags;","title":"variable imageUsageFlags"},{"location":"api/Classes/classngfx_1_1Texture/#variable-texturetype","text":"TextureType textureType; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable textureType"},{"location":"api/Classes/classngfx_1_1Timer/","text":"ngfx::Timer Public Functions Name Timer () void update () Public Attributes Name float elapsed std::chrono::system_clock::time_point t0 Public Functions Documentation function Timer Timer() function update void update() Public Attributes Documentation variable elapsed float elapsed; variable t0 std::chrono::system_clock::time_point t0; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Timer"},{"location":"api/Classes/classngfx_1_1Timer/#ngfxtimer","text":"","title":"ngfx::Timer"},{"location":"api/Classes/classngfx_1_1Timer/#public-functions","text":"Name Timer () void update ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Timer/#public-attributes","text":"Name float elapsed std::chrono::system_clock::time_point t0","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Timer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Timer/#function-timer","text":"Timer()","title":"function Timer"},{"location":"api/Classes/classngfx_1_1Timer/#function-update","text":"void update()","title":"function update"},{"location":"api/Classes/classngfx_1_1Timer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Timer/#variable-elapsed","text":"float elapsed;","title":"variable elapsed"},{"location":"api/Classes/classngfx_1_1Timer/#variable-t0","text":"std::chrono::system_clock::time_point t0; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable t0"},{"location":"api/Classes/classngfx_1_1Util/","text":"ngfx::Util Public Functions Name template <typename T > bool contains (std::vector< T > & v, T item) uint64_t hash (const std::string & s) Public Functions Documentation function contains template <typename T > static inline bool contains( std::vector< T > & v, T item ) function hash static uint64_t hash( const std::string & s ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Util"},{"location":"api/Classes/classngfx_1_1Util/#ngfxutil","text":"","title":"ngfx::Util"},{"location":"api/Classes/classngfx_1_1Util/#public-functions","text":"Name template <typename T > bool contains (std::vector< T > & v, T item) uint64_t hash (const std::string & s)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Util/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Util/#function-contains","text":"template <typename T > static inline bool contains( std::vector< T > & v, T item )","title":"function contains"},{"location":"api/Classes/classngfx_1_1Util/#function-hash","text":"static uint64_t hash( const std::string & s ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function hash"},{"location":"api/Classes/classngfx_1_1VKBuffer/","text":"ngfx::VKBuffer Inherits from ngfx::Buffer Public Functions Name void create ( VKGraphicsContext * ctx, const void * data, uint32_t size, VkBufferUsageFlags bufferUsageFlags, VkMemoryPropertyFlags memoryPropertyFlags =VkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT virtual ~VKBuffer () virtual void * map () override virtual void unmap () override virtual void upload (const void * data, uint32_t size, uint32_t offset =0) override virtual void download (void * data, uint32_t size, uint32_t offset =0) override const VkDescriptorSet & getUboDescriptorSet (ShaderStageFlags shaderStageFlags) const VkDescriptorSet & getSsboDescriptorSet (ShaderStageFlags shaderStageFlags) Protected Functions Name void createBuffer (const void * data, uint32_t size, VkBufferUsageFlags bufferUsageFlags) void createMemory (VkMemoryPropertyFlags memoryPropertyFlags) void initDescriptorSet (VkDescriptorPool descriptorPool, VkDescriptorSetLayout descriptorSetLayout, VkDescriptorType descriptorType, VkDescriptorSet & descriptorSet) Public Attributes Name VkDeviceMemory memory VkBuffer v uint32_t size VkBufferCreateInfo createInfo VkMemoryAllocateInfo allocInfo VkDescriptorSet uboDescriptorSet VkDescriptorSet ssboDescriptorSet Protected Attributes Name VKGraphicsContext * ctx VkMemoryRequirements memReqs Additional inherited members Public Functions inherited from ngfx::Buffer Name virtual ~Buffer () Public Functions Documentation function create void create( VKGraphicsContext * ctx, const void * data, uint32_t size, VkBufferUsageFlags bufferUsageFlags, VkMemoryPropertyFlags memoryPropertyFlags =VkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) ) function ~VKBuffer virtual ~VKBuffer() function map virtual void * map() override Reimplements : ngfx::Buffer::map Map the buffer contents for CPU read/write access function unmap virtual void unmap() override Reimplements : ngfx::Buffer::unmap Unmap the buffer function upload virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::upload Upload the CPU data to the GPU buffer function download virtual void download( void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::download Download the GPU data to CPU-accessible memory function getUboDescriptorSet const VkDescriptorSet & getUboDescriptorSet( ShaderStageFlags shaderStageFlags ) function getSsboDescriptorSet const VkDescriptorSet & getSsboDescriptorSet( ShaderStageFlags shaderStageFlags ) Protected Functions Documentation function createBuffer void createBuffer( const void * data, uint32_t size, VkBufferUsageFlags bufferUsageFlags ) function createMemory void createMemory( VkMemoryPropertyFlags memoryPropertyFlags ) function initDescriptorSet void initDescriptorSet( VkDescriptorPool descriptorPool, VkDescriptorSetLayout descriptorSetLayout, VkDescriptorType descriptorType, VkDescriptorSet & descriptorSet ) Public Attributes Documentation variable memory VkDeviceMemory memory = VK_NULL_HANDLE; variable v VkBuffer v = VK_NULL_HANDLE; variable size uint32_t size; variable createInfo VkBufferCreateInfo createInfo; variable allocInfo VkMemoryAllocateInfo allocInfo; variable uboDescriptorSet VkDescriptorSet uboDescriptorSet = 0; variable ssboDescriptorSet VkDescriptorSet ssboDescriptorSet = 0; Protected Attributes Documentation variable ctx VKGraphicsContext * ctx; variable memReqs VkMemoryRequirements memReqs; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKBuffer"},{"location":"api/Classes/classngfx_1_1VKBuffer/#ngfxvkbuffer","text":"Inherits from ngfx::Buffer","title":"ngfx::VKBuffer"},{"location":"api/Classes/classngfx_1_1VKBuffer/#public-functions","text":"Name void create ( VKGraphicsContext * ctx, const void * data, uint32_t size, VkBufferUsageFlags bufferUsageFlags, VkMemoryPropertyFlags memoryPropertyFlags =VkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT virtual ~VKBuffer () virtual void * map () override virtual void unmap () override virtual void upload (const void * data, uint32_t size, uint32_t offset =0) override virtual void download (void * data, uint32_t size, uint32_t offset =0) override const VkDescriptorSet & getUboDescriptorSet (ShaderStageFlags shaderStageFlags) const VkDescriptorSet & getSsboDescriptorSet (ShaderStageFlags shaderStageFlags)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKBuffer/#protected-functions","text":"Name void createBuffer (const void * data, uint32_t size, VkBufferUsageFlags bufferUsageFlags) void createMemory (VkMemoryPropertyFlags memoryPropertyFlags) void initDescriptorSet (VkDescriptorPool descriptorPool, VkDescriptorSetLayout descriptorSetLayout, VkDescriptorType descriptorType, VkDescriptorSet & descriptorSet)","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1VKBuffer/#public-attributes","text":"Name VkDeviceMemory memory VkBuffer v uint32_t size VkBufferCreateInfo createInfo VkMemoryAllocateInfo allocInfo VkDescriptorSet uboDescriptorSet VkDescriptorSet ssboDescriptorSet","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKBuffer/#protected-attributes","text":"Name VKGraphicsContext * ctx VkMemoryRequirements memReqs","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1VKBuffer/#additional-inherited-members","text":"Public Functions inherited from ngfx::Buffer Name virtual ~Buffer ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-create","text":"void create( VKGraphicsContext * ctx, const void * data, uint32_t size, VkBufferUsageFlags bufferUsageFlags, VkMemoryPropertyFlags memoryPropertyFlags =VkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT|VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-vkbuffer","text":"virtual ~VKBuffer()","title":"function ~VKBuffer"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-map","text":"virtual void * map() override Reimplements : ngfx::Buffer::map Map the buffer contents for CPU read/write access","title":"function map"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-unmap","text":"virtual void unmap() override Reimplements : ngfx::Buffer::unmap Unmap the buffer","title":"function unmap"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-upload","text":"virtual void upload( const void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The buffer data size The size of the data (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::upload Upload the CPU data to the GPU buffer","title":"function upload"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t offset =0 ) override Parameters : data The destination address size The size of the data to download (in bytes) offset The destination offset (in bytes) Reimplements : ngfx::Buffer::download Download the GPU data to CPU-accessible memory","title":"function download"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-getubodescriptorset","text":"const VkDescriptorSet & getUboDescriptorSet( ShaderStageFlags shaderStageFlags )","title":"function getUboDescriptorSet"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-getssbodescriptorset","text":"const VkDescriptorSet & getSsboDescriptorSet( ShaderStageFlags shaderStageFlags )","title":"function getSsboDescriptorSet"},{"location":"api/Classes/classngfx_1_1VKBuffer/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-createbuffer","text":"void createBuffer( const void * data, uint32_t size, VkBufferUsageFlags bufferUsageFlags )","title":"function createBuffer"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-creatememory","text":"void createMemory( VkMemoryPropertyFlags memoryPropertyFlags )","title":"function createMemory"},{"location":"api/Classes/classngfx_1_1VKBuffer/#function-initdescriptorset","text":"void initDescriptorSet( VkDescriptorPool descriptorPool, VkDescriptorSetLayout descriptorSetLayout, VkDescriptorType descriptorType, VkDescriptorSet & descriptorSet )","title":"function initDescriptorSet"},{"location":"api/Classes/classngfx_1_1VKBuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKBuffer/#variable-memory","text":"VkDeviceMemory memory = VK_NULL_HANDLE;","title":"variable memory"},{"location":"api/Classes/classngfx_1_1VKBuffer/#variable-v","text":"VkBuffer v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKBuffer/#variable-size","text":"uint32_t size;","title":"variable size"},{"location":"api/Classes/classngfx_1_1VKBuffer/#variable-createinfo","text":"VkBufferCreateInfo createInfo;","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKBuffer/#variable-allocinfo","text":"VkMemoryAllocateInfo allocInfo;","title":"variable allocInfo"},{"location":"api/Classes/classngfx_1_1VKBuffer/#variable-ubodescriptorset","text":"VkDescriptorSet uboDescriptorSet = 0;","title":"variable uboDescriptorSet"},{"location":"api/Classes/classngfx_1_1VKBuffer/#variable-ssbodescriptorset","text":"VkDescriptorSet ssboDescriptorSet = 0;","title":"variable ssboDescriptorSet"},{"location":"api/Classes/classngfx_1_1VKBuffer/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKBuffer/#variable-ctx","text":"VKGraphicsContext * ctx;","title":"variable ctx"},{"location":"api/Classes/classngfx_1_1VKBuffer/#variable-memreqs","text":"VkMemoryRequirements memReqs; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable memReqs"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/","text":"ngfx::VKCommandBuffer Inherits from ngfx::CommandBuffer Public Functions Name void create (VkDevice device, VkCommandPool cmdPool, VkCommandBufferLevel level =VK_COMMAND_BUFFER_LEVEL_PRIMARY) virtual ~VKCommandBuffer () virtual void begin () virtual void end () Public Attributes Name VkCommandBuffer v VkCommandPool cmdPool VkCommandBufferAllocateInfo allocateInfo Additional inherited members Public Functions inherited from ngfx::CommandBuffer Name virtual ~CommandBuffer () Public Functions Documentation function create void create( VkDevice device, VkCommandPool cmdPool, VkCommandBufferLevel level =VK_COMMAND_BUFFER_LEVEL_PRIMARY ) function ~VKCommandBuffer virtual ~VKCommandBuffer() function begin virtual void begin() Reimplements : ngfx::CommandBuffer::begin Begin recording function end virtual void end() Reimplements : ngfx::CommandBuffer::end End recording Public Attributes Documentation variable v VkCommandBuffer v = VK_NULL_HANDLE; variable cmdPool VkCommandPool cmdPool; variable allocateInfo VkCommandBufferAllocateInfo allocateInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKCommandBuffer"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#ngfxvkcommandbuffer","text":"Inherits from ngfx::CommandBuffer","title":"ngfx::VKCommandBuffer"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#public-functions","text":"Name void create (VkDevice device, VkCommandPool cmdPool, VkCommandBufferLevel level =VK_COMMAND_BUFFER_LEVEL_PRIMARY) virtual ~VKCommandBuffer () virtual void begin () virtual void end ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#public-attributes","text":"Name VkCommandBuffer v VkCommandPool cmdPool VkCommandBufferAllocateInfo allocateInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#additional-inherited-members","text":"Public Functions inherited from ngfx::CommandBuffer Name virtual ~CommandBuffer ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#function-create","text":"void create( VkDevice device, VkCommandPool cmdPool, VkCommandBufferLevel level =VK_COMMAND_BUFFER_LEVEL_PRIMARY )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#function-vkcommandbuffer","text":"virtual ~VKCommandBuffer()","title":"function ~VKCommandBuffer"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#function-begin","text":"virtual void begin() Reimplements : ngfx::CommandBuffer::begin Begin recording","title":"function begin"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#function-end","text":"virtual void end() Reimplements : ngfx::CommandBuffer::end End recording","title":"function end"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#variable-v","text":"VkCommandBuffer v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#variable-cmdpool","text":"VkCommandPool cmdPool;","title":"variable cmdPool"},{"location":"api/Classes/classngfx_1_1VKCommandBuffer/#variable-allocateinfo","text":"VkCommandBufferAllocateInfo allocateInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable allocateInfo"},{"location":"api/Classes/classngfx_1_1VKCommandPool/","text":"ngfx::VKCommandPool Public Functions Name void create (VkDevice device, uint32_t queueFamilyIndex, VkCommandPoolCreateFlags createFlags =VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT) virtual ~VKCommandPool () Public Attributes Name VkCommandPool v VkCommandPoolCreateInfo createInfo Public Functions Documentation function create void create( VkDevice device, uint32_t queueFamilyIndex, VkCommandPoolCreateFlags createFlags =VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT ) function ~VKCommandPool virtual ~VKCommandPool() Public Attributes Documentation variable v VkCommandPool v = VK_NULL_HANDLE; variable createInfo VkCommandPoolCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKCommandPool"},{"location":"api/Classes/classngfx_1_1VKCommandPool/#ngfxvkcommandpool","text":"","title":"ngfx::VKCommandPool"},{"location":"api/Classes/classngfx_1_1VKCommandPool/#public-functions","text":"Name void create (VkDevice device, uint32_t queueFamilyIndex, VkCommandPoolCreateFlags createFlags =VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT) virtual ~VKCommandPool ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKCommandPool/#public-attributes","text":"Name VkCommandPool v VkCommandPoolCreateInfo createInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKCommandPool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKCommandPool/#function-create","text":"void create( VkDevice device, uint32_t queueFamilyIndex, VkCommandPoolCreateFlags createFlags =VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKCommandPool/#function-vkcommandpool","text":"virtual ~VKCommandPool()","title":"function ~VKCommandPool"},{"location":"api/Classes/classngfx_1_1VKCommandPool/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKCommandPool/#variable-v","text":"VkCommandPool v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKCommandPool/#variable-createinfo","text":"VkCommandPoolCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/","text":"ngfx::VKComputePipeline Inherits from ngfx::ComputePipeline , ngfx::VKPipeline , ngfx::Pipeline Public Functions Name void create ( VKGraphicsContext * ctx, const std::vector< VKPipeline::Descriptor > & descriptors, VkShaderModule shaderModule) Public Attributes Name VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo VkPipelineShaderStageCreateInfo shaderStageCreateInfo VkComputePipelineCreateInfo createInfo Additional inherited members Public Functions inherited from ngfx::ComputePipeline Name virtual ~ComputePipeline () Public Attributes inherited from ngfx::ComputePipeline Name std::vector< uint32_t > descriptorBindings Public Classes inherited from ngfx::VKPipeline Name struct Descriptor struct ShaderStage Public Functions inherited from ngfx::VKPipeline Name virtual ~VKPipeline () Public Attributes inherited from ngfx::VKPipeline Name VkPipeline v VkPipelineLayout pipelineLayout Protected Attributes inherited from ngfx::VKPipeline Name VkDevice device Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create void create( VKGraphicsContext * ctx, const std::vector< VKPipeline::Descriptor > & descriptors, VkShaderModule shaderModule ) Public Attributes Documentation variable pipelineLayoutCreateInfo VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo; variable shaderStageCreateInfo VkPipelineShaderStageCreateInfo shaderStageCreateInfo; variable createInfo VkComputePipelineCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKComputePipeline"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/#ngfxvkcomputepipeline","text":"Inherits from ngfx::ComputePipeline , ngfx::VKPipeline , ngfx::Pipeline","title":"ngfx::VKComputePipeline"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/#public-functions","text":"Name void create ( VKGraphicsContext * ctx, const std::vector< VKPipeline::Descriptor > & descriptors, VkShaderModule shaderModule)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/#public-attributes","text":"Name VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo VkPipelineShaderStageCreateInfo shaderStageCreateInfo VkComputePipelineCreateInfo createInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/#additional-inherited-members","text":"Public Functions inherited from ngfx::ComputePipeline Name virtual ~ComputePipeline () Public Attributes inherited from ngfx::ComputePipeline Name std::vector< uint32_t > descriptorBindings Public Classes inherited from ngfx::VKPipeline Name struct Descriptor struct ShaderStage Public Functions inherited from ngfx::VKPipeline Name virtual ~VKPipeline () Public Attributes inherited from ngfx::VKPipeline Name VkPipeline v VkPipelineLayout pipelineLayout Protected Attributes inherited from ngfx::VKPipeline Name VkDevice device Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/#function-create","text":"void create( VKGraphicsContext * ctx, const std::vector< VKPipeline::Descriptor > & descriptors, VkShaderModule shaderModule )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/#variable-pipelinelayoutcreateinfo","text":"VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo;","title":"variable pipelineLayoutCreateInfo"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/#variable-shaderstagecreateinfo","text":"VkPipelineShaderStageCreateInfo shaderStageCreateInfo;","title":"variable shaderStageCreateInfo"},{"location":"api/Classes/classngfx_1_1VKComputePipeline/#variable-createinfo","text":"VkComputePipelineCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKComputeShaderModule/","text":"ngfx::VKComputeShaderModule Inherits from ngfx::ComputeShaderModule , ngfx::VKShaderModule , ngfx::ShaderModule Public Functions Name virtual ~VKComputeShaderModule () Additional inherited members Public Functions inherited from ngfx::ComputeShaderModule Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::VKShaderModule Name virtual void initFromFile (VkDevice device, const std::string & filename) virtual ~VKShaderModule () Protected Functions inherited from ngfx::VKShaderModule Name virtual void initFromByteCode (VkDevice device, void * data, uint32_t size) Public Attributes inherited from ngfx::VKShaderModule Name VkShaderModule v Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function ~VKComputeShaderModule inline virtual ~VKComputeShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKComputeShaderModule"},{"location":"api/Classes/classngfx_1_1VKComputeShaderModule/#ngfxvkcomputeshadermodule","text":"Inherits from ngfx::ComputeShaderModule , ngfx::VKShaderModule , ngfx::ShaderModule","title":"ngfx::VKComputeShaderModule"},{"location":"api/Classes/classngfx_1_1VKComputeShaderModule/#public-functions","text":"Name virtual ~VKComputeShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKComputeShaderModule/#additional-inherited-members","text":"Public Functions inherited from ngfx::ComputeShaderModule Name std::unique_ptr< ComputeShaderModule > create ( Device * device, const std::string & filename) virtual ~ComputeShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::VKShaderModule Name virtual void initFromFile (VkDevice device, const std::string & filename) virtual ~VKShaderModule () Protected Functions inherited from ngfx::VKShaderModule Name virtual void initFromByteCode (VkDevice device, void * data, uint32_t size) Public Attributes inherited from ngfx::VKShaderModule Name VkShaderModule v Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKComputeShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKComputeShaderModule/#function-vkcomputeshadermodule","text":"inline virtual ~VKComputeShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~VKComputeShaderModule"},{"location":"api/Classes/classngfx_1_1VKDebugMessenger/","text":"ngfx::VKDebugMessenger Public Functions Name void create (VkInstance instance, VkDebugReportFlagsEXT flags =VK_DEBUG_REPORT_ERROR_BIT_EXT void destroy () const char * VkResultToString (VkResult errorCode) Public Attributes Name VKDebugMessenger inst Public Functions Documentation function create void create( VkInstance instance, VkDebugReportFlagsEXT flags =VK_DEBUG_REPORT_ERROR_BIT_EXT|VK_DEBUG_REPORT_WARNING_BIT_EXT ) function destroy void destroy() function VkResultToString const char * VkResultToString( VkResult errorCode ) Public Attributes Documentation variable inst static VKDebugMessenger inst; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKDebugMessenger"},{"location":"api/Classes/classngfx_1_1VKDebugMessenger/#ngfxvkdebugmessenger","text":"","title":"ngfx::VKDebugMessenger"},{"location":"api/Classes/classngfx_1_1VKDebugMessenger/#public-functions","text":"Name void create (VkInstance instance, VkDebugReportFlagsEXT flags =VK_DEBUG_REPORT_ERROR_BIT_EXT void destroy () const char * VkResultToString (VkResult errorCode)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKDebugMessenger/#public-attributes","text":"Name VKDebugMessenger inst","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKDebugMessenger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKDebugMessenger/#function-create","text":"void create( VkInstance instance, VkDebugReportFlagsEXT flags =VK_DEBUG_REPORT_ERROR_BIT_EXT|VK_DEBUG_REPORT_WARNING_BIT_EXT )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKDebugMessenger/#function-destroy","text":"void destroy()","title":"function destroy"},{"location":"api/Classes/classngfx_1_1VKDebugMessenger/#function-vkresulttostring","text":"const char * VkResultToString( VkResult errorCode )","title":"function VkResultToString"},{"location":"api/Classes/classngfx_1_1VKDebugMessenger/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKDebugMessenger/#variable-inst","text":"static VKDebugMessenger inst; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable inst"},{"location":"api/Classes/classngfx_1_1VKDescriptorSetLayoutCache/","text":"ngfx::VKDescriptorSetLayoutCache Public Functions Name void create (VkDevice device) VkDescriptorSetLayout get (VkDescriptorType type, VkShaderStageFlags stageFlags =VK_SHADER_STAGE_ALL) ~VKDescriptorSetLayoutCache () Public Functions Documentation function create void create( VkDevice device ) function get VkDescriptorSetLayout get( VkDescriptorType type, VkShaderStageFlags stageFlags =VK_SHADER_STAGE_ALL ) function ~VKDescriptorSetLayoutCache ~VKDescriptorSetLayoutCache() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKDescriptorSetLayoutCache"},{"location":"api/Classes/classngfx_1_1VKDescriptorSetLayoutCache/#ngfxvkdescriptorsetlayoutcache","text":"","title":"ngfx::VKDescriptorSetLayoutCache"},{"location":"api/Classes/classngfx_1_1VKDescriptorSetLayoutCache/#public-functions","text":"Name void create (VkDevice device) VkDescriptorSetLayout get (VkDescriptorType type, VkShaderStageFlags stageFlags =VK_SHADER_STAGE_ALL) ~VKDescriptorSetLayoutCache ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKDescriptorSetLayoutCache/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKDescriptorSetLayoutCache/#function-create","text":"void create( VkDevice device )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKDescriptorSetLayoutCache/#function-get","text":"VkDescriptorSetLayout get( VkDescriptorType type, VkShaderStageFlags stageFlags =VK_SHADER_STAGE_ALL )","title":"function get"},{"location":"api/Classes/classngfx_1_1VKDescriptorSetLayoutCache/#function-vkdescriptorsetlayoutcache","text":"~VKDescriptorSetLayoutCache() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~VKDescriptorSetLayoutCache"},{"location":"api/Classes/classngfx_1_1VKDevice/","text":"ngfx::VKDevice Inherits from ngfx::Device Public Functions Name void create ( VKPhysicalDevice * vkPhysicalDevice) virtual ~VKDevice () void waitIdle () Public Attributes Name std::vector< VkDeviceQueueCreateInfo > queueCreateInfos uint32_t graphics uint32_t compute uint32_t transfer struct ngfx::VKDevice::@3 queueFamilyIndices VkDevice v bool enableDebugMarkers std::vector< std::string > deviceExtensions VKPhysicalDevice * vkPhysicalDevice VkDeviceCreateInfo createInfo std::vector< const char * > enabledDeviceExtensions Public Functions Documentation function create void create( VKPhysicalDevice * vkPhysicalDevice ) function ~VKDevice virtual ~VKDevice() function waitIdle void waitIdle() Public Attributes Documentation variable queueCreateInfos std::vector< VkDeviceQueueCreateInfo > queueCreateInfos; variable graphics uint32_t graphics; variable compute uint32_t compute; variable transfer uint32_t transfer; variable queueFamilyIndices struct ngfx::VKDevice::@3 queueFamilyIndices; variable v VkDevice v = VK_NULL_HANDLE; variable enableDebugMarkers bool enableDebugMarkers = false; variable deviceExtensions std::vector< std::string > deviceExtensions; variable vkPhysicalDevice VKPhysicalDevice * vkPhysicalDevice; variable createInfo VkDeviceCreateInfo createInfo; variable enabledDeviceExtensions std::vector< const char * > enabledDeviceExtensions; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKDevice"},{"location":"api/Classes/classngfx_1_1VKDevice/#ngfxvkdevice","text":"Inherits from ngfx::Device","title":"ngfx::VKDevice"},{"location":"api/Classes/classngfx_1_1VKDevice/#public-functions","text":"Name void create ( VKPhysicalDevice * vkPhysicalDevice) virtual ~VKDevice () void waitIdle ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKDevice/#public-attributes","text":"Name std::vector< VkDeviceQueueCreateInfo > queueCreateInfos uint32_t graphics uint32_t compute uint32_t transfer struct ngfx::VKDevice::@3 queueFamilyIndices VkDevice v bool enableDebugMarkers std::vector< std::string > deviceExtensions VKPhysicalDevice * vkPhysicalDevice VkDeviceCreateInfo createInfo std::vector< const char * > enabledDeviceExtensions","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKDevice/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKDevice/#function-create","text":"void create( VKPhysicalDevice * vkPhysicalDevice )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKDevice/#function-vkdevice","text":"virtual ~VKDevice()","title":"function ~VKDevice"},{"location":"api/Classes/classngfx_1_1VKDevice/#function-waitidle","text":"void waitIdle()","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1VKDevice/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-queuecreateinfos","text":"std::vector< VkDeviceQueueCreateInfo > queueCreateInfos;","title":"variable queueCreateInfos"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-graphics","text":"uint32_t graphics;","title":"variable graphics"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-compute","text":"uint32_t compute;","title":"variable compute"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-transfer","text":"uint32_t transfer;","title":"variable transfer"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-queuefamilyindices","text":"struct ngfx::VKDevice::@3 queueFamilyIndices;","title":"variable queueFamilyIndices"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-v","text":"VkDevice v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-enabledebugmarkers","text":"bool enableDebugMarkers = false;","title":"variable enableDebugMarkers"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-deviceextensions","text":"std::vector< std::string > deviceExtensions;","title":"variable deviceExtensions"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-vkphysicaldevice","text":"VKPhysicalDevice * vkPhysicalDevice;","title":"variable vkPhysicalDevice"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-createinfo","text":"VkDeviceCreateInfo createInfo;","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKDevice/#variable-enableddeviceextensions","text":"std::vector< const char * > enabledDeviceExtensions; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable enabledDeviceExtensions"},{"location":"api/Classes/classngfx_1_1VKFence/","text":"ngfx::VKFence Inherits from ngfx::Fence Public Functions Name void create (VkDevice device, VkFenceCreateFlags flags =0) virtual ~VKFence () virtual void wait () virtual void reset () Public Attributes Name VkFence v VkFenceCreateInfo createInfo Additional inherited members Public Functions inherited from ngfx::Fence Name virtual ~Fence () Public Functions Documentation function create void create( VkDevice device, VkFenceCreateFlags flags =0 ) function ~VKFence virtual ~VKFence() function wait virtual void wait() Reimplements : ngfx::Fence::wait Wait for the fence to be signaled by the GPU function reset virtual void reset() Reimplements : ngfx::Fence::reset Reset the fence Public Attributes Documentation variable v VkFence v = VK_NULL_HANDLE; variable createInfo VkFenceCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKFence"},{"location":"api/Classes/classngfx_1_1VKFence/#ngfxvkfence","text":"Inherits from ngfx::Fence","title":"ngfx::VKFence"},{"location":"api/Classes/classngfx_1_1VKFence/#public-functions","text":"Name void create (VkDevice device, VkFenceCreateFlags flags =0) virtual ~VKFence () virtual void wait () virtual void reset ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKFence/#public-attributes","text":"Name VkFence v VkFenceCreateInfo createInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKFence/#additional-inherited-members","text":"Public Functions inherited from ngfx::Fence Name virtual ~Fence ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKFence/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKFence/#function-create","text":"void create( VkDevice device, VkFenceCreateFlags flags =0 )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKFence/#function-vkfence","text":"virtual ~VKFence()","title":"function ~VKFence"},{"location":"api/Classes/classngfx_1_1VKFence/#function-wait","text":"virtual void wait() Reimplements : ngfx::Fence::wait Wait for the fence to be signaled by the GPU","title":"function wait"},{"location":"api/Classes/classngfx_1_1VKFence/#function-reset","text":"virtual void reset() Reimplements : ngfx::Fence::reset Reset the fence","title":"function reset"},{"location":"api/Classes/classngfx_1_1VKFence/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKFence/#variable-v","text":"VkFence v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKFence/#variable-createinfo","text":"VkFenceCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKFragmentShaderModule/","text":"ngfx::VKFragmentShaderModule Inherits from ngfx::FragmentShaderModule , ngfx::VKShaderModule , ngfx::ShaderModule Public Functions Name virtual ~VKFragmentShaderModule () Additional inherited members Public Functions inherited from ngfx::FragmentShaderModule Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::VKShaderModule Name virtual void initFromFile (VkDevice device, const std::string & filename) virtual ~VKShaderModule () Protected Functions inherited from ngfx::VKShaderModule Name virtual void initFromByteCode (VkDevice device, void * data, uint32_t size) Public Attributes inherited from ngfx::VKShaderModule Name VkShaderModule v Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function ~VKFragmentShaderModule inline virtual ~VKFragmentShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKFragmentShaderModule"},{"location":"api/Classes/classngfx_1_1VKFragmentShaderModule/#ngfxvkfragmentshadermodule","text":"Inherits from ngfx::FragmentShaderModule , ngfx::VKShaderModule , ngfx::ShaderModule","title":"ngfx::VKFragmentShaderModule"},{"location":"api/Classes/classngfx_1_1VKFragmentShaderModule/#public-functions","text":"Name virtual ~VKFragmentShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKFragmentShaderModule/#additional-inherited-members","text":"Public Functions inherited from ngfx::FragmentShaderModule Name std::unique_ptr< FragmentShaderModule > create ( Device * device, const std::string & filename) virtual ~FragmentShaderModule () void initBindings (const std::string & filename) Public Functions inherited from ngfx::VKShaderModule Name virtual void initFromFile (VkDevice device, const std::string & filename) virtual ~VKShaderModule () Protected Functions inherited from ngfx::VKShaderModule Name virtual void initFromByteCode (VkDevice device, void * data, uint32_t size) Public Attributes inherited from ngfx::VKShaderModule Name VkShaderModule v Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKFragmentShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKFragmentShaderModule/#function-vkfragmentshadermodule","text":"inline virtual ~VKFragmentShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~VKFragmentShaderModule"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/","text":"ngfx::VKFramebuffer Inherits from ngfx::Framebuffer Public Classes Name struct VKAttachmentDescriptor struct VKAttachmentInfo Public Functions Name void create (VkDevice device, VkRenderPass renderPass, const std::vector< VKAttachmentDescriptor > & attachments, uint32_t w, uint32_t h, uint32_t layers =1) virtual ~VKFramebuffer () Public Attributes Name VkFramebuffer v std::vector< VkImageView > vkAttachments std::vector< VKAttachmentInfo > vkAttachmentInfos VkFramebufferCreateInfo createInfo Additional inherited members Public Classes inherited from ngfx::Framebuffer Name struct Attachment Public Functions inherited from ngfx::Framebuffer Name virtual ~Framebuffer () Public Attributes inherited from ngfx::Framebuffer Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments Public Functions Documentation function create void create( VkDevice device, VkRenderPass renderPass, const std::vector< VKAttachmentDescriptor > & attachments, uint32_t w, uint32_t h, uint32_t layers =1 ) function ~VKFramebuffer virtual ~VKFramebuffer() Public Attributes Documentation variable v VkFramebuffer v = VK_NULL_HANDLE; variable vkAttachments std::vector< VkImageView > vkAttachments; variable vkAttachmentInfos std::vector< VKAttachmentInfo > vkAttachmentInfos; variable createInfo VkFramebufferCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKFramebuffer"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#ngfxvkframebuffer","text":"Inherits from ngfx::Framebuffer","title":"ngfx::VKFramebuffer"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#public-classes","text":"Name struct VKAttachmentDescriptor struct VKAttachmentInfo","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#public-functions","text":"Name void create (VkDevice device, VkRenderPass renderPass, const std::vector< VKAttachmentDescriptor > & attachments, uint32_t w, uint32_t h, uint32_t layers =1) virtual ~VKFramebuffer ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#public-attributes","text":"Name VkFramebuffer v std::vector< VkImageView > vkAttachments std::vector< VKAttachmentInfo > vkAttachmentInfos VkFramebufferCreateInfo createInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#additional-inherited-members","text":"Public Classes inherited from ngfx::Framebuffer Name struct Attachment Public Functions inherited from ngfx::Framebuffer Name virtual ~Framebuffer () Public Attributes inherited from ngfx::Framebuffer Name uint32_t w uint32_t h uint32_t layers uint32_t numAttachments std::vector< Attachment > attachments","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#function-create","text":"void create( VkDevice device, VkRenderPass renderPass, const std::vector< VKAttachmentDescriptor > & attachments, uint32_t w, uint32_t h, uint32_t layers =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#function-vkframebuffer","text":"virtual ~VKFramebuffer()","title":"function ~VKFramebuffer"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#variable-v","text":"VkFramebuffer v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#variable-vkattachments","text":"std::vector< VkImageView > vkAttachments;","title":"variable vkAttachments"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#variable-vkattachmentinfos","text":"std::vector< VKAttachmentInfo > vkAttachmentInfos;","title":"variable vkAttachmentInfos"},{"location":"api/Classes/classngfx_1_1VKFramebuffer/#variable-createinfo","text":"VkFramebufferCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKGraphics/","text":"ngfx::VKGraphics Inherits from ngfx::Graphics Public Functions Name void create () virtual ~VKGraphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) override virtual void endComputePass ( CommandBuffer * commandBuffer) override virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) override virtual void endRenderPass ( CommandBuffer * commandBuffer) override virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) override virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat) override virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) override virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) override virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) override virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) override virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) override virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void waitIdle ( CommandBuffer * cmdBuffer) override Additional inherited members Public Functions inherited from ngfx::Graphics Name virtual ~Graphics () Public Attributes inherited from ngfx::Graphics Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer Protected Attributes inherited from ngfx::Graphics Name GraphicsContext * ctx Public Functions Documentation function create inline void create() function ~VKGraphics inline virtual ~VKGraphics() function beginComputePass inline virtual void beginComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::beginComputePass function endComputePass inline virtual void endComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endComputePass function beginRenderPass virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) override Reimplements : ngfx::Graphics::beginRenderPass function endRenderPass virtual void endRenderPass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endRenderPass function bindVertexBuffer virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) override Reimplements : ngfx::Graphics::bindVertexBuffer function bindIndexBuffer virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat ) override Reimplements : ngfx::Graphics::bindIndexBuffer function bindUniformBuffer virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindUniformBuffer function bindStorageBuffer virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindStorageBuffer function bindComputePipeline virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) override Reimplements : ngfx::Graphics::bindComputePipeline function bindGraphicsPipeline virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) override Reimplements : ngfx::Graphics::bindGraphicsPipeline function bindTexture virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) override Reimplements : ngfx::Graphics::bindTexture function dispatch virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) override Reimplements : ngfx::Graphics::dispatch function draw virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::draw function drawIndexed virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::drawIndexed function setViewport virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setViewport function setScissor virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setScissor function waitIdle virtual void waitIdle( CommandBuffer * cmdBuffer ) override Reimplements : ngfx::Graphics::waitIdle Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKGraphics"},{"location":"api/Classes/classngfx_1_1VKGraphics/#ngfxvkgraphics","text":"Inherits from ngfx::Graphics","title":"ngfx::VKGraphics"},{"location":"api/Classes/classngfx_1_1VKGraphics/#public-functions","text":"Name void create () virtual ~VKGraphics () virtual void beginComputePass ( CommandBuffer * commandBuffer) override virtual void endComputePass ( CommandBuffer * commandBuffer) override virtual void beginRenderPass ( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0) override virtual void endRenderPass ( CommandBuffer * commandBuffer) override virtual void bindVertexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride) override virtual void bindIndexBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat) override virtual void bindUniformBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindStorageBuffer ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override virtual void bindComputePipeline ( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline) override virtual void bindGraphicsPipeline ( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline) override virtual void bindTexture ( CommandBuffer * commandBuffer, Texture * texture, uint32_t set) override virtual void dispatch ( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override virtual void draw ( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0) override virtual void drawIndexed ( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0) override virtual void setViewport ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void setScissor ( CommandBuffer * cmdBuffer, Rect2D rect) override virtual void waitIdle ( CommandBuffer * cmdBuffer) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKGraphics/#additional-inherited-members","text":"Public Functions inherited from ngfx::Graphics Name virtual ~Graphics () Public Attributes inherited from ngfx::Graphics Name Rect2D scissorRect Rect2D viewport Pipeline * currentPipeline RenderPass * currentRenderPass Framebuffer * currentFramebuffer Protected Attributes inherited from ngfx::Graphics Name GraphicsContext * ctx","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKGraphics/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-create","text":"inline void create()","title":"function create"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-vkgraphics","text":"inline virtual ~VKGraphics()","title":"function ~VKGraphics"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-begincomputepass","text":"inline virtual void beginComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::beginComputePass","title":"function beginComputePass"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-endcomputepass","text":"inline virtual void endComputePass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endComputePass","title":"function endComputePass"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-beginrenderpass","text":"virtual void beginRenderPass( CommandBuffer * commandBuffer, RenderPass * renderPass, Framebuffer * framebuffer, glm::vec4 clearColor =glm::vec4(0.0f), float clearDepth =1.0f, uint32_t clearStencil =0 ) override Reimplements : ngfx::Graphics::beginRenderPass","title":"function beginRenderPass"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-endrenderpass","text":"virtual void endRenderPass( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Graphics::endRenderPass","title":"function endRenderPass"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-bindvertexbuffer","text":"virtual void bindVertexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t location, uint32_t stride ) override Reimplements : ngfx::Graphics::bindVertexBuffer","title":"function bindVertexBuffer"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-bindindexbuffer","text":"virtual void bindIndexBuffer( CommandBuffer * commandBuffer, Buffer * buffer, IndexFormat indexFormat ) override Reimplements : ngfx::Graphics::bindIndexBuffer","title":"function bindIndexBuffer"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-binduniformbuffer","text":"virtual void bindUniformBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindUniformBuffer","title":"function bindUniformBuffer"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-bindstoragebuffer","text":"virtual void bindStorageBuffer( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t binding, ShaderStageFlags shaderStageFlags ) override Reimplements : ngfx::Graphics::bindStorageBuffer","title":"function bindStorageBuffer"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-bindcomputepipeline","text":"virtual void bindComputePipeline( CommandBuffer * cmdBuffer, ComputePipeline * computePipeline ) override Reimplements : ngfx::Graphics::bindComputePipeline","title":"function bindComputePipeline"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-bindgraphicspipeline","text":"virtual void bindGraphicsPipeline( CommandBuffer * cmdBuffer, GraphicsPipeline * graphicsPipeline ) override Reimplements : ngfx::Graphics::bindGraphicsPipeline","title":"function bindGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-bindtexture","text":"virtual void bindTexture( CommandBuffer * commandBuffer, Texture * texture, uint32_t set ) override Reimplements : ngfx::Graphics::bindTexture","title":"function bindTexture"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-dispatch","text":"virtual void dispatch( CommandBuffer * cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ ) override Reimplements : ngfx::Graphics::dispatch","title":"function dispatch"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-draw","text":"virtual void draw( CommandBuffer * cmdBuffer, uint32_t vertexCount, uint32_t instanceCount =1, uint32_t firstVertex =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::draw","title":"function draw"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-drawindexed","text":"virtual void drawIndexed( CommandBuffer * cmdBuffer, uint32_t indexCount, uint32_t instanceCount =1, uint32_t firstIndex =0, int32_t vertexOffset =0, uint32_t firstInstance =0 ) override Reimplements : ngfx::Graphics::drawIndexed","title":"function drawIndexed"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-setviewport","text":"virtual void setViewport( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setViewport","title":"function setViewport"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-setscissor","text":"virtual void setScissor( CommandBuffer * cmdBuffer, Rect2D rect ) override Reimplements : ngfx::Graphics::setScissor","title":"function setScissor"},{"location":"api/Classes/classngfx_1_1VKGraphics/#function-waitidle","text":"virtual void waitIdle( CommandBuffer * cmdBuffer ) override Reimplements : ngfx::Graphics::waitIdle Updated on 3 April 2021 at 20:21:51 PDT","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/","text":"ngfx::VKGraphicsContext Inherits from ngfx::GraphicsContext Public Classes Name struct VKRenderPassData Public Functions Name void create (const char * appName, bool enableDepthStencil, bool debug) virtual ~VKGraphicsContext () virtual void setSurface ( Surface * surface) override virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) override virtual CommandBuffer * copyCommandBuffer () override virtual CommandBuffer * computeCommandBuffer () override void createBindings () virtual RenderPass * getRenderPass ( RenderPassConfig config) override Public Attributes Name VKInstance vkInstance VKPhysicalDevice vkPhysicalDevice VKDevice vkDevice VKCommandPool vkCommandPool VKQueue vkQueue std::unique_ptr< VKSwapchain > vkSwapchain std::vector< VKCommandBuffer > vkDrawCommandBuffers VKCommandBuffer vkCopyCommandBuffer VKCommandBuffer vkComputeCommandBuffer VKImage vkDepthStencilImage VKImage vkMultisampleColorImage VKImage vkMultisampleDepthImage VKImageView vkDepthStencilImageView VKImageView vkMultisampleColorImageView VKImageView vkMultisampleDepthImageView std::vector< std::unique_ptr< VKRenderPassData > > vkRenderPassCache VKRenderPass * vkDefaultRenderPass VKRenderPass * vkDefaultOffscreenRenderPass VKPipelineCache vkPipelineCache std::vector< VKFramebuffer > vkSwapchainFramebuffers std::vector< VKFence > vkWaitFences VKFence vkComputeFence VKSemaphore vkPresentCompleteSemaphore VKSemaphore vkRenderCompleteSemaphore VkDescriptorPool vkDescriptorPool VKDescriptorSetLayoutCache vkDescriptorSetLayoutCache bool offscreen uint32_t numSamples std::vector< VkDescriptorPoolSize > descriptorPoolSizes VkDescriptorPoolCreateInfo descriptorPoolCreateInfo VKImageCreateInfo msColorImageCreateInfo VKImageCreateInfo msDepthImageCreateInfo Additional inherited members Public Classes inherited from ngfx::GraphicsContext Name struct AttachmentDescription struct RenderPassConfig Public Functions inherited from ngfx::GraphicsContext Name virtual ~GraphicsContext () virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void submit ( CommandBuffer * commandBuffer) Public Attributes inherited from ngfx::GraphicsContext Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor Protected Attributes inherited from ngfx::GraphicsContext Name bool debug bool enableDepthStencil Public Functions Documentation function create void create( const char * appName, bool enableDepthStencil, bool debug ) function ~VKGraphicsContext virtual ~VKGraphicsContext() function setSurface virtual void setSurface( Surface * surface ) override Reimplements : ngfx::GraphicsContext::setSurface function drawCommandBuffer virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) override Reimplements : ngfx::GraphicsContext::drawCommandBuffer function copyCommandBuffer virtual CommandBuffer * copyCommandBuffer() override Reimplements : ngfx::GraphicsContext::copyCommandBuffer function computeCommandBuffer virtual CommandBuffer * computeCommandBuffer() override Reimplements : ngfx::GraphicsContext::computeCommandBuffer function createBindings void createBindings() function getRenderPass virtual RenderPass * getRenderPass( RenderPassConfig config ) override Reimplements : ngfx::GraphicsContext::getRenderPass Public Attributes Documentation variable vkInstance VKInstance vkInstance; variable vkPhysicalDevice VKPhysicalDevice vkPhysicalDevice; variable vkDevice VKDevice vkDevice; variable vkCommandPool VKCommandPool vkCommandPool; variable vkQueue VKQueue vkQueue; variable vkSwapchain std::unique_ptr< VKSwapchain > vkSwapchain; variable vkDrawCommandBuffers std::vector< VKCommandBuffer > vkDrawCommandBuffers; variable vkCopyCommandBuffer VKCommandBuffer vkCopyCommandBuffer; variable vkComputeCommandBuffer VKCommandBuffer vkComputeCommandBuffer; variable vkDepthStencilImage VKImage vkDepthStencilImage; variable vkMultisampleColorImage VKImage vkMultisampleColorImage; variable vkMultisampleDepthImage VKImage vkMultisampleDepthImage; variable vkDepthStencilImageView VKImageView vkDepthStencilImageView; variable vkMultisampleColorImageView VKImageView vkMultisampleColorImageView; variable vkMultisampleDepthImageView VKImageView vkMultisampleDepthImageView; variable vkRenderPassCache std::vector< std::unique_ptr< VKRenderPassData > > vkRenderPassCache; variable vkDefaultRenderPass VKRenderPass * vkDefaultRenderPass = nullptr; variable vkDefaultOffscreenRenderPass VKRenderPass * vkDefaultOffscreenRenderPass = nullptr; variable vkPipelineCache VKPipelineCache vkPipelineCache; variable vkSwapchainFramebuffers std::vector< VKFramebuffer > vkSwapchainFramebuffers; variable vkWaitFences std::vector< VKFence > vkWaitFences; variable vkComputeFence VKFence vkComputeFence; variable vkPresentCompleteSemaphore VKSemaphore vkPresentCompleteSemaphore; variable vkRenderCompleteSemaphore VKSemaphore vkRenderCompleteSemaphore; variable vkDescriptorPool VkDescriptorPool vkDescriptorPool; variable vkDescriptorSetLayoutCache VKDescriptorSetLayoutCache vkDescriptorSetLayoutCache; variable offscreen bool offscreen = true; variable numSamples uint32_t numSamples = 1; variable descriptorPoolSizes std::vector< VkDescriptorPoolSize > descriptorPoolSizes; variable descriptorPoolCreateInfo VkDescriptorPoolCreateInfo descriptorPoolCreateInfo; variable msColorImageCreateInfo VKImageCreateInfo msColorImageCreateInfo; variable msDepthImageCreateInfo VKImageCreateInfo msDepthImageCreateInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKGraphicsContext"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#ngfxvkgraphicscontext","text":"Inherits from ngfx::GraphicsContext","title":"ngfx::VKGraphicsContext"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#public-classes","text":"Name struct VKRenderPassData","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#public-functions","text":"Name void create (const char * appName, bool enableDepthStencil, bool debug) virtual ~VKGraphicsContext () virtual void setSurface ( Surface * surface) override virtual CommandBuffer * drawCommandBuffer (int32_t index =-1) override virtual CommandBuffer * copyCommandBuffer () override virtual CommandBuffer * computeCommandBuffer () override void createBindings () virtual RenderPass * getRenderPass ( RenderPassConfig config) override","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#public-attributes","text":"Name VKInstance vkInstance VKPhysicalDevice vkPhysicalDevice VKDevice vkDevice VKCommandPool vkCommandPool VKQueue vkQueue std::unique_ptr< VKSwapchain > vkSwapchain std::vector< VKCommandBuffer > vkDrawCommandBuffers VKCommandBuffer vkCopyCommandBuffer VKCommandBuffer vkComputeCommandBuffer VKImage vkDepthStencilImage VKImage vkMultisampleColorImage VKImage vkMultisampleDepthImage VKImageView vkDepthStencilImageView VKImageView vkMultisampleColorImageView VKImageView vkMultisampleDepthImageView std::vector< std::unique_ptr< VKRenderPassData > > vkRenderPassCache VKRenderPass * vkDefaultRenderPass VKRenderPass * vkDefaultOffscreenRenderPass VKPipelineCache vkPipelineCache std::vector< VKFramebuffer > vkSwapchainFramebuffers std::vector< VKFence > vkWaitFences VKFence vkComputeFence VKSemaphore vkPresentCompleteSemaphore VKSemaphore vkRenderCompleteSemaphore VkDescriptorPool vkDescriptorPool VKDescriptorSetLayoutCache vkDescriptorSetLayoutCache bool offscreen uint32_t numSamples std::vector< VkDescriptorPoolSize > descriptorPoolSizes VkDescriptorPoolCreateInfo descriptorPoolCreateInfo VKImageCreateInfo msColorImageCreateInfo VKImageCreateInfo msDepthImageCreateInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#additional-inherited-members","text":"Public Classes inherited from ngfx::GraphicsContext Name struct AttachmentDescription struct RenderPassConfig Public Functions inherited from ngfx::GraphicsContext Name virtual ~GraphicsContext () virtual void beginRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void beginOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics, Framebuffer * outputFramebuffer) virtual void endRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void endOffscreenRenderPass ( CommandBuffer * commandBuffer, Graphics * graphics) virtual void submit ( CommandBuffer * commandBuffer) Public Attributes inherited from ngfx::GraphicsContext Name Device * device uint32_t numDrawCommandBuffers std::vector< Framebuffer * > swapchainFramebuffers Queue * queue RenderPass * defaultRenderPass RenderPass * defaultOffscreenRenderPass Swapchain * swapchain Surface * surface uint32_t currentImageIndex std::vector< Fence * > frameFences Fence * computeFence Semaphore * presentCompleteSemaphore Semaphore * renderCompleteSemaphore PipelineCache * pipelineCache PixelFormat surfaceFormat PixelFormat defaultOffscreenSurfaceFormat PixelFormat depthFormat glm::vec4 clearColor Protected Attributes inherited from ngfx::GraphicsContext Name bool debug bool enableDepthStencil","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#function-create","text":"void create( const char * appName, bool enableDepthStencil, bool debug )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#function-vkgraphicscontext","text":"virtual ~VKGraphicsContext()","title":"function ~VKGraphicsContext"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#function-setsurface","text":"virtual void setSurface( Surface * surface ) override Reimplements : ngfx::GraphicsContext::setSurface","title":"function setSurface"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#function-drawcommandbuffer","text":"virtual CommandBuffer * drawCommandBuffer( int32_t index =-1 ) override Reimplements : ngfx::GraphicsContext::drawCommandBuffer","title":"function drawCommandBuffer"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#function-copycommandbuffer","text":"virtual CommandBuffer * copyCommandBuffer() override Reimplements : ngfx::GraphicsContext::copyCommandBuffer","title":"function copyCommandBuffer"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#function-computecommandbuffer","text":"virtual CommandBuffer * computeCommandBuffer() override Reimplements : ngfx::GraphicsContext::computeCommandBuffer","title":"function computeCommandBuffer"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#function-createbindings","text":"void createBindings()","title":"function createBindings"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#function-getrenderpass","text":"virtual RenderPass * getRenderPass( RenderPassConfig config ) override Reimplements : ngfx::GraphicsContext::getRenderPass","title":"function getRenderPass"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkinstance","text":"VKInstance vkInstance;","title":"variable vkInstance"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkphysicaldevice","text":"VKPhysicalDevice vkPhysicalDevice;","title":"variable vkPhysicalDevice"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkdevice","text":"VKDevice vkDevice;","title":"variable vkDevice"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkcommandpool","text":"VKCommandPool vkCommandPool;","title":"variable vkCommandPool"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkqueue","text":"VKQueue vkQueue;","title":"variable vkQueue"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkswapchain","text":"std::unique_ptr< VKSwapchain > vkSwapchain;","title":"variable vkSwapchain"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkdrawcommandbuffers","text":"std::vector< VKCommandBuffer > vkDrawCommandBuffers;","title":"variable vkDrawCommandBuffers"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkcopycommandbuffer","text":"VKCommandBuffer vkCopyCommandBuffer;","title":"variable vkCopyCommandBuffer"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkcomputecommandbuffer","text":"VKCommandBuffer vkComputeCommandBuffer;","title":"variable vkComputeCommandBuffer"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkdepthstencilimage","text":"VKImage vkDepthStencilImage;","title":"variable vkDepthStencilImage"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkmultisamplecolorimage","text":"VKImage vkMultisampleColorImage;","title":"variable vkMultisampleColorImage"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkmultisampledepthimage","text":"VKImage vkMultisampleDepthImage;","title":"variable vkMultisampleDepthImage"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkdepthstencilimageview","text":"VKImageView vkDepthStencilImageView;","title":"variable vkDepthStencilImageView"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkmultisamplecolorimageview","text":"VKImageView vkMultisampleColorImageView;","title":"variable vkMultisampleColorImageView"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkmultisampledepthimageview","text":"VKImageView vkMultisampleDepthImageView;","title":"variable vkMultisampleDepthImageView"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkrenderpasscache","text":"std::vector< std::unique_ptr< VKRenderPassData > > vkRenderPassCache;","title":"variable vkRenderPassCache"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkdefaultrenderpass","text":"VKRenderPass * vkDefaultRenderPass = nullptr;","title":"variable vkDefaultRenderPass"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkdefaultoffscreenrenderpass","text":"VKRenderPass * vkDefaultOffscreenRenderPass = nullptr;","title":"variable vkDefaultOffscreenRenderPass"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkpipelinecache","text":"VKPipelineCache vkPipelineCache;","title":"variable vkPipelineCache"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkswapchainframebuffers","text":"std::vector< VKFramebuffer > vkSwapchainFramebuffers;","title":"variable vkSwapchainFramebuffers"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkwaitfences","text":"std::vector< VKFence > vkWaitFences;","title":"variable vkWaitFences"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkcomputefence","text":"VKFence vkComputeFence;","title":"variable vkComputeFence"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkpresentcompletesemaphore","text":"VKSemaphore vkPresentCompleteSemaphore;","title":"variable vkPresentCompleteSemaphore"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkrendercompletesemaphore","text":"VKSemaphore vkRenderCompleteSemaphore;","title":"variable vkRenderCompleteSemaphore"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkdescriptorpool","text":"VkDescriptorPool vkDescriptorPool;","title":"variable vkDescriptorPool"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-vkdescriptorsetlayoutcache","text":"VKDescriptorSetLayoutCache vkDescriptorSetLayoutCache;","title":"variable vkDescriptorSetLayoutCache"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-offscreen","text":"bool offscreen = true;","title":"variable offscreen"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-numsamples","text":"uint32_t numSamples = 1;","title":"variable numSamples"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-descriptorpoolsizes","text":"std::vector< VkDescriptorPoolSize > descriptorPoolSizes;","title":"variable descriptorPoolSizes"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-descriptorpoolcreateinfo","text":"VkDescriptorPoolCreateInfo descriptorPoolCreateInfo;","title":"variable descriptorPoolCreateInfo"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-mscolorimagecreateinfo","text":"VKImageCreateInfo msColorImageCreateInfo;","title":"variable msColorImageCreateInfo"},{"location":"api/Classes/classngfx_1_1VKGraphicsContext/#variable-msdepthimagecreateinfo","text":"VKImageCreateInfo msDepthImageCreateInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable msDepthImageCreateInfo"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/","text":"ngfx::VKGraphicsPipeline Inherits from ngfx::GraphicsPipeline , ngfx::VKPipeline , ngfx::Pipeline Public Classes Name struct State Public Functions Name void create ( VKGraphicsContext * ctx, const State & state, const std::vector< VKPipeline::Descriptor > & descriptors, const std::vector< VkVertexInputBindingDescription > & vertexInputBindings, const std::vector< VkVertexInputAttributeDescription > & vertexInputAttributes, const std::vector< VKPipeline::ShaderStage > & shaderStages, VkFormat colorFormat) virtual ~VKGraphicsPipeline () Public Attributes Name VkPipelineInputAssemblyStateCreateInfo inputAssemblyState VkPipelineRasterizationStateCreateInfo rasterizationState std::vector< VkPipelineColorBlendAttachmentState > blendAttachmentState VkPipelineColorBlendStateCreateInfo colorBlendState VkPipelineViewportStateCreateInfo viewportState std::vector< VkDynamicState > dynamicStateEnables VkPipelineDynamicStateCreateInfo dynamicState VkPipelineDepthStencilStateCreateInfo depthStencilState VkPipelineMultisampleStateCreateInfo multisampleState VkPipelineVertexInputStateCreateInfo vertexInputState std::vector< VkPipelineShaderStageCreateInfo > vkShaderStages std::vector< VkDescriptorSetLayout > descriptorSetLayouts VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo VkGraphicsPipelineCreateInfo createInfo Additional inherited members Public Classes inherited from ngfx::GraphicsPipeline Name struct Descriptor struct State Public Functions inherited from ngfx::GraphicsPipeline Name virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings) Public Attributes inherited from ngfx::GraphicsPipeline Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings Public Classes inherited from ngfx::VKPipeline Name struct Descriptor struct ShaderStage Public Functions inherited from ngfx::VKPipeline Name virtual ~VKPipeline () Public Attributes inherited from ngfx::VKPipeline Name VkPipeline v VkPipelineLayout pipelineLayout Protected Attributes inherited from ngfx::VKPipeline Name VkDevice device Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline () Public Functions Documentation function create void create( VKGraphicsContext * ctx, const State & state, const std::vector< VKPipeline::Descriptor > & descriptors, const std::vector< VkVertexInputBindingDescription > & vertexInputBindings, const std::vector< VkVertexInputAttributeDescription > & vertexInputAttributes, const std::vector< VKPipeline::ShaderStage > & shaderStages, VkFormat colorFormat ) function ~VKGraphicsPipeline inline virtual ~VKGraphicsPipeline() Public Attributes Documentation variable inputAssemblyState VkPipelineInputAssemblyStateCreateInfo inputAssemblyState; variable rasterizationState VkPipelineRasterizationStateCreateInfo rasterizationState; variable blendAttachmentState std::vector< VkPipelineColorBlendAttachmentState > blendAttachmentState; variable colorBlendState VkPipelineColorBlendStateCreateInfo colorBlendState; variable viewportState VkPipelineViewportStateCreateInfo viewportState; variable dynamicStateEnables std::vector< VkDynamicState > dynamicStateEnables; variable dynamicState VkPipelineDynamicStateCreateInfo dynamicState; variable depthStencilState VkPipelineDepthStencilStateCreateInfo depthStencilState; variable multisampleState VkPipelineMultisampleStateCreateInfo multisampleState; variable vertexInputState VkPipelineVertexInputStateCreateInfo vertexInputState; variable vkShaderStages std::vector< VkPipelineShaderStageCreateInfo > vkShaderStages; variable descriptorSetLayouts std::vector< VkDescriptorSetLayout > descriptorSetLayouts; variable pipelineLayoutCreateInfo VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo; variable createInfo VkGraphicsPipelineCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#ngfxvkgraphicspipeline","text":"Inherits from ngfx::GraphicsPipeline , ngfx::VKPipeline , ngfx::Pipeline","title":"ngfx::VKGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#public-classes","text":"Name struct State","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#public-functions","text":"Name void create ( VKGraphicsContext * ctx, const State & state, const std::vector< VKPipeline::Descriptor > & descriptors, const std::vector< VkVertexInputBindingDescription > & vertexInputBindings, const std::vector< VkVertexInputAttributeDescription > & vertexInputAttributes, const std::vector< VKPipeline::ShaderStage > & shaderStages, VkFormat colorFormat) virtual ~VKGraphicsPipeline ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#public-attributes","text":"Name VkPipelineInputAssemblyStateCreateInfo inputAssemblyState VkPipelineRasterizationStateCreateInfo rasterizationState std::vector< VkPipelineColorBlendAttachmentState > blendAttachmentState VkPipelineColorBlendStateCreateInfo colorBlendState VkPipelineViewportStateCreateInfo viewportState std::vector< VkDynamicState > dynamicStateEnables VkPipelineDynamicStateCreateInfo dynamicState VkPipelineDepthStencilStateCreateInfo depthStencilState VkPipelineMultisampleStateCreateInfo multisampleState VkPipelineVertexInputStateCreateInfo vertexInputState std::vector< VkPipelineShaderStageCreateInfo > vkShaderStages std::vector< VkDescriptorSetLayout > descriptorSetLayouts VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo VkGraphicsPipelineCreateInfo createInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#additional-inherited-members","text":"Public Classes inherited from ngfx::GraphicsPipeline Name struct Descriptor struct State Public Functions inherited from ngfx::GraphicsPipeline Name virtual ~GraphicsPipeline () void getBindings (std::vector< uint32_t * > pDescriptorBindings, std::vector< uint32_t * > pVertexAttribBindings) Public Attributes inherited from ngfx::GraphicsPipeline Name std::vector< uint32_t > descriptorBindings std::vector< uint32_t > vertexAttributeBindings Public Classes inherited from ngfx::VKPipeline Name struct Descriptor struct ShaderStage Public Functions inherited from ngfx::VKPipeline Name virtual ~VKPipeline () Public Attributes inherited from ngfx::VKPipeline Name VkPipeline v VkPipelineLayout pipelineLayout Protected Attributes inherited from ngfx::VKPipeline Name VkDevice device Public Functions inherited from ngfx::Pipeline Name virtual ~Pipeline ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#function-create","text":"void create( VKGraphicsContext * ctx, const State & state, const std::vector< VKPipeline::Descriptor > & descriptors, const std::vector< VkVertexInputBindingDescription > & vertexInputBindings, const std::vector< VkVertexInputAttributeDescription > & vertexInputAttributes, const std::vector< VKPipeline::ShaderStage > & shaderStages, VkFormat colorFormat )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#function-vkgraphicspipeline","text":"inline virtual ~VKGraphicsPipeline()","title":"function ~VKGraphicsPipeline"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-inputassemblystate","text":"VkPipelineInputAssemblyStateCreateInfo inputAssemblyState;","title":"variable inputAssemblyState"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-rasterizationstate","text":"VkPipelineRasterizationStateCreateInfo rasterizationState;","title":"variable rasterizationState"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-blendattachmentstate","text":"std::vector< VkPipelineColorBlendAttachmentState > blendAttachmentState;","title":"variable blendAttachmentState"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-colorblendstate","text":"VkPipelineColorBlendStateCreateInfo colorBlendState;","title":"variable colorBlendState"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-viewportstate","text":"VkPipelineViewportStateCreateInfo viewportState;","title":"variable viewportState"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-dynamicstateenables","text":"std::vector< VkDynamicState > dynamicStateEnables;","title":"variable dynamicStateEnables"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-dynamicstate","text":"VkPipelineDynamicStateCreateInfo dynamicState;","title":"variable dynamicState"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-depthstencilstate","text":"VkPipelineDepthStencilStateCreateInfo depthStencilState;","title":"variable depthStencilState"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-multisamplestate","text":"VkPipelineMultisampleStateCreateInfo multisampleState;","title":"variable multisampleState"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-vertexinputstate","text":"VkPipelineVertexInputStateCreateInfo vertexInputState;","title":"variable vertexInputState"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-vkshaderstages","text":"std::vector< VkPipelineShaderStageCreateInfo > vkShaderStages;","title":"variable vkShaderStages"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-descriptorsetlayouts","text":"std::vector< VkDescriptorSetLayout > descriptorSetLayouts;","title":"variable descriptorSetLayouts"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-pipelinelayoutcreateinfo","text":"VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo;","title":"variable pipelineLayoutCreateInfo"},{"location":"api/Classes/classngfx_1_1VKGraphicsPipeline/#variable-createinfo","text":"VkGraphicsPipelineCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKImage/","text":"ngfx::VKImage Public Functions Name void create ( VKDevice * vkDevice, VkExtent3D extent, VkFormat format =VK_FORMAT_R8G8B8A8_UNORM, VkImageUsageFlags usage =VK_IMAGE_USAGE_SAMPLED_BIT, VkImageType imageType =VK_IMAGE_TYPE_2D, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t numSamples =1, VkImageCreateFlags imageCreateFlags =0, VkMemoryPropertyFlags memoryPropertyFlags =VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) void create ( VKDevice * vkDevice, const VKImageCreateInfo & createInfo, VkMemoryPropertyFlags memoryPropertyFlags =VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) void changeLayout (VkCommandBuffer commandBuffer, VkImageLayout newLayout, VkImageAspectFlags dstAccessMask, VkPipelineStageFlags dstStageMask, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t baseMipLevel =0, uint32_t levelCount =1, uint32_t baseArrayLayer =0, uint32_t layerCount =1) virtual ~VKImage () Public Attributes Name VkImage v VkDeviceMemory memory std::vector< VkImageLayout > imageLayout std::vector< VkAccessFlags > accessMask std::vector< VkPipelineStageFlags > stageMask VKImageCreateInfo createInfo Public Functions Documentation function create void create( VKDevice * vkDevice, VkExtent3D extent, VkFormat format =VK_FORMAT_R8G8B8A8_UNORM, VkImageUsageFlags usage =VK_IMAGE_USAGE_SAMPLED_BIT, VkImageType imageType =VK_IMAGE_TYPE_2D, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t numSamples =1, VkImageCreateFlags imageCreateFlags =0, VkMemoryPropertyFlags memoryPropertyFlags =VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ) function create void create( VKDevice * vkDevice, const VKImageCreateInfo & createInfo, VkMemoryPropertyFlags memoryPropertyFlags =VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ) function changeLayout void changeLayout( VkCommandBuffer commandBuffer, VkImageLayout newLayout, VkImageAspectFlags dstAccessMask, VkPipelineStageFlags dstStageMask, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t baseMipLevel =0, uint32_t levelCount =1, uint32_t baseArrayLayer =0, uint32_t layerCount =1 ) function ~VKImage virtual ~VKImage() Public Attributes Documentation variable v VkImage v = VK_NULL_HANDLE; variable memory VkDeviceMemory memory = VK_NULL_HANDLE; variable imageLayout std::vector< VkImageLayout > imageLayout; variable accessMask std::vector< VkAccessFlags > accessMask; variable stageMask std::vector< VkPipelineStageFlags > stageMask; variable createInfo VKImageCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKImage"},{"location":"api/Classes/classngfx_1_1VKImage/#ngfxvkimage","text":"","title":"ngfx::VKImage"},{"location":"api/Classes/classngfx_1_1VKImage/#public-functions","text":"Name void create ( VKDevice * vkDevice, VkExtent3D extent, VkFormat format =VK_FORMAT_R8G8B8A8_UNORM, VkImageUsageFlags usage =VK_IMAGE_USAGE_SAMPLED_BIT, VkImageType imageType =VK_IMAGE_TYPE_2D, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t numSamples =1, VkImageCreateFlags imageCreateFlags =0, VkMemoryPropertyFlags memoryPropertyFlags =VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) void create ( VKDevice * vkDevice, const VKImageCreateInfo & createInfo, VkMemoryPropertyFlags memoryPropertyFlags =VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) void changeLayout (VkCommandBuffer commandBuffer, VkImageLayout newLayout, VkImageAspectFlags dstAccessMask, VkPipelineStageFlags dstStageMask, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t baseMipLevel =0, uint32_t levelCount =1, uint32_t baseArrayLayer =0, uint32_t layerCount =1) virtual ~VKImage ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKImage/#public-attributes","text":"Name VkImage v VkDeviceMemory memory std::vector< VkImageLayout > imageLayout std::vector< VkAccessFlags > accessMask std::vector< VkPipelineStageFlags > stageMask VKImageCreateInfo createInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKImage/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKImage/#function-create","text":"void create( VKDevice * vkDevice, VkExtent3D extent, VkFormat format =VK_FORMAT_R8G8B8A8_UNORM, VkImageUsageFlags usage =VK_IMAGE_USAGE_SAMPLED_BIT, VkImageType imageType =VK_IMAGE_TYPE_2D, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t numSamples =1, VkImageCreateFlags imageCreateFlags =0, VkMemoryPropertyFlags memoryPropertyFlags =VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKImage/#function-create_1","text":"void create( VKDevice * vkDevice, const VKImageCreateInfo & createInfo, VkMemoryPropertyFlags memoryPropertyFlags =VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKImage/#function-changelayout","text":"void changeLayout( VkCommandBuffer commandBuffer, VkImageLayout newLayout, VkImageAspectFlags dstAccessMask, VkPipelineStageFlags dstStageMask, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t baseMipLevel =0, uint32_t levelCount =1, uint32_t baseArrayLayer =0, uint32_t layerCount =1 )","title":"function changeLayout"},{"location":"api/Classes/classngfx_1_1VKImage/#function-vkimage","text":"virtual ~VKImage()","title":"function ~VKImage"},{"location":"api/Classes/classngfx_1_1VKImage/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKImage/#variable-v","text":"VkImage v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKImage/#variable-memory","text":"VkDeviceMemory memory = VK_NULL_HANDLE;","title":"variable memory"},{"location":"api/Classes/classngfx_1_1VKImage/#variable-imagelayout","text":"std::vector< VkImageLayout > imageLayout;","title":"variable imageLayout"},{"location":"api/Classes/classngfx_1_1VKImage/#variable-accessmask","text":"std::vector< VkAccessFlags > accessMask;","title":"variable accessMask"},{"location":"api/Classes/classngfx_1_1VKImage/#variable-stagemask","text":"std::vector< VkPipelineStageFlags > stageMask;","title":"variable stageMask"},{"location":"api/Classes/classngfx_1_1VKImage/#variable-createinfo","text":"VKImageCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKImageView/","text":"ngfx::VKImageView Public Functions Name void create (VkDevice device, VkImage image, VkImageViewType imageViewType =VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat =VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0) void create (VkDevice device, VKImageViewCreateInfo & createInfo) virtual ~VKImageView () Public Attributes Name VkImageView v VKImageViewCreateInfo createInfo Public Functions Documentation function create void create( VkDevice device, VkImage image, VkImageViewType imageViewType =VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat =VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0 ) function create void create( VkDevice device, VKImageViewCreateInfo & createInfo ) function ~VKImageView virtual ~VKImageView() Public Attributes Documentation variable v VkImageView v = VK_NULL_HANDLE; variable createInfo VKImageViewCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKImageView"},{"location":"api/Classes/classngfx_1_1VKImageView/#ngfxvkimageview","text":"","title":"ngfx::VKImageView"},{"location":"api/Classes/classngfx_1_1VKImageView/#public-functions","text":"Name void create (VkDevice device, VkImage image, VkImageViewType imageViewType =VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat =VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0) void create (VkDevice device, VKImageViewCreateInfo & createInfo) virtual ~VKImageView ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKImageView/#public-attributes","text":"Name VkImageView v VKImageViewCreateInfo createInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKImageView/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKImageView/#function-create","text":"void create( VkDevice device, VkImage image, VkImageViewType imageViewType =VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat =VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0 )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKImageView/#function-create_1","text":"void create( VkDevice device, VKImageViewCreateInfo & createInfo )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKImageView/#function-vkimageview","text":"virtual ~VKImageView()","title":"function ~VKImageView"},{"location":"api/Classes/classngfx_1_1VKImageView/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKImageView/#variable-v","text":"VkImageView v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKImageView/#variable-createinfo","text":"VKImageViewCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKInstance/","text":"ngfx::VKInstance Public Functions Name void create (const char * appName, const char * engineName, uint32_t apiVersion, bool enableValidation) virtual ~VKInstance () bool hasInstanceLayer (const char * name) Public Attributes Name bool enableValidation struct ngfx::VKInstance::@4 settings std::vector< const char * > instanceExtensions std::vector< const char * > instanceLayers std::vector< VkLayerProperties > instanceLayerProperties VkInstance v VkInstanceCreateInfo createInfo VkApplicationInfo appInfo Public Functions Documentation function create void create( const char * appName, const char * engineName, uint32_t apiVersion, bool enableValidation ) function ~VKInstance virtual ~VKInstance() function hasInstanceLayer bool hasInstanceLayer( const char * name ) Public Attributes Documentation variable enableValidation bool enableValidation = false; variable settings struct ngfx::VKInstance::@4 settings; variable instanceExtensions std::vector< const char * > instanceExtensions; variable instanceLayers std::vector< const char * > instanceLayers; variable instanceLayerProperties std::vector< VkLayerProperties > instanceLayerProperties; variable v VkInstance v = VK_NULL_HANDLE; variable createInfo VkInstanceCreateInfo createInfo; variable appInfo VkApplicationInfo appInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKInstance"},{"location":"api/Classes/classngfx_1_1VKInstance/#ngfxvkinstance","text":"","title":"ngfx::VKInstance"},{"location":"api/Classes/classngfx_1_1VKInstance/#public-functions","text":"Name void create (const char * appName, const char * engineName, uint32_t apiVersion, bool enableValidation) virtual ~VKInstance () bool hasInstanceLayer (const char * name)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKInstance/#public-attributes","text":"Name bool enableValidation struct ngfx::VKInstance::@4 settings std::vector< const char * > instanceExtensions std::vector< const char * > instanceLayers std::vector< VkLayerProperties > instanceLayerProperties VkInstance v VkInstanceCreateInfo createInfo VkApplicationInfo appInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKInstance/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKInstance/#function-create","text":"void create( const char * appName, const char * engineName, uint32_t apiVersion, bool enableValidation )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKInstance/#function-vkinstance","text":"virtual ~VKInstance()","title":"function ~VKInstance"},{"location":"api/Classes/classngfx_1_1VKInstance/#function-hasinstancelayer","text":"bool hasInstanceLayer( const char * name )","title":"function hasInstanceLayer"},{"location":"api/Classes/classngfx_1_1VKInstance/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKInstance/#variable-enablevalidation","text":"bool enableValidation = false;","title":"variable enableValidation"},{"location":"api/Classes/classngfx_1_1VKInstance/#variable-settings","text":"struct ngfx::VKInstance::@4 settings;","title":"variable settings"},{"location":"api/Classes/classngfx_1_1VKInstance/#variable-instanceextensions","text":"std::vector< const char * > instanceExtensions;","title":"variable instanceExtensions"},{"location":"api/Classes/classngfx_1_1VKInstance/#variable-instancelayers","text":"std::vector< const char * > instanceLayers;","title":"variable instanceLayers"},{"location":"api/Classes/classngfx_1_1VKInstance/#variable-instancelayerproperties","text":"std::vector< VkLayerProperties > instanceLayerProperties;","title":"variable instanceLayerProperties"},{"location":"api/Classes/classngfx_1_1VKInstance/#variable-v","text":"VkInstance v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKInstance/#variable-createinfo","text":"VkInstanceCreateInfo createInfo;","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKInstance/#variable-appinfo","text":"VkApplicationInfo appInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable appInfo"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/","text":"ngfx::VKPhysicalDevice Public Functions Name void create (VkInstance instance) virtual ~VKPhysicalDevice () bool extensionSupported (std::string extension) uint32_t getMemoryType (uint32_t typeBits, VkMemoryPropertyFlags memoryPropertyFlags) Public Attributes Name VkPhysicalDevice v VkPhysicalDeviceProperties deviceProperties VkPhysicalDeviceFeatures deviceFeatures VkPhysicalDeviceMemoryProperties deviceMemoryProperties std::vector< VkQueueFamilyProperties > queueFamilyProperties std::vector< std::string > supportedExtensions VkFormat depthFormat Public Functions Documentation function create void create( VkInstance instance ) function ~VKPhysicalDevice virtual ~VKPhysicalDevice() function extensionSupported bool extensionSupported( std::string extension ) function getMemoryType uint32_t getMemoryType( uint32_t typeBits, VkMemoryPropertyFlags memoryPropertyFlags ) Public Attributes Documentation variable v VkPhysicalDevice v = VK_NULL_HANDLE; variable deviceProperties VkPhysicalDeviceProperties deviceProperties; variable deviceFeatures VkPhysicalDeviceFeatures deviceFeatures; variable deviceMemoryProperties VkPhysicalDeviceMemoryProperties deviceMemoryProperties; variable queueFamilyProperties std::vector< VkQueueFamilyProperties > queueFamilyProperties; variable supportedExtensions std::vector< std::string > supportedExtensions; variable depthFormat VkFormat depthFormat; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKPhysicalDevice"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#ngfxvkphysicaldevice","text":"","title":"ngfx::VKPhysicalDevice"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#public-functions","text":"Name void create (VkInstance instance) virtual ~VKPhysicalDevice () bool extensionSupported (std::string extension) uint32_t getMemoryType (uint32_t typeBits, VkMemoryPropertyFlags memoryPropertyFlags)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#public-attributes","text":"Name VkPhysicalDevice v VkPhysicalDeviceProperties deviceProperties VkPhysicalDeviceFeatures deviceFeatures VkPhysicalDeviceMemoryProperties deviceMemoryProperties std::vector< VkQueueFamilyProperties > queueFamilyProperties std::vector< std::string > supportedExtensions VkFormat depthFormat","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#function-create","text":"void create( VkInstance instance )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#function-vkphysicaldevice","text":"virtual ~VKPhysicalDevice()","title":"function ~VKPhysicalDevice"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#function-extensionsupported","text":"bool extensionSupported( std::string extension )","title":"function extensionSupported"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#function-getmemorytype","text":"uint32_t getMemoryType( uint32_t typeBits, VkMemoryPropertyFlags memoryPropertyFlags )","title":"function getMemoryType"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#variable-v","text":"VkPhysicalDevice v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#variable-deviceproperties","text":"VkPhysicalDeviceProperties deviceProperties;","title":"variable deviceProperties"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#variable-devicefeatures","text":"VkPhysicalDeviceFeatures deviceFeatures;","title":"variable deviceFeatures"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#variable-devicememoryproperties","text":"VkPhysicalDeviceMemoryProperties deviceMemoryProperties;","title":"variable deviceMemoryProperties"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#variable-queuefamilyproperties","text":"std::vector< VkQueueFamilyProperties > queueFamilyProperties;","title":"variable queueFamilyProperties"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#variable-supportedextensions","text":"std::vector< std::string > supportedExtensions;","title":"variable supportedExtensions"},{"location":"api/Classes/classngfx_1_1VKPhysicalDevice/#variable-depthformat","text":"VkFormat depthFormat; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable depthFormat"},{"location":"api/Classes/classngfx_1_1VKPipeline/","text":"ngfx::VKPipeline Inherited by ngfx::VKComputePipeline , ngfx::VKGraphicsPipeline Public Classes Name struct Descriptor struct ShaderStage Public Functions Name virtual ~VKPipeline () Public Attributes Name VkPipeline v VkPipelineLayout pipelineLayout Protected Attributes Name VkDevice device Public Functions Documentation function ~VKPipeline virtual ~VKPipeline() Public Attributes Documentation variable v VkPipeline v = VK_NULL_HANDLE; variable pipelineLayout VkPipelineLayout pipelineLayout = VK_NULL_HANDLE; Protected Attributes Documentation variable device VkDevice device; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKPipeline"},{"location":"api/Classes/classngfx_1_1VKPipeline/#ngfxvkpipeline","text":"Inherited by ngfx::VKComputePipeline , ngfx::VKGraphicsPipeline","title":"ngfx::VKPipeline"},{"location":"api/Classes/classngfx_1_1VKPipeline/#public-classes","text":"Name struct Descriptor struct ShaderStage","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1VKPipeline/#public-functions","text":"Name virtual ~VKPipeline ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKPipeline/#public-attributes","text":"Name VkPipeline v VkPipelineLayout pipelineLayout","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKPipeline/#protected-attributes","text":"Name VkDevice device","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1VKPipeline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKPipeline/#function-vkpipeline","text":"virtual ~VKPipeline()","title":"function ~VKPipeline"},{"location":"api/Classes/classngfx_1_1VKPipeline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKPipeline/#variable-v","text":"VkPipeline v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKPipeline/#variable-pipelinelayout","text":"VkPipelineLayout pipelineLayout = VK_NULL_HANDLE;","title":"variable pipelineLayout"},{"location":"api/Classes/classngfx_1_1VKPipeline/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKPipeline/#variable-device","text":"VkDevice device; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable device"},{"location":"api/Classes/classngfx_1_1VKPipelineCache/","text":"ngfx::VKPipelineCache Inherits from ngfx::PipelineCache Public Functions Name void create (VkDevice device) virtual ~VKPipelineCache () Public Attributes Name VkPipelineCache v Additional inherited members Public Functions inherited from ngfx::PipelineCache Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value) Public Functions Documentation function create void create( VkDevice device ) function ~VKPipelineCache virtual ~VKPipelineCache() Public Attributes Documentation variable v VkPipelineCache v; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKPipelineCache"},{"location":"api/Classes/classngfx_1_1VKPipelineCache/#ngfxvkpipelinecache","text":"Inherits from ngfx::PipelineCache","title":"ngfx::VKPipelineCache"},{"location":"api/Classes/classngfx_1_1VKPipelineCache/#public-functions","text":"Name void create (VkDevice device) virtual ~VKPipelineCache ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKPipelineCache/#public-attributes","text":"Name VkPipelineCache v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKPipelineCache/#additional-inherited-members","text":"Public Functions inherited from ngfx::PipelineCache Name virtual ~PipelineCache () virtual Pipeline * get (const std::string & key) virtual void add (const std::string & key, Pipeline * value)","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKPipelineCache/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKPipelineCache/#function-create","text":"void create( VkDevice device )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKPipelineCache/#function-vkpipelinecache","text":"virtual ~VKPipelineCache()","title":"function ~VKPipelineCache"},{"location":"api/Classes/classngfx_1_1VKPipelineCache/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKPipelineCache/#variable-v","text":"VkPipelineCache v; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKQueue/","text":"ngfx::VKQueue Inherits from ngfx::Queue Public Functions Name void create ( VKGraphicsContext * ctx, int queueFamilyIndex, int queueIndex) virtual ~VKQueue () virtual void present () virtual void submit ( CommandBuffer * commandBuffer) void submit ( CommandBuffer * commandBuffer, VkPipelineStageFlags waitStageMask, const std::vector< Semaphore * > & waitSemaphores, const std::vector< Semaphore * > & signalSemaphores, Fence * waitFence) virtual void waitIdle () Public Attributes Name VkQueue v Additional inherited members Public Functions inherited from ngfx::Queue Name virtual ~Queue () Public Functions Documentation function create void create( VKGraphicsContext * ctx, int queueFamilyIndex, int queueIndex ) function ~VKQueue virtual ~VKQueue() function present virtual void present() Reimplements : ngfx::Queue::present function submit virtual void submit( CommandBuffer * commandBuffer ) Reimplements : ngfx::Queue::submit function submit void submit( CommandBuffer * commandBuffer, VkPipelineStageFlags waitStageMask, const std::vector< Semaphore * > & waitSemaphores, const std::vector< Semaphore * > & signalSemaphores, Fence * waitFence ) function waitIdle virtual void waitIdle() Reimplements : ngfx::Queue::waitIdle Public Attributes Documentation variable v VkQueue v = VK_NULL_HANDLE; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKQueue"},{"location":"api/Classes/classngfx_1_1VKQueue/#ngfxvkqueue","text":"Inherits from ngfx::Queue","title":"ngfx::VKQueue"},{"location":"api/Classes/classngfx_1_1VKQueue/#public-functions","text":"Name void create ( VKGraphicsContext * ctx, int queueFamilyIndex, int queueIndex) virtual ~VKQueue () virtual void present () virtual void submit ( CommandBuffer * commandBuffer) void submit ( CommandBuffer * commandBuffer, VkPipelineStageFlags waitStageMask, const std::vector< Semaphore * > & waitSemaphores, const std::vector< Semaphore * > & signalSemaphores, Fence * waitFence) virtual void waitIdle ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKQueue/#public-attributes","text":"Name VkQueue v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKQueue/#additional-inherited-members","text":"Public Functions inherited from ngfx::Queue Name virtual ~Queue ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKQueue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKQueue/#function-create","text":"void create( VKGraphicsContext * ctx, int queueFamilyIndex, int queueIndex )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKQueue/#function-vkqueue","text":"virtual ~VKQueue()","title":"function ~VKQueue"},{"location":"api/Classes/classngfx_1_1VKQueue/#function-present","text":"virtual void present() Reimplements : ngfx::Queue::present","title":"function present"},{"location":"api/Classes/classngfx_1_1VKQueue/#function-submit","text":"virtual void submit( CommandBuffer * commandBuffer ) Reimplements : ngfx::Queue::submit","title":"function submit"},{"location":"api/Classes/classngfx_1_1VKQueue/#function-submit_1","text":"void submit( CommandBuffer * commandBuffer, VkPipelineStageFlags waitStageMask, const std::vector< Semaphore * > & waitSemaphores, const std::vector< Semaphore * > & signalSemaphores, Fence * waitFence )","title":"function submit"},{"location":"api/Classes/classngfx_1_1VKQueue/#function-waitidle","text":"virtual void waitIdle() Reimplements : ngfx::Queue::waitIdle","title":"function waitIdle"},{"location":"api/Classes/classngfx_1_1VKQueue/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKQueue/#variable-v","text":"VkQueue v = VK_NULL_HANDLE; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKRenderPass/","text":"ngfx::VKRenderPass Inherits from ngfx::RenderPass Public Functions Name void create (VkDevice device, const std::vector< VkAttachmentDescription > & attachmentsDesc, const std::vector< VkSubpassDescription > & subpassesDesc, const std::vector< VkSubpassDependency > & dependencies) virtual ~VKRenderPass () Public Attributes Name VkRenderPass v VkRenderPassCreateInfo createInfo std::vector< VkAttachmentDescription > attachmentsDesc std::vector< VkSubpassDescription > subpassesDesc std::vector< VkSubpassDependency > dependencies Additional inherited members Public Functions inherited from ngfx::RenderPass Name virtual ~RenderPass () Public Attributes inherited from ngfx::RenderPass Name Framebuffer * currentFramebuffer Public Functions Documentation function create void create( VkDevice device, const std::vector< VkAttachmentDescription > & attachmentsDesc, const std::vector< VkSubpassDescription > & subpassesDesc, const std::vector< VkSubpassDependency > & dependencies ) function ~VKRenderPass virtual ~VKRenderPass() Public Attributes Documentation variable v VkRenderPass v = VK_NULL_HANDLE; variable createInfo VkRenderPassCreateInfo createInfo; variable attachmentsDesc std::vector< VkAttachmentDescription > attachmentsDesc; variable subpassesDesc std::vector< VkSubpassDescription > subpassesDesc; variable dependencies std::vector< VkSubpassDependency > dependencies; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKRenderPass"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#ngfxvkrenderpass","text":"Inherits from ngfx::RenderPass","title":"ngfx::VKRenderPass"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#public-functions","text":"Name void create (VkDevice device, const std::vector< VkAttachmentDescription > & attachmentsDesc, const std::vector< VkSubpassDescription > & subpassesDesc, const std::vector< VkSubpassDependency > & dependencies) virtual ~VKRenderPass ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#public-attributes","text":"Name VkRenderPass v VkRenderPassCreateInfo createInfo std::vector< VkAttachmentDescription > attachmentsDesc std::vector< VkSubpassDescription > subpassesDesc std::vector< VkSubpassDependency > dependencies","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#additional-inherited-members","text":"Public Functions inherited from ngfx::RenderPass Name virtual ~RenderPass () Public Attributes inherited from ngfx::RenderPass Name Framebuffer * currentFramebuffer","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#function-create","text":"void create( VkDevice device, const std::vector< VkAttachmentDescription > & attachmentsDesc, const std::vector< VkSubpassDescription > & subpassesDesc, const std::vector< VkSubpassDependency > & dependencies )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#function-vkrenderpass","text":"virtual ~VKRenderPass()","title":"function ~VKRenderPass"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#variable-v","text":"VkRenderPass v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#variable-createinfo","text":"VkRenderPassCreateInfo createInfo;","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#variable-attachmentsdesc","text":"std::vector< VkAttachmentDescription > attachmentsDesc;","title":"variable attachmentsDesc"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#variable-subpassesdesc","text":"std::vector< VkSubpassDescription > subpassesDesc;","title":"variable subpassesDesc"},{"location":"api/Classes/classngfx_1_1VKRenderPass/#variable-dependencies","text":"std::vector< VkSubpassDependency > dependencies; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable dependencies"},{"location":"api/Classes/classngfx_1_1VKSemaphore/","text":"ngfx::VKSemaphore Inherits from ngfx::Semaphore Public Functions Name void create (VkDevice device) virtual ~VKSemaphore () virtual uint64_t wait () virtual void signal (uint64_t value =1) Public Attributes Name VkSemaphore v VkSemaphoreCreateInfo createInfo Additional inherited members Public Functions inherited from ngfx::Semaphore Name virtual ~Semaphore () Public Functions Documentation function create void create( VkDevice device ) function ~VKSemaphore virtual ~VKSemaphore() function wait virtual uint64_t wait() Reimplements : ngfx::Semaphore::wait function signal virtual void signal( uint64_t value =1 ) Reimplements : ngfx::Semaphore::signal Public Attributes Documentation variable v VkSemaphore v = VK_NULL_HANDLE; variable createInfo VkSemaphoreCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKSemaphore"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#ngfxvksemaphore","text":"Inherits from ngfx::Semaphore","title":"ngfx::VKSemaphore"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#public-functions","text":"Name void create (VkDevice device) virtual ~VKSemaphore () virtual uint64_t wait () virtual void signal (uint64_t value =1)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#public-attributes","text":"Name VkSemaphore v VkSemaphoreCreateInfo createInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#additional-inherited-members","text":"Public Functions inherited from ngfx::Semaphore Name virtual ~Semaphore ()","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#function-create","text":"void create( VkDevice device )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#function-vksemaphore","text":"virtual ~VKSemaphore()","title":"function ~VKSemaphore"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#function-wait","text":"virtual uint64_t wait() Reimplements : ngfx::Semaphore::wait","title":"function wait"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#function-signal","text":"virtual void signal( uint64_t value =1 ) Reimplements : ngfx::Semaphore::signal","title":"function signal"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#variable-v","text":"VkSemaphore v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKSemaphore/#variable-createinfo","text":"VkSemaphoreCreateInfo createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKShaderModule/","text":"ngfx::VKShaderModule Inherited by ngfx::VKComputeShaderModule , ngfx::VKFragmentShaderModule , ngfx::VKVertexShaderModule Public Functions Name virtual void initFromFile (VkDevice device, const std::string & filename) virtual ~VKShaderModule () Protected Functions Name virtual void initFromByteCode (VkDevice device, void * data, uint32_t size) Public Attributes Name VkShaderModule v Public Functions Documentation function initFromFile virtual void initFromFile( VkDevice device, const std::string & filename ) function ~VKShaderModule virtual ~VKShaderModule() Protected Functions Documentation function initFromByteCode virtual void initFromByteCode( VkDevice device, void * data, uint32_t size ) Public Attributes Documentation variable v VkShaderModule v = VK_NULL_HANDLE; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKShaderModule"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#ngfxvkshadermodule","text":"Inherited by ngfx::VKComputeShaderModule , ngfx::VKFragmentShaderModule , ngfx::VKVertexShaderModule","title":"ngfx::VKShaderModule"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#public-functions","text":"Name virtual void initFromFile (VkDevice device, const std::string & filename) virtual ~VKShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#protected-functions","text":"Name virtual void initFromByteCode (VkDevice device, void * data, uint32_t size)","title":"Protected Functions"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#public-attributes","text":"Name VkShaderModule v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#function-initfromfile","text":"virtual void initFromFile( VkDevice device, const std::string & filename )","title":"function initFromFile"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#function-vkshadermodule","text":"virtual ~VKShaderModule()","title":"function ~VKShaderModule"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#function-initfrombytecode","text":"virtual void initFromByteCode( VkDevice device, void * data, uint32_t size )","title":"function initFromByteCode"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKShaderModule/#variable-v","text":"VkShaderModule v = VK_NULL_HANDLE; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKSurface/","text":"ngfx::VKSurface Inherits from ngfx::Surface Public Functions Name virtual ~VKSurface () void destroy () Public Attributes Name VkInstance instance VkSurfaceKHR v Additional inherited members Public Functions inherited from ngfx::Surface Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface () Public Attributes inherited from ngfx::Surface Name uint32_t w uint32_t h bool offscreen Public Functions Documentation function ~VKSurface inline virtual ~VKSurface() function destroy void destroy() Public Attributes Documentation variable instance VkInstance instance = 0; variable v VkSurfaceKHR v = 0; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKSurface"},{"location":"api/Classes/classngfx_1_1VKSurface/#ngfxvksurface","text":"Inherits from ngfx::Surface","title":"ngfx::VKSurface"},{"location":"api/Classes/classngfx_1_1VKSurface/#public-functions","text":"Name virtual ~VKSurface () void destroy ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKSurface/#public-attributes","text":"Name VkInstance instance VkSurfaceKHR v","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKSurface/#additional-inherited-members","text":"Public Functions inherited from ngfx::Surface Name Surface () Surface (uint32_t w, uint32_t h, bool offscreen =false) virtual ~Surface () Public Attributes inherited from ngfx::Surface Name uint32_t w uint32_t h bool offscreen","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKSurface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKSurface/#function-vksurface","text":"inline virtual ~VKSurface()","title":"function ~VKSurface"},{"location":"api/Classes/classngfx_1_1VKSurface/#function-destroy","text":"void destroy()","title":"function destroy"},{"location":"api/Classes/classngfx_1_1VKSurface/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKSurface/#variable-instance","text":"VkInstance instance = 0;","title":"variable instance"},{"location":"api/Classes/classngfx_1_1VKSurface/#variable-v","text":"VkSurfaceKHR v = 0; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKSwapchain/","text":"ngfx::VKSwapchain Inherits from ngfx::Swapchain Public Classes Name struct queueFamilyProperties Public Functions Name VKSwapchain ( VKGraphicsContext * ctx, VKSurface * surface) virtual ~VKSwapchain () virtual void acquireNextImage () Public Attributes Name VkSurfaceCapabilitiesKHR surfaceCaps VKSurface * surface VkSwapchainKHR v VkSurfaceFormatKHR surfaceFormat std::vector< VkSurfaceFormatKHR > surfaceFormats std::vector< VkPresentModeKHR > presentModes VkPresentModeKHR presentMode VkCompositeAlphaFlagBitsKHR compositeAlpha VkSurfaceTransformFlagsKHR preTransform std::vector< VkImage > images std::vector< VKImageView > imageViews std::vector< queueFamilyProperties > queueFamilyProperties VkSwapchainCreateInfoKHR createInfo Additional inherited members Public Functions inherited from ngfx::Swapchain Name virtual ~Swapchain () Public Attributes inherited from ngfx::Swapchain Name uint32_t numImages Public Functions Documentation function VKSwapchain VKSwapchain( VKGraphicsContext * ctx, VKSurface * surface ) function ~VKSwapchain virtual ~VKSwapchain() function acquireNextImage virtual void acquireNextImage() Reimplements : ngfx::Swapchain::acquireNextImage Public Attributes Documentation variable surfaceCaps VkSurfaceCapabilitiesKHR surfaceCaps; variable surface VKSurface * surface; variable v VkSwapchainKHR v = VK_NULL_HANDLE; variable surfaceFormat VkSurfaceFormatKHR surfaceFormat; variable surfaceFormats std::vector< VkSurfaceFormatKHR > surfaceFormats; variable presentModes std::vector< VkPresentModeKHR > presentModes; variable presentMode VkPresentModeKHR presentMode; variable compositeAlpha VkCompositeAlphaFlagBitsKHR compositeAlpha; variable preTransform VkSurfaceTransformFlagsKHR preTransform; variable images std::vector< VkImage > images; variable imageViews std::vector< VKImageView > imageViews; variable queueFamilyProperties std::vector< queueFamilyProperties > queueFamilyProperties; variable createInfo VkSwapchainCreateInfoKHR createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKSwapchain"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#ngfxvkswapchain","text":"Inherits from ngfx::Swapchain","title":"ngfx::VKSwapchain"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#public-classes","text":"Name struct queueFamilyProperties","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#public-functions","text":"Name VKSwapchain ( VKGraphicsContext * ctx, VKSurface * surface) virtual ~VKSwapchain () virtual void acquireNextImage ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#public-attributes","text":"Name VkSurfaceCapabilitiesKHR surfaceCaps VKSurface * surface VkSwapchainKHR v VkSurfaceFormatKHR surfaceFormat std::vector< VkSurfaceFormatKHR > surfaceFormats std::vector< VkPresentModeKHR > presentModes VkPresentModeKHR presentMode VkCompositeAlphaFlagBitsKHR compositeAlpha VkSurfaceTransformFlagsKHR preTransform std::vector< VkImage > images std::vector< VKImageView > imageViews std::vector< queueFamilyProperties > queueFamilyProperties VkSwapchainCreateInfoKHR createInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#additional-inherited-members","text":"Public Functions inherited from ngfx::Swapchain Name virtual ~Swapchain () Public Attributes inherited from ngfx::Swapchain Name uint32_t numImages","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#function-vkswapchain","text":"VKSwapchain( VKGraphicsContext * ctx, VKSurface * surface )","title":"function VKSwapchain"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#function-vkswapchain_1","text":"virtual ~VKSwapchain()","title":"function ~VKSwapchain"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#function-acquirenextimage","text":"virtual void acquireNextImage() Reimplements : ngfx::Swapchain::acquireNextImage","title":"function acquireNextImage"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-surfacecaps","text":"VkSurfaceCapabilitiesKHR surfaceCaps;","title":"variable surfaceCaps"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-surface","text":"VKSurface * surface;","title":"variable surface"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-v","text":"VkSwapchainKHR v = VK_NULL_HANDLE;","title":"variable v"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-surfaceformat","text":"VkSurfaceFormatKHR surfaceFormat;","title":"variable surfaceFormat"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-surfaceformats","text":"std::vector< VkSurfaceFormatKHR > surfaceFormats;","title":"variable surfaceFormats"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-presentmodes","text":"std::vector< VkPresentModeKHR > presentModes;","title":"variable presentModes"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-presentmode","text":"VkPresentModeKHR presentMode;","title":"variable presentMode"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-compositealpha","text":"VkCompositeAlphaFlagBitsKHR compositeAlpha;","title":"variable compositeAlpha"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-pretransform","text":"VkSurfaceTransformFlagsKHR preTransform;","title":"variable preTransform"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-images","text":"std::vector< VkImage > images;","title":"variable images"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-imageviews","text":"std::vector< VKImageView > imageViews;","title":"variable imageViews"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-queuefamilyproperties","text":"std::vector< queueFamilyProperties > queueFamilyProperties;","title":"variable queueFamilyProperties"},{"location":"api/Classes/classngfx_1_1VKSwapchain/#variable-createinfo","text":"VkSwapchainCreateInfoKHR createInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable createInfo"},{"location":"api/Classes/classngfx_1_1VKTexture/","text":"ngfx::VKTexture Inherits from ngfx::Texture Public Functions Name void create ( VKGraphicsContext * ctx, void * data, uint32_t size, VkExtent3D extent, uint32_t arrayLayers, VkFormat format, VkImageUsageFlags imageUsageFlags, VkImageViewType imageViewType, bool genMipmaps, VKSamplerCreateInfo * pSamplerCreateInfo, uint32_t numSamples =1) virtual ~VKTexture () virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) override virtual void generateMipmaps ( CommandBuffer * commandBuffer) override VKImageView * getImageView (VkImageViewType imageViewType, uint32_t mipLevels, uint32_t arrayLayers, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0) Public Attributes Name VkFormat vkFormat VKImage vkImage std::vector< std::unique_ptr< VKImageView > > vkImageViewCache VKImageView * vkDefaultImageView VkDescriptorSet samplerDescriptorSet VkDescriptorSet storageImageDescriptorSet VkSampler sampler VkImageAspectFlags aspectFlags bool depthTexture bool genMipmaps std::unique_ptr< VKSamplerCreateInfo > samplerCreateInfo Additional inherited members Public Functions inherited from ngfx::Texture Name virtual ~Texture () Public Attributes inherited from ngfx::Texture Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType Public Functions Documentation function create void create( VKGraphicsContext * ctx, void * data, uint32_t size, VkExtent3D extent, uint32_t arrayLayers, VkFormat format, VkImageUsageFlags imageUsageFlags, VkImageViewType imageViewType, bool genMipmaps, VKSamplerCreateInfo * pSamplerCreateInfo, uint32_t numSamples =1 ) function ~VKTexture virtual ~VKTexture() function upload virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::upload function download virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::download function changeLayout virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) override Reimplements : ngfx::Texture::changeLayout function generateMipmaps virtual void generateMipmaps( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Texture::generateMipmaps function getImageView VKImageView * getImageView( VkImageViewType imageViewType, uint32_t mipLevels, uint32_t arrayLayers, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0 ) Public Attributes Documentation variable vkFormat VkFormat vkFormat; variable vkImage VKImage vkImage; variable vkImageViewCache std::vector< std::unique_ptr< VKImageView > > vkImageViewCache; variable vkDefaultImageView VKImageView * vkDefaultImageView = nullptr; variable samplerDescriptorSet VkDescriptorSet samplerDescriptorSet = 0; variable storageImageDescriptorSet VkDescriptorSet storageImageDescriptorSet = 0; variable sampler VkSampler sampler = 0; variable aspectFlags VkImageAspectFlags aspectFlags; variable depthTexture bool depthTexture = false; variable genMipmaps bool genMipmaps = false; variable samplerCreateInfo std::unique_ptr< VKSamplerCreateInfo > samplerCreateInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKTexture"},{"location":"api/Classes/classngfx_1_1VKTexture/#ngfxvktexture","text":"Inherits from ngfx::Texture","title":"ngfx::VKTexture"},{"location":"api/Classes/classngfx_1_1VKTexture/#public-functions","text":"Name void create ( VKGraphicsContext * ctx, void * data, uint32_t size, VkExtent3D extent, uint32_t arrayLayers, VkFormat format, VkImageUsageFlags imageUsageFlags, VkImageViewType imageViewType, bool genMipmaps, VKSamplerCreateInfo * pSamplerCreateInfo, uint32_t numSamples =1) virtual ~VKTexture () virtual void upload (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void download (void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1) override virtual void changeLayout ( CommandBuffer * commandBuffer, ImageLayout imageLayout) override virtual void generateMipmaps ( CommandBuffer * commandBuffer) override VKImageView * getImageView (VkImageViewType imageViewType, uint32_t mipLevels, uint32_t arrayLayers, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKTexture/#public-attributes","text":"Name VkFormat vkFormat VKImage vkImage std::vector< std::unique_ptr< VKImageView > > vkImageViewCache VKImageView * vkDefaultImageView VkDescriptorSet samplerDescriptorSet VkDescriptorSet storageImageDescriptorSet VkSampler sampler VkImageAspectFlags aspectFlags bool depthTexture bool genMipmaps std::unique_ptr< VKSamplerCreateInfo > samplerCreateInfo","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKTexture/#additional-inherited-members","text":"Public Functions inherited from ngfx::Texture Name virtual ~Texture () Public Attributes inherited from ngfx::Texture Name PixelFormat format uint32_t w uint32_t h uint32_t d uint32_t arrayLayers uint32_t mipLevels uint32_t numSamples ImageUsageFlags imageUsageFlags TextureType textureType","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKTexture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKTexture/#function-create","text":"void create( VKGraphicsContext * ctx, void * data, uint32_t size, VkExtent3D extent, uint32_t arrayLayers, VkFormat format, VkImageUsageFlags imageUsageFlags, VkImageViewType imageViewType, bool genMipmaps, VKSamplerCreateInfo * pSamplerCreateInfo, uint32_t numSamples =1 )","title":"function create"},{"location":"api/Classes/classngfx_1_1VKTexture/#function-vktexture","text":"virtual ~VKTexture()","title":"function ~VKTexture"},{"location":"api/Classes/classngfx_1_1VKTexture/#function-upload","text":"virtual void upload( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::upload","title":"function upload"},{"location":"api/Classes/classngfx_1_1VKTexture/#function-download","text":"virtual void download( void * data, uint32_t size, uint32_t x =0, uint32_t y =0, uint32_t z =0, int32_t w =-1, int32_t h =-1, int32_t d =-1, int32_t arrayLayers =-1 ) override Reimplements : ngfx::Texture::download","title":"function download"},{"location":"api/Classes/classngfx_1_1VKTexture/#function-changelayout","text":"virtual void changeLayout( CommandBuffer * commandBuffer, ImageLayout imageLayout ) override Reimplements : ngfx::Texture::changeLayout","title":"function changeLayout"},{"location":"api/Classes/classngfx_1_1VKTexture/#function-generatemipmaps","text":"virtual void generateMipmaps( CommandBuffer * commandBuffer ) override Reimplements : ngfx::Texture::generateMipmaps","title":"function generateMipmaps"},{"location":"api/Classes/classngfx_1_1VKTexture/#function-getimageview","text":"VKImageView * getImageView( VkImageViewType imageViewType, uint32_t mipLevels, uint32_t arrayLayers, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0 )","title":"function getImageView"},{"location":"api/Classes/classngfx_1_1VKTexture/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-vkformat","text":"VkFormat vkFormat;","title":"variable vkFormat"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-vkimage","text":"VKImage vkImage;","title":"variable vkImage"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-vkimageviewcache","text":"std::vector< std::unique_ptr< VKImageView > > vkImageViewCache;","title":"variable vkImageViewCache"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-vkdefaultimageview","text":"VKImageView * vkDefaultImageView = nullptr;","title":"variable vkDefaultImageView"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-samplerdescriptorset","text":"VkDescriptorSet samplerDescriptorSet = 0;","title":"variable samplerDescriptorSet"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-storageimagedescriptorset","text":"VkDescriptorSet storageImageDescriptorSet = 0;","title":"variable storageImageDescriptorSet"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-sampler","text":"VkSampler sampler = 0;","title":"variable sampler"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-aspectflags","text":"VkImageAspectFlags aspectFlags;","title":"variable aspectFlags"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-depthtexture","text":"bool depthTexture = false;","title":"variable depthTexture"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-genmipmaps","text":"bool genMipmaps = false;","title":"variable genMipmaps"},{"location":"api/Classes/classngfx_1_1VKTexture/#variable-samplercreateinfo","text":"std::unique_ptr< VKSamplerCreateInfo > samplerCreateInfo; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable samplerCreateInfo"},{"location":"api/Classes/classngfx_1_1VKVertexShaderModule/","text":"ngfx::VKVertexShaderModule Inherits from ngfx::VertexShaderModule , ngfx::VKShaderModule , ngfx::ShaderModule Public Functions Name virtual ~VKVertexShaderModule () Additional inherited members Public Classes inherited from ngfx::VertexShaderModule Name struct AttributeDescription Public Functions inherited from ngfx::VertexShaderModule Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename) Public Attributes inherited from ngfx::VertexShaderModule Name std::vector< AttributeDescription > attributes Public Functions inherited from ngfx::VKShaderModule Name virtual void initFromFile (VkDevice device, const std::string & filename) virtual ~VKShaderModule () Protected Functions inherited from ngfx::VKShaderModule Name virtual void initFromByteCode (VkDevice device, void * data, uint32_t size) Public Attributes inherited from ngfx::VKShaderModule Name VkShaderModule v Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function ~VKVertexShaderModule inline virtual ~VKVertexShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKVertexShaderModule"},{"location":"api/Classes/classngfx_1_1VKVertexShaderModule/#ngfxvkvertexshadermodule","text":"Inherits from ngfx::VertexShaderModule , ngfx::VKShaderModule , ngfx::ShaderModule","title":"ngfx::VKVertexShaderModule"},{"location":"api/Classes/classngfx_1_1VKVertexShaderModule/#public-functions","text":"Name virtual ~VKVertexShaderModule ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKVertexShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::VertexShaderModule Name struct AttributeDescription Public Functions inherited from ngfx::VertexShaderModule Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename) Public Attributes inherited from ngfx::VertexShaderModule Name std::vector< AttributeDescription > attributes Public Functions inherited from ngfx::VKShaderModule Name virtual void initFromFile (VkDevice device, const std::string & filename) virtual ~VKShaderModule () Protected Functions inherited from ngfx::VKShaderModule Name virtual void initFromByteCode (VkDevice device, void * data, uint32_t size) Public Attributes inherited from ngfx::VKShaderModule Name VkShaderModule v Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) void initBindings (std::ifstream & in, ShaderStageFlags shaderStages) void initBindings (const std::string & filename, ShaderStageFlags shaderStages) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKVertexShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKVertexShaderModule/#function-vkvertexshadermodule","text":"inline virtual ~VKVertexShaderModule() Updated on 3 April 2021 at 20:21:51 PDT","title":"function ~VKVertexShaderModule"},{"location":"api/Classes/classngfx_1_1VKWindow/","text":"ngfx::VKWindow Inherits from ngfx::Window Public Functions Name virtual ~VKWindow () Public Attributes Name VKSurface vkSurface Protected Attributes Name VkInstance instance Additional inherited members Public Types inherited from ngfx::Window Name enum @2 { DISPLAY_WIDTH, DISPLAY_HEIGHT} Public Functions inherited from ngfx::Window Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () virtual bool shouldClose () =0 virtual void pollEvents () =0 Public Attributes inherited from ngfx::Window Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton Public Functions Documentation function ~VKWindow inline virtual ~VKWindow() Public Attributes Documentation variable vkSurface VKSurface vkSurface; Protected Attributes Documentation variable instance VkInstance instance; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKWindow"},{"location":"api/Classes/classngfx_1_1VKWindow/#ngfxvkwindow","text":"Inherits from ngfx::Window","title":"ngfx::VKWindow"},{"location":"api/Classes/classngfx_1_1VKWindow/#public-functions","text":"Name virtual ~VKWindow ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VKWindow/#public-attributes","text":"Name VKSurface vkSurface","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VKWindow/#protected-attributes","text":"Name VkInstance instance","title":"Protected Attributes"},{"location":"api/Classes/classngfx_1_1VKWindow/#additional-inherited-members","text":"Public Types inherited from ngfx::Window Name enum @2 { DISPLAY_WIDTH, DISPLAY_HEIGHT} Public Functions inherited from ngfx::Window Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () virtual bool shouldClose () =0 virtual void pollEvents () =0 Public Attributes inherited from ngfx::Window Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VKWindow/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VKWindow/#function-vkwindow","text":"inline virtual ~VKWindow()","title":"function ~VKWindow"},{"location":"api/Classes/classngfx_1_1VKWindow/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKWindow/#variable-vksurface","text":"VKSurface vkSurface;","title":"variable vkSurface"},{"location":"api/Classes/classngfx_1_1VKWindow/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VKWindow/#variable-instance","text":"VkInstance instance; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable instance"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/","text":"ngfx::VertexShaderModule Inherits from ngfx::ShaderModule Inherited by ngfx::D3DVertexShaderModule , ngfx::MTLVertexShaderModule , ngfx::VKVertexShaderModule Public Classes Name struct AttributeDescription Public Functions Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename) Public Attributes Name std::vector< AttributeDescription > attributes Additional inherited members Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos Public Functions Documentation function create static std::unique_ptr< VertexShaderModule > create( Device * device, const std::string & filename ) function ~VertexShaderModule inline virtual ~VertexShaderModule() function findAttribute inline AttributeDescription * findAttribute( const std::string & name ) function initBindings void initBindings( const std::string & filename ) Public Attributes Documentation variable attributes std::vector< AttributeDescription > attributes; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VertexShaderModule"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#ngfxvertexshadermodule","text":"Inherits from ngfx::ShaderModule Inherited by ngfx::D3DVertexShaderModule , ngfx::MTLVertexShaderModule , ngfx::VKVertexShaderModule","title":"ngfx::VertexShaderModule"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-classes","text":"Name struct AttributeDescription","title":"Public Classes"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-functions","text":"Name std::unique_ptr< VertexShaderModule > create ( Device * device, const std::string & filename) virtual ~VertexShaderModule () AttributeDescription * findAttribute (const std::string & name) void initBindings (const std::string & filename)","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-attributes","text":"Name std::vector< AttributeDescription > attributes","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#additional-inherited-members","text":"Public Classes inherited from ngfx::ShaderModule Name struct BufferInfo struct BufferMemberInfo struct DescriptorInfo Public Types inherited from ngfx::ShaderModule Name typedef std::vector< DescriptorInfo > DescriptorInfos typedef std::map< std::string, BufferMemberInfo > BufferMemberInfos typedef std::map< std::string, BufferInfo > BufferInfos Public Functions inherited from ngfx::ShaderModule Name virtual ~ShaderModule () DescriptorInfo * findDescriptorInfo (const std::string & name) BufferInfo * findUniformBufferInfo (const std::string & name) BufferInfo * findStorageBufferInfo (const std::string & name) Public Attributes inherited from ngfx::ShaderModule Name DescriptorInfos descriptors BufferInfos uniformBufferInfos BufferInfos shaderStorageBufferInfos","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-create","text":"static std::unique_ptr< VertexShaderModule > create( Device * device, const std::string & filename )","title":"function create"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-vertexshadermodule","text":"inline virtual ~VertexShaderModule()","title":"function ~VertexShaderModule"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-findattribute","text":"inline AttributeDescription * findAttribute( const std::string & name )","title":"function findAttribute"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#function-initbindings","text":"void initBindings( const std::string & filename )","title":"function initBindings"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1VertexShaderModule/#variable-attributes","text":"std::vector< AttributeDescription > attributes; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable attributes"},{"location":"api/Classes/classngfx_1_1WWindow/","text":"ngfx::WWindow Inherits from ngfx::D3DWindow , ngfx::Window Public Functions Name void create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w, int h) virtual bool shouldClose () virtual void pollEvents () virtual ~WWindow () virtual void destroySurface () Additional inherited members Public Functions inherited from ngfx::D3DWindow Name virtual ~D3DWindow () Public Attributes inherited from ngfx::D3DWindow Name D3DSurface d3dSurface Public Types inherited from ngfx::Window Name enum @2 { DISPLAY_WIDTH, DISPLAY_HEIGHT} Public Functions inherited from ngfx::Window Name virtual ~Window () Public Attributes inherited from ngfx::Window Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton Public Functions Documentation function create void create( GraphicsContext * graphicsContext, const char * title, std::function< void(Window *thiz)> onWindowCreated, int w, int h ) function shouldClose virtual bool shouldClose() Reimplements : ngfx::Window::shouldClose function pollEvents virtual void pollEvents() Reimplements : ngfx::Window::pollEvents function ~WWindow virtual ~WWindow() function destroySurface virtual void destroySurface() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::WWindow"},{"location":"api/Classes/classngfx_1_1WWindow/#ngfxwwindow","text":"Inherits from ngfx::D3DWindow , ngfx::Window","title":"ngfx::WWindow"},{"location":"api/Classes/classngfx_1_1WWindow/#public-functions","text":"Name void create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w, int h) virtual bool shouldClose () virtual void pollEvents () virtual ~WWindow () virtual void destroySurface ()","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1WWindow/#additional-inherited-members","text":"Public Functions inherited from ngfx::D3DWindow Name virtual ~D3DWindow () Public Attributes inherited from ngfx::D3DWindow Name D3DSurface d3dSurface Public Types inherited from ngfx::Window Name enum @2 { DISPLAY_WIDTH, DISPLAY_HEIGHT} Public Functions inherited from ngfx::Window Name virtual ~Window () Public Attributes inherited from ngfx::Window Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton","title":"Additional inherited members"},{"location":"api/Classes/classngfx_1_1WWindow/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1WWindow/#function-create","text":"void create( GraphicsContext * graphicsContext, const char * title, std::function< void(Window *thiz)> onWindowCreated, int w, int h )","title":"function create"},{"location":"api/Classes/classngfx_1_1WWindow/#function-shouldclose","text":"virtual bool shouldClose() Reimplements : ngfx::Window::shouldClose","title":"function shouldClose"},{"location":"api/Classes/classngfx_1_1WWindow/#function-pollevents","text":"virtual void pollEvents() Reimplements : ngfx::Window::pollEvents","title":"function pollEvents"},{"location":"api/Classes/classngfx_1_1WWindow/#function-wwindow","text":"virtual ~WWindow()","title":"function ~WWindow"},{"location":"api/Classes/classngfx_1_1WWindow/#function-destroysurface","text":"virtual void destroySurface() Updated on 3 April 2021 at 20:21:51 PDT","title":"function destroySurface"},{"location":"api/Classes/classngfx_1_1Window/","text":"ngfx::Window Inherited by ngfx::D3DWindow , ngfx::MTLWindow , ngfx::VKWindow Public Types Name enum @2 { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1} Public Functions Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () virtual bool shouldClose () =0 virtual void pollEvents () =0 Public Attributes Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton Public Types Documentation enum @2 Enumerator Value Description DISPLAY_WIDTH -1 DISPLAY_HEIGHT -1 Public Functions Documentation function create static Window * create( GraphicsContext * graphicsContext, const char * title, std::function< void(Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT ) function ~Window inline virtual ~Window() function shouldClose virtual bool shouldClose() =0 Reimplemented by : ngfx::WWindow::shouldClose , ngfx::MTLWindow::shouldClose function pollEvents virtual void pollEvents() =0 Reimplemented by : ngfx::WWindow::pollEvents , ngfx::MTLWindow::pollEvents Public Attributes Documentation variable w int w; variable h int h; variable surface Surface * surface = nullptr; variable onUpdate std::function< void()> onUpdate = nullptr; variable onPaint std::function< void()> onPaint = nullptr; variable onKey std::function< void(KeyCode code, InputAction action)> onKey = nullptr; variable onScroll std::function< void(double xoffset, double yoffset)> onScroll = nullptr; variable onCursorPos std::function< void(double x, double y)> onCursorPos = nullptr; variable onMouseButton std::function< void(MouseButton button, InputAction action)> onMouseButton = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Window"},{"location":"api/Classes/classngfx_1_1Window/#ngfxwindow","text":"Inherited by ngfx::D3DWindow , ngfx::MTLWindow , ngfx::VKWindow","title":"ngfx::Window"},{"location":"api/Classes/classngfx_1_1Window/#public-types","text":"Name enum @2 { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1}","title":"Public Types"},{"location":"api/Classes/classngfx_1_1Window/#public-functions","text":"Name Window * create ( GraphicsContext * graphicsContext, const char * title, std::function< void( Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT) virtual ~Window () virtual bool shouldClose () =0 virtual void pollEvents () =0","title":"Public Functions"},{"location":"api/Classes/classngfx_1_1Window/#public-attributes","text":"Name int w int h Surface * surface std::function< void()> onUpdate std::function< void()> onPaint std::function< void(KeyCode code, InputAction action)> onKey std::function< void(double xoffset, double yoffset)> onScroll std::function< void(double x, double y)> onCursorPos std::function< void(MouseButton button, InputAction action)> onMouseButton","title":"Public Attributes"},{"location":"api/Classes/classngfx_1_1Window/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/classngfx_1_1Window/#enum-2","text":"Enumerator Value Description DISPLAY_WIDTH -1 DISPLAY_HEIGHT -1","title":"enum @2"},{"location":"api/Classes/classngfx_1_1Window/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/classngfx_1_1Window/#function-create","text":"static Window * create( GraphicsContext * graphicsContext, const char * title, std::function< void(Window *thiz)> onWindowCreated, int w =DISPLAY_WIDTH, int h =DISPLAY_HEIGHT )","title":"function create"},{"location":"api/Classes/classngfx_1_1Window/#function-window","text":"inline virtual ~Window()","title":"function ~Window"},{"location":"api/Classes/classngfx_1_1Window/#function-shouldclose","text":"virtual bool shouldClose() =0 Reimplemented by : ngfx::WWindow::shouldClose , ngfx::MTLWindow::shouldClose","title":"function shouldClose"},{"location":"api/Classes/classngfx_1_1Window/#function-pollevents","text":"virtual void pollEvents() =0 Reimplemented by : ngfx::WWindow::pollEvents , ngfx::MTLWindow::pollEvents","title":"function pollEvents"},{"location":"api/Classes/classngfx_1_1Window/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/classngfx_1_1Window/#variable-w","text":"int w;","title":"variable w"},{"location":"api/Classes/classngfx_1_1Window/#variable-h","text":"int h;","title":"variable h"},{"location":"api/Classes/classngfx_1_1Window/#variable-surface","text":"Surface * surface = nullptr;","title":"variable surface"},{"location":"api/Classes/classngfx_1_1Window/#variable-onupdate","text":"std::function< void()> onUpdate = nullptr;","title":"variable onUpdate"},{"location":"api/Classes/classngfx_1_1Window/#variable-onpaint","text":"std::function< void()> onPaint = nullptr;","title":"variable onPaint"},{"location":"api/Classes/classngfx_1_1Window/#variable-onkey","text":"std::function< void(KeyCode code, InputAction action)> onKey = nullptr;","title":"variable onKey"},{"location":"api/Classes/classngfx_1_1Window/#variable-onscroll","text":"std::function< void(double xoffset, double yoffset)> onScroll = nullptr;","title":"variable onScroll"},{"location":"api/Classes/classngfx_1_1Window/#variable-oncursorpos","text":"std::function< void(double x, double y)> onCursorPos = nullptr;","title":"variable onCursorPos"},{"location":"api/Classes/classngfx_1_1Window/#variable-onmousebutton","text":"std::function< void(MouseButton button, InputAction action)> onMouseButton = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable onMouseButton"},{"location":"api/Classes/interfaceAppDelegate/","text":"AppDelegate Inherits from NSObject, Updated on 3 April 2021 at 20:21:51 PDT","title":"AppDelegate"},{"location":"api/Classes/interfaceAppDelegate/#appdelegate","text":"Inherits from NSObject, Updated on 3 April 2021 at 20:21:51 PDT","title":"AppDelegate"},{"location":"api/Classes/interfaceMTLViewDelegate/","text":"MTLViewDelegate Inherits from NSObject, Public Functions Name virtual nonnull instancetype create: (nonnull MTKView * mtkView) Public Functions Documentation function create: virtual nonnull instancetype create:( nonnull MTKView * mtkView ) Updated on 3 April 2021 at 20:21:51 PDT","title":"MTLViewDelegate"},{"location":"api/Classes/interfaceMTLViewDelegate/#mtlviewdelegate","text":"Inherits from NSObject,","title":"MTLViewDelegate"},{"location":"api/Classes/interfaceMTLViewDelegate/#public-functions","text":"Name virtual nonnull instancetype create: (nonnull MTKView * mtkView)","title":"Public Functions"},{"location":"api/Classes/interfaceMTLViewDelegate/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/interfaceMTLViewDelegate/#function-create","text":"virtual nonnull instancetype create:( nonnull MTKView * mtkView ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function create:"},{"location":"api/Classes/interfaceViewController/","text":"ViewController Inherits from NSViewController Updated on 3 April 2021 at 20:21:51 PDT","title":"ViewController"},{"location":"api/Classes/interfaceViewController/#viewcontroller","text":"Inherits from NSViewController Updated on 3 April 2021 at 20:21:51 PDT","title":"ViewController"},{"location":"api/Classes/structDebugUtil/","text":"DebugUtil Public Functions Name void Exit (uint32_t code) Public Functions Documentation function Exit static inline void Exit( uint32_t code ) Updated on 3 April 2021 at 20:21:51 PDT","title":"DebugUtil"},{"location":"api/Classes/structDebugUtil/#debugutil","text":"","title":"DebugUtil"},{"location":"api/Classes/structDebugUtil/#public-functions","text":"Name void Exit (uint32_t code)","title":"Public Functions"},{"location":"api/Classes/structDebugUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structDebugUtil/#function-exit","text":"static inline void Exit( uint32_t code ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function Exit"},{"location":"api/Classes/structMTLGraphicsUtil/","text":"MTLGraphicsUtil Public Functions Name void setViewport ( MTLGraphics * g, Rect2D & r) void setScissor ( MTLGraphics * g, Rect2D & r) Public Functions Documentation function setViewport static inline void setViewport( MTLGraphics * g, Rect2D & r ) function setScissor static inline void setScissor( MTLGraphics * g, Rect2D & r ) Updated on 3 April 2021 at 20:21:51 PDT","title":"MTLGraphicsUtil"},{"location":"api/Classes/structMTLGraphicsUtil/#mtlgraphicsutil","text":"","title":"MTLGraphicsUtil"},{"location":"api/Classes/structMTLGraphicsUtil/#public-functions","text":"Name void setViewport ( MTLGraphics * g, Rect2D & r) void setScissor ( MTLGraphics * g, Rect2D & r)","title":"Public Functions"},{"location":"api/Classes/structMTLGraphicsUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structMTLGraphicsUtil/#function-setviewport","text":"static inline void setViewport( MTLGraphics * g, Rect2D & r )","title":"function setViewport"},{"location":"api/Classes/structMTLGraphicsUtil/#function-setscissor","text":"static inline void setScissor( MTLGraphics * g, Rect2D & r ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function setScissor"},{"location":"api/Classes/structVertexFormatInfo/","text":"VertexFormatInfo Public Attributes Name VertexFormat format uint32_t count uint32_t elementSize Public Attributes Documentation variable format VertexFormat format; variable count uint32_t count; variable elementSize uint32_t elementSize; Updated on 3 April 2021 at 20:21:51 PDT","title":"VertexFormatInfo"},{"location":"api/Classes/structVertexFormatInfo/#vertexformatinfo","text":"","title":"VertexFormatInfo"},{"location":"api/Classes/structVertexFormatInfo/#public-attributes","text":"Name VertexFormat format uint32_t count uint32_t elementSize","title":"Public Attributes"},{"location":"api/Classes/structVertexFormatInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structVertexFormatInfo/#variable-format","text":"VertexFormat format;","title":"variable format"},{"location":"api/Classes/structVertexFormatInfo/#variable-count","text":"uint32_t count;","title":"variable count"},{"location":"api/Classes/structVertexFormatInfo/#variable-elementsize","text":"uint32_t elementSize; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable elementSize"},{"location":"api/Classes/structngfx_1_1D3DBlitOp_1_1UBOData/","text":"ngfx::D3DBlitOp::UBOData Public Attributes Name uint32_t lod uint32_t padding Public Attributes Documentation variable lod uint32_t lod; variable padding uint32_t padding; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DBlitOp::UBOData"},{"location":"api/Classes/structngfx_1_1D3DBlitOp_1_1UBOData/#ngfxd3dblitopubodata","text":"","title":"ngfx::D3DBlitOp::UBOData"},{"location":"api/Classes/structngfx_1_1D3DBlitOp_1_1UBOData/#public-attributes","text":"Name uint32_t lod uint32_t padding","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1D3DBlitOp_1_1UBOData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1D3DBlitOp_1_1UBOData/#variable-lod","text":"uint32_t lod;","title":"variable lod"},{"location":"api/Classes/structngfx_1_1D3DBlitOp_1_1UBOData/#variable-padding","text":"uint32_t padding; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable padding"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/","text":"ngfx::D3DFramebuffer::D3DAttachment Public Attributes Name ID3D12Resource * resource D3D12_CPU_DESCRIPTOR_HANDLE cpuDescriptor uint32_t subresourceIndex uint32_t imageUsageFlags uint32_t numSamples DXGI_FORMAT format D3DTexture * texture Public Attributes Documentation variable resource ID3D12Resource * resource; variable cpuDescriptor D3D12_CPU_DESCRIPTOR_HANDLE cpuDescriptor; variable subresourceIndex uint32_t subresourceIndex = 0; variable imageUsageFlags uint32_t imageUsageFlags = 0; variable numSamples uint32_t numSamples = 1; variable format DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN; variable texture D3DTexture * texture = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DFramebuffer::D3DAttachment"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/#ngfxd3dframebufferd3dattachment","text":"","title":"ngfx::D3DFramebuffer::D3DAttachment"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/#public-attributes","text":"Name ID3D12Resource * resource D3D12_CPU_DESCRIPTOR_HANDLE cpuDescriptor uint32_t subresourceIndex uint32_t imageUsageFlags uint32_t numSamples DXGI_FORMAT format D3DTexture * texture","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/#variable-resource","text":"ID3D12Resource * resource;","title":"variable resource"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/#variable-cpudescriptor","text":"D3D12_CPU_DESCRIPTOR_HANDLE cpuDescriptor;","title":"variable cpuDescriptor"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/#variable-subresourceindex","text":"uint32_t subresourceIndex = 0;","title":"variable subresourceIndex"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/#variable-imageusageflags","text":"uint32_t imageUsageFlags = 0;","title":"variable imageUsageFlags"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/#variable-numsamples","text":"uint32_t numSamples = 1;","title":"variable numSamples"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/#variable-format","text":"DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN;","title":"variable format"},{"location":"api/Classes/structngfx_1_1D3DFramebuffer_1_1D3DAttachment/#variable-texture","text":"D3DTexture * texture = nullptr; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable texture"},{"location":"api/Classes/structngfx_1_1D3DGraphicsContext_1_1D3DRenderPassData/","text":"ngfx::D3DGraphicsContext::D3DRenderPassData Public Attributes Name RenderPassConfig config D3DRenderPass d3dRenderPass Public Attributes Documentation variable config RenderPassConfig config; variable d3dRenderPass D3DRenderPass d3dRenderPass; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DGraphicsContext::D3DRenderPassData"},{"location":"api/Classes/structngfx_1_1D3DGraphicsContext_1_1D3DRenderPassData/#ngfxd3dgraphicscontextd3drenderpassdata","text":"","title":"ngfx::D3DGraphicsContext::D3DRenderPassData"},{"location":"api/Classes/structngfx_1_1D3DGraphicsContext_1_1D3DRenderPassData/#public-attributes","text":"Name RenderPassConfig config D3DRenderPass d3dRenderPass","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1D3DGraphicsContext_1_1D3DRenderPassData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1D3DGraphicsContext_1_1D3DRenderPassData/#variable-config","text":"RenderPassConfig config;","title":"variable config"},{"location":"api/Classes/structngfx_1_1D3DGraphicsContext_1_1D3DRenderPassData/#variable-d3drenderpass","text":"D3DRenderPass d3dRenderPass; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable d3dRenderPass"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1Shaders/","text":"ngfx::D3DGraphicsPipeline::Shaders Public Attributes Name D3D12_SHADER_BYTECODE VS D3D12_SHADER_BYTECODE PS D3D12_SHADER_BYTECODE DS D3D12_SHADER_BYTECODE HS D3D12_SHADER_BYTECODE GS Public Attributes Documentation variable VS D3D12_SHADER_BYTECODE VS {}; variable PS D3D12_SHADER_BYTECODE PS {}; variable DS D3D12_SHADER_BYTECODE DS {}; variable HS D3D12_SHADER_BYTECODE HS {}; variable GS D3D12_SHADER_BYTECODE GS {}; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DGraphicsPipeline::Shaders"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1Shaders/#ngfxd3dgraphicspipelineshaders","text":"","title":"ngfx::D3DGraphicsPipeline::Shaders"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1Shaders/#public-attributes","text":"Name D3D12_SHADER_BYTECODE VS D3D12_SHADER_BYTECODE PS D3D12_SHADER_BYTECODE DS D3D12_SHADER_BYTECODE HS D3D12_SHADER_BYTECODE GS","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1Shaders/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1Shaders/#variable-vs","text":"D3D12_SHADER_BYTECODE VS {};","title":"variable VS"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1Shaders/#variable-ps","text":"D3D12_SHADER_BYTECODE PS {};","title":"variable PS"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1Shaders/#variable-ds","text":"D3D12_SHADER_BYTECODE DS {};","title":"variable DS"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1Shaders/#variable-hs","text":"D3D12_SHADER_BYTECODE HS {};","title":"variable HS"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1Shaders/#variable-gs","text":"D3D12_SHADER_BYTECODE GS {}; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable GS"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/","text":"ngfx::D3DGraphicsPipeline::State Public Attributes Name D3D12_PRIMITIVE_TOPOLOGY primitiveTopology D3D12_FILL_MODE fillMode bool blendEnable D3D12_BLEND blendSrcColorFactor D3D12_BLEND blendDstColorFactor D3D12_BLEND_OP blendColorOp D3D12_BLEND blendSrcAlphaFactor D3D12_BLEND blendDstAlphaFactor D3D12_BLEND_OP blendAlphaOp UINT8 colorWriteMask D3D12_CULL_MODE cullMode bool frontFaceCounterClockwise float lineWidth bool depthTestEnable bool depthWriteEnable D3DRenderPass * renderPass uint32_t numSamples uint32_t numColorAttachments Public Attributes Documentation variable primitiveTopology D3D12_PRIMITIVE_TOPOLOGY primitiveTopology = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST; variable fillMode D3D12_FILL_MODE fillMode = D3D12_FILL_MODE_SOLID; variable blendEnable bool blendEnable = false; variable blendSrcColorFactor D3D12_BLEND blendSrcColorFactor = D3D12_BLEND_SRC_ALPHA; variable blendDstColorFactor D3D12_BLEND blendDstColorFactor = D3D12_BLEND_INV_SRC_ALPHA; variable blendColorOp D3D12_BLEND_OP blendColorOp = D3D12_BLEND_OP_ADD; variable blendSrcAlphaFactor D3D12_BLEND blendSrcAlphaFactor = D3D12_BLEND_SRC_ALPHA; variable blendDstAlphaFactor D3D12_BLEND blendDstAlphaFactor = D3D12_BLEND_INV_SRC_ALPHA; variable blendAlphaOp D3D12_BLEND_OP blendAlphaOp = D3D12_BLEND_OP_ADD; variable colorWriteMask UINT8 colorWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; variable cullMode D3D12_CULL_MODE cullMode = D3D12_CULL_MODE_BACK; variable frontFaceCounterClockwise bool frontFaceCounterClockwise = false; variable lineWidth float lineWidth = 1.0f; variable depthTestEnable bool depthTestEnable = false; variable depthWriteEnable bool depthWriteEnable = false; variable renderPass D3DRenderPass * renderPass = nullptr; variable numSamples uint32_t numSamples = 1; variable numColorAttachments uint32_t numColorAttachments = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DGraphicsPipeline::State"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#ngfxd3dgraphicspipelinestate","text":"","title":"ngfx::D3DGraphicsPipeline::State"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#public-attributes","text":"Name D3D12_PRIMITIVE_TOPOLOGY primitiveTopology D3D12_FILL_MODE fillMode bool blendEnable D3D12_BLEND blendSrcColorFactor D3D12_BLEND blendDstColorFactor D3D12_BLEND_OP blendColorOp D3D12_BLEND blendSrcAlphaFactor D3D12_BLEND blendDstAlphaFactor D3D12_BLEND_OP blendAlphaOp UINT8 colorWriteMask D3D12_CULL_MODE cullMode bool frontFaceCounterClockwise float lineWidth bool depthTestEnable bool depthWriteEnable D3DRenderPass * renderPass uint32_t numSamples uint32_t numColorAttachments","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-primitivetopology","text":"D3D12_PRIMITIVE_TOPOLOGY primitiveTopology = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;","title":"variable primitiveTopology"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-fillmode","text":"D3D12_FILL_MODE fillMode = D3D12_FILL_MODE_SOLID;","title":"variable fillMode"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-blendenable","text":"bool blendEnable = false;","title":"variable blendEnable"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-blendsrccolorfactor","text":"D3D12_BLEND blendSrcColorFactor = D3D12_BLEND_SRC_ALPHA;","title":"variable blendSrcColorFactor"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-blenddstcolorfactor","text":"D3D12_BLEND blendDstColorFactor = D3D12_BLEND_INV_SRC_ALPHA;","title":"variable blendDstColorFactor"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-blendcolorop","text":"D3D12_BLEND_OP blendColorOp = D3D12_BLEND_OP_ADD;","title":"variable blendColorOp"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-blendsrcalphafactor","text":"D3D12_BLEND blendSrcAlphaFactor = D3D12_BLEND_SRC_ALPHA;","title":"variable blendSrcAlphaFactor"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-blenddstalphafactor","text":"D3D12_BLEND blendDstAlphaFactor = D3D12_BLEND_INV_SRC_ALPHA;","title":"variable blendDstAlphaFactor"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-blendalphaop","text":"D3D12_BLEND_OP blendAlphaOp = D3D12_BLEND_OP_ADD;","title":"variable blendAlphaOp"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-colorwritemask","text":"UINT8 colorWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;","title":"variable colorWriteMask"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-cullmode","text":"D3D12_CULL_MODE cullMode = D3D12_CULL_MODE_BACK;","title":"variable cullMode"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-frontfacecounterclockwise","text":"bool frontFaceCounterClockwise = false;","title":"variable frontFaceCounterClockwise"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-linewidth","text":"float lineWidth = 1.0f;","title":"variable lineWidth"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-depthtestenable","text":"bool depthTestEnable = false;","title":"variable depthTestEnable"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-depthwriteenable","text":"bool depthWriteEnable = false;","title":"variable depthWriteEnable"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-renderpass","text":"D3DRenderPass * renderPass = nullptr;","title":"variable renderPass"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-numsamples","text":"uint32_t numSamples = 1;","title":"variable numSamples"},{"location":"api/Classes/structngfx_1_1D3DGraphicsPipeline_1_1State/#variable-numcolorattachments","text":"uint32_t numColorAttachments = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable numColorAttachments"},{"location":"api/Classes/structngfx_1_1D3DPipelineUtil/","text":"ngfx::D3DPipelineUtil Public Types Name enum PipelineType { PIPELINE_TYPE_COMPUTE, PIPELINE_TYPE_GRAPHICS} Public Functions Name void parseDescriptors (std::map< uint32_t, ShaderModule::DescriptorInfo > & uniforms, std::vector< uint32_t > & uniformBindings, std::vector< CD3DX12_ROOT_PARAMETER1 > & d3dRootParams, std::vector< std::unique_ptr< CD3DX12_DESCRIPTOR_RANGE1 >> & d3dDescriptorRanges, PipelineType pipelineType) Public Types Documentation enum PipelineType Enumerator Value Description PIPELINE_TYPE_COMPUTE PIPELINE_TYPE_GRAPHICS Public Functions Documentation function parseDescriptors static void parseDescriptors( std::map< uint32_t, ShaderModule::DescriptorInfo > & uniforms, std::vector< uint32_t > & uniformBindings, std::vector< CD3DX12_ROOT_PARAMETER1 > & d3dRootParams, std::vector< std::unique_ptr< CD3DX12_DESCRIPTOR_RANGE1 >> & d3dDescriptorRanges, PipelineType pipelineType ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DPipelineUtil"},{"location":"api/Classes/structngfx_1_1D3DPipelineUtil/#ngfxd3dpipelineutil","text":"","title":"ngfx::D3DPipelineUtil"},{"location":"api/Classes/structngfx_1_1D3DPipelineUtil/#public-types","text":"Name enum PipelineType { PIPELINE_TYPE_COMPUTE, PIPELINE_TYPE_GRAPHICS}","title":"Public Types"},{"location":"api/Classes/structngfx_1_1D3DPipelineUtil/#public-functions","text":"Name void parseDescriptors (std::map< uint32_t, ShaderModule::DescriptorInfo > & uniforms, std::vector< uint32_t > & uniformBindings, std::vector< CD3DX12_ROOT_PARAMETER1 > & d3dRootParams, std::vector< std::unique_ptr< CD3DX12_DESCRIPTOR_RANGE1 >> & d3dDescriptorRanges, PipelineType pipelineType)","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1D3DPipelineUtil/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"api/Classes/structngfx_1_1D3DPipelineUtil/#enum-pipelinetype","text":"Enumerator Value Description PIPELINE_TYPE_COMPUTE PIPELINE_TYPE_GRAPHICS","title":"enum PipelineType"},{"location":"api/Classes/structngfx_1_1D3DPipelineUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1D3DPipelineUtil/#function-parsedescriptors","text":"static void parseDescriptors( std::map< uint32_t, ShaderModule::DescriptorInfo > & uniforms, std::vector< uint32_t > & uniformBindings, std::vector< CD3DX12_ROOT_PARAMETER1 > & d3dRootParams, std::vector< std::unique_ptr< CD3DX12_DESCRIPTOR_RANGE1 >> & d3dDescriptorRanges, PipelineType pipelineType ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function parseDescriptors"},{"location":"api/Classes/structngfx_1_1D3DSamplerDesc/","text":"ngfx::D3DSamplerDesc Inherits from D3D12_SAMPLER_DESC Public Functions Name D3DSamplerDesc () Public Functions Documentation function D3DSamplerDesc inline D3DSamplerDesc() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DSamplerDesc"},{"location":"api/Classes/structngfx_1_1D3DSamplerDesc/#ngfxd3dsamplerdesc","text":"Inherits from D3D12_SAMPLER_DESC","title":"ngfx::D3DSamplerDesc"},{"location":"api/Classes/structngfx_1_1D3DSamplerDesc/#public-functions","text":"Name D3DSamplerDesc ()","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1D3DSamplerDesc/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1D3DSamplerDesc/#function-d3dsamplerdesc","text":"inline D3DSamplerDesc() Updated on 3 April 2021 at 20:21:51 PDT","title":"function D3DSamplerDesc"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1GenMipmapData/","text":"ngfx::D3DTexture::GenMipmapData Public Attributes Name std::vector< D3DBlitOp > ops Public Attributes Documentation variable ops std::vector< D3DBlitOp > ops; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DTexture::GenMipmapData"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1GenMipmapData/#ngfxd3dtexturegenmipmapdata","text":"","title":"ngfx::D3DTexture::GenMipmapData"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1GenMipmapData/#public-attributes","text":"Name std::vector< D3DBlitOp > ops","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1GenMipmapData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1GenMipmapData/#variable-ops","text":"std::vector< D3DBlitOp > ops; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable ops"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1RtvData/","text":"ngfx::D3DTexture::RtvData Public Attributes Name D3D12_RENDER_TARGET_VIEW_DESC desc D3DDescriptorHandle handle Public Attributes Documentation variable desc D3D12_RENDER_TARGET_VIEW_DESC desc; variable handle D3DDescriptorHandle handle; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DTexture::RtvData"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1RtvData/#ngfxd3dtexturertvdata","text":"","title":"ngfx::D3DTexture::RtvData"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1RtvData/#public-attributes","text":"Name D3D12_RENDER_TARGET_VIEW_DESC desc D3DDescriptorHandle handle","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1RtvData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1RtvData/#variable-desc","text":"D3D12_RENDER_TARGET_VIEW_DESC desc;","title":"variable desc"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1RtvData/#variable-handle","text":"D3DDescriptorHandle handle; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable handle"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SamplerData/","text":"ngfx::D3DTexture::SamplerData Public Attributes Name D3DSamplerDesc desc D3DDescriptorHandle handle Public Attributes Documentation variable desc D3DSamplerDesc desc; variable handle D3DDescriptorHandle handle; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DTexture::SamplerData"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SamplerData/#ngfxd3dtexturesamplerdata","text":"","title":"ngfx::D3DTexture::SamplerData"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SamplerData/#public-attributes","text":"Name D3DSamplerDesc desc D3DDescriptorHandle handle","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SamplerData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SamplerData/#variable-desc","text":"D3DSamplerDesc desc;","title":"variable desc"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SamplerData/#variable-handle","text":"D3DDescriptorHandle handle; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable handle"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SrvData/","text":"ngfx::D3DTexture::SrvData Public Attributes Name D3D12_SHADER_RESOURCE_VIEW_DESC desc D3DDescriptorHandle handle Public Attributes Documentation variable desc D3D12_SHADER_RESOURCE_VIEW_DESC desc; variable handle D3DDescriptorHandle handle; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::D3DTexture::SrvData"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SrvData/#ngfxd3dtexturesrvdata","text":"","title":"ngfx::D3DTexture::SrvData"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SrvData/#public-attributes","text":"Name D3D12_SHADER_RESOURCE_VIEW_DESC desc D3DDescriptorHandle handle","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SrvData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SrvData/#variable-desc","text":"D3D12_SHADER_RESOURCE_VIEW_DESC desc;","title":"variable desc"},{"location":"api/Classes/structngfx_1_1D3DTexture_1_1SrvData/#variable-handle","text":"D3DDescriptorHandle handle; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable handle"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/","text":"ngfx::DrawMeshOp::LightData Public Attributes Name vec4 ambient vec4 diffuse vec4 specular vec4 lightViewPos vec2 shininess vec2 padding Public Attributes Documentation variable ambient vec4 ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f); variable diffuse vec4 diffuse = vec4(1.0f); variable specular vec4 specular = vec4(1.0f); variable lightViewPos vec4 lightViewPos = vec4(0.0f, 0.0f, 1.0f, 1.0f); variable shininess vec2 shininess = vec2(10.0f, 0.0f); variable padding vec2 padding; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::DrawMeshOp::LightData"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#ngfxdrawmeshoplightdata","text":"","title":"ngfx::DrawMeshOp::LightData"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#public-attributes","text":"Name vec4 ambient vec4 diffuse vec4 specular vec4 lightViewPos vec2 shininess vec2 padding","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-ambient","text":"vec4 ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f);","title":"variable ambient"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-diffuse","text":"vec4 diffuse = vec4(1.0f);","title":"variable diffuse"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-specular","text":"vec4 specular = vec4(1.0f);","title":"variable specular"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-lightviewpos","text":"vec4 lightViewPos = vec4(0.0f, 0.0f, 1.0f, 1.0f);","title":"variable lightViewPos"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-shininess","text":"vec2 shininess = vec2(10.0f, 0.0f);","title":"variable shininess"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1LightData/#variable-padding","text":"vec2 padding; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable padding"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__FS__Data/","text":"ngfx::DrawMeshOp::UBO_FS_Data Public Attributes Name LightData light0 Public Attributes Documentation variable light0 LightData light0; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::DrawMeshOp::UBO_FS_Data"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__FS__Data/#ngfxdrawmeshopubo_fs_data","text":"","title":"ngfx::DrawMeshOp::UBO_FS_Data"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__FS__Data/#public-attributes","text":"Name LightData light0","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__FS__Data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__FS__Data/#variable-light0","text":"LightData light0; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable light0"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/","text":"ngfx::DrawMeshOp::UBO_VS_Data Public Attributes Name mat4 modelView mat4 modelViewInverseTranspose mat4 modelViewProj Public Attributes Documentation variable modelView mat4 modelView; variable modelViewInverseTranspose mat4 modelViewInverseTranspose; variable modelViewProj mat4 modelViewProj; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::DrawMeshOp::UBO_VS_Data"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#ngfxdrawmeshopubo_vs_data","text":"","title":"ngfx::DrawMeshOp::UBO_VS_Data"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#public-attributes","text":"Name mat4 modelView mat4 modelViewInverseTranspose mat4 modelViewProj","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#variable-modelview","text":"mat4 modelView;","title":"variable modelView"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#variable-modelviewinversetranspose","text":"mat4 modelViewInverseTranspose;","title":"variable modelViewInverseTranspose"},{"location":"api/Classes/structngfx_1_1DrawMeshOp_1_1UBO__VS__Data/#variable-modelviewproj","text":"mat4 modelViewProj; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable modelViewProj"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/","text":"ngfx::FileUtil::Lock Public Functions Name Lock (const std::string & path, uint32_t timeoutMs =3000) ~Lock () Public Attributes Name std::string lockPath uint32_t timeoutMs Public Functions Documentation function Lock Lock( const std::string & path, uint32_t timeoutMs =3000 ) function ~Lock ~Lock() Public Attributes Documentation variable lockPath std::string lockPath; variable timeoutMs uint32_t timeoutMs; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::FileUtil::Lock"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#ngfxfileutillock","text":"","title":"ngfx::FileUtil::Lock"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#public-functions","text":"Name Lock (const std::string & path, uint32_t timeoutMs =3000) ~Lock ()","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#public-attributes","text":"Name std::string lockPath uint32_t timeoutMs","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#function-lock","text":"Lock( const std::string & path, uint32_t timeoutMs =3000 )","title":"function Lock"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#function-lock_1","text":"~Lock()","title":"function ~Lock"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#variable-lockpath","text":"std::string lockPath;","title":"variable lockPath"},{"location":"api/Classes/structngfx_1_1FileUtil_1_1Lock/#variable-timeoutms","text":"uint32_t timeoutMs; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable timeoutMs"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/","text":"ngfx::Framebuffer::Attachment Public Attributes Name Texture * texture uint32_t level uint32_t layer Public Attributes Documentation variable texture Texture * texture = nullptr; The destination texture variable level uint32_t level = 0; The destination texture mipmap level variable layer uint32_t layer = 0; The destination texture array layer index Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Framebuffer::Attachment"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#ngfxframebufferattachment","text":"","title":"ngfx::Framebuffer::Attachment"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#public-attributes","text":"Name Texture * texture uint32_t level uint32_t layer","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#variable-texture","text":"Texture * texture = nullptr; The destination texture","title":"variable texture"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#variable-level","text":"uint32_t level = 0; The destination texture mipmap level","title":"variable level"},{"location":"api/Classes/structngfx_1_1Framebuffer_1_1Attachment/#variable-layer","text":"uint32_t layer = 0; The destination texture array layer index Updated on 3 April 2021 at 20:21:51 PDT","title":"variable layer"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/","text":"ngfx::GraphicsContext::AttachmentDescription Public Functions Name bool operator== (const AttachmentDescription & rhs) const Public Attributes Name PixelFormat format std::optional< ImageLayout > initialLayout std::optional< ImageLayout > finalLayout Public Functions Documentation function operator== inline bool operator==( const AttachmentDescription & rhs ) const Public Attributes Documentation variable format PixelFormat format; variable initialLayout std::optional< ImageLayout > initialLayout; variable finalLayout std::optional< ImageLayout > finalLayout; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::GraphicsContext::AttachmentDescription"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#ngfxgraphicscontextattachmentdescription","text":"","title":"ngfx::GraphicsContext::AttachmentDescription"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-functions","text":"Name bool operator== (const AttachmentDescription & rhs) const","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-attributes","text":"Name PixelFormat format std::optional< ImageLayout > initialLayout std::optional< ImageLayout > finalLayout","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#function-operator","text":"inline bool operator==( const AttachmentDescription & rhs ) const","title":"function operator=="},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#variable-format","text":"PixelFormat format;","title":"variable format"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#variable-initiallayout","text":"std::optional< ImageLayout > initialLayout;","title":"variable initialLayout"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1AttachmentDescription/#variable-finallayout","text":"std::optional< ImageLayout > finalLayout; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable finalLayout"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/","text":"ngfx::GraphicsContext::RenderPassConfig Public Functions Name bool operator== (const RenderPassConfig & rhs) const uint32_t numColorAttachments () const Public Attributes Name std::vector< AttachmentDescription > colorAttachmentDescriptions std::optional< AttachmentDescription > depthStencilAttachmentDescription bool enableDepthStencilResolve uint32_t numSamples Public Functions Documentation function operator== inline bool operator==( const RenderPassConfig & rhs ) const function numColorAttachments inline uint32_t numColorAttachments() const Public Attributes Documentation variable colorAttachmentDescriptions std::vector< AttachmentDescription > colorAttachmentDescriptions; variable depthStencilAttachmentDescription std::optional< AttachmentDescription > depthStencilAttachmentDescription; variable enableDepthStencilResolve bool enableDepthStencilResolve = false; variable numSamples uint32_t numSamples = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::GraphicsContext::RenderPassConfig"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#ngfxgraphicscontextrenderpassconfig","text":"","title":"ngfx::GraphicsContext::RenderPassConfig"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-functions","text":"Name bool operator== (const RenderPassConfig & rhs) const uint32_t numColorAttachments () const","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-attributes","text":"Name std::vector< AttachmentDescription > colorAttachmentDescriptions std::optional< AttachmentDescription > depthStencilAttachmentDescription bool enableDepthStencilResolve uint32_t numSamples","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#function-operator","text":"inline bool operator==( const RenderPassConfig & rhs ) const","title":"function operator=="},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#function-numcolorattachments","text":"inline uint32_t numColorAttachments() const","title":"function numColorAttachments"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-colorattachmentdescriptions","text":"std::vector< AttachmentDescription > colorAttachmentDescriptions;","title":"variable colorAttachmentDescriptions"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-depthstencilattachmentdescription","text":"std::optional< AttachmentDescription > depthStencilAttachmentDescription;","title":"variable depthStencilAttachmentDescription"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-enabledepthstencilresolve","text":"bool enableDepthStencilResolve = false;","title":"variable enableDepthStencilResolve"},{"location":"api/Classes/structngfx_1_1GraphicsContext_1_1RenderPassConfig/#variable-numsamples","text":"uint32_t numSamples = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable numSamples"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/","text":"ngfx::GraphicsPipeline::Descriptor Public Attributes Name DescriptorType type ShaderStageFlags stageFlags Public Attributes Documentation variable type DescriptorType type; variable stageFlags ShaderStageFlags stageFlags = SHADER_STAGE_ALL; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::GraphicsPipeline::Descriptor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#ngfxgraphicspipelinedescriptor","text":"","title":"ngfx::GraphicsPipeline::Descriptor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#public-attributes","text":"Name DescriptorType type ShaderStageFlags stageFlags","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#variable-type","text":"DescriptorType type;","title":"variable type"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1Descriptor/#variable-stageflags","text":"ShaderStageFlags stageFlags = SHADER_STAGE_ALL; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable stageFlags"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/","text":"ngfx::GraphicsPipeline::State Public Attributes Name PrimitiveTopology primitiveTopology PolygonMode polygonMode bool blendEnable BlendFactor srcColorBlendFactor BlendFactor dstColorBlendFactor BlendFactor srcAlphaBlendFactor BlendFactor dstAlphaBlendFactor BlendOp colorBlendOp BlendOp alphaBlendOp uint8_t colorWriteMask CullModeFlags cullModeFlags FrontFace frontFace float lineWidth bool depthTestEnable bool depthWriteEnable RenderPass * renderPass uint32_t numSamples uint32_t numColorAttachments Public Attributes Documentation variable primitiveTopology PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; variable polygonMode PolygonMode polygonMode = POLYGON_MODE_FILL; variable blendEnable bool blendEnable = false; variable srcColorBlendFactor BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA; variable dstColorBlendFactor BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; variable srcAlphaBlendFactor BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA; variable dstAlphaBlendFactor BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; variable colorBlendOp BlendOp colorBlendOp = BLEND_OP_ADD; variable alphaBlendOp BlendOp alphaBlendOp = BLEND_OP_ADD; variable colorWriteMask uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT; variable cullModeFlags CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT; variable frontFace FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE; variable lineWidth float lineWidth = 1.0f; variable depthTestEnable bool depthTestEnable = false; variable depthWriteEnable bool depthWriteEnable = false; variable renderPass RenderPass * renderPass = nullptr; variable numSamples uint32_t numSamples = 1; variable numColorAttachments uint32_t numColorAttachments = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::GraphicsPipeline::State"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#ngfxgraphicspipelinestate","text":"","title":"ngfx::GraphicsPipeline::State"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#public-attributes","text":"Name PrimitiveTopology primitiveTopology PolygonMode polygonMode bool blendEnable BlendFactor srcColorBlendFactor BlendFactor dstColorBlendFactor BlendFactor srcAlphaBlendFactor BlendFactor dstAlphaBlendFactor BlendOp colorBlendOp BlendOp alphaBlendOp uint8_t colorWriteMask CullModeFlags cullModeFlags FrontFace frontFace float lineWidth bool depthTestEnable bool depthWriteEnable RenderPass * renderPass uint32_t numSamples uint32_t numColorAttachments","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-primitivetopology","text":"PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;","title":"variable primitiveTopology"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-polygonmode","text":"PolygonMode polygonMode = POLYGON_MODE_FILL;","title":"variable polygonMode"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-blendenable","text":"bool blendEnable = false;","title":"variable blendEnable"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-srccolorblendfactor","text":"BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA;","title":"variable srcColorBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-dstcolorblendfactor","text":"BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;","title":"variable dstColorBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-srcalphablendfactor","text":"BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA;","title":"variable srcAlphaBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-dstalphablendfactor","text":"BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;","title":"variable dstAlphaBlendFactor"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-colorblendop","text":"BlendOp colorBlendOp = BLEND_OP_ADD;","title":"variable colorBlendOp"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-alphablendop","text":"BlendOp alphaBlendOp = BLEND_OP_ADD;","title":"variable alphaBlendOp"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-colorwritemask","text":"uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT;","title":"variable colorWriteMask"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-cullmodeflags","text":"CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT;","title":"variable cullModeFlags"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-frontface","text":"FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE;","title":"variable frontFace"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-linewidth","text":"float lineWidth = 1.0f;","title":"variable lineWidth"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-depthtestenable","text":"bool depthTestEnable = false;","title":"variable depthTestEnable"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-depthwriteenable","text":"bool depthWriteEnable = false;","title":"variable depthWriteEnable"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-renderpass","text":"RenderPass * renderPass = nullptr;","title":"variable renderPass"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-numsamples","text":"uint32_t numSamples = 1;","title":"variable numSamples"},{"location":"api/Classes/structngfx_1_1GraphicsPipeline_1_1State/#variable-numcolorattachments","text":"uint32_t numColorAttachments = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable numColorAttachments"},{"location":"api/Classes/structngfx_1_1MTLGraphicsContext_1_1MTLRenderPassData/","text":"ngfx::MTLGraphicsContext::MTLRenderPassData Public Attributes Name RenderPassConfig config MTLRenderPass mtlRenderPass Public Attributes Documentation variable config RenderPassConfig config; variable mtlRenderPass MTLRenderPass mtlRenderPass; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLGraphicsContext::MTLRenderPassData"},{"location":"api/Classes/structngfx_1_1MTLGraphicsContext_1_1MTLRenderPassData/#ngfxmtlgraphicscontextmtlrenderpassdata","text":"","title":"ngfx::MTLGraphicsContext::MTLRenderPassData"},{"location":"api/Classes/structngfx_1_1MTLGraphicsContext_1_1MTLRenderPassData/#public-attributes","text":"Name RenderPassConfig config MTLRenderPass mtlRenderPass","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1MTLGraphicsContext_1_1MTLRenderPassData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1MTLGraphicsContext_1_1MTLRenderPassData/#variable-config","text":"RenderPassConfig config;","title":"variable config"},{"location":"api/Classes/structngfx_1_1MTLGraphicsContext_1_1MTLRenderPassData/#variable-mtlrenderpass","text":"MTLRenderPass mtlRenderPass; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable mtlRenderPass"},{"location":"api/Classes/structngfx_1_1MTLGraphicsPipeline_1_1Shaders/","text":"ngfx::MTLGraphicsPipeline::Shaders Public Attributes Name id< MTLFunction > VS id< MTLFunction > PS Public Attributes Documentation variable VS id< MTLFunction > VS; variable PS id< MTLFunction > PS; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLGraphicsPipeline::Shaders"},{"location":"api/Classes/structngfx_1_1MTLGraphicsPipeline_1_1Shaders/#ngfxmtlgraphicspipelineshaders","text":"","title":"ngfx::MTLGraphicsPipeline::Shaders"},{"location":"api/Classes/structngfx_1_1MTLGraphicsPipeline_1_1Shaders/#public-attributes","text":"Name id< MTLFunction > VS id< MTLFunction > PS","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1MTLGraphicsPipeline_1_1Shaders/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1MTLGraphicsPipeline_1_1Shaders/#variable-vs","text":"id< MTLFunction > VS;","title":"variable VS"},{"location":"api/Classes/structngfx_1_1MTLGraphicsPipeline_1_1Shaders/#variable-ps","text":"id< MTLFunction > PS; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable PS"},{"location":"api/Classes/structngfx_1_1MTLPipelineUtil/","text":"ngfx::MTLPipelineUtil Public Functions Name void parseDescriptors (ShaderModule::DescriptorInfos & descriptorInfos, std::vector< uint32_t > & descriptorBindings) Public Functions Documentation function parseDescriptors static void parseDescriptors( ShaderModule::DescriptorInfos & descriptorInfos, std::vector< uint32_t > & descriptorBindings ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MTLPipelineUtil"},{"location":"api/Classes/structngfx_1_1MTLPipelineUtil/#ngfxmtlpipelineutil","text":"","title":"ngfx::MTLPipelineUtil"},{"location":"api/Classes/structngfx_1_1MTLPipelineUtil/#public-functions","text":"Name void parseDescriptors (ShaderModule::DescriptorInfos & descriptorInfos, std::vector< uint32_t > & descriptorBindings)","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1MTLPipelineUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1MTLPipelineUtil/#function-parsedescriptors","text":"static void parseDescriptors( ShaderModule::DescriptorInfos & descriptorInfos, std::vector< uint32_t > & descriptorBindings ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function parseDescriptors"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/","text":"ngfx::MatrixMultiplyGPUOp::UboData Public Attributes Name int32_t src0_w int32_t src0_h int32_t src1t_w int32_t src1t_h int32_t dst_w int32_t dst_h Public Attributes Documentation variable src0_w int32_t src0_w; variable src0_h int32_t src0_h; variable src1t_w int32_t src1t_w; variable src1t_h int32_t src1t_h; variable dst_w int32_t dst_w; variable dst_h int32_t dst_h; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MatrixMultiplyGPUOp::UboData"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#ngfxmatrixmultiplygpuopubodata","text":"","title":"ngfx::MatrixMultiplyGPUOp::UboData"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#public-attributes","text":"Name int32_t src0_w int32_t src0_h int32_t src1t_w int32_t src1t_h int32_t dst_w int32_t dst_h","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-src0_w","text":"int32_t src0_w;","title":"variable src0_w"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-src0_h","text":"int32_t src0_h;","title":"variable src0_h"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-src1t_w","text":"int32_t src1t_w;","title":"variable src1t_w"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-src1t_h","text":"int32_t src1t_h;","title":"variable src1t_h"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-dst_w","text":"int32_t dst_w;","title":"variable dst_w"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyGPUOp_1_1UboData/#variable-dst_h","text":"int32_t dst_h; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable dst_h"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/","text":"ngfx::MatrixMultiplyOp::MatrixParam Public Attributes Name uint32_t w uint32_t h float * data Public Attributes Documentation variable w uint32_t w; variable h uint32_t h; variable data float * data; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MatrixMultiplyOp::MatrixParam"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#ngfxmatrixmultiplyopmatrixparam","text":"","title":"ngfx::MatrixMultiplyOp::MatrixParam"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#public-attributes","text":"Name uint32_t w uint32_t h float * data","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#variable-w","text":"uint32_t w;","title":"variable w"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#variable-h","text":"uint32_t h;","title":"variable h"},{"location":"api/Classes/structngfx_1_1MatrixMultiplyOp_1_1MatrixParam/#variable-data","text":"float * data; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable data"},{"location":"api/Classes/structngfx_1_1MeshData/","text":"ngfx::MeshData Public Attributes Name std::vector< vec3 > pos std::vector< vec3 > normal std::vector< ivec3 > faces vec3 bounds Public Attributes Documentation variable pos std::vector< vec3 > pos; variable normal std::vector< vec3 > normal; variable faces std::vector< ivec3 > faces; variable bounds vec3 bounds = {vec3(FLT_MAX), vec3(FLT_MIN)}; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MeshData"},{"location":"api/Classes/structngfx_1_1MeshData/#ngfxmeshdata","text":"","title":"ngfx::MeshData"},{"location":"api/Classes/structngfx_1_1MeshData/#public-attributes","text":"Name std::vector< vec3 > pos std::vector< vec3 > normal std::vector< ivec3 > faces vec3 bounds","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1MeshData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-pos","text":"std::vector< vec3 > pos;","title":"variable pos"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-normal","text":"std::vector< vec3 > normal;","title":"variable normal"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-faces","text":"std::vector< ivec3 > faces;","title":"variable faces"},{"location":"api/Classes/structngfx_1_1MeshData/#variable-bounds","text":"vec3 bounds = {vec3(FLT_MAX), vec3(FLT_MIN)}; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable bounds"},{"location":"api/Classes/structngfx_1_1MeshUtil/","text":"ngfx::MeshUtil Public Functions Name void importMesh (const std::string & file, MeshData & meshData) void exportMesh (const std::string & file, MeshData & meshData) Public Functions Documentation function importMesh static void importMesh( const std::string & file, MeshData & meshData ) function exportMesh static void exportMesh( const std::string & file, MeshData & meshData ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::MeshUtil"},{"location":"api/Classes/structngfx_1_1MeshUtil/#ngfxmeshutil","text":"","title":"ngfx::MeshUtil"},{"location":"api/Classes/structngfx_1_1MeshUtil/#public-functions","text":"Name void importMesh (const std::string & file, MeshData & meshData) void exportMesh (const std::string & file, MeshData & meshData)","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1MeshUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1MeshUtil/#function-importmesh","text":"static void importMesh( const std::string & file, MeshData & meshData )","title":"function importMesh"},{"location":"api/Classes/structngfx_1_1MeshUtil/#function-exportmesh","text":"static void exportMesh( const std::string & file, MeshData & meshData ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function exportMesh"},{"location":"api/Classes/structngfx_1_1Rect2D/","text":"ngfx::Rect2D Public Attributes Name int32_t x int32_t y uint32_t w uint32_t h Public Attributes Documentation variable x int32_t x; variable y int32_t y; variable w uint32_t w; variable h uint32_t h; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Rect2D"},{"location":"api/Classes/structngfx_1_1Rect2D/#ngfxrect2d","text":"","title":"ngfx::Rect2D"},{"location":"api/Classes/structngfx_1_1Rect2D/#public-attributes","text":"Name int32_t x int32_t y uint32_t w uint32_t h","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1Rect2D/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-x","text":"int32_t x;","title":"variable x"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-y","text":"int32_t y;","title":"variable y"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-w","text":"uint32_t w;","title":"variable w"},{"location":"api/Classes/structngfx_1_1Rect2D/#variable-h","text":"uint32_t h; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable h"},{"location":"api/Classes/structngfx_1_1RegexUtil_1_1Match/","text":"ngfx::RegexUtil::Match Public Attributes Name std::vector< std::string > s Public Attributes Documentation variable s std::vector< std::string > s; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::RegexUtil::Match"},{"location":"api/Classes/structngfx_1_1RegexUtil_1_1Match/#ngfxregexutilmatch","text":"","title":"ngfx::RegexUtil::Match"},{"location":"api/Classes/structngfx_1_1RegexUtil_1_1Match/#public-attributes","text":"Name std::vector< std::string > s","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1RegexUtil_1_1Match/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1RegexUtil_1_1Match/#variable-s","text":"std::vector< std::string > s; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable s"},{"location":"api/Classes/structngfx_1_1Region/","text":"ngfx::Region Public Attributes Name glm::ivec3 p0 glm::ivec3 p1 Public Attributes Documentation variable p0 glm::ivec3 p0; variable p1 glm::ivec3 p1; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::Region"},{"location":"api/Classes/structngfx_1_1Region/#ngfxregion","text":"","title":"ngfx::Region"},{"location":"api/Classes/structngfx_1_1Region/#public-attributes","text":"Name glm::ivec3 p0 glm::ivec3 p1","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1Region/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1Region/#variable-p0","text":"glm::ivec3 p0;","title":"variable p0"},{"location":"api/Classes/structngfx_1_1Region/#variable-p1","text":"glm::ivec3 p1; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable p1"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/","text":"ngfx::ShaderModule::BufferInfo Public Attributes Name std::string name uint32_t set ShaderStageFlags shaderStages BufferMemberInfos memberInfos Public Attributes Documentation variable name std::string name; variable set uint32_t set; variable shaderStages ShaderStageFlags shaderStages; variable memberInfos BufferMemberInfos memberInfos; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ShaderModule::BufferInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#ngfxshadermodulebufferinfo","text":"","title":"ngfx::ShaderModule::BufferInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#public-attributes","text":"Name std::string name uint32_t set ShaderStageFlags shaderStages BufferMemberInfos memberInfos","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-set","text":"uint32_t set;","title":"variable set"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-shaderstages","text":"ShaderStageFlags shaderStages;","title":"variable shaderStages"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferInfo/#variable-memberinfos","text":"BufferMemberInfos memberInfos; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable memberInfos"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/","text":"ngfx::ShaderModule::BufferMemberInfo Public Attributes Name uint32_t offset uint32_t size uint32_t arrayCount uint32_t arrayStride Public Attributes Documentation variable offset uint32_t offset; variable size uint32_t size; variable arrayCount uint32_t arrayCount; variable arrayStride uint32_t arrayStride; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ShaderModule::BufferMemberInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#ngfxshadermodulebuffermemberinfo","text":"","title":"ngfx::ShaderModule::BufferMemberInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#public-attributes","text":"Name uint32_t offset uint32_t size uint32_t arrayCount uint32_t arrayStride","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-offset","text":"uint32_t offset;","title":"variable offset"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-size","text":"uint32_t size;","title":"variable size"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-arraycount","text":"uint32_t arrayCount;","title":"variable arrayCount"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1BufferMemberInfo/#variable-arraystride","text":"uint32_t arrayStride; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable arrayStride"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/","text":"ngfx::ShaderModule::DescriptorInfo Public Attributes Name std::string name uint32_t set DescriptorType type Public Attributes Documentation variable name std::string name; variable set uint32_t set; variable type DescriptorType type; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ShaderModule::DescriptorInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#ngfxshadermoduledescriptorinfo","text":"","title":"ngfx::ShaderModule::DescriptorInfo"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#public-attributes","text":"Name std::string name uint32_t set DescriptorType type","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#variable-set","text":"uint32_t set;","title":"variable set"},{"location":"api/Classes/structngfx_1_1ShaderModule_1_1DescriptorInfo/#variable-type","text":"DescriptorType type; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable type"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/","text":"ngfx::ShaderTools::HLSLReflectData Public Attributes Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures Public Attributes Documentation variable attributes std::vector< RegexUtil::Match > attributes; variable buffers std::vector< RegexUtil::Match > buffers; variable textures std::vector< RegexUtil::Match > textures; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ShaderTools::HLSLReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#ngfxshadertoolshlslreflectdata","text":"","title":"ngfx::ShaderTools::HLSLReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#public-attributes","text":"Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#variable-attributes","text":"std::vector< RegexUtil::Match > attributes;","title":"variable attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#variable-buffers","text":"std::vector< RegexUtil::Match > buffers;","title":"variable buffers"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1HLSLReflectData/#variable-textures","text":"std::vector< RegexUtil::Match > textures; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable textures"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/","text":"ngfx::ShaderTools::MacroDefinition Public Attributes Name std::string name std::string value Public Attributes Documentation variable name std::string name; variable value std::string value; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ShaderTools::MacroDefinition"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#ngfxshadertoolsmacrodefinition","text":"","title":"ngfx::ShaderTools::MacroDefinition"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#public-attributes","text":"Name std::string name std::string value","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MacroDefinition/#variable-value","text":"std::string value; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable value"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/","text":"ngfx::ShaderTools::MetalReflectData Public Attributes Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures Public Attributes Documentation variable attributes std::vector< RegexUtil::Match > attributes; variable buffers std::vector< RegexUtil::Match > buffers; variable textures std::vector< RegexUtil::Match > textures; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::ShaderTools::MetalReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#ngfxshadertoolsmetalreflectdata","text":"","title":"ngfx::ShaderTools::MetalReflectData"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#public-attributes","text":"Name std::vector< RegexUtil::Match > attributes std::vector< RegexUtil::Match > buffers std::vector< RegexUtil::Match > textures","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#variable-attributes","text":"std::vector< RegexUtil::Match > attributes;","title":"variable attributes"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#variable-buffers","text":"std::vector< RegexUtil::Match > buffers;","title":"variable buffers"},{"location":"api/Classes/structngfx_1_1ShaderTools_1_1MetalReflectData/#variable-textures","text":"std::vector< RegexUtil::Match > textures; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable textures"},{"location":"api/Classes/structngfx_1_1VKBlit/","text":"ngfx::VKBlit Public Classes Name struct Region Public Functions Name void blitImage (VkCommandBuffer cmdBuffer, VkImage srcImage, uint32_t srcLevel, VkImage dstImage, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer =0, uint32_t srcLayerCount =1, uint32_t dstBaseLayer =0, uint32_t dstLayerCount =1, VkImageLayout srcImageLayout =VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VkImageLayout dstImageLayout =VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VkFilter filter =VK_FILTER_LINEAR) Public Functions Documentation function blitImage static void blitImage( VkCommandBuffer cmdBuffer, VkImage srcImage, uint32_t srcLevel, VkImage dstImage, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer =0, uint32_t srcLayerCount =1, uint32_t dstBaseLayer =0, uint32_t dstLayerCount =1, VkImageLayout srcImageLayout =VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VkImageLayout dstImageLayout =VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VkFilter filter =VK_FILTER_LINEAR ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKBlit"},{"location":"api/Classes/structngfx_1_1VKBlit/#ngfxvkblit","text":"","title":"ngfx::VKBlit"},{"location":"api/Classes/structngfx_1_1VKBlit/#public-classes","text":"Name struct Region","title":"Public Classes"},{"location":"api/Classes/structngfx_1_1VKBlit/#public-functions","text":"Name void blitImage (VkCommandBuffer cmdBuffer, VkImage srcImage, uint32_t srcLevel, VkImage dstImage, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer =0, uint32_t srcLayerCount =1, uint32_t dstBaseLayer =0, uint32_t dstLayerCount =1, VkImageLayout srcImageLayout =VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VkImageLayout dstImageLayout =VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VkFilter filter =VK_FILTER_LINEAR)","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1VKBlit/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1VKBlit/#function-blitimage","text":"static void blitImage( VkCommandBuffer cmdBuffer, VkImage srcImage, uint32_t srcLevel, VkImage dstImage, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer =0, uint32_t srcLayerCount =1, uint32_t dstBaseLayer =0, uint32_t dstLayerCount =1, VkImageLayout srcImageLayout =VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VkImageLayout dstImageLayout =VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VkFilter filter =VK_FILTER_LINEAR ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function blitImage"},{"location":"api/Classes/structngfx_1_1VKBlit_1_1Region/","text":"ngfx::VKBlit::Region Public Attributes Name VkOffset3D p0 VkOffset3D p1 Public Attributes Documentation variable p0 VkOffset3D p0; variable p1 VkOffset3D p1; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKBlit::Region"},{"location":"api/Classes/structngfx_1_1VKBlit_1_1Region/#ngfxvkblitregion","text":"","title":"ngfx::VKBlit::Region"},{"location":"api/Classes/structngfx_1_1VKBlit_1_1Region/#public-attributes","text":"Name VkOffset3D p0 VkOffset3D p1","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VKBlit_1_1Region/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VKBlit_1_1Region/#variable-p0","text":"VkOffset3D p0;","title":"variable p0"},{"location":"api/Classes/structngfx_1_1VKBlit_1_1Region/#variable-p1","text":"VkOffset3D p1; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable p1"},{"location":"api/Classes/structngfx_1_1VKDescriptorSetLayoutCache_1_1VKDescriptorSetLayoutData/","text":"ngfx::VKDescriptorSetLayoutCache::VKDescriptorSetLayoutData Public Attributes Name VkDescriptorSetLayoutCreateInfo createInfo VkDescriptorSetLayout layout VkDescriptorSetLayoutBinding layoutBinding Public Attributes Documentation variable createInfo VkDescriptorSetLayoutCreateInfo createInfo; variable layout VkDescriptorSetLayout layout; variable layoutBinding VkDescriptorSetLayoutBinding layoutBinding; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKDescriptorSetLayoutCache::VKDescriptorSetLayoutData"},{"location":"api/Classes/structngfx_1_1VKDescriptorSetLayoutCache_1_1VKDescriptorSetLayoutData/#ngfxvkdescriptorsetlayoutcachevkdescriptorsetlayoutdata","text":"","title":"ngfx::VKDescriptorSetLayoutCache::VKDescriptorSetLayoutData"},{"location":"api/Classes/structngfx_1_1VKDescriptorSetLayoutCache_1_1VKDescriptorSetLayoutData/#public-attributes","text":"Name VkDescriptorSetLayoutCreateInfo createInfo VkDescriptorSetLayout layout VkDescriptorSetLayoutBinding layoutBinding","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VKDescriptorSetLayoutCache_1_1VKDescriptorSetLayoutData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VKDescriptorSetLayoutCache_1_1VKDescriptorSetLayoutData/#variable-createinfo","text":"VkDescriptorSetLayoutCreateInfo createInfo;","title":"variable createInfo"},{"location":"api/Classes/structngfx_1_1VKDescriptorSetLayoutCache_1_1VKDescriptorSetLayoutData/#variable-layout","text":"VkDescriptorSetLayout layout;","title":"variable layout"},{"location":"api/Classes/structngfx_1_1VKDescriptorSetLayoutCache_1_1VKDescriptorSetLayoutData/#variable-layoutbinding","text":"VkDescriptorSetLayoutBinding layoutBinding; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable layoutBinding"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentDescriptor/","text":"ngfx::VKFramebuffer::VKAttachmentDescriptor Public Attributes Name VKImageView * imageView VKAttachmentInfo info Public Attributes Documentation variable imageView VKImageView * imageView = nullptr; variable info VKAttachmentInfo info; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKFramebuffer::VKAttachmentDescriptor"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentDescriptor/#ngfxvkframebuffervkattachmentdescriptor","text":"","title":"ngfx::VKFramebuffer::VKAttachmentDescriptor"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentDescriptor/#public-attributes","text":"Name VKImageView * imageView VKAttachmentInfo info","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentDescriptor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentDescriptor/#variable-imageview","text":"VKImageView * imageView = nullptr;","title":"variable imageView"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentDescriptor/#variable-info","text":"VKAttachmentInfo info; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable info"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentInfo/","text":"ngfx::VKFramebuffer::VKAttachmentInfo Public Attributes Name VkImageUsageFlags imageUsageFlags Public Attributes Documentation variable imageUsageFlags VkImageUsageFlags imageUsageFlags; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKFramebuffer::VKAttachmentInfo"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentInfo/#ngfxvkframebuffervkattachmentinfo","text":"","title":"ngfx::VKFramebuffer::VKAttachmentInfo"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentInfo/#public-attributes","text":"Name VkImageUsageFlags imageUsageFlags","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VKFramebuffer_1_1VKAttachmentInfo/#variable-imageusageflags","text":"VkImageUsageFlags imageUsageFlags; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable imageUsageFlags"},{"location":"api/Classes/structngfx_1_1VKGraphicsContext_1_1VKRenderPassData/","text":"ngfx::VKGraphicsContext::VKRenderPassData Public Attributes Name RenderPassConfig config VKRenderPass vkRenderPass Public Attributes Documentation variable config RenderPassConfig config; variable vkRenderPass VKRenderPass vkRenderPass; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKGraphicsContext::VKRenderPassData"},{"location":"api/Classes/structngfx_1_1VKGraphicsContext_1_1VKRenderPassData/#ngfxvkgraphicscontextvkrenderpassdata","text":"","title":"ngfx::VKGraphicsContext::VKRenderPassData"},{"location":"api/Classes/structngfx_1_1VKGraphicsContext_1_1VKRenderPassData/#public-attributes","text":"Name RenderPassConfig config VKRenderPass vkRenderPass","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VKGraphicsContext_1_1VKRenderPassData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VKGraphicsContext_1_1VKRenderPassData/#variable-config","text":"RenderPassConfig config;","title":"variable config"},{"location":"api/Classes/structngfx_1_1VKGraphicsContext_1_1VKRenderPassData/#variable-vkrenderpass","text":"VKRenderPass vkRenderPass; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable vkRenderPass"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/","text":"ngfx::VKGraphicsPipeline::State Public Attributes Name VkPrimitiveTopology primitiveTopology VkPolygonMode polygonMode VkBool32 blendEnable VkBlendFactor srcColorBlendFactor VkBlendFactor dstColorBlendFactor VkBlendFactor srcAlphaBlendFactor VkBlendFactor dstAlphaBlendFactor VkBlendOp colorBlendOp VkBlendOp alphaBlendOp VkColorComponentFlags colorWriteMask VkCullModeFlags cullModeFlags VkFrontFace frontFace float lineWidth VkBool32 depthTestEnable VkBool32 depthWriteEnable VkRenderPass renderPass uint32_t numSamples uint32_t numColorAttachments Public Attributes Documentation variable primitiveTopology VkPrimitiveTopology primitiveTopology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; variable polygonMode VkPolygonMode polygonMode = VK_POLYGON_MODE_FILL; variable blendEnable VkBool32 blendEnable = VK_FALSE; variable srcColorBlendFactor VkBlendFactor srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; variable dstColorBlendFactor VkBlendFactor dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; variable srcAlphaBlendFactor VkBlendFactor srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; variable dstAlphaBlendFactor VkBlendFactor dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; variable colorBlendOp VkBlendOp colorBlendOp = VK_BLEND_OP_ADD; variable alphaBlendOp VkBlendOp alphaBlendOp = VK_BLEND_OP_ADD; variable colorWriteMask VkColorComponentFlags colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; variable cullModeFlags VkCullModeFlags cullModeFlags = VK_CULL_MODE_BACK_BIT; variable frontFace VkFrontFace frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE; variable lineWidth float lineWidth = 1.0f; variable depthTestEnable VkBool32 depthTestEnable = VK_FALSE; variable depthWriteEnable VkBool32 depthWriteEnable = VK_FALSE; variable renderPass VkRenderPass renderPass; variable numSamples uint32_t numSamples = 1; variable numColorAttachments uint32_t numColorAttachments = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKGraphicsPipeline::State"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#ngfxvkgraphicspipelinestate","text":"","title":"ngfx::VKGraphicsPipeline::State"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#public-attributes","text":"Name VkPrimitiveTopology primitiveTopology VkPolygonMode polygonMode VkBool32 blendEnable VkBlendFactor srcColorBlendFactor VkBlendFactor dstColorBlendFactor VkBlendFactor srcAlphaBlendFactor VkBlendFactor dstAlphaBlendFactor VkBlendOp colorBlendOp VkBlendOp alphaBlendOp VkColorComponentFlags colorWriteMask VkCullModeFlags cullModeFlags VkFrontFace frontFace float lineWidth VkBool32 depthTestEnable VkBool32 depthWriteEnable VkRenderPass renderPass uint32_t numSamples uint32_t numColorAttachments","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-primitivetopology","text":"VkPrimitiveTopology primitiveTopology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;","title":"variable primitiveTopology"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-polygonmode","text":"VkPolygonMode polygonMode = VK_POLYGON_MODE_FILL;","title":"variable polygonMode"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-blendenable","text":"VkBool32 blendEnable = VK_FALSE;","title":"variable blendEnable"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-srccolorblendfactor","text":"VkBlendFactor srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;","title":"variable srcColorBlendFactor"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-dstcolorblendfactor","text":"VkBlendFactor dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;","title":"variable dstColorBlendFactor"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-srcalphablendfactor","text":"VkBlendFactor srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;","title":"variable srcAlphaBlendFactor"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-dstalphablendfactor","text":"VkBlendFactor dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;","title":"variable dstAlphaBlendFactor"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-colorblendop","text":"VkBlendOp colorBlendOp = VK_BLEND_OP_ADD;","title":"variable colorBlendOp"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-alphablendop","text":"VkBlendOp alphaBlendOp = VK_BLEND_OP_ADD;","title":"variable alphaBlendOp"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-colorwritemask","text":"VkColorComponentFlags colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;","title":"variable colorWriteMask"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-cullmodeflags","text":"VkCullModeFlags cullModeFlags = VK_CULL_MODE_BACK_BIT;","title":"variable cullModeFlags"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-frontface","text":"VkFrontFace frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;","title":"variable frontFace"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-linewidth","text":"float lineWidth = 1.0f;","title":"variable lineWidth"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-depthtestenable","text":"VkBool32 depthTestEnable = VK_FALSE;","title":"variable depthTestEnable"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-depthwriteenable","text":"VkBool32 depthWriteEnable = VK_FALSE;","title":"variable depthWriteEnable"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-renderpass","text":"VkRenderPass renderPass;","title":"variable renderPass"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-numsamples","text":"uint32_t numSamples = 1;","title":"variable numSamples"},{"location":"api/Classes/structngfx_1_1VKGraphicsPipeline_1_1State/#variable-numcolorattachments","text":"uint32_t numColorAttachments = 1; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable numColorAttachments"},{"location":"api/Classes/structngfx_1_1VKImageCreateInfo/","text":"ngfx::VKImageCreateInfo Inherits from VkImageCreateInfo Public Functions Name VKImageCreateInfo () Public Functions Documentation function VKImageCreateInfo inline VKImageCreateInfo() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKImageCreateInfo"},{"location":"api/Classes/structngfx_1_1VKImageCreateInfo/#ngfxvkimagecreateinfo","text":"Inherits from VkImageCreateInfo","title":"ngfx::VKImageCreateInfo"},{"location":"api/Classes/structngfx_1_1VKImageCreateInfo/#public-functions","text":"Name VKImageCreateInfo ()","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1VKImageCreateInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1VKImageCreateInfo/#function-vkimagecreateinfo","text":"inline VKImageCreateInfo() Updated on 3 April 2021 at 20:21:51 PDT","title":"function VKImageCreateInfo"},{"location":"api/Classes/structngfx_1_1VKImageViewCreateInfo/","text":"ngfx::VKImageViewCreateInfo Inherits from VkImageViewCreateInfo Public Functions Name VKImageViewCreateInfo () VKImageViewCreateInfo (VkImage image, VkImageViewType imageViewType =VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat =VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0) Public Functions Documentation function VKImageViewCreateInfo inline VKImageViewCreateInfo() function VKImageViewCreateInfo inline VKImageViewCreateInfo( VkImage image, VkImageViewType imageViewType =VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat =VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0 ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKImageViewCreateInfo"},{"location":"api/Classes/structngfx_1_1VKImageViewCreateInfo/#ngfxvkimageviewcreateinfo","text":"Inherits from VkImageViewCreateInfo","title":"ngfx::VKImageViewCreateInfo"},{"location":"api/Classes/structngfx_1_1VKImageViewCreateInfo/#public-functions","text":"Name VKImageViewCreateInfo () VKImageViewCreateInfo (VkImage image, VkImageViewType imageViewType =VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat =VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0)","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1VKImageViewCreateInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1VKImageViewCreateInfo/#function-vkimageviewcreateinfo","text":"inline VKImageViewCreateInfo()","title":"function VKImageViewCreateInfo"},{"location":"api/Classes/structngfx_1_1VKImageViewCreateInfo/#function-vkimageviewcreateinfo_1","text":"inline VKImageViewCreateInfo( VkImage image, VkImageViewType imageViewType =VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat =VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask =VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels =1, uint32_t arrayLayers =1, uint32_t baseMipLevel =0, uint32_t baseArrayLayer =0 ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function VKImageViewCreateInfo"},{"location":"api/Classes/structngfx_1_1VKPipelineUtil/","text":"ngfx::VKPipelineUtil Public Functions Name void parseDescriptors (std::vector< ShaderModule::DescriptorInfo > & descriptors, VkShaderStageFlagBits shaderStage, std::vector< VKPipeline::Descriptor > & vkDescriptors, std::vector< uint32_t > & descriptorBindings) Public Functions Documentation function parseDescriptors static void parseDescriptors( std::vector< ShaderModule::DescriptorInfo > & descriptors, VkShaderStageFlagBits shaderStage, std::vector< VKPipeline::Descriptor > & vkDescriptors, std::vector< uint32_t > & descriptorBindings ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKPipelineUtil"},{"location":"api/Classes/structngfx_1_1VKPipelineUtil/#ngfxvkpipelineutil","text":"","title":"ngfx::VKPipelineUtil"},{"location":"api/Classes/structngfx_1_1VKPipelineUtil/#public-functions","text":"Name void parseDescriptors (std::vector< ShaderModule::DescriptorInfo > & descriptors, VkShaderStageFlagBits shaderStage, std::vector< VKPipeline::Descriptor > & vkDescriptors, std::vector< uint32_t > & descriptorBindings)","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1VKPipelineUtil/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1VKPipelineUtil/#function-parsedescriptors","text":"static void parseDescriptors( std::vector< ShaderModule::DescriptorInfo > & descriptors, VkShaderStageFlagBits shaderStage, std::vector< VKPipeline::Descriptor > & vkDescriptors, std::vector< uint32_t > & descriptorBindings ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function parseDescriptors"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1Descriptor/","text":"ngfx::VKPipeline::Descriptor Public Attributes Name VkDescriptorType type VkShaderStageFlags stageFlags Public Attributes Documentation variable type VkDescriptorType type; variable stageFlags VkShaderStageFlags stageFlags = 0; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKPipeline::Descriptor"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1Descriptor/#ngfxvkpipelinedescriptor","text":"","title":"ngfx::VKPipeline::Descriptor"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1Descriptor/#public-attributes","text":"Name VkDescriptorType type VkShaderStageFlags stageFlags","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1Descriptor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1Descriptor/#variable-type","text":"VkDescriptorType type;","title":"variable type"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1Descriptor/#variable-stageflags","text":"VkShaderStageFlags stageFlags = 0; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable stageFlags"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1ShaderStage/","text":"ngfx::VKPipeline::ShaderStage Public Attributes Name VkShaderStageFlagBits stage VKShaderModule * module Public Attributes Documentation variable stage VkShaderStageFlagBits stage; variable module VKShaderModule * module; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKPipeline::ShaderStage"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1ShaderStage/#ngfxvkpipelineshaderstage","text":"","title":"ngfx::VKPipeline::ShaderStage"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1ShaderStage/#public-attributes","text":"Name VkShaderStageFlagBits stage VKShaderModule * module","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1ShaderStage/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1ShaderStage/#variable-stage","text":"VkShaderStageFlagBits stage;","title":"variable stage"},{"location":"api/Classes/structngfx_1_1VKPipeline_1_1ShaderStage/#variable-module","text":"VKShaderModule * module; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable module"},{"location":"api/Classes/structngfx_1_1VKSamplerCreateInfo/","text":"ngfx::VKSamplerCreateInfo Inherits from VkSamplerCreateInfo Public Functions Name VKSamplerCreateInfo () Public Functions Documentation function VKSamplerCreateInfo inline VKSamplerCreateInfo() Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKSamplerCreateInfo"},{"location":"api/Classes/structngfx_1_1VKSamplerCreateInfo/#ngfxvksamplercreateinfo","text":"Inherits from VkSamplerCreateInfo","title":"ngfx::VKSamplerCreateInfo"},{"location":"api/Classes/structngfx_1_1VKSamplerCreateInfo/#public-functions","text":"Name VKSamplerCreateInfo ()","title":"Public Functions"},{"location":"api/Classes/structngfx_1_1VKSamplerCreateInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"api/Classes/structngfx_1_1VKSamplerCreateInfo/#function-vksamplercreateinfo","text":"inline VKSamplerCreateInfo() Updated on 3 April 2021 at 20:21:51 PDT","title":"function VKSamplerCreateInfo"},{"location":"api/Classes/structngfx_1_1VKSwapchain_1_1queueFamilyProperties/","text":"ngfx::VKSwapchain::queueFamilyProperties Public Attributes Name VkBool32 supportsPresent Public Attributes Documentation variable supportsPresent VkBool32 supportsPresent = VK_FALSE; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VKSwapchain::queueFamilyProperties"},{"location":"api/Classes/structngfx_1_1VKSwapchain_1_1queueFamilyProperties/#ngfxvkswapchainqueuefamilyproperties","text":"","title":"ngfx::VKSwapchain::queueFamilyProperties"},{"location":"api/Classes/structngfx_1_1VKSwapchain_1_1queueFamilyProperties/#public-attributes","text":"Name VkBool32 supportsPresent","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VKSwapchain_1_1queueFamilyProperties/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VKSwapchain_1_1queueFamilyProperties/#variable-supportspresent","text":"VkBool32 supportsPresent = VK_FALSE; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable supportsPresent"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/","text":"ngfx::VertexShaderModule::AttributeDescription Public Attributes Name std::string semantic uint32_t location VertexFormat format std::string name uint32_t count uint32_t elementSize Public Attributes Documentation variable semantic std::string semantic; variable location uint32_t location; variable format VertexFormat format; variable name std::string name; variable count uint32_t count; variable elementSize uint32_t elementSize; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::VertexShaderModule::AttributeDescription"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#ngfxvertexshadermoduleattributedescription","text":"","title":"ngfx::VertexShaderModule::AttributeDescription"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#public-attributes","text":"Name std::string semantic uint32_t location VertexFormat format std::string name uint32_t count uint32_t elementSize","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-semantic","text":"std::string semantic;","title":"variable semantic"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-location","text":"uint32_t location;","title":"variable location"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-format","text":"VertexFormat format;","title":"variable format"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-name","text":"std::string name;","title":"variable name"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-count","text":"uint32_t count;","title":"variable count"},{"location":"api/Classes/structngfx_1_1VertexShaderModule_1_1AttributeDescription/#variable-elementsize","text":"uint32_t elementSize; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable elementSize"},{"location":"api/Classes/structngfx_1_1WWindow_1_1Monitor/","text":"ngfx::WWindow::Monitor Public Attributes Name DISPLAY_DEVICEW adapter DISPLAY_DEVICEW display Public Attributes Documentation variable adapter DISPLAY_DEVICEW adapter; variable display DISPLAY_DEVICEW display; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::WWindow::Monitor"},{"location":"api/Classes/structngfx_1_1WWindow_1_1Monitor/#ngfxwwindowmonitor","text":"","title":"ngfx::WWindow::Monitor"},{"location":"api/Classes/structngfx_1_1WWindow_1_1Monitor/#public-attributes","text":"Name DISPLAY_DEVICEW adapter DISPLAY_DEVICEW display","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1WWindow_1_1Monitor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1WWindow_1_1Monitor/#variable-adapter","text":"DISPLAY_DEVICEW adapter;","title":"variable adapter"},{"location":"api/Classes/structngfx_1_1WWindow_1_1Monitor/#variable-display","text":"DISPLAY_DEVICEW display; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable display"},{"location":"api/Classes/structngfx_1_1WWindow_1_1VideoMode/","text":"ngfx::WWindow::VideoMode Public Attributes Name int width int height Public Attributes Documentation variable width int width; variable height int height; Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx::WWindow::VideoMode"},{"location":"api/Classes/structngfx_1_1WWindow_1_1VideoMode/#ngfxwwindowvideomode","text":"","title":"ngfx::WWindow::VideoMode"},{"location":"api/Classes/structngfx_1_1WWindow_1_1VideoMode/#public-attributes","text":"Name int width int height","title":"Public Attributes"},{"location":"api/Classes/structngfx_1_1WWindow_1_1VideoMode/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Classes/structngfx_1_1WWindow_1_1VideoMode/#variable-width","text":"int width;","title":"variable width"},{"location":"api/Classes/structngfx_1_1WWindow_1_1VideoMode/#variable-height","text":"int height; Updated on 3 April 2021 at 20:21:51 PDT","title":"variable height"},{"location":"api/Examples/","text":"Examples Updated on 3 April 2021 at 20:21:52 PDT","title":"Examples"},{"location":"api/Examples/#examples","text":"Updated on 3 April 2021 at 20:21:52 PDT","title":"Examples"},{"location":"api/Files/","text":"Files dir src dir src/ngfx dir src/ngfx/compute file src/ngfx/compute/ComputeApplication.cpp file src/ngfx/compute/ComputeApplication.h file src/ngfx/compute/ComputeOp.h file src/ngfx/compute/ComputePass.h file src/ngfx/compute/ComputePipeline.h dir src/ngfx/computeOps file src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp file src/ngfx/computeOps/MatrixMultiplyCPUOp.h file src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp file src/ngfx/computeOps/MatrixMultiplyGPUOp.h file src/ngfx/computeOps/MatrixMultiplyOp.h dir src/ngfx/core file src/ngfx/core/Application.h file src/ngfx/core/BaseApplication.cpp file src/ngfx/core/BaseApplication.h file src/ngfx/core/DebugUtil.h file src/ngfx/core/FPSCounter.cpp file src/ngfx/core/FPSCounter.h file src/ngfx/core/File.cpp file src/ngfx/core/File.h file src/ngfx/core/FileUtil.cpp file src/ngfx/core/FileUtil.h file src/ngfx/core/ProcessUtil.cpp file src/ngfx/core/ProcessUtil.h file src/ngfx/core/StringUtil.cpp file src/ngfx/core/StringUtil.h file src/ngfx/core/Timer.cpp file src/ngfx/core/Timer.h file src/ngfx/core/Util.cpp file src/ngfx/core/Util.h dir src/ngfx/drawOps file src/ngfx/drawOps/DrawColorOp.cpp file src/ngfx/drawOps/DrawColorOp.h file src/ngfx/drawOps/DrawMeshOp.cpp file src/ngfx/drawOps/DrawMeshOp.h file src/ngfx/drawOps/DrawTextureOp.cpp file src/ngfx/drawOps/DrawTextureOp.h dir src/ngfx/graphics file src/ngfx/graphics/Buffer.h file src/ngfx/graphics/BufferUtil.h file src/ngfx/graphics/Camera.cpp file src/ngfx/graphics/Camera.h file src/ngfx/graphics/CommandBuffer.h file src/ngfx/graphics/Config.h file src/ngfx/graphics/Device.h file src/ngfx/graphics/DrawOp.h file src/ngfx/graphics/Fence.h file src/ngfx/graphics/FilterOp.cpp file src/ngfx/graphics/FilterOp.h file src/ngfx/graphics/Framebuffer.h file src/ngfx/graphics/Graphics.h file src/ngfx/graphics/GraphicsContext.h file src/ngfx/graphics/GraphicsCore.h file src/ngfx/graphics/GraphicsPipeline.cpp file src/ngfx/graphics/GraphicsPipeline.h file src/ngfx/graphics/MeshData.h file src/ngfx/graphics/MeshUtil.cpp file src/ngfx/graphics/MeshUtil.h file src/ngfx/graphics/Pipeline.h file src/ngfx/graphics/PipelineCache.cpp file src/ngfx/graphics/PipelineCache.h file src/ngfx/graphics/Queue.h file src/ngfx/graphics/RenderPass.h file src/ngfx/graphics/Semaphore.h file src/ngfx/graphics/ShaderModule.cpp file src/ngfx/graphics/ShaderModule.h file src/ngfx/graphics/ShaderTools.cpp file src/ngfx/graphics/ShaderTools.h file src/ngfx/graphics/Surface.h file src/ngfx/graphics/Swapchain.h file src/ngfx/graphics/Texture.cpp file src/ngfx/graphics/Texture.h file src/ngfx/graphics/Window.h dir src/ngfx/input file src/ngfx/input/InputListener.h file src/ngfx/input/InputMap.h dir src/ngfx/porting dir src/ngfx/porting/appkit file src/ngfx/porting/appkit/AppDelegate.h file src/ngfx/porting/appkit/AppDelegate.mm file src/ngfx/porting/appkit/AppKitInputMap.h file src/ngfx/porting/appkit/ViewController.h file src/ngfx/porting/appkit/ViewController.mm dir src/ngfx/porting/d3d file src/ngfx/porting/d3d/D3DBlitOp.cpp file src/ngfx/porting/d3d/D3DBlitOp.h file src/ngfx/porting/d3d/D3DBuffer.cpp file src/ngfx/porting/d3d/D3DBuffer.h file src/ngfx/porting/d3d/D3DCommandList.cpp file src/ngfx/porting/d3d/D3DCommandList.h file src/ngfx/porting/d3d/D3DCommandQueue.cpp file src/ngfx/porting/d3d/D3DCommandQueue.h file src/ngfx/porting/d3d/D3DComputePass.h file src/ngfx/porting/d3d/D3DComputePipeline.cpp file src/ngfx/porting/d3d/D3DComputePipeline.h file src/ngfx/porting/d3d/D3DDebugUtil.h file src/ngfx/porting/d3d/D3DDescriptorHandle.cpp file src/ngfx/porting/d3d/D3DDescriptorHandle.h file src/ngfx/porting/d3d/D3DDescriptorHeap.cpp file src/ngfx/porting/d3d/D3DDescriptorHeap.h file src/ngfx/porting/d3d/D3DDevice.cpp file src/ngfx/porting/d3d/D3DDevice.h file src/ngfx/porting/d3d/D3DFence.cpp file src/ngfx/porting/d3d/D3DFence.h file src/ngfx/porting/d3d/D3DFramebuffer.cpp file src/ngfx/porting/d3d/D3DFramebuffer.h file src/ngfx/porting/d3d/D3DGraphics.cpp file src/ngfx/porting/d3d/D3DGraphics.h file src/ngfx/porting/d3d/D3DGraphicsContext.cpp file src/ngfx/porting/d3d/D3DGraphicsContext.h file src/ngfx/porting/d3d/D3DGraphicsCore.h file src/ngfx/porting/d3d/D3DGraphicsPipeline.cpp file src/ngfx/porting/d3d/D3DGraphicsPipeline.h file src/ngfx/porting/d3d/D3DPipeline.cpp file src/ngfx/porting/d3d/D3DPipeline.h file src/ngfx/porting/d3d/D3DPipelineCache.h file src/ngfx/porting/d3d/D3DReadbackBuffer.cpp file src/ngfx/porting/d3d/D3DReadbackBuffer.h file src/ngfx/porting/d3d/D3DRenderPass.cpp file src/ngfx/porting/d3d/D3DRenderPass.h file src/ngfx/porting/d3d/D3DSamplerDesc.h file src/ngfx/porting/d3d/D3DShaderModule.cpp file src/ngfx/porting/d3d/D3DShaderModule.h file src/ngfx/porting/d3d/D3DSurface.h file src/ngfx/porting/d3d/D3DSwapchain.cpp file src/ngfx/porting/d3d/D3DSwapchain.h file src/ngfx/porting/d3d/D3DTexture.cpp file src/ngfx/porting/d3d/D3DTexture.h file src/ngfx/porting/d3d/D3DUtil.h file src/ngfx/porting/d3d/D3DWindow.h dir src/ngfx/porting/glfw file src/ngfx/porting/glfw/GLFWInputMap.h file src/ngfx/porting/glfw/GLFWWindow.cpp file src/ngfx/porting/glfw/GLFWWindow.h dir src/ngfx/porting/metal file src/ngfx/porting/metal/MTLApplication.h file src/ngfx/porting/metal/MTLApplication.mm file src/ngfx/porting/metal/MTLBuffer.h file src/ngfx/porting/metal/MTLBuffer.mm file src/ngfx/porting/metal/MTLCommandBuffer.h file src/ngfx/porting/metal/MTLCommandBuffer.mm file src/ngfx/porting/metal/MTLCommandEncoder.h file src/ngfx/porting/metal/MTLComputeCommandEncoder.h file src/ngfx/porting/metal/MTLComputePipeline.h file src/ngfx/porting/metal/MTLComputePipeline.mm file src/ngfx/porting/metal/MTLDepthStencilTexture.h file src/ngfx/porting/metal/MTLDepthStencilTexture.mm file src/ngfx/porting/metal/MTLDevice.h file src/ngfx/porting/metal/MTLDevice.mm file src/ngfx/porting/metal/MTLFramebuffer.h file src/ngfx/porting/metal/MTLFramebuffer.mm file src/ngfx/porting/metal/MTLGraphics.h file src/ngfx/porting/metal/MTLGraphics.mm file src/ngfx/porting/metal/MTLGraphicsContext.h file src/ngfx/porting/metal/MTLGraphicsContext.mm file src/ngfx/porting/metal/MTLGraphicsCore.h file src/ngfx/porting/metal/MTLGraphicsCoreDefines.h file src/ngfx/porting/metal/MTLGraphicsPipeline.h file src/ngfx/porting/metal/MTLGraphicsPipeline.mm file src/ngfx/porting/metal/MTLPipelineCache.h file src/ngfx/porting/metal/MTLPipelineUtil.h file src/ngfx/porting/metal/MTLPipelineUtil.mm file src/ngfx/porting/metal/MTLRenderCommandEncoder.h file src/ngfx/porting/metal/MTLRenderPass.h file src/ngfx/porting/metal/MTLRenderPass.mm file src/ngfx/porting/metal/MTLShaderModule.h file src/ngfx/porting/metal/MTLShaderModule.mm file src/ngfx/porting/metal/MTLSurface.h file src/ngfx/porting/metal/MTLTexture.h file src/ngfx/porting/metal/MTLTexture.mm file src/ngfx/porting/metal/MTLUtil.h file src/ngfx/porting/metal/MTLViewDelegate.h file src/ngfx/porting/metal/MTLViewDelegate.mm file src/ngfx/porting/metal/MTLWindow.h file src/ngfx/porting/metal/MTLWindow.mm dir src/ngfx/porting/vulkan file src/ngfx/porting/vulkan/VKBlit.cpp file src/ngfx/porting/vulkan/VKBlit.h file src/ngfx/porting/vulkan/VKBuffer.cpp file src/ngfx/porting/vulkan/VKBuffer.h file src/ngfx/porting/vulkan/VKCommandBuffer.cpp file src/ngfx/porting/vulkan/VKCommandBuffer.h file src/ngfx/porting/vulkan/VKCommandPool.cpp file src/ngfx/porting/vulkan/VKCommandPool.h file src/ngfx/porting/vulkan/VKComputePipeline.cpp file src/ngfx/porting/vulkan/VKComputePipeline.h file src/ngfx/porting/vulkan/VKConfig.h file src/ngfx/porting/vulkan/VKDebugUtil.cpp file src/ngfx/porting/vulkan/VKDebugUtil.h file src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.cpp file src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h file src/ngfx/porting/vulkan/VKDevice.cpp file src/ngfx/porting/vulkan/VKDevice.h file src/ngfx/porting/vulkan/VKFence.cpp file src/ngfx/porting/vulkan/VKFence.h file src/ngfx/porting/vulkan/VKFramebuffer.cpp file src/ngfx/porting/vulkan/VKFramebuffer.h file src/ngfx/porting/vulkan/VKGraphics.cpp file src/ngfx/porting/vulkan/VKGraphics.h file src/ngfx/porting/vulkan/VKGraphicsContext.cpp file src/ngfx/porting/vulkan/VKGraphicsContext.h file src/ngfx/porting/vulkan/VKGraphicsCore.h file src/ngfx/porting/vulkan/VKGraphicsPipeline.cpp file src/ngfx/porting/vulkan/VKGraphicsPipeline.h file src/ngfx/porting/vulkan/VKImage.cpp file src/ngfx/porting/vulkan/VKImage.h file src/ngfx/porting/vulkan/VKImageCreateInfo.h file src/ngfx/porting/vulkan/VKImageView.cpp file src/ngfx/porting/vulkan/VKImageView.h file src/ngfx/porting/vulkan/VKImageViewCreateInfo.h file src/ngfx/porting/vulkan/VKInstance.cpp file src/ngfx/porting/vulkan/VKInstance.h file src/ngfx/porting/vulkan/VKPhysicalDevice.cpp file src/ngfx/porting/vulkan/VKPhysicalDevice.h file src/ngfx/porting/vulkan/VKPipeline.cpp file src/ngfx/porting/vulkan/VKPipeline.h file src/ngfx/porting/vulkan/VKPipelineCache.cpp file src/ngfx/porting/vulkan/VKPipelineCache.h file src/ngfx/porting/vulkan/VKQueue.cpp file src/ngfx/porting/vulkan/VKQueue.h file src/ngfx/porting/vulkan/VKRenderPass.cpp file src/ngfx/porting/vulkan/VKRenderPass.h file src/ngfx/porting/vulkan/VKSamplerCreateInfo.h file src/ngfx/porting/vulkan/VKSemaphore.cpp file src/ngfx/porting/vulkan/VKSemaphore.h file src/ngfx/porting/vulkan/VKShaderModule.cpp file src/ngfx/porting/vulkan/VKShaderModule.h file src/ngfx/porting/vulkan/VKSurface.cpp file src/ngfx/porting/vulkan/VKSurface.h file src/ngfx/porting/vulkan/VKSwapchain.cpp file src/ngfx/porting/vulkan/VKSwapchain.h file src/ngfx/porting/vulkan/VKTexture.cpp file src/ngfx/porting/vulkan/VKTexture.h file src/ngfx/porting/vulkan/VKUtil.h file src/ngfx/porting/vulkan/VKWindow.h dir src/ngfx/porting/windows file src/ngfx/porting/windows/WInputMap.h file src/ngfx/porting/windows/WWindow.cpp file src/ngfx/porting/windows/WWindow.h dir src/ngfx/regex file src/ngfx/regex/RegexUtil.cpp file src/ngfx/regex/RegexUtil.h Updated on 3 April 2021 at 20:21:52 PDT","title":"Files"},{"location":"api/Files/#files","text":"dir src dir src/ngfx dir src/ngfx/compute file src/ngfx/compute/ComputeApplication.cpp file src/ngfx/compute/ComputeApplication.h file src/ngfx/compute/ComputeOp.h file src/ngfx/compute/ComputePass.h file src/ngfx/compute/ComputePipeline.h dir src/ngfx/computeOps file src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp file src/ngfx/computeOps/MatrixMultiplyCPUOp.h file src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp file src/ngfx/computeOps/MatrixMultiplyGPUOp.h file src/ngfx/computeOps/MatrixMultiplyOp.h dir src/ngfx/core file src/ngfx/core/Application.h file src/ngfx/core/BaseApplication.cpp file src/ngfx/core/BaseApplication.h file src/ngfx/core/DebugUtil.h file src/ngfx/core/FPSCounter.cpp file src/ngfx/core/FPSCounter.h file src/ngfx/core/File.cpp file src/ngfx/core/File.h file src/ngfx/core/FileUtil.cpp file src/ngfx/core/FileUtil.h file src/ngfx/core/ProcessUtil.cpp file src/ngfx/core/ProcessUtil.h file src/ngfx/core/StringUtil.cpp file src/ngfx/core/StringUtil.h file src/ngfx/core/Timer.cpp file src/ngfx/core/Timer.h file src/ngfx/core/Util.cpp file src/ngfx/core/Util.h dir src/ngfx/drawOps file src/ngfx/drawOps/DrawColorOp.cpp file src/ngfx/drawOps/DrawColorOp.h file src/ngfx/drawOps/DrawMeshOp.cpp file src/ngfx/drawOps/DrawMeshOp.h file src/ngfx/drawOps/DrawTextureOp.cpp file src/ngfx/drawOps/DrawTextureOp.h dir src/ngfx/graphics file src/ngfx/graphics/Buffer.h file src/ngfx/graphics/BufferUtil.h file src/ngfx/graphics/Camera.cpp file src/ngfx/graphics/Camera.h file src/ngfx/graphics/CommandBuffer.h file src/ngfx/graphics/Config.h file src/ngfx/graphics/Device.h file src/ngfx/graphics/DrawOp.h file src/ngfx/graphics/Fence.h file src/ngfx/graphics/FilterOp.cpp file src/ngfx/graphics/FilterOp.h file src/ngfx/graphics/Framebuffer.h file src/ngfx/graphics/Graphics.h file src/ngfx/graphics/GraphicsContext.h file src/ngfx/graphics/GraphicsCore.h file src/ngfx/graphics/GraphicsPipeline.cpp file src/ngfx/graphics/GraphicsPipeline.h file src/ngfx/graphics/MeshData.h file src/ngfx/graphics/MeshUtil.cpp file src/ngfx/graphics/MeshUtil.h file src/ngfx/graphics/Pipeline.h file src/ngfx/graphics/PipelineCache.cpp file src/ngfx/graphics/PipelineCache.h file src/ngfx/graphics/Queue.h file src/ngfx/graphics/RenderPass.h file src/ngfx/graphics/Semaphore.h file src/ngfx/graphics/ShaderModule.cpp file src/ngfx/graphics/ShaderModule.h file src/ngfx/graphics/ShaderTools.cpp file src/ngfx/graphics/ShaderTools.h file src/ngfx/graphics/Surface.h file src/ngfx/graphics/Swapchain.h file src/ngfx/graphics/Texture.cpp file src/ngfx/graphics/Texture.h file src/ngfx/graphics/Window.h dir src/ngfx/input file src/ngfx/input/InputListener.h file src/ngfx/input/InputMap.h dir src/ngfx/porting dir src/ngfx/porting/appkit file src/ngfx/porting/appkit/AppDelegate.h file src/ngfx/porting/appkit/AppDelegate.mm file src/ngfx/porting/appkit/AppKitInputMap.h file src/ngfx/porting/appkit/ViewController.h file src/ngfx/porting/appkit/ViewController.mm dir src/ngfx/porting/d3d file src/ngfx/porting/d3d/D3DBlitOp.cpp file src/ngfx/porting/d3d/D3DBlitOp.h file src/ngfx/porting/d3d/D3DBuffer.cpp file src/ngfx/porting/d3d/D3DBuffer.h file src/ngfx/porting/d3d/D3DCommandList.cpp file src/ngfx/porting/d3d/D3DCommandList.h file src/ngfx/porting/d3d/D3DCommandQueue.cpp file src/ngfx/porting/d3d/D3DCommandQueue.h file src/ngfx/porting/d3d/D3DComputePass.h file src/ngfx/porting/d3d/D3DComputePipeline.cpp file src/ngfx/porting/d3d/D3DComputePipeline.h file src/ngfx/porting/d3d/D3DDebugUtil.h file src/ngfx/porting/d3d/D3DDescriptorHandle.cpp file src/ngfx/porting/d3d/D3DDescriptorHandle.h file src/ngfx/porting/d3d/D3DDescriptorHeap.cpp file src/ngfx/porting/d3d/D3DDescriptorHeap.h file src/ngfx/porting/d3d/D3DDevice.cpp file src/ngfx/porting/d3d/D3DDevice.h file src/ngfx/porting/d3d/D3DFence.cpp file src/ngfx/porting/d3d/D3DFence.h file src/ngfx/porting/d3d/D3DFramebuffer.cpp file src/ngfx/porting/d3d/D3DFramebuffer.h file src/ngfx/porting/d3d/D3DGraphics.cpp file src/ngfx/porting/d3d/D3DGraphics.h file src/ngfx/porting/d3d/D3DGraphicsContext.cpp file src/ngfx/porting/d3d/D3DGraphicsContext.h file src/ngfx/porting/d3d/D3DGraphicsCore.h file src/ngfx/porting/d3d/D3DGraphicsPipeline.cpp file src/ngfx/porting/d3d/D3DGraphicsPipeline.h file src/ngfx/porting/d3d/D3DPipeline.cpp file src/ngfx/porting/d3d/D3DPipeline.h file src/ngfx/porting/d3d/D3DPipelineCache.h file src/ngfx/porting/d3d/D3DReadbackBuffer.cpp file src/ngfx/porting/d3d/D3DReadbackBuffer.h file src/ngfx/porting/d3d/D3DRenderPass.cpp file src/ngfx/porting/d3d/D3DRenderPass.h file src/ngfx/porting/d3d/D3DSamplerDesc.h file src/ngfx/porting/d3d/D3DShaderModule.cpp file src/ngfx/porting/d3d/D3DShaderModule.h file src/ngfx/porting/d3d/D3DSurface.h file src/ngfx/porting/d3d/D3DSwapchain.cpp file src/ngfx/porting/d3d/D3DSwapchain.h file src/ngfx/porting/d3d/D3DTexture.cpp file src/ngfx/porting/d3d/D3DTexture.h file src/ngfx/porting/d3d/D3DUtil.h file src/ngfx/porting/d3d/D3DWindow.h dir src/ngfx/porting/glfw file src/ngfx/porting/glfw/GLFWInputMap.h file src/ngfx/porting/glfw/GLFWWindow.cpp file src/ngfx/porting/glfw/GLFWWindow.h dir src/ngfx/porting/metal file src/ngfx/porting/metal/MTLApplication.h file src/ngfx/porting/metal/MTLApplication.mm file src/ngfx/porting/metal/MTLBuffer.h file src/ngfx/porting/metal/MTLBuffer.mm file src/ngfx/porting/metal/MTLCommandBuffer.h file src/ngfx/porting/metal/MTLCommandBuffer.mm file src/ngfx/porting/metal/MTLCommandEncoder.h file src/ngfx/porting/metal/MTLComputeCommandEncoder.h file src/ngfx/porting/metal/MTLComputePipeline.h file src/ngfx/porting/metal/MTLComputePipeline.mm file src/ngfx/porting/metal/MTLDepthStencilTexture.h file src/ngfx/porting/metal/MTLDepthStencilTexture.mm file src/ngfx/porting/metal/MTLDevice.h file src/ngfx/porting/metal/MTLDevice.mm file src/ngfx/porting/metal/MTLFramebuffer.h file src/ngfx/porting/metal/MTLFramebuffer.mm file src/ngfx/porting/metal/MTLGraphics.h file src/ngfx/porting/metal/MTLGraphics.mm file src/ngfx/porting/metal/MTLGraphicsContext.h file src/ngfx/porting/metal/MTLGraphicsContext.mm file src/ngfx/porting/metal/MTLGraphicsCore.h file src/ngfx/porting/metal/MTLGraphicsCoreDefines.h file src/ngfx/porting/metal/MTLGraphicsPipeline.h file src/ngfx/porting/metal/MTLGraphicsPipeline.mm file src/ngfx/porting/metal/MTLPipelineCache.h file src/ngfx/porting/metal/MTLPipelineUtil.h file src/ngfx/porting/metal/MTLPipelineUtil.mm file src/ngfx/porting/metal/MTLRenderCommandEncoder.h file src/ngfx/porting/metal/MTLRenderPass.h file src/ngfx/porting/metal/MTLRenderPass.mm file src/ngfx/porting/metal/MTLShaderModule.h file src/ngfx/porting/metal/MTLShaderModule.mm file src/ngfx/porting/metal/MTLSurface.h file src/ngfx/porting/metal/MTLTexture.h file src/ngfx/porting/metal/MTLTexture.mm file src/ngfx/porting/metal/MTLUtil.h file src/ngfx/porting/metal/MTLViewDelegate.h file src/ngfx/porting/metal/MTLViewDelegate.mm file src/ngfx/porting/metal/MTLWindow.h file src/ngfx/porting/metal/MTLWindow.mm dir src/ngfx/porting/vulkan file src/ngfx/porting/vulkan/VKBlit.cpp file src/ngfx/porting/vulkan/VKBlit.h file src/ngfx/porting/vulkan/VKBuffer.cpp file src/ngfx/porting/vulkan/VKBuffer.h file src/ngfx/porting/vulkan/VKCommandBuffer.cpp file src/ngfx/porting/vulkan/VKCommandBuffer.h file src/ngfx/porting/vulkan/VKCommandPool.cpp file src/ngfx/porting/vulkan/VKCommandPool.h file src/ngfx/porting/vulkan/VKComputePipeline.cpp file src/ngfx/porting/vulkan/VKComputePipeline.h file src/ngfx/porting/vulkan/VKConfig.h file src/ngfx/porting/vulkan/VKDebugUtil.cpp file src/ngfx/porting/vulkan/VKDebugUtil.h file src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.cpp file src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h file src/ngfx/porting/vulkan/VKDevice.cpp file src/ngfx/porting/vulkan/VKDevice.h file src/ngfx/porting/vulkan/VKFence.cpp file src/ngfx/porting/vulkan/VKFence.h file src/ngfx/porting/vulkan/VKFramebuffer.cpp file src/ngfx/porting/vulkan/VKFramebuffer.h file src/ngfx/porting/vulkan/VKGraphics.cpp file src/ngfx/porting/vulkan/VKGraphics.h file src/ngfx/porting/vulkan/VKGraphicsContext.cpp file src/ngfx/porting/vulkan/VKGraphicsContext.h file src/ngfx/porting/vulkan/VKGraphicsCore.h file src/ngfx/porting/vulkan/VKGraphicsPipeline.cpp file src/ngfx/porting/vulkan/VKGraphicsPipeline.h file src/ngfx/porting/vulkan/VKImage.cpp file src/ngfx/porting/vulkan/VKImage.h file src/ngfx/porting/vulkan/VKImageCreateInfo.h file src/ngfx/porting/vulkan/VKImageView.cpp file src/ngfx/porting/vulkan/VKImageView.h file src/ngfx/porting/vulkan/VKImageViewCreateInfo.h file src/ngfx/porting/vulkan/VKInstance.cpp file src/ngfx/porting/vulkan/VKInstance.h file src/ngfx/porting/vulkan/VKPhysicalDevice.cpp file src/ngfx/porting/vulkan/VKPhysicalDevice.h file src/ngfx/porting/vulkan/VKPipeline.cpp file src/ngfx/porting/vulkan/VKPipeline.h file src/ngfx/porting/vulkan/VKPipelineCache.cpp file src/ngfx/porting/vulkan/VKPipelineCache.h file src/ngfx/porting/vulkan/VKQueue.cpp file src/ngfx/porting/vulkan/VKQueue.h file src/ngfx/porting/vulkan/VKRenderPass.cpp file src/ngfx/porting/vulkan/VKRenderPass.h file src/ngfx/porting/vulkan/VKSamplerCreateInfo.h file src/ngfx/porting/vulkan/VKSemaphore.cpp file src/ngfx/porting/vulkan/VKSemaphore.h file src/ngfx/porting/vulkan/VKShaderModule.cpp file src/ngfx/porting/vulkan/VKShaderModule.h file src/ngfx/porting/vulkan/VKSurface.cpp file src/ngfx/porting/vulkan/VKSurface.h file src/ngfx/porting/vulkan/VKSwapchain.cpp file src/ngfx/porting/vulkan/VKSwapchain.h file src/ngfx/porting/vulkan/VKTexture.cpp file src/ngfx/porting/vulkan/VKTexture.h file src/ngfx/porting/vulkan/VKUtil.h file src/ngfx/porting/vulkan/VKWindow.h dir src/ngfx/porting/windows file src/ngfx/porting/windows/WInputMap.h file src/ngfx/porting/windows/WWindow.cpp file src/ngfx/porting/windows/WWindow.h dir src/ngfx/regex file src/ngfx/regex/RegexUtil.cpp file src/ngfx/regex/RegexUtil.h Updated on 3 April 2021 at 20:21:52 PDT","title":"Files"},{"location":"api/Files/AppDelegate_8h/","text":"src/ngfx/porting/appkit/AppDelegate.h Classes Name class AppDelegate Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <Cocoa/Cocoa.h> @interface AppDelegate : NSObject <NSApplicationDelegate> @end Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/appkit/AppDelegate.h"},{"location":"api/Files/AppDelegate_8h/#srcngfxportingappkitappdelegateh","text":"","title":"src/ngfx/porting/appkit/AppDelegate.h"},{"location":"api/Files/AppDelegate_8h/#classes","text":"Name class AppDelegate","title":"Classes"},{"location":"api/Files/AppDelegate_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <Cocoa/Cocoa.h> @interface AppDelegate : NSObject <NSApplicationDelegate> @end Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/AppDelegate_8mm/","text":"src/ngfx/porting/appkit/AppDelegate.mm Source code #include \"porting/appkit/AppDelegate.h\" @implementation AppDelegate - (void)applicationDidFinishLaunching:(NSNotification *)aNotification { NSWindow* mainWindow = [[NSApplication sharedApplication] mainWindow]; [mainWindow makeKeyAndOrderFront:self]; } - (void)applicationWillTerminate:(NSNotification *)aNotification {} -(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)app { return YES; } @end Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/appkit/AppDelegate.mm"},{"location":"api/Files/AppDelegate_8mm/#srcngfxportingappkitappdelegatemm","text":"","title":"src/ngfx/porting/appkit/AppDelegate.mm"},{"location":"api/Files/AppDelegate_8mm/#source-code","text":"#include \"porting/appkit/AppDelegate.h\" @implementation AppDelegate - (void)applicationDidFinishLaunching:(NSNotification *)aNotification { NSWindow* mainWindow = [[NSApplication sharedApplication] mainWindow]; [mainWindow makeKeyAndOrderFront:self]; } - (void)applicationWillTerminate:(NSNotification *)aNotification {} -(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)app { return YES; } @end Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/AppKitInputMap_8h/","text":"src/ngfx/porting/appkit/AppKitInputMap.h Namespaces Name ngfx Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { enum KeyCode { KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT }; enum InputAction { RELEASE, PRESS }; enum MouseButton { MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/appkit/AppKitInputMap.h"},{"location":"api/Files/AppKitInputMap_8h/#srcngfxportingappkitappkitinputmaph","text":"","title":"src/ngfx/porting/appkit/AppKitInputMap.h"},{"location":"api/Files/AppKitInputMap_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/AppKitInputMap_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { enum KeyCode { KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT }; enum InputAction { RELEASE, PRESS }; enum MouseButton { MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Application_8h/","text":"src/ngfx/core/Application.h Defines Name Application Macro Documentation define Application #define Application BaseApplication Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #if defined(NGFX_GRAPHICS_BACKEND_METAL) #include \"ngfx/porting/metal/MTLApplication.h\" #define Application MTLApplication #else #include \"ngfx/BaseApplication.h\" #define Application BaseApplication #endif Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/Application.h"},{"location":"api/Files/Application_8h/#srcngfxcoreapplicationh","text":"","title":"src/ngfx/core/Application.h"},{"location":"api/Files/Application_8h/#defines","text":"Name Application","title":"Defines"},{"location":"api/Files/Application_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/Application_8h/#define-application","text":"#define Application BaseApplication","title":"define Application"},{"location":"api/Files/Application_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #if defined(NGFX_GRAPHICS_BACKEND_METAL) #include \"ngfx/porting/metal/MTLApplication.h\" #define Application MTLApplication #else #include \"ngfx/BaseApplication.h\" #define Application BaseApplication #endif Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/BaseApplication_8cpp/","text":"src/ngfx/core/BaseApplication.cpp Namespaces Name std::placeholders Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/BaseApplication.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/FPSCounter.h\" #include <cstdio> using namespace ngfx; using namespace std::placeholders; BaseApplication::BaseApplication(const std::string &appName, int w, int h, bool enableDepthStencil, bool offscreen) : appName(appName), w(w), h(h), enableDepthStencil(enableDepthStencil), offscreen(offscreen) {} void BaseApplication::init() { auto &ctx = graphicsContext; ctx.reset(GraphicsContext::create(appName.c_str(), enableDepthStencil)); if (offscreen) { Surface surface(w, h, true); graphicsContext->setSurface(&surface); } else { createWindow(); } graphics.reset(Graphics::create(ctx.get())); if (window) { window->onUpdate = std::bind(&BaseApplication::onUpdate, this); window->onPaint = std::bind(&BaseApplication::onPaint, this); window->onKey = std::bind(&BaseApplication::onKey, this, _1, _2); window->onScroll = std::bind(&BaseApplication::onScroll, this, _1, _2); window->onCursorPos = std::bind(&BaseApplication::onCursorPos, this, _1, _2); window->onMouseButton = std::bind(&BaseApplication::onMouseButton, this, _1, _2); } else if (offscreen) { uint32_t size = w * h * 4; outputTexture.reset(ngfx::Texture::create( ctx.get(), graphics.get(), nullptr, PIXELFORMAT_RGBA8_UNORM, size, w, h, 1, 1, ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT | IMAGE_USAGE_COLOR_ATTACHMENT_BIT))); std::vector<ngfx::Framebuffer::Attachment> attachments = { {outputTexture.get()}}; if (enableDepthStencil) { depthTexture.reset(ngfx::Texture::create( ctx.get(), graphics.get(), nullptr, ctx->depthFormat, size, w, h, 1, 1, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)); attachments.push_back({depthTexture.get()}); } outputFramebuffer.reset(Framebuffer::create( ctx->device, ctx->defaultOffscreenRenderPass, attachments, w, h)); } onInit(); if (persistentCommandBuffers) recordCommandBuffers(); } void BaseApplication::createWindow() { auto &ctx = graphicsContext; window.reset(Window::create( ctx.get(), appName.c_str(), [&](Window *thiz) { ctx->setSurface(thiz->surface); }, w, h)); } void BaseApplication::run() { if (initOnce) { init(); initOnce = false; } FPSCounter fpsCounter; while (!window->shouldClose()) { drawFrame(); fpsCounter.update(); } close(); } void BaseApplication::drawFrame() { if (initOnce) { init(); initOnce = false; } if (window) window->pollEvents(); else if (offscreen) { onUpdate(); onPaint(); } } void BaseApplication::close() { auto commandBuffer = graphicsContext->drawCommandBuffer(); graphics->waitIdle(commandBuffer); } void BaseApplication::recordCommandBuffers() { auto &ctx = graphicsContext; for (uint32_t j = 0; j < ctx->numDrawCommandBuffers; j++) { auto commandBuffer = ctx->drawCommandBuffer(j); commandBuffer->begin(); ctx->currentImageIndex = j; onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } } void BaseApplication::onPaint() { paint(); } void BaseApplication::paint() { auto &ctx = graphicsContext; if (!offscreen) ctx->swapchain->acquireNextImage(); auto commandBuffer = ctx->drawCommandBuffer(); if (!persistentCommandBuffers) { commandBuffer->begin(); onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } ctx->queue->submit(commandBuffer); if (!offscreen) ctx->queue->present(); else { graphics->waitIdle(commandBuffer); } } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/BaseApplication.cpp"},{"location":"api/Files/BaseApplication_8cpp/#srcngfxcorebaseapplicationcpp","text":"","title":"src/ngfx/core/BaseApplication.cpp"},{"location":"api/Files/BaseApplication_8cpp/#namespaces","text":"Name std::placeholders","title":"Namespaces"},{"location":"api/Files/BaseApplication_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/BaseApplication.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/FPSCounter.h\" #include <cstdio> using namespace ngfx; using namespace std::placeholders; BaseApplication::BaseApplication(const std::string &appName, int w, int h, bool enableDepthStencil, bool offscreen) : appName(appName), w(w), h(h), enableDepthStencil(enableDepthStencil), offscreen(offscreen) {} void BaseApplication::init() { auto &ctx = graphicsContext; ctx.reset(GraphicsContext::create(appName.c_str(), enableDepthStencil)); if (offscreen) { Surface surface(w, h, true); graphicsContext->setSurface(&surface); } else { createWindow(); } graphics.reset(Graphics::create(ctx.get())); if (window) { window->onUpdate = std::bind(&BaseApplication::onUpdate, this); window->onPaint = std::bind(&BaseApplication::onPaint, this); window->onKey = std::bind(&BaseApplication::onKey, this, _1, _2); window->onScroll = std::bind(&BaseApplication::onScroll, this, _1, _2); window->onCursorPos = std::bind(&BaseApplication::onCursorPos, this, _1, _2); window->onMouseButton = std::bind(&BaseApplication::onMouseButton, this, _1, _2); } else if (offscreen) { uint32_t size = w * h * 4; outputTexture.reset(ngfx::Texture::create( ctx.get(), graphics.get(), nullptr, PIXELFORMAT_RGBA8_UNORM, size, w, h, 1, 1, ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT | IMAGE_USAGE_COLOR_ATTACHMENT_BIT))); std::vector<ngfx::Framebuffer::Attachment> attachments = { {outputTexture.get()}}; if (enableDepthStencil) { depthTexture.reset(ngfx::Texture::create( ctx.get(), graphics.get(), nullptr, ctx->depthFormat, size, w, h, 1, 1, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)); attachments.push_back({depthTexture.get()}); } outputFramebuffer.reset(Framebuffer::create( ctx->device, ctx->defaultOffscreenRenderPass, attachments, w, h)); } onInit(); if (persistentCommandBuffers) recordCommandBuffers(); } void BaseApplication::createWindow() { auto &ctx = graphicsContext; window.reset(Window::create( ctx.get(), appName.c_str(), [&](Window *thiz) { ctx->setSurface(thiz->surface); }, w, h)); } void BaseApplication::run() { if (initOnce) { init(); initOnce = false; } FPSCounter fpsCounter; while (!window->shouldClose()) { drawFrame(); fpsCounter.update(); } close(); } void BaseApplication::drawFrame() { if (initOnce) { init(); initOnce = false; } if (window) window->pollEvents(); else if (offscreen) { onUpdate(); onPaint(); } } void BaseApplication::close() { auto commandBuffer = graphicsContext->drawCommandBuffer(); graphics->waitIdle(commandBuffer); } void BaseApplication::recordCommandBuffers() { auto &ctx = graphicsContext; for (uint32_t j = 0; j < ctx->numDrawCommandBuffers; j++) { auto commandBuffer = ctx->drawCommandBuffer(j); commandBuffer->begin(); ctx->currentImageIndex = j; onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } } void BaseApplication::onPaint() { paint(); } void BaseApplication::paint() { auto &ctx = graphicsContext; if (!offscreen) ctx->swapchain->acquireNextImage(); auto commandBuffer = ctx->drawCommandBuffer(); if (!persistentCommandBuffers) { commandBuffer->begin(); onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } ctx->queue->submit(commandBuffer); if (!offscreen) ctx->queue->present(); else { graphics->waitIdle(commandBuffer); } } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/BaseApplication_8h/","text":"src/ngfx/core/BaseApplication.h Namespaces Name ngfx Classes Name class ngfx::BaseApplication Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/graphics/Window.h\" #include \"ngfx/input/InputListener.h\" #include <memory> #include <string> namespace ngfx { class BaseApplication : public InputListener { public: BaseApplication(const std::string &appName, int w = Window::DISPLAY_WIDTH, int h = Window::DISPLAY_HEIGHT, bool enableDepthStencil = false, bool offscreen = false); virtual ~BaseApplication() {} virtual void init(); virtual void createWindow(); virtual void paint(); virtual void recordCommandBuffers(); virtual void close(); virtual void onInit() {} virtual void onRecordCommandBuffer(CommandBuffer *commandBuffer) = 0; virtual void onUpdate() {} virtual void onPaint(); virtual void run(); virtual void drawFrame(); std::unique_ptr<Graphics> graphics; std::unique_ptr<Window> window; std::unique_ptr<GraphicsContext> graphicsContext; std::string appName; int w, h; bool enableDepthStencil = false; bool offscreen = false; bool persistentCommandBuffers = true; protected: bool initOnce = true; std::unique_ptr<ngfx::Texture> outputTexture, depthTexture; std::unique_ptr<Framebuffer> outputFramebuffer; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/BaseApplication.h"},{"location":"api/Files/BaseApplication_8h/#srcngfxcorebaseapplicationh","text":"","title":"src/ngfx/core/BaseApplication.h"},{"location":"api/Files/BaseApplication_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/BaseApplication_8h/#classes","text":"Name class ngfx::BaseApplication","title":"Classes"},{"location":"api/Files/BaseApplication_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/graphics/Window.h\" #include \"ngfx/input/InputListener.h\" #include <memory> #include <string> namespace ngfx { class BaseApplication : public InputListener { public: BaseApplication(const std::string &appName, int w = Window::DISPLAY_WIDTH, int h = Window::DISPLAY_HEIGHT, bool enableDepthStencil = false, bool offscreen = false); virtual ~BaseApplication() {} virtual void init(); virtual void createWindow(); virtual void paint(); virtual void recordCommandBuffers(); virtual void close(); virtual void onInit() {} virtual void onRecordCommandBuffer(CommandBuffer *commandBuffer) = 0; virtual void onUpdate() {} virtual void onPaint(); virtual void run(); virtual void drawFrame(); std::unique_ptr<Graphics> graphics; std::unique_ptr<Window> window; std::unique_ptr<GraphicsContext> graphicsContext; std::string appName; int w, h; bool enableDepthStencil = false; bool offscreen = false; bool persistentCommandBuffers = true; protected: bool initOnce = true; std::unique_ptr<ngfx::Texture> outputTexture, depthTexture; std::unique_ptr<Framebuffer> outputFramebuffer; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/BufferUtil_8h/","text":"src/ngfx/graphics/BufferUtil.h Namespaces Name ngfx Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" namespace ngfx { static Buffer *createVertexBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_VERTEX_BUFFER_BIT); } template <typename T> static inline Buffer *createVertexBuffer(GraphicsContext *ctx, const std::vector<T> &v) { return createVertexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createIndexBuffer(GraphicsContext *ctx, const void *data, uint32_t size, uint32_t stride = sizeof(uint32_t)) { return Buffer::create(ctx, data, size, BUFFER_USAGE_INDEX_BUFFER_BIT); } template <typename T> static inline Buffer *createIndexBuffer(GraphicsContext *ctx, const std::vector<T> &v, uint32_t stride = sizeof(uint32_t)) { return createIndexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createUniformBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_UNIFORM_BUFFER_BIT); } static Buffer *createStorageBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_STORAGE_BUFFER_BIT); } }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/BufferUtil.h"},{"location":"api/Files/BufferUtil_8h/#srcngfxgraphicsbufferutilh","text":"","title":"src/ngfx/graphics/BufferUtil.h"},{"location":"api/Files/BufferUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/BufferUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" namespace ngfx { static Buffer *createVertexBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_VERTEX_BUFFER_BIT); } template <typename T> static inline Buffer *createVertexBuffer(GraphicsContext *ctx, const std::vector<T> &v) { return createVertexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createIndexBuffer(GraphicsContext *ctx, const void *data, uint32_t size, uint32_t stride = sizeof(uint32_t)) { return Buffer::create(ctx, data, size, BUFFER_USAGE_INDEX_BUFFER_BIT); } template <typename T> static inline Buffer *createIndexBuffer(GraphicsContext *ctx, const std::vector<T> &v, uint32_t stride = sizeof(uint32_t)) { return createIndexBuffer(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } static Buffer *createUniformBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_UNIFORM_BUFFER_BIT); } static Buffer *createStorageBuffer(GraphicsContext *ctx, const void *data, uint32_t size) { return Buffer::create(ctx, data, size, BUFFER_USAGE_STORAGE_BUFFER_BIT); } }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Buffer_8h/","text":"src/ngfx/graphics/Buffer.h Namespaces Name ngfx Classes Name class ngfx::Buffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <vector> namespace ngfx { class GraphicsContext; class Buffer { public: static Buffer *create(GraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags usageFlags); template <typename T> static inline Buffer *create(GraphicsContext *ctx, const std::vector<T> &v, BufferUsageFlags usageFlags) { return create(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } virtual ~Buffer() {} virtual void *map() = 0; virtual void unmap() = 0; virtual void upload(const void *data, uint32_t size, uint32_t offset = 0) = 0; virtual void download(void *data, uint32_t size, uint32_t offset = 0) = 0; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Buffer.h"},{"location":"api/Files/Buffer_8h/#srcngfxgraphicsbufferh","text":"","title":"src/ngfx/graphics/Buffer.h"},{"location":"api/Files/Buffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Buffer_8h/#classes","text":"Name class ngfx::Buffer","title":"Classes"},{"location":"api/Files/Buffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <vector> namespace ngfx { class GraphicsContext; class Buffer { public: static Buffer *create(GraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags usageFlags); template <typename T> static inline Buffer *create(GraphicsContext *ctx, const std::vector<T> &v, BufferUsageFlags usageFlags) { return create(ctx, v.data(), uint32_t(v.size() * sizeof(v[0]))); } virtual ~Buffer() {} virtual void *map() = 0; virtual void unmap() = 0; virtual void upload(const void *data, uint32_t size, uint32_t offset = 0) = 0; virtual void download(void *data, uint32_t size, uint32_t offset = 0) = 0; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Camera_8cpp/","text":"src/ngfx/graphics/Camera.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Camera.h\" #include \"ngfx/core/DebugUtil.h\" #include <glm/gtx/euler_angles.hpp> #include <glm/gtx/transform.hpp> using namespace ngfx; void Camera::onKey(KeyCode code, InputAction action) {} void Camera::onScroll(double xOffset, double yOffset) { zoom += float(yOffset) / 10.0f; } void Camera::onCursorPos(double x, double y) { auto &s = inputState; if (s.state == 1) { s.x = x; s.y = y; s.state = 2; } else if (s.state == 2) { double dx = x - s.x, dy = y - s.y; yaw += float(radians(dx * 10.0f)); pitch += float(radians(dy * 10.0f)); s.x = x; s.y = y; } } void Camera::onMouseButton(MouseButton button, InputAction action) { auto &s = inputState; if (button == MOUSE_BUTTON_MIDDLE) { if (s.state == 0 && action == PRESS) s.state = 1; else if (s.state != 0 && action == RELEASE) s.state = 0; } } void Camera::update() { viewMat = translate(vec3(panX, panY, 0)) * translate(vec3(0, 0, zoom)) * yawPitchRoll(radians(yaw), radians(pitch), radians(roll)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Camera.cpp"},{"location":"api/Files/Camera_8cpp/#srcngfxgraphicscameracpp","text":"","title":"src/ngfx/graphics/Camera.cpp"},{"location":"api/Files/Camera_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Camera.h\" #include \"ngfx/core/DebugUtil.h\" #include <glm/gtx/euler_angles.hpp> #include <glm/gtx/transform.hpp> using namespace ngfx; void Camera::onKey(KeyCode code, InputAction action) {} void Camera::onScroll(double xOffset, double yOffset) { zoom += float(yOffset) / 10.0f; } void Camera::onCursorPos(double x, double y) { auto &s = inputState; if (s.state == 1) { s.x = x; s.y = y; s.state = 2; } else if (s.state == 2) { double dx = x - s.x, dy = y - s.y; yaw += float(radians(dx * 10.0f)); pitch += float(radians(dy * 10.0f)); s.x = x; s.y = y; } } void Camera::onMouseButton(MouseButton button, InputAction action) { auto &s = inputState; if (button == MOUSE_BUTTON_MIDDLE) { if (s.state == 0 && action == PRESS) s.state = 1; else if (s.state != 0 && action == RELEASE) s.state = 0; } } void Camera::update() { viewMat = translate(vec3(panX, panY, 0)) * translate(vec3(0, 0, zoom)) * yawPitchRoll(radians(yaw), radians(pitch), radians(roll)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Camera_8h/","text":"src/ngfx/graphics/Camera.h Namespaces Name ngfx Classes Name class ngfx::Camera Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/input/InputListener.h\" #include <glm/glm.hpp> using namespace glm; namespace ngfx { class Camera : public InputListener { public: virtual ~Camera() {} void onKey(KeyCode keyCode, InputAction keyAction) override; void onScroll(double xoffset, double yoffset) override; void onCursorPos(double x, double y) override; void onMouseButton(MouseButton button, InputAction action) override; void update(); float panX = 0.0f, panY = 0.0f, zoom = 0.0f, yaw = 0.0f, pitch = 0.0f, roll = 0.0f; mat4 viewMat; private: struct { uint32_t state = 0; double x = -1.0, y = -1.0; } inputState; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Camera.h"},{"location":"api/Files/Camera_8h/#srcngfxgraphicscamerah","text":"","title":"src/ngfx/graphics/Camera.h"},{"location":"api/Files/Camera_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Camera_8h/#classes","text":"Name class ngfx::Camera","title":"Classes"},{"location":"api/Files/Camera_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/input/InputListener.h\" #include <glm/glm.hpp> using namespace glm; namespace ngfx { class Camera : public InputListener { public: virtual ~Camera() {} void onKey(KeyCode keyCode, InputAction keyAction) override; void onScroll(double xoffset, double yoffset) override; void onCursorPos(double x, double y) override; void onMouseButton(MouseButton button, InputAction action) override; void update(); float panX = 0.0f, panY = 0.0f, zoom = 0.0f, yaw = 0.0f, pitch = 0.0f, roll = 0.0f; mat4 viewMat; private: struct { uint32_t state = 0; double x = -1.0, y = -1.0; } inputState; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/CommandBuffer_8h/","text":"src/ngfx/graphics/CommandBuffer.h Namespaces Name ngfx Classes Name class ngfx::CommandBuffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class GraphicsContext; class CommandBuffer { public: static CommandBuffer * create(GraphicsContext *ctx, CommandBufferLevel level = COMMAND_BUFFER_LEVEL_PRIMARY); virtual ~CommandBuffer() {} virtual void begin() = 0; virtual void end() = 0; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/CommandBuffer.h"},{"location":"api/Files/CommandBuffer_8h/#srcngfxgraphicscommandbufferh","text":"","title":"src/ngfx/graphics/CommandBuffer.h"},{"location":"api/Files/CommandBuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/CommandBuffer_8h/#classes","text":"Name class ngfx::CommandBuffer","title":"Classes"},{"location":"api/Files/CommandBuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class GraphicsContext; class CommandBuffer { public: static CommandBuffer * create(GraphicsContext *ctx, CommandBufferLevel level = COMMAND_BUFFER_LEVEL_PRIMARY); virtual ~CommandBuffer() {} virtual void begin() = 0; virtual void end() = 0; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ComputeApplication_8cpp/","text":"src/ngfx/compute/ComputeApplication.cpp Namespaces Name glm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/compute/ComputeApplication.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include \"ngfx/graphics/Graphics.h\" #include <memory> using namespace ngfx; using namespace glm; using namespace std; ComputeApplication::ComputeApplication(const std::string &name, int w, int h) : appName(name), w(w), h(h) {} void ComputeApplication::init() { graphicsContext.reset(GraphicsContext::create(appName.c_str())); if (w == 0 && h == 0) graphicsContext->setSurface(nullptr); else { window.reset(Window::create( graphicsContext.get(), appName.c_str(), [&](Window *thiz) { graphicsContext->setSurface(thiz->surface); })); } graphics.reset(Graphics::create(graphicsContext.get())); } void ComputeApplication::recordCommandBuffer(CommandBuffer *commandBuffer) { commandBuffer->begin(); onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } void ComputeApplication::run() { init(); onInit(); auto commandBuffer = graphicsContext->computeCommandBuffer(); recordCommandBuffer(commandBuffer); onUpdate(); doCompute(commandBuffer); close(); } void ComputeApplication::close() {} void ComputeApplication::doCompute(CommandBuffer *commandBuffer) { Timer timer; graphicsContext->submit(commandBuffer); graphics->waitIdle(commandBuffer); timer.update(); NGFX_LOG(\"compute elapsed: %f\", timer.elapsed); onComputeFinished(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/compute/ComputeApplication.cpp"},{"location":"api/Files/ComputeApplication_8cpp/#srcngfxcomputecomputeapplicationcpp","text":"","title":"src/ngfx/compute/ComputeApplication.cpp"},{"location":"api/Files/ComputeApplication_8cpp/#namespaces","text":"Name glm","title":"Namespaces"},{"location":"api/Files/ComputeApplication_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/compute/ComputeApplication.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include \"ngfx/graphics/Graphics.h\" #include <memory> using namespace ngfx; using namespace glm; using namespace std; ComputeApplication::ComputeApplication(const std::string &name, int w, int h) : appName(name), w(w), h(h) {} void ComputeApplication::init() { graphicsContext.reset(GraphicsContext::create(appName.c_str())); if (w == 0 && h == 0) graphicsContext->setSurface(nullptr); else { window.reset(Window::create( graphicsContext.get(), appName.c_str(), [&](Window *thiz) { graphicsContext->setSurface(thiz->surface); })); } graphics.reset(Graphics::create(graphicsContext.get())); } void ComputeApplication::recordCommandBuffer(CommandBuffer *commandBuffer) { commandBuffer->begin(); onRecordCommandBuffer(commandBuffer); commandBuffer->end(); } void ComputeApplication::run() { init(); onInit(); auto commandBuffer = graphicsContext->computeCommandBuffer(); recordCommandBuffer(commandBuffer); onUpdate(); doCompute(commandBuffer); close(); } void ComputeApplication::close() {} void ComputeApplication::doCompute(CommandBuffer *commandBuffer) { Timer timer; graphicsContext->submit(commandBuffer); graphics->waitIdle(commandBuffer); timer.update(); NGFX_LOG(\"compute elapsed: %f\", timer.elapsed); onComputeFinished(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ComputeApplication_8h/","text":"src/ngfx/compute/ComputeApplication.h Namespaces Name ngfx Classes Name class ngfx::ComputeApplication Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/graphics/Window.h\" namespace ngfx { class ComputeApplication { public: ComputeApplication(const std::string &name, int w = 0, int h = 0); virtual ~ComputeApplication() {} virtual void onInit() {} virtual void onRecordCommandBuffer(CommandBuffer *commandBuffer) {} virtual void onUpdate() {} virtual void run(); protected: virtual void init(); virtual void close(); virtual void doCompute(CommandBuffer *commandBuffer); virtual void onComputeFinished() {} virtual void recordCommandBuffer(CommandBuffer *commandBuffer); std::unique_ptr<Graphics> graphics; std::unique_ptr<Window> window; std::unique_ptr<GraphicsContext> graphicsContext; std::string appName; int w, h; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/compute/ComputeApplication.h"},{"location":"api/Files/ComputeApplication_8h/#srcngfxcomputecomputeapplicationh","text":"","title":"src/ngfx/compute/ComputeApplication.h"},{"location":"api/Files/ComputeApplication_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ComputeApplication_8h/#classes","text":"Name class ngfx::ComputeApplication","title":"Classes"},{"location":"api/Files/ComputeApplication_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/graphics/Window.h\" namespace ngfx { class ComputeApplication { public: ComputeApplication(const std::string &name, int w = 0, int h = 0); virtual ~ComputeApplication() {} virtual void onInit() {} virtual void onRecordCommandBuffer(CommandBuffer *commandBuffer) {} virtual void onUpdate() {} virtual void run(); protected: virtual void init(); virtual void close(); virtual void doCompute(CommandBuffer *commandBuffer); virtual void onComputeFinished() {} virtual void recordCommandBuffer(CommandBuffer *commandBuffer); std::unique_ptr<Graphics> graphics; std::unique_ptr<Window> window; std::unique_ptr<GraphicsContext> graphicsContext; std::string appName; int w, h; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ComputeOp_8h/","text":"src/ngfx/compute/ComputeOp.h Namespaces Name ngfx Classes Name class ngfx::ComputeOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class ComputeOp { public: ComputeOp(GraphicsContext *ctx) : ctx(ctx) {} virtual ~ComputeOp() {} virtual void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) = 0; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/compute/ComputeOp.h"},{"location":"api/Files/ComputeOp_8h/#srcngfxcomputecomputeoph","text":"","title":"src/ngfx/compute/ComputeOp.h"},{"location":"api/Files/ComputeOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ComputeOp_8h/#classes","text":"Name class ngfx::ComputeOp","title":"Classes"},{"location":"api/Files/ComputeOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class ComputeOp { public: ComputeOp(GraphicsContext *ctx) : ctx(ctx) {} virtual ~ComputeOp() {} virtual void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) = 0; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ComputePass_8h/","text":"src/ngfx/compute/ComputePass.h Namespaces Name ngfx Classes Name class ngfx::ComputePass Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" namespace ngfx { class GraphicsContext; class ComputePass { public: virtual ~ComputePass() {} virtual void begin(GraphicsContext *ctx, CommandBuffer *commandBuffer) {} virtual void end(CommandBuffer *commandBuffer) {} }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/compute/ComputePass.h"},{"location":"api/Files/ComputePass_8h/#srcngfxcomputecomputepassh","text":"","title":"src/ngfx/compute/ComputePass.h"},{"location":"api/Files/ComputePass_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ComputePass_8h/#classes","text":"Name class ngfx::ComputePass","title":"Classes"},{"location":"api/Files/ComputePass_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" namespace ngfx { class GraphicsContext; class ComputePass { public: virtual ~ComputePass() {} virtual void begin(GraphicsContext *ctx, CommandBuffer *commandBuffer) {} virtual void end(CommandBuffer *commandBuffer) {} }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ComputePipeline_8h/","text":"src/ngfx/compute/ComputePipeline.h Namespaces Name ngfx Classes Name class ngfx::ComputePipeline Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Pipeline.h\" #include \"ngfx/graphics/ShaderModule.h\" namespace ngfx { class GraphicsContext; class ComputePipeline : public Pipeline { public: static ComputePipeline *create(GraphicsContext *graphicsContext, ComputeShaderModule *cs); virtual ~ComputePipeline() {} std::vector<uint32_t> descriptorBindings; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/compute/ComputePipeline.h"},{"location":"api/Files/ComputePipeline_8h/#srcngfxcomputecomputepipelineh","text":"","title":"src/ngfx/compute/ComputePipeline.h"},{"location":"api/Files/ComputePipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ComputePipeline_8h/#classes","text":"Name class ngfx::ComputePipeline","title":"Classes"},{"location":"api/Files/ComputePipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Pipeline.h\" #include \"ngfx/graphics/ShaderModule.h\" namespace ngfx { class GraphicsContext; class ComputePipeline : public Pipeline { public: static ComputePipeline *create(GraphicsContext *graphicsContext, ComputeShaderModule *cs); virtual ~ComputePipeline() {} std::vector<uint32_t> descriptorBindings; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Config_8h/","text":"src/ngfx/graphics/Config.h Defines Name PREFERRED_NUM_SWAPCHAIN_IMAGES ENABLE_VSYNC USE_PRECOMPILED_SHADERS ORIGIN_BOTTOM_LEFT Macro Documentation define PREFERRED_NUM_SWAPCHAIN_IMAGES #define PREFERRED_NUM_SWAPCHAIN_IMAGES 3 define ENABLE_VSYNC #define ENABLE_VSYNC define USE_PRECOMPILED_SHADERS #define USE_PRECOMPILED_SHADERS define ORIGIN_BOTTOM_LEFT #define ORIGIN_BOTTOM_LEFT Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> #define PREFERRED_NUM_SWAPCHAIN_IMAGES 3 #define ENABLE_VSYNC #define USE_PRECOMPILED_SHADERS #define ORIGIN_BOTTOM_LEFT Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Config.h"},{"location":"api/Files/Config_8h/#srcngfxgraphicsconfigh","text":"","title":"src/ngfx/graphics/Config.h"},{"location":"api/Files/Config_8h/#defines","text":"Name PREFERRED_NUM_SWAPCHAIN_IMAGES ENABLE_VSYNC USE_PRECOMPILED_SHADERS ORIGIN_BOTTOM_LEFT","title":"Defines"},{"location":"api/Files/Config_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/Config_8h/#define-preferred_num_swapchain_images","text":"#define PREFERRED_NUM_SWAPCHAIN_IMAGES 3","title":"define PREFERRED_NUM_SWAPCHAIN_IMAGES"},{"location":"api/Files/Config_8h/#define-enable_vsync","text":"#define ENABLE_VSYNC","title":"define ENABLE_VSYNC"},{"location":"api/Files/Config_8h/#define-use_precompiled_shaders","text":"#define USE_PRECOMPILED_SHADERS","title":"define USE_PRECOMPILED_SHADERS"},{"location":"api/Files/Config_8h/#define-origin_bottom_left","text":"#define ORIGIN_BOTTOM_LEFT","title":"define ORIGIN_BOTTOM_LEFT"},{"location":"api/Files/Config_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> #define PREFERRED_NUM_SWAPCHAIN_IMAGES 3 #define ENABLE_VSYNC #define USE_PRECOMPILED_SHADERS #define ORIGIN_BOTTOM_LEFT Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DBlitOp_8cpp/","text":"src/ngfx/porting/d3d/D3DBlitOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DBlitOp.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphics.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DTexture.h\" #include <glm/gtc/type_ptr.hpp> using namespace ngfx; using namespace glm; D3DBlitOp::D3DBlitOp(D3DGraphicsContext *ctx, D3DTexture *srcTexture, uint32_t srcLevel, D3DTexture *dstTexture, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer, uint32_t srcLayerCount, uint32_t dstBaseLayer, uint32_t dstLayerCount) : ctx(ctx), srcTexture(srcTexture), srcLevel(srcLevel), dstTexture(dstTexture), dstLevel(dstLevel), srcRegion(srcRegion), dstRegion(dstRegion), srcBaseLayer(srcBaseLayer), srcLayerCount(srcLayerCount), dstBaseLayer(dstBaseLayer), dstLayerCount(dstLayerCount) { outputFramebuffer.reset((D3DFramebuffer *)Framebuffer::create( ctx->device, ctx->defaultOffscreenRenderPass, {{dstTexture, dstLevel, 0}}, dstTexture->w >> dstLevel, dstTexture->h >> dstLevel)); std::vector<vec2> pos = {vec2(-1, 1), vec2(-1, -1), vec2(1, 1), vec2(1, -1)}; std::vector<vec2> texCoord = {vec2(0, 0), vec2(0, 1), vec2(1, 0), vec2(1, 1)}; bPos.reset((D3DBuffer *)createVertexBuffer<vec2>(ctx, pos)); bTexCoord.reset((D3DBuffer *)createVertexBuffer<vec2>(ctx, texCoord)); numVerts = uint32_t(pos.size()); UBOData uboData = {srcLevel}; bUbo.reset((D3DBuffer *)createUniformBuffer(ctx, &uboData, sizeof(uboData))); createPipeline(); graphicsPipeline->getBindings({&U_UBO, &U_TEXTURE}, {&B_POS, &B_TEXCOORD}); } void D3DBlitOp::createPipeline() { const std::string key = \"d3dBlitOp\"; graphicsPipeline = (D3DGraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultOffscreenRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP; auto device = ctx->device; graphicsPipeline = (D3DGraphicsPipeline *)GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/d3dBlitOp.vert\").get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/d3dBlitOp.frag\") .get(), dstTexture->format, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } void D3DBlitOp::draw(D3DCommandList *cmdList, D3DGraphics *graphics) { graphics->bindGraphicsPipeline(cmdList, graphicsPipeline); graphics->bindVertexBuffer(cmdList, bPos.get(), B_POS, sizeof(vec2)); graphics->bindUniformBuffer(cmdList, bUbo.get(), U_UBO, SHADER_STAGE_FRAGMENT_BIT); graphics->bindVertexBuffer(cmdList, bTexCoord.get(), B_TEXCOORD, sizeof(vec2)); D3D_TRACE(cmdList->v->SetGraphicsRootDescriptorTable( U_TEXTURE, srcTexture->getSrvDescriptor(srcLevel, 1).gpuHandle)); D3D12_FILTER filter = D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT; D3D_TRACE(cmdList->v->SetGraphicsRootDescriptorTable( U_TEXTURE + 1, srcTexture->getSamplerDescriptor(filter).gpuHandle)); graphics->draw(cmdList, 4); } void D3DBlitOp::apply(D3DGraphicsContext *ctx, D3DCommandList *cmdList, D3DGraphics *graphics) { ctx->beginOffscreenRenderPass(cmdList, graphics, outputFramebuffer.get()); draw(cmdList, graphics); ctx->endOffscreenRenderPass(cmdList, graphics); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DBlitOp.cpp"},{"location":"api/Files/D3DBlitOp_8cpp/#srcngfxportingd3dd3dblitopcpp","text":"","title":"src/ngfx/porting/d3d/D3DBlitOp.cpp"},{"location":"api/Files/D3DBlitOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DBlitOp.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphics.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DTexture.h\" #include <glm/gtc/type_ptr.hpp> using namespace ngfx; using namespace glm; D3DBlitOp::D3DBlitOp(D3DGraphicsContext *ctx, D3DTexture *srcTexture, uint32_t srcLevel, D3DTexture *dstTexture, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer, uint32_t srcLayerCount, uint32_t dstBaseLayer, uint32_t dstLayerCount) : ctx(ctx), srcTexture(srcTexture), srcLevel(srcLevel), dstTexture(dstTexture), dstLevel(dstLevel), srcRegion(srcRegion), dstRegion(dstRegion), srcBaseLayer(srcBaseLayer), srcLayerCount(srcLayerCount), dstBaseLayer(dstBaseLayer), dstLayerCount(dstLayerCount) { outputFramebuffer.reset((D3DFramebuffer *)Framebuffer::create( ctx->device, ctx->defaultOffscreenRenderPass, {{dstTexture, dstLevel, 0}}, dstTexture->w >> dstLevel, dstTexture->h >> dstLevel)); std::vector<vec2> pos = {vec2(-1, 1), vec2(-1, -1), vec2(1, 1), vec2(1, -1)}; std::vector<vec2> texCoord = {vec2(0, 0), vec2(0, 1), vec2(1, 0), vec2(1, 1)}; bPos.reset((D3DBuffer *)createVertexBuffer<vec2>(ctx, pos)); bTexCoord.reset((D3DBuffer *)createVertexBuffer<vec2>(ctx, texCoord)); numVerts = uint32_t(pos.size()); UBOData uboData = {srcLevel}; bUbo.reset((D3DBuffer *)createUniformBuffer(ctx, &uboData, sizeof(uboData))); createPipeline(); graphicsPipeline->getBindings({&U_UBO, &U_TEXTURE}, {&B_POS, &B_TEXCOORD}); } void D3DBlitOp::createPipeline() { const std::string key = \"d3dBlitOp\"; graphicsPipeline = (D3DGraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultOffscreenRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP; auto device = ctx->device; graphicsPipeline = (D3DGraphicsPipeline *)GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/d3dBlitOp.vert\").get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/d3dBlitOp.frag\") .get(), dstTexture->format, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } void D3DBlitOp::draw(D3DCommandList *cmdList, D3DGraphics *graphics) { graphics->bindGraphicsPipeline(cmdList, graphicsPipeline); graphics->bindVertexBuffer(cmdList, bPos.get(), B_POS, sizeof(vec2)); graphics->bindUniformBuffer(cmdList, bUbo.get(), U_UBO, SHADER_STAGE_FRAGMENT_BIT); graphics->bindVertexBuffer(cmdList, bTexCoord.get(), B_TEXCOORD, sizeof(vec2)); D3D_TRACE(cmdList->v->SetGraphicsRootDescriptorTable( U_TEXTURE, srcTexture->getSrvDescriptor(srcLevel, 1).gpuHandle)); D3D12_FILTER filter = D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT; D3D_TRACE(cmdList->v->SetGraphicsRootDescriptorTable( U_TEXTURE + 1, srcTexture->getSamplerDescriptor(filter).gpuHandle)); graphics->draw(cmdList, 4); } void D3DBlitOp::apply(D3DGraphicsContext *ctx, D3DCommandList *cmdList, D3DGraphics *graphics) { ctx->beginOffscreenRenderPass(cmdList, graphics, outputFramebuffer.get()); draw(cmdList, graphics); ctx->endOffscreenRenderPass(cmdList, graphics); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DBlitOp_8h/","text":"src/ngfx/porting/d3d/D3DBlitOp.h Namespaces Name ngfx Classes Name struct ngfx::Region class ngfx::D3DBlitOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DFramebuffer.h\" #include \"ngfx/porting/d3d/D3DGraphicsPipeline.h\" #include <glm/glm.hpp> namespace ngfx { struct Region { glm::ivec3 p0, p1; }; class D3DGraphicsContext; class D3DTexture; class D3DGraphics; class D3DBlitOp { public: D3DBlitOp(D3DGraphicsContext *ctx, D3DTexture *srcTexture, uint32_t srcLevel, D3DTexture *dstTexture, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer = 0, uint32_t srcLayerCount = 1, uint32_t dstBaseLayer = 0, uint32_t dstLayerCount = 1); void apply(D3DGraphicsContext *ctx, D3DCommandList *cmdList, D3DGraphics *graphics); void draw(D3DCommandList *cmdList, D3DGraphics *graphics); std::unique_ptr<D3DFramebuffer> outputFramebuffer; std::unique_ptr<D3DBuffer> bPos, bTexCoord, bUbo; D3DTexture *srcTexture, *dstTexture; uint32_t srcLevel, dstLevel; Region srcRegion, dstRegion; uint32_t srcBaseLayer, srcLayerCount, dstBaseLayer, dstLayerCount; protected: virtual void createPipeline(); struct UBOData { uint32_t lod, padding[3]; }; D3DGraphicsPipeline *graphicsPipeline; uint32_t numVerts; uint32_t B_POS, B_TEXCOORD, U_UBO, U_TEXTURE; D3DGraphicsContext *ctx; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DBlitOp.h"},{"location":"api/Files/D3DBlitOp_8h/#srcngfxportingd3dd3dblitoph","text":"","title":"src/ngfx/porting/d3d/D3DBlitOp.h"},{"location":"api/Files/D3DBlitOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DBlitOp_8h/#classes","text":"Name struct ngfx::Region class ngfx::D3DBlitOp","title":"Classes"},{"location":"api/Files/D3DBlitOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DFramebuffer.h\" #include \"ngfx/porting/d3d/D3DGraphicsPipeline.h\" #include <glm/glm.hpp> namespace ngfx { struct Region { glm::ivec3 p0, p1; }; class D3DGraphicsContext; class D3DTexture; class D3DGraphics; class D3DBlitOp { public: D3DBlitOp(D3DGraphicsContext *ctx, D3DTexture *srcTexture, uint32_t srcLevel, D3DTexture *dstTexture, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer = 0, uint32_t srcLayerCount = 1, uint32_t dstBaseLayer = 0, uint32_t dstLayerCount = 1); void apply(D3DGraphicsContext *ctx, D3DCommandList *cmdList, D3DGraphics *graphics); void draw(D3DCommandList *cmdList, D3DGraphics *graphics); std::unique_ptr<D3DFramebuffer> outputFramebuffer; std::unique_ptr<D3DBuffer> bPos, bTexCoord, bUbo; D3DTexture *srcTexture, *dstTexture; uint32_t srcLevel, dstLevel; Region srcRegion, dstRegion; uint32_t srcBaseLayer, srcLayerCount, dstBaseLayer, dstLayerCount; protected: virtual void createPipeline(); struct UBOData { uint32_t lod, padding[3]; }; D3DGraphicsPipeline *graphicsPipeline; uint32_t numVerts; uint32_t B_POS, B_TEXCOORD, U_UBO, U_TEXTURE; D3DGraphicsContext *ctx; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DBuffer_8cpp/","text":"src/ngfx/porting/d3d/D3DBuffer.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DReadbackBuffer.h\" #include <cassert> #include <d3dx12.h> using namespace ngfx; void D3DBuffer::create(D3DGraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags bufferUsageFlags) { if (bufferUsageFlags & BUFFER_USAGE_TRANSFER_SRC_BIT) heapType = D3D12_HEAP_TYPE_UPLOAD; else heapType = D3D12_HEAP_TYPE_DEFAULT; D3D12_RESOURCE_FLAGS resourceFlags = D3D12_RESOURCE_FLAG_NONE; if (bufferUsageFlags & BUFFER_USAGE_STORAGE_BUFFER_BIT) resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS; create(ctx, data, size, heapType, resourceFlags); } void D3DBuffer::create(D3DGraphicsContext *ctx, const void *data, uint32_t size, D3D12_HEAP_TYPE heapType, D3D12_RESOURCE_FLAGS resourceFlags, D3D12_RESOURCE_STATES initialResourceState) { HRESULT hResult; this->ctx = ctx; auto &device = ctx->d3dDevice.v; this->size = size; this->heapType = heapType; this->initialResourceState = initialResourceState; CD3DX12_HEAP_PROPERTIES heapProperties(heapType); CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(size, resourceFlags); V(device->CreateCommittedResource(&heapProperties, D3D12_HEAP_FLAG_NONE, &resourceDesc, initialResourceState, nullptr, IID_PPV_ARGS(&v))); currentResourceState = initialResourceState; if (data) upload(data, size, 0); } D3DBuffer::~D3DBuffer() {} // TODO: add read/write flags for map void *D3DBuffer::map() { if (heapType == D3D12_HEAP_TYPE_DEFAULT) { assert(d3dReadbackBuffer == nullptr); auto &copyCommandList = ctx->d3dCopyCommandList; copyCommandList.begin(); d3dReadbackBuffer = new D3DReadbackBuffer(); d3dReadbackBuffer->create(ctx, size); if (currentResourceState != D3D12_RESOURCE_STATE_COPY_SOURCE) { CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition( v.Get(), currentResourceState, D3D12_RESOURCE_STATE_COPY_SOURCE); D3D_TRACE(copyCommandList.v.Get()->ResourceBarrier(1, &resourceBarrier)); } D3D_TRACE(copyCommandList.v.Get()->CopyBufferRegion( d3dReadbackBuffer->v.Get(), 0, v.Get(), 0, size)); CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition(v.Get(), D3D12_RESOURCE_STATE_COPY_SOURCE, D3D12_RESOURCE_STATE_GENERIC_READ); D3D_TRACE(copyCommandList.v.Get()->ResourceBarrier(1, &resourceBarrier)); copyCommandList.end(); ctx->d3dCommandQueue.submit(&copyCommandList); ctx->d3dCommandQueue.waitIdle(); d3dReadBackBufferPtr = d3dReadbackBuffer->map(); return d3dReadBackBufferPtr; } else { UINT8 *ptr; HRESULT hResult; V(v->Map(0, nullptr, reinterpret_cast<void **>(&ptr))); return ptr; } } void D3DBuffer::unmap() { if (heapType == D3D12_HEAP_TYPE_DEFAULT) { assert(d3dReadbackBuffer); upload(d3dReadBackBufferPtr, size, 0); d3dReadbackBuffer->unmap(); delete d3dReadbackBuffer; d3dReadbackBuffer = nullptr; d3dReadBackBufferPtr = nullptr; } else { D3D_TRACE(v->Unmap(0, nullptr)); } } void D3DBuffer::upload(const void *data, uint32_t size, uint32_t offset) { if (heapType == D3D12_HEAP_TYPE_DEFAULT) { auto &copyCommandList = ctx->d3dCopyCommandList; copyCommandList.begin(); D3DBuffer stagingBuffer; if (data) { stagingBuffer.create(ctx, data, size, D3D12_HEAP_TYPE_UPLOAD); if (currentResourceState != D3D12_RESOURCE_STATE_COPY_DEST) { CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition( v.Get(), currentResourceState, D3D12_RESOURCE_STATE_COPY_DEST); D3D_TRACE( copyCommandList.v.Get()->ResourceBarrier(1, &resourceBarrier)); } D3D_TRACE(copyCommandList.v.Get()->CopyBufferRegion( v.Get(), 0, stagingBuffer.v.Get(), 0, size)); } CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition(v.Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_GENERIC_READ); D3D_TRACE(copyCommandList.v.Get()->ResourceBarrier(1, &resourceBarrier)); copyCommandList.end(); ctx->d3dCommandQueue.submit(&copyCommandList); ctx->d3dCommandQueue.waitIdle(); currentResourceState = D3D12_RESOURCE_STATE_GENERIC_READ; } else { uint8_t *dst = (uint8_t *)map(); memcpy(dst + offset, data, size); unmap(); } } Buffer *Buffer::create(GraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags usageFlags) { D3DBuffer *d3dBuffer = new D3DBuffer(); d3dBuffer->create(d3d(ctx), data, size, usageFlags); return d3dBuffer; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DBuffer.cpp"},{"location":"api/Files/D3DBuffer_8cpp/#srcngfxportingd3dd3dbuffercpp","text":"","title":"src/ngfx/porting/d3d/D3DBuffer.cpp"},{"location":"api/Files/D3DBuffer_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DReadbackBuffer.h\" #include <cassert> #include <d3dx12.h> using namespace ngfx; void D3DBuffer::create(D3DGraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags bufferUsageFlags) { if (bufferUsageFlags & BUFFER_USAGE_TRANSFER_SRC_BIT) heapType = D3D12_HEAP_TYPE_UPLOAD; else heapType = D3D12_HEAP_TYPE_DEFAULT; D3D12_RESOURCE_FLAGS resourceFlags = D3D12_RESOURCE_FLAG_NONE; if (bufferUsageFlags & BUFFER_USAGE_STORAGE_BUFFER_BIT) resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS; create(ctx, data, size, heapType, resourceFlags); } void D3DBuffer::create(D3DGraphicsContext *ctx, const void *data, uint32_t size, D3D12_HEAP_TYPE heapType, D3D12_RESOURCE_FLAGS resourceFlags, D3D12_RESOURCE_STATES initialResourceState) { HRESULT hResult; this->ctx = ctx; auto &device = ctx->d3dDevice.v; this->size = size; this->heapType = heapType; this->initialResourceState = initialResourceState; CD3DX12_HEAP_PROPERTIES heapProperties(heapType); CD3DX12_RESOURCE_DESC resourceDesc = CD3DX12_RESOURCE_DESC::Buffer(size, resourceFlags); V(device->CreateCommittedResource(&heapProperties, D3D12_HEAP_FLAG_NONE, &resourceDesc, initialResourceState, nullptr, IID_PPV_ARGS(&v))); currentResourceState = initialResourceState; if (data) upload(data, size, 0); } D3DBuffer::~D3DBuffer() {} // TODO: add read/write flags for map void *D3DBuffer::map() { if (heapType == D3D12_HEAP_TYPE_DEFAULT) { assert(d3dReadbackBuffer == nullptr); auto &copyCommandList = ctx->d3dCopyCommandList; copyCommandList.begin(); d3dReadbackBuffer = new D3DReadbackBuffer(); d3dReadbackBuffer->create(ctx, size); if (currentResourceState != D3D12_RESOURCE_STATE_COPY_SOURCE) { CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition( v.Get(), currentResourceState, D3D12_RESOURCE_STATE_COPY_SOURCE); D3D_TRACE(copyCommandList.v.Get()->ResourceBarrier(1, &resourceBarrier)); } D3D_TRACE(copyCommandList.v.Get()->CopyBufferRegion( d3dReadbackBuffer->v.Get(), 0, v.Get(), 0, size)); CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition(v.Get(), D3D12_RESOURCE_STATE_COPY_SOURCE, D3D12_RESOURCE_STATE_GENERIC_READ); D3D_TRACE(copyCommandList.v.Get()->ResourceBarrier(1, &resourceBarrier)); copyCommandList.end(); ctx->d3dCommandQueue.submit(&copyCommandList); ctx->d3dCommandQueue.waitIdle(); d3dReadBackBufferPtr = d3dReadbackBuffer->map(); return d3dReadBackBufferPtr; } else { UINT8 *ptr; HRESULT hResult; V(v->Map(0, nullptr, reinterpret_cast<void **>(&ptr))); return ptr; } } void D3DBuffer::unmap() { if (heapType == D3D12_HEAP_TYPE_DEFAULT) { assert(d3dReadbackBuffer); upload(d3dReadBackBufferPtr, size, 0); d3dReadbackBuffer->unmap(); delete d3dReadbackBuffer; d3dReadbackBuffer = nullptr; d3dReadBackBufferPtr = nullptr; } else { D3D_TRACE(v->Unmap(0, nullptr)); } } void D3DBuffer::upload(const void *data, uint32_t size, uint32_t offset) { if (heapType == D3D12_HEAP_TYPE_DEFAULT) { auto &copyCommandList = ctx->d3dCopyCommandList; copyCommandList.begin(); D3DBuffer stagingBuffer; if (data) { stagingBuffer.create(ctx, data, size, D3D12_HEAP_TYPE_UPLOAD); if (currentResourceState != D3D12_RESOURCE_STATE_COPY_DEST) { CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition( v.Get(), currentResourceState, D3D12_RESOURCE_STATE_COPY_DEST); D3D_TRACE( copyCommandList.v.Get()->ResourceBarrier(1, &resourceBarrier)); } D3D_TRACE(copyCommandList.v.Get()->CopyBufferRegion( v.Get(), 0, stagingBuffer.v.Get(), 0, size)); } CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition(v.Get(), D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_GENERIC_READ); D3D_TRACE(copyCommandList.v.Get()->ResourceBarrier(1, &resourceBarrier)); copyCommandList.end(); ctx->d3dCommandQueue.submit(&copyCommandList); ctx->d3dCommandQueue.waitIdle(); currentResourceState = D3D12_RESOURCE_STATE_GENERIC_READ; } else { uint8_t *dst = (uint8_t *)map(); memcpy(dst + offset, data, size); unmap(); } } Buffer *Buffer::create(GraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags usageFlags) { D3DBuffer *d3dBuffer = new D3DBuffer(); d3dBuffer->create(d3d(ctx), data, size, usageFlags); return d3dBuffer; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DBuffer_8h/","text":"src/ngfx/porting/d3d/D3DBuffer.h Namespaces Name ngfx Classes Name class ngfx::D3DBuffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/porting/d3d/D3DDevice.h\" namespace ngfx { class D3DGraphicsContext; class D3DReadbackBuffer; class D3DBuffer : public Buffer { public: void create(D3DGraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags bufferUsageFlags); void create(D3DGraphicsContext *ctx, const void *data, uint32_t size, D3D12_HEAP_TYPE heapType = D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_FLAGS resourceFlags = D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATES initialResourceState = D3D12_RESOURCE_STATE_GENERIC_READ); virtual ~D3DBuffer(); void *map() override; void unmap() override; void upload(const void *data, uint32_t size, uint32_t offset = 0) override; void download(void *data, uint32_t size, uint32_t offset = 0) override { NGFX_TODO(\"\"); } uint32_t size; ComPtr<ID3D12Resource> v; protected: D3DGraphicsContext *ctx; D3D12_HEAP_TYPE heapType; D3D12_RESOURCE_STATES initialResourceState, currentResourceState; D3DReadbackBuffer *d3dReadbackBuffer = nullptr; void *d3dReadBackBufferPtr = nullptr; }; D3D_CAST(Buffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DBuffer.h"},{"location":"api/Files/D3DBuffer_8h/#srcngfxportingd3dd3dbufferh","text":"","title":"src/ngfx/porting/d3d/D3DBuffer.h"},{"location":"api/Files/D3DBuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DBuffer_8h/#classes","text":"Name class ngfx::D3DBuffer","title":"Classes"},{"location":"api/Files/D3DBuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/porting/d3d/D3DDevice.h\" namespace ngfx { class D3DGraphicsContext; class D3DReadbackBuffer; class D3DBuffer : public Buffer { public: void create(D3DGraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags bufferUsageFlags); void create(D3DGraphicsContext *ctx, const void *data, uint32_t size, D3D12_HEAP_TYPE heapType = D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_FLAGS resourceFlags = D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATES initialResourceState = D3D12_RESOURCE_STATE_GENERIC_READ); virtual ~D3DBuffer(); void *map() override; void unmap() override; void upload(const void *data, uint32_t size, uint32_t offset = 0) override; void download(void *data, uint32_t size, uint32_t offset = 0) override { NGFX_TODO(\"\"); } uint32_t size; ComPtr<ID3D12Resource> v; protected: D3DGraphicsContext *ctx; D3D12_HEAP_TYPE heapType; D3D12_RESOURCE_STATES initialResourceState, currentResourceState; D3DReadbackBuffer *d3dReadbackBuffer = nullptr; void *d3dReadBackBufferPtr = nullptr; }; D3D_CAST(Buffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DCommandList_8cpp/","text":"src/ngfx/porting/d3d/D3DCommandList.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" using namespace ngfx; void D3DCommandList::create(ID3D12Device *device, D3D12_COMMAND_LIST_TYPE type) { HRESULT hResult; V(device->CreateCommandAllocator(type, IID_PPV_ARGS(&cmdAllocator))); V(device->CreateCommandList(0, type, cmdAllocator.Get(), nullptr, IID_PPV_ARGS(&v))); V(v->Close()); } void D3DCommandList::begin() { HRESULT hResult; V(cmdAllocator->Reset()); V(v->Reset(cmdAllocator.Get(), nullptr)); } void D3DCommandList::end() { HRESULT hResult; V(v->Close()); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DCommandList.cpp"},{"location":"api/Files/D3DCommandList_8cpp/#srcngfxportingd3dd3dcommandlistcpp","text":"","title":"src/ngfx/porting/d3d/D3DCommandList.cpp"},{"location":"api/Files/D3DCommandList_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" using namespace ngfx; void D3DCommandList::create(ID3D12Device *device, D3D12_COMMAND_LIST_TYPE type) { HRESULT hResult; V(device->CreateCommandAllocator(type, IID_PPV_ARGS(&cmdAllocator))); V(device->CreateCommandList(0, type, cmdAllocator.Get(), nullptr, IID_PPV_ARGS(&v))); V(v->Close()); } void D3DCommandList::begin() { HRESULT hResult; V(cmdAllocator->Reset()); V(v->Reset(cmdAllocator.Get(), nullptr)); } void D3DCommandList::end() { HRESULT hResult; V(v->Close()); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DCommandList_8h/","text":"src/ngfx/porting/d3d/D3DCommandList.h Namespaces Name ngfx Classes Name class ngfx::D3DCommandList Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DCommandList : public CommandBuffer { public: void create(ID3D12Device *device, D3D12_COMMAND_LIST_TYPE type = D3D12_COMMAND_LIST_TYPE_DIRECT); virtual ~D3DCommandList() {} void begin() override; void end() override; ComPtr<ID3D12GraphicsCommandList> v; private: ComPtr<ID3D12CommandAllocator> cmdAllocator; }; inline D3DCommandList *d3d(CommandBuffer *g) { return (D3DCommandList *)g; } } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DCommandList.h"},{"location":"api/Files/D3DCommandList_8h/#srcngfxportingd3dd3dcommandlisth","text":"","title":"src/ngfx/porting/d3d/D3DCommandList.h"},{"location":"api/Files/D3DCommandList_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DCommandList_8h/#classes","text":"Name class ngfx::D3DCommandList","title":"Classes"},{"location":"api/Files/D3DCommandList_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DCommandList : public CommandBuffer { public: void create(ID3D12Device *device, D3D12_COMMAND_LIST_TYPE type = D3D12_COMMAND_LIST_TYPE_DIRECT); virtual ~D3DCommandList() {} void begin() override; void end() override; ComPtr<ID3D12GraphicsCommandList> v; private: ComPtr<ID3D12CommandAllocator> cmdAllocator; }; inline D3DCommandList *d3d(CommandBuffer *g) { return (D3DCommandList *)g; } } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DCommandQueue_8cpp/","text":"src/ngfx/porting/d3d/D3DCommandQueue.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DCommandQueue.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" using namespace ngfx; void D3DCommandQueue::create(D3DGraphicsContext *ctx) { HRESULT hResult; this->ctx = ctx; auto d3dDevice = ctx->d3dDevice.v.Get(); D3D12_COMMAND_QUEUE_DESC queueDesc = {D3D12_COMMAND_LIST_TYPE_DIRECT, 0, D3D12_COMMAND_QUEUE_FLAG_NONE, D3D12_COMMAND_LIST_TYPE_DIRECT}; V(d3dDevice->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&v))); } void D3DCommandQueue::present() { ctx->d3dSwapchain.present(); } void D3DCommandQueue::submit(CommandBuffer *commandBuffer) { ID3D12CommandList *d3dCommandList = d3d(commandBuffer)->v.Get(); ID3D12Fence *fence = nullptr; if (d3dCommandList == ctx->d3dCopyCommandList.v.Get()) { } else if (d3dCommandList == ctx->d3dComputeCommandList.v.Get()) { } else { fence = ctx->d3dWaitFences[ctx->currentImageIndex].v.Get(); } submit(d3dCommandList, fence); } void D3DCommandQueue::submit(ID3D12CommandList *commandList, ID3D12Fence *fence) { HRESULT hResult; D3D_TRACE(v->ExecuteCommandLists(1, &commandList)); if (fence) V(v->Signal(fence, D3DFence::SIGNALED)); } void D3DCommandQueue::waitIdle() { HRESULT hResult; D3DFence fence; fence.create(ctx->d3dDevice.v.Get()); // Schedule a Signal command in the queue. V(v->Signal(fence.v.Get(), D3DFence::SIGNALED)); fence.wait(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DCommandQueue.cpp"},{"location":"api/Files/D3DCommandQueue_8cpp/#srcngfxportingd3dd3dcommandqueuecpp","text":"","title":"src/ngfx/porting/d3d/D3DCommandQueue.cpp"},{"location":"api/Files/D3DCommandQueue_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DCommandQueue.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" using namespace ngfx; void D3DCommandQueue::create(D3DGraphicsContext *ctx) { HRESULT hResult; this->ctx = ctx; auto d3dDevice = ctx->d3dDevice.v.Get(); D3D12_COMMAND_QUEUE_DESC queueDesc = {D3D12_COMMAND_LIST_TYPE_DIRECT, 0, D3D12_COMMAND_QUEUE_FLAG_NONE, D3D12_COMMAND_LIST_TYPE_DIRECT}; V(d3dDevice->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&v))); } void D3DCommandQueue::present() { ctx->d3dSwapchain.present(); } void D3DCommandQueue::submit(CommandBuffer *commandBuffer) { ID3D12CommandList *d3dCommandList = d3d(commandBuffer)->v.Get(); ID3D12Fence *fence = nullptr; if (d3dCommandList == ctx->d3dCopyCommandList.v.Get()) { } else if (d3dCommandList == ctx->d3dComputeCommandList.v.Get()) { } else { fence = ctx->d3dWaitFences[ctx->currentImageIndex].v.Get(); } submit(d3dCommandList, fence); } void D3DCommandQueue::submit(ID3D12CommandList *commandList, ID3D12Fence *fence) { HRESULT hResult; D3D_TRACE(v->ExecuteCommandLists(1, &commandList)); if (fence) V(v->Signal(fence, D3DFence::SIGNALED)); } void D3DCommandQueue::waitIdle() { HRESULT hResult; D3DFence fence; fence.create(ctx->d3dDevice.v.Get()); // Schedule a Signal command in the queue. V(v->Signal(fence.v.Get(), D3DFence::SIGNALED)); fence.wait(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DCommandQueue_8h/","text":"src/ngfx/porting/d3d/D3DCommandQueue.h Namespaces Name ngfx Classes Name class ngfx::D3DCommandQueue Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Queue.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DGraphicsContext; class D3DCommandQueue : public Queue { public: void create(D3DGraphicsContext *ctx); virtual ~D3DCommandQueue() {} void present() override; void submit(CommandBuffer *commandBuffer) override; void submit(ID3D12CommandList *commandList, ID3D12Fence *fence); void waitIdle() override; ComPtr<ID3D12CommandQueue> v; private: D3DGraphicsContext *ctx; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DCommandQueue.h"},{"location":"api/Files/D3DCommandQueue_8h/#srcngfxportingd3dd3dcommandqueueh","text":"","title":"src/ngfx/porting/d3d/D3DCommandQueue.h"},{"location":"api/Files/D3DCommandQueue_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DCommandQueue_8h/#classes","text":"Name class ngfx::D3DCommandQueue","title":"Classes"},{"location":"api/Files/D3DCommandQueue_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Queue.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DGraphicsContext; class D3DCommandQueue : public Queue { public: void create(D3DGraphicsContext *ctx); virtual ~D3DCommandQueue() {} void present() override; void submit(CommandBuffer *commandBuffer) override; void submit(ID3D12CommandList *commandList, ID3D12Fence *fence); void waitIdle() override; ComPtr<ID3D12CommandQueue> v; private: D3DGraphicsContext *ctx; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DComputePass_8h/","text":"src/ngfx/porting/d3d/D3DComputePass.h Namespaces Name ngfx Classes Name class ngfx::D3DComputePass Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePass.h\" namespace ngfx { class D3DComputePass : public ComputePass { public: virtual ~D3DComputePass() {} }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DComputePass.h"},{"location":"api/Files/D3DComputePass_8h/#srcngfxportingd3dd3dcomputepassh","text":"","title":"src/ngfx/porting/d3d/D3DComputePass.h"},{"location":"api/Files/D3DComputePass_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DComputePass_8h/#classes","text":"Name class ngfx::D3DComputePass","title":"Classes"},{"location":"api/Files/D3DComputePass_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePass.h\" namespace ngfx { class D3DComputePass : public ComputePass { public: virtual ~D3DComputePass() {} }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DComputePipeline_8cpp/","text":"src/ngfx/porting/d3d/D3DComputePipeline.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DComputePipeline.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DShaderModule.h\" using namespace ngfx; void D3DComputePipeline::create( D3DGraphicsContext *ctx, const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, D3D12_SHADER_BYTECODE shaderByteCode) { D3DPipeline::create(ctx); HRESULT hResult; auto d3dDevice = ctx->d3dDevice.v; createRootSignature(rootParameters); D3D12_COMPUTE_PIPELINE_STATE_DESC desc = {}; desc.pRootSignature = d3dRootSignature.Get(); desc.CS.pShaderBytecode = shaderByteCode.pShaderBytecode; desc.CS.BytecodeLength = shaderByteCode.BytecodeLength; V(d3dDevice->CreateComputePipelineState(&desc, IID_PPV_ARGS(&d3dPipelineState))); } ComputePipeline *ComputePipeline::create(GraphicsContext *graphicsContext, ComputeShaderModule *cs) { D3DComputePipeline *d3dComputePipeline = new D3DComputePipeline(); std::vector<CD3DX12_ROOT_PARAMETER1> d3dRootParams; std::vector<D3D12_STATIC_SAMPLER_DESC> d3dSamplers; std::vector<std::unique_ptr<CD3DX12_DESCRIPTOR_RANGE1>> d3dDescriptorRanges; auto &descriptorBindings = d3dComputePipeline->descriptorBindings; uint32_t numDescriptors = uint32_t(cs->descriptors.size()); std::map<uint32_t, ShaderModule::DescriptorInfo> descriptors; for (auto &csDescriptor : cs->descriptors) descriptors[csDescriptor.set] = csDescriptor; descriptorBindings.resize(numDescriptors); D3DPipelineUtil::parseDescriptors(descriptors, descriptorBindings, d3dRootParams, d3dDescriptorRanges, D3DPipelineUtil::PIPELINE_TYPE_COMPUTE); d3dComputePipeline->create(d3d(graphicsContext), d3dRootParams, d3d(cs)->d3dShaderByteCode); return d3dComputePipeline; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DComputePipeline.cpp"},{"location":"api/Files/D3DComputePipeline_8cpp/#srcngfxportingd3dd3dcomputepipelinecpp","text":"","title":"src/ngfx/porting/d3d/D3DComputePipeline.cpp"},{"location":"api/Files/D3DComputePipeline_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DComputePipeline.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DShaderModule.h\" using namespace ngfx; void D3DComputePipeline::create( D3DGraphicsContext *ctx, const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, D3D12_SHADER_BYTECODE shaderByteCode) { D3DPipeline::create(ctx); HRESULT hResult; auto d3dDevice = ctx->d3dDevice.v; createRootSignature(rootParameters); D3D12_COMPUTE_PIPELINE_STATE_DESC desc = {}; desc.pRootSignature = d3dRootSignature.Get(); desc.CS.pShaderBytecode = shaderByteCode.pShaderBytecode; desc.CS.BytecodeLength = shaderByteCode.BytecodeLength; V(d3dDevice->CreateComputePipelineState(&desc, IID_PPV_ARGS(&d3dPipelineState))); } ComputePipeline *ComputePipeline::create(GraphicsContext *graphicsContext, ComputeShaderModule *cs) { D3DComputePipeline *d3dComputePipeline = new D3DComputePipeline(); std::vector<CD3DX12_ROOT_PARAMETER1> d3dRootParams; std::vector<D3D12_STATIC_SAMPLER_DESC> d3dSamplers; std::vector<std::unique_ptr<CD3DX12_DESCRIPTOR_RANGE1>> d3dDescriptorRanges; auto &descriptorBindings = d3dComputePipeline->descriptorBindings; uint32_t numDescriptors = uint32_t(cs->descriptors.size()); std::map<uint32_t, ShaderModule::DescriptorInfo> descriptors; for (auto &csDescriptor : cs->descriptors) descriptors[csDescriptor.set] = csDescriptor; descriptorBindings.resize(numDescriptors); D3DPipelineUtil::parseDescriptors(descriptors, descriptorBindings, d3dRootParams, d3dDescriptorRanges, D3DPipelineUtil::PIPELINE_TYPE_COMPUTE); d3dComputePipeline->create(d3d(graphicsContext), d3dRootParams, d3d(cs)->d3dShaderByteCode); return d3dComputePipeline; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DComputePipeline_8h/","text":"src/ngfx/porting/d3d/D3DComputePipeline.h Namespaces Name ngfx Classes Name class ngfx::D3DComputePipeline Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DPipeline.h\" namespace ngfx { class D3DComputePipeline : public ComputePipeline, public D3DPipeline { public: void create(D3DGraphicsContext *ctx, const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, D3D12_SHADER_BYTECODE shaderByteCode); ComPtr<ID3D12PipelineState> d3dPipelineState; }; D3D_CAST(ComputePipeline); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DComputePipeline.h"},{"location":"api/Files/D3DComputePipeline_8h/#srcngfxportingd3dd3dcomputepipelineh","text":"","title":"src/ngfx/porting/d3d/D3DComputePipeline.h"},{"location":"api/Files/D3DComputePipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DComputePipeline_8h/#classes","text":"Name class ngfx::D3DComputePipeline","title":"Classes"},{"location":"api/Files/D3DComputePipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DPipeline.h\" namespace ngfx { class D3DComputePipeline : public ComputePipeline, public D3DPipeline { public: void create(D3DGraphicsContext *ctx, const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, D3D12_SHADER_BYTECODE shaderByteCode); ComPtr<ID3D12PipelineState> d3dPipelineState; }; D3D_CAST(ComputePipeline); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DDebugUtil_8h/","text":"src/ngfx/porting/d3d/D3DDebugUtil.h Attributes Name const bool D3D_ENABLE_TRACE const bool DEBUG_SHADERS Defines Name D3D_TRACE (func) V0 (func, fmt, ...) V (func) Attributes Documentation variable D3D_ENABLE_TRACE const bool D3D_ENABLE_TRACE = false; Trace all Direct3D calls to log output variable DEBUG_SHADERS const bool DEBUG_SHADERS = true; Macro Documentation define D3D_TRACE #define D3D_TRACE( func ) { \\ if (D3D_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ func; \\ } define V0 #define V0( func, fmt, ... ) { \\ if (D3D_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ hResult = func; \\ if (FAILED(hResult)) { \\ NGFX_ERR(\"%s failed: 0x%08X %s \" fmt, #func, hResult, \\ std::system_category().message(hResult).c_str(), \\ ##__VA_ARGS__); \\ } \\ } define V #define V( func ) V0(func, \"\") Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include <d3d12.h> #include <system_error> const bool D3D_ENABLE_TRACE = false; const bool DEBUG_SHADERS = true; #define D3D_TRACE(func) \\ { \\ if (D3D_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ func; \\ } #define V0(func, fmt, ...) \\ { \\ if (D3D_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ hResult = func; \\ if (FAILED(hResult)) { \\ NGFX_ERR(\"%s failed: 0x%08X %s \" fmt, #func, hResult, \\ std::system_category().message(hResult).c_str(), \\ ##__VA_ARGS__); \\ } \\ } #define V(func) V0(func, \"\") Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DDebugUtil.h"},{"location":"api/Files/D3DDebugUtil_8h/#srcngfxportingd3dd3ddebugutilh","text":"","title":"src/ngfx/porting/d3d/D3DDebugUtil.h"},{"location":"api/Files/D3DDebugUtil_8h/#attributes","text":"Name const bool D3D_ENABLE_TRACE const bool DEBUG_SHADERS","title":"Attributes"},{"location":"api/Files/D3DDebugUtil_8h/#defines","text":"Name D3D_TRACE (func) V0 (func, fmt, ...) V (func)","title":"Defines"},{"location":"api/Files/D3DDebugUtil_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/D3DDebugUtil_8h/#variable-d3d_enable_trace","text":"const bool D3D_ENABLE_TRACE = false; Trace all Direct3D calls to log output","title":"variable D3D_ENABLE_TRACE"},{"location":"api/Files/D3DDebugUtil_8h/#variable-debug_shaders","text":"const bool DEBUG_SHADERS = true;","title":"variable DEBUG_SHADERS"},{"location":"api/Files/D3DDebugUtil_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/D3DDebugUtil_8h/#define-d3d_trace","text":"#define D3D_TRACE( func ) { \\ if (D3D_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ func; \\ }","title":"define D3D_TRACE"},{"location":"api/Files/D3DDebugUtil_8h/#define-v0","text":"#define V0( func, fmt, ... ) { \\ if (D3D_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ hResult = func; \\ if (FAILED(hResult)) { \\ NGFX_ERR(\"%s failed: 0x%08X %s \" fmt, #func, hResult, \\ std::system_category().message(hResult).c_str(), \\ ##__VA_ARGS__); \\ } \\ }","title":"define V0"},{"location":"api/Files/D3DDebugUtil_8h/#define-v","text":"#define V( func ) V0(func, \"\")","title":"define V"},{"location":"api/Files/D3DDebugUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include <d3d12.h> #include <system_error> const bool D3D_ENABLE_TRACE = false; const bool DEBUG_SHADERS = true; #define D3D_TRACE(func) \\ { \\ if (D3D_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ func; \\ } #define V0(func, fmt, ...) \\ { \\ if (D3D_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ hResult = func; \\ if (FAILED(hResult)) { \\ NGFX_ERR(\"%s failed: 0x%08X %s \" fmt, #func, hResult, \\ std::system_category().message(hResult).c_str(), \\ ##__VA_ARGS__); \\ } \\ } #define V(func) V0(func, \"\") Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DDescriptorHandle_8cpp/","text":"src/ngfx/porting/d3d/D3DDescriptorHandle.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DDescriptorHandle.h\" using namespace ngfx; D3DDescriptorHandle::D3DDescriptorHandle(uint32_t descriptorSize) : descriptorSize(descriptorSize) {} D3DDescriptorHandle &D3DDescriptorHandle::operator++() { cpuHandle.ptr += descriptorSize; gpuHandle.ptr += descriptorSize; return *this; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DDescriptorHandle.cpp"},{"location":"api/Files/D3DDescriptorHandle_8cpp/#srcngfxportingd3dd3ddescriptorhandlecpp","text":"","title":"src/ngfx/porting/d3d/D3DDescriptorHandle.cpp"},{"location":"api/Files/D3DDescriptorHandle_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DDescriptorHandle.h\" using namespace ngfx; D3DDescriptorHandle::D3DDescriptorHandle(uint32_t descriptorSize) : descriptorSize(descriptorSize) {} D3DDescriptorHandle &D3DDescriptorHandle::operator++() { cpuHandle.ptr += descriptorSize; gpuHandle.ptr += descriptorSize; return *this; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DDescriptorHandle_8h/","text":"src/ngfx/porting/d3d/D3DDescriptorHandle.h Namespaces Name ngfx Classes Name class ngfx::D3DDescriptorHandle Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <d3dx12.h> namespace ngfx { class D3DDescriptorHandle { public: D3DDescriptorHandle() {} D3DDescriptorHandle(uint32_t descriptorSize); D3DDescriptorHandle &operator++(); D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle{}; D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle{}; uint32_t descriptorSize = 0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DDescriptorHandle.h"},{"location":"api/Files/D3DDescriptorHandle_8h/#srcngfxportingd3dd3ddescriptorhandleh","text":"","title":"src/ngfx/porting/d3d/D3DDescriptorHandle.h"},{"location":"api/Files/D3DDescriptorHandle_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DDescriptorHandle_8h/#classes","text":"Name class ngfx::D3DDescriptorHandle","title":"Classes"},{"location":"api/Files/D3DDescriptorHandle_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <d3dx12.h> namespace ngfx { class D3DDescriptorHandle { public: D3DDescriptorHandle() {} D3DDescriptorHandle(uint32_t descriptorSize); D3DDescriptorHandle &operator++(); D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle{}; D3D12_GPU_DESCRIPTOR_HANDLE gpuHandle{}; uint32_t descriptorSize = 0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DDescriptorHeap_8cpp/","text":"src/ngfx/porting/d3d/D3DDescriptorHeap.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DDescriptorHeap.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" using namespace ngfx; void D3DDescriptorHeap::create(ID3D12Device *d3dDevice, D3D12_DESCRIPTOR_HEAP_TYPE type, UINT maxDescriptors, D3D12_DESCRIPTOR_HEAP_FLAGS flags) { HRESULT hResult; this->type = type; this->maxDescriptors = maxDescriptors; D3D12_DESCRIPTOR_HEAP_DESC desc = {type, maxDescriptors, flags, 0}; V(d3dDevice->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&v))); D3D_TRACE(handle.cpuHandle = v->GetCPUDescriptorHandleForHeapStart()); D3D_TRACE(handle.descriptorSize = d3dDevice->GetDescriptorHandleIncrementSize(type)); D3D_TRACE(handle.gpuHandle = v->GetGPUDescriptorHandleForHeapStart()); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DDescriptorHeap.cpp"},{"location":"api/Files/D3DDescriptorHeap_8cpp/#srcngfxportingd3dd3ddescriptorheapcpp","text":"","title":"src/ngfx/porting/d3d/D3DDescriptorHeap.cpp"},{"location":"api/Files/D3DDescriptorHeap_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DDescriptorHeap.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" using namespace ngfx; void D3DDescriptorHeap::create(ID3D12Device *d3dDevice, D3D12_DESCRIPTOR_HEAP_TYPE type, UINT maxDescriptors, D3D12_DESCRIPTOR_HEAP_FLAGS flags) { HRESULT hResult; this->type = type; this->maxDescriptors = maxDescriptors; D3D12_DESCRIPTOR_HEAP_DESC desc = {type, maxDescriptors, flags, 0}; V(d3dDevice->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&v))); D3D_TRACE(handle.cpuHandle = v->GetCPUDescriptorHandleForHeapStart()); D3D_TRACE(handle.descriptorSize = d3dDevice->GetDescriptorHandleIncrementSize(type)); D3D_TRACE(handle.gpuHandle = v->GetGPUDescriptorHandleForHeapStart()); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DDescriptorHeap_8h/","text":"src/ngfx/porting/d3d/D3DDescriptorHeap.h Namespaces Name ngfx Classes Name class ngfx::D3DDescriptorHeap Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/d3d/D3DDescriptorHandle.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DDescriptorHeap { public: void create(ID3D12Device *d3dDevice, D3D12_DESCRIPTOR_HEAP_TYPE type, UINT maxDescriptors, D3D12_DESCRIPTOR_HEAP_FLAGS flags); D3DDescriptorHandle handle; UINT maxDescriptors; D3D12_DESCRIPTOR_HEAP_TYPE type; ComPtr<ID3D12DescriptorHeap> v; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DDescriptorHeap.h"},{"location":"api/Files/D3DDescriptorHeap_8h/#srcngfxportingd3dd3ddescriptorheaph","text":"","title":"src/ngfx/porting/d3d/D3DDescriptorHeap.h"},{"location":"api/Files/D3DDescriptorHeap_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DDescriptorHeap_8h/#classes","text":"Name class ngfx::D3DDescriptorHeap","title":"Classes"},{"location":"api/Files/D3DDescriptorHeap_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/d3d/D3DDescriptorHandle.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DDescriptorHeap { public: void create(ID3D12Device *d3dDevice, D3D12_DESCRIPTOR_HEAP_TYPE type, UINT maxDescriptors, D3D12_DESCRIPTOR_HEAP_FLAGS flags); D3DDescriptorHandle handle; UINT maxDescriptors; D3D12_DESCRIPTOR_HEAP_TYPE type; ComPtr<ID3D12DescriptorHeap> v; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DDevice_8cpp/","text":"src/ngfx/porting/d3d/D3DDevice.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DDevice.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DFence.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" using namespace ngfx; void D3DDevice::create(D3DGraphicsContext *ctx) { this->ctx = ctx; HRESULT hResult; auto factory = ctx->d3dFactory.Get(); hardwareAdapter = nullptr; for (UINT adapterIndex = 0; DXGI_ERROR_NOT_FOUND != factory->EnumAdapters1(adapterIndex, &hardwareAdapter); adapterIndex++) { DXGI_ADAPTER_DESC1 desc; hardwareAdapter->GetDesc1(&desc); if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) continue; // Check to see if the adapter supports Direct3D 12 if (SUCCEEDED(D3D12CreateDevice(hardwareAdapter.Get(), D3D_FEATURE_LEVEL_11_0, _uuidof(ID3D12Device), nullptr))) break; } V(D3D12CreateDevice(hardwareAdapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&v))); } void D3DDevice::waitIdle() { ctx->d3dCommandQueue.waitIdle(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DDevice.cpp"},{"location":"api/Files/D3DDevice_8cpp/#srcngfxportingd3dd3ddevicecpp","text":"","title":"src/ngfx/porting/d3d/D3DDevice.cpp"},{"location":"api/Files/D3DDevice_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DDevice.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DFence.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" using namespace ngfx; void D3DDevice::create(D3DGraphicsContext *ctx) { this->ctx = ctx; HRESULT hResult; auto factory = ctx->d3dFactory.Get(); hardwareAdapter = nullptr; for (UINT adapterIndex = 0; DXGI_ERROR_NOT_FOUND != factory->EnumAdapters1(adapterIndex, &hardwareAdapter); adapterIndex++) { DXGI_ADAPTER_DESC1 desc; hardwareAdapter->GetDesc1(&desc); if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) continue; // Check to see if the adapter supports Direct3D 12 if (SUCCEEDED(D3D12CreateDevice(hardwareAdapter.Get(), D3D_FEATURE_LEVEL_11_0, _uuidof(ID3D12Device), nullptr))) break; } V(D3D12CreateDevice(hardwareAdapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&v))); } void D3DDevice::waitIdle() { ctx->d3dCommandQueue.waitIdle(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DDevice_8h/","text":"src/ngfx/porting/d3d/D3DDevice.h Namespaces Name ngfx Classes Name class ngfx::D3DDevice Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DGraphicsContext; class D3DDevice : public Device { public: void create(D3DGraphicsContext *ctx); void waitIdle(); ComPtr<IDXGIAdapter1> hardwareAdapter; ComPtr<ID3D12Device> v; private: D3DGraphicsContext *ctx; }; D3D_CAST(Device); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DDevice.h"},{"location":"api/Files/D3DDevice_8h/#srcngfxportingd3dd3ddeviceh","text":"","title":"src/ngfx/porting/d3d/D3DDevice.h"},{"location":"api/Files/D3DDevice_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DDevice_8h/#classes","text":"Name class ngfx::D3DDevice","title":"Classes"},{"location":"api/Files/D3DDevice_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DGraphicsContext; class D3DDevice : public Device { public: void create(D3DGraphicsContext *ctx); void waitIdle(); ComPtr<IDXGIAdapter1> hardwareAdapter; ComPtr<ID3D12Device> v; private: D3DGraphicsContext *ctx; }; D3D_CAST(Device); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DFence_8cpp/","text":"src/ngfx/porting/d3d/D3DFence.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DFence.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" using namespace ngfx; void D3DFence::create(ID3D12Device *device, Value initialValue) { HRESULT hResult; V(device->CreateFence(initialValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&v))); fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr); } void D3DFence::wait() { HRESULT hResult; if (v->GetCompletedValue() == SIGNALED) return; V(v->SetEventOnCompletion(SIGNALED, fenceEvent)); D3D_TRACE(WaitForSingleObjectEx(fenceEvent, INFINITE, FALSE)); } void D3DFence::reset() { HRESULT hResult; V(v->Signal(UNSIGNALED)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DFence.cpp"},{"location":"api/Files/D3DFence_8cpp/#srcngfxportingd3dd3dfencecpp","text":"","title":"src/ngfx/porting/d3d/D3DFence.cpp"},{"location":"api/Files/D3DFence_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DFence.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" using namespace ngfx; void D3DFence::create(ID3D12Device *device, Value initialValue) { HRESULT hResult; V(device->CreateFence(initialValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&v))); fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr); } void D3DFence::wait() { HRESULT hResult; if (v->GetCompletedValue() == SIGNALED) return; V(v->SetEventOnCompletion(SIGNALED, fenceEvent)); D3D_TRACE(WaitForSingleObjectEx(fenceEvent, INFINITE, FALSE)); } void D3DFence::reset() { HRESULT hResult; V(v->Signal(UNSIGNALED)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DFence_8h/","text":"src/ngfx/porting/d3d/D3DFence.h Namespaces Name ngfx Classes Name class ngfx::D3DFence Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Fence.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DFence : public Fence { public: enum Value { UNSIGNALED, SIGNALED }; void create(ID3D12Device *device, Value initialValue = UNSIGNALED); virtual ~D3DFence() {} void wait() override; void reset() override; ComPtr<ID3D12Fence> v; HANDLE fenceEvent; private: ID3D12Device *device; }; D3D_CAST(Fence); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DFence.h"},{"location":"api/Files/D3DFence_8h/#srcngfxportingd3dd3dfenceh","text":"","title":"src/ngfx/porting/d3d/D3DFence.h"},{"location":"api/Files/D3DFence_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DFence_8h/#classes","text":"Name class ngfx::D3DFence","title":"Classes"},{"location":"api/Files/D3DFence_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Fence.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DFence : public Fence { public: enum Value { UNSIGNALED, SIGNALED }; void create(ID3D12Device *device, Value initialValue = UNSIGNALED); virtual ~D3DFence() {} void wait() override; void reset() override; ComPtr<ID3D12Fence> v; HANDLE fenceEvent; private: ID3D12Device *device; }; D3D_CAST(Fence); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DFramebuffer_8cpp/","text":"src/ngfx/porting/d3d/D3DFramebuffer.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DFramebuffer.h\" #include \"ngfx/porting/d3d/D3DTexture.h\" using namespace ngfx; void D3DFramebuffer::create(std::vector<D3DAttachment> &d3dAttachments, int32_t w, uint32_t h, uint32_t layers) { this->d3dAttachments = d3dAttachments; this->numAttachments = uint32_t(d3dAttachments.size()); this->w = w; this->h = h; auto it = this->d3dAttachments.begin(); while (it != this->d3dAttachments.end()) { if (it->imageUsageFlags & IMAGE_USAGE_COLOR_ATTACHMENT_BIT) { if (it->numSamples > 1) { colorAttachments.push_back(&(*it++)); resolveAttachments.push_back(&(*it++)); } else { colorAttachments.push_back(&(*it++)); } } else if (it->imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) { if (it->numSamples > 1) { depthStencilAttachment = &(*it++); if (it != this->d3dAttachments.end()) depthResolve = &(*it++); } else { depthStencilAttachment = &(*it++); } } } } Framebuffer *Framebuffer::create(Device *device, RenderPass *renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers) { D3DFramebuffer *d3dFramebuffer = new D3DFramebuffer(); d3dFramebuffer->attachments = attachments; std::vector<D3DFramebuffer::D3DAttachment> d3dAttachments(attachments.size()); for (uint32_t j = 0; j < attachments.size(); j++) { auto &attachment = attachments[j]; auto &d3dAttachment = d3dAttachments[j]; auto d3dTexture = d3d(attachment.texture); bool depthStencilAttachment = d3dTexture->imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT; d3dAttachment = { d3dTexture->v.Get(), depthStencilAttachment ? d3dTexture->dsvDescriptor.cpuHandle : d3dTexture ->getRtvDescriptor(attachment.level, attachment.layer, layers) .cpuHandle, attachment.layer * d3dTexture->mipLevels + attachment.level, d3dTexture->imageUsageFlags, d3dTexture->numSamples, DXGI_FORMAT(d3dTexture->format), d3dTexture}; } d3dFramebuffer->create(d3dAttachments, w, h, layers); return d3dFramebuffer; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DFramebuffer.cpp"},{"location":"api/Files/D3DFramebuffer_8cpp/#srcngfxportingd3dd3dframebuffercpp","text":"","title":"src/ngfx/porting/d3d/D3DFramebuffer.cpp"},{"location":"api/Files/D3DFramebuffer_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DFramebuffer.h\" #include \"ngfx/porting/d3d/D3DTexture.h\" using namespace ngfx; void D3DFramebuffer::create(std::vector<D3DAttachment> &d3dAttachments, int32_t w, uint32_t h, uint32_t layers) { this->d3dAttachments = d3dAttachments; this->numAttachments = uint32_t(d3dAttachments.size()); this->w = w; this->h = h; auto it = this->d3dAttachments.begin(); while (it != this->d3dAttachments.end()) { if (it->imageUsageFlags & IMAGE_USAGE_COLOR_ATTACHMENT_BIT) { if (it->numSamples > 1) { colorAttachments.push_back(&(*it++)); resolveAttachments.push_back(&(*it++)); } else { colorAttachments.push_back(&(*it++)); } } else if (it->imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) { if (it->numSamples > 1) { depthStencilAttachment = &(*it++); if (it != this->d3dAttachments.end()) depthResolve = &(*it++); } else { depthStencilAttachment = &(*it++); } } } } Framebuffer *Framebuffer::create(Device *device, RenderPass *renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers) { D3DFramebuffer *d3dFramebuffer = new D3DFramebuffer(); d3dFramebuffer->attachments = attachments; std::vector<D3DFramebuffer::D3DAttachment> d3dAttachments(attachments.size()); for (uint32_t j = 0; j < attachments.size(); j++) { auto &attachment = attachments[j]; auto &d3dAttachment = d3dAttachments[j]; auto d3dTexture = d3d(attachment.texture); bool depthStencilAttachment = d3dTexture->imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT; d3dAttachment = { d3dTexture->v.Get(), depthStencilAttachment ? d3dTexture->dsvDescriptor.cpuHandle : d3dTexture ->getRtvDescriptor(attachment.level, attachment.layer, layers) .cpuHandle, attachment.layer * d3dTexture->mipLevels + attachment.level, d3dTexture->imageUsageFlags, d3dTexture->numSamples, DXGI_FORMAT(d3dTexture->format), d3dTexture}; } d3dFramebuffer->create(d3dAttachments, w, h, layers); return d3dFramebuffer; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DFramebuffer_8h/","text":"src/ngfx/porting/d3d/D3DFramebuffer.h Namespaces Name ngfx Classes Name class ngfx::D3DFramebuffer struct ngfx::D3DFramebuffer::D3DAttachment Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DTexture; class D3DFramebuffer : public Framebuffer { public: struct D3DAttachment { ID3D12Resource *resource; D3D12_CPU_DESCRIPTOR_HANDLE cpuDescriptor; uint32_t subresourceIndex = 0; uint32_t imageUsageFlags = 0; uint32_t numSamples = 1; DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN; D3DTexture *texture = nullptr; }; void create(std::vector<D3DAttachment> &attachments, int32_t w, uint32_t h, uint32_t layers = 1); virtual ~D3DFramebuffer() {} std::vector<D3DAttachment> d3dAttachments; std::vector<D3DAttachment *> colorAttachments, resolveAttachments; D3DAttachment *depthStencilAttachment = nullptr, *depthResolve = nullptr; }; D3D_CAST(Framebuffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DFramebuffer.h"},{"location":"api/Files/D3DFramebuffer_8h/#srcngfxportingd3dd3dframebufferh","text":"","title":"src/ngfx/porting/d3d/D3DFramebuffer.h"},{"location":"api/Files/D3DFramebuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DFramebuffer_8h/#classes","text":"Name class ngfx::D3DFramebuffer struct ngfx::D3DFramebuffer::D3DAttachment","title":"Classes"},{"location":"api/Files/D3DFramebuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DTexture; class D3DFramebuffer : public Framebuffer { public: struct D3DAttachment { ID3D12Resource *resource; D3D12_CPU_DESCRIPTOR_HANDLE cpuDescriptor; uint32_t subresourceIndex = 0; uint32_t imageUsageFlags = 0; uint32_t numSamples = 1; DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN; D3DTexture *texture = nullptr; }; void create(std::vector<D3DAttachment> &attachments, int32_t w, uint32_t h, uint32_t layers = 1); virtual ~D3DFramebuffer() {} std::vector<D3DAttachment> d3dAttachments; std::vector<D3DAttachment *> colorAttachments, resolveAttachments; D3DAttachment *depthStencilAttachment = nullptr, *depthResolve = nullptr; }; D3D_CAST(Framebuffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DGraphicsContext_8cpp/","text":"src/ngfx/porting/d3d/D3DGraphicsContext.cpp Defines Name MAX_DESCRIPTORS Macro Documentation define MAX_DESCRIPTORS #define MAX_DESCRIPTORS 1024 Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include <dxgi1_4.h> #include <wrl.h> using namespace ngfx; using namespace std; using Microsoft::WRL::ComPtr; #define MAX_DESCRIPTORS 1024 void D3DGraphicsContext::create(const char *appName, bool enableDepthStencil, bool debug) { HRESULT hResult; this->debug = debug; this->enableDepthStencil = enableDepthStencil; depthFormat = PIXELFORMAT_D16_UNORM; UINT dxgiFactoryFlags = 0; if (debug) { ComPtr<ID3D12Debug> debugController; V(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController))); debugController->EnableDebugLayer(); // Enable additional debug layers. dxgiFactoryFlags |= DXGI_CREATE_FACTORY_DEBUG; } V(CreateDXGIFactory2(dxgiFactoryFlags, IID_PPV_ARGS(&d3dFactory))); d3dDevice.create(this); d3dCommandQueue.create(this); createDescriptorHeaps(); } void D3DGraphicsContext::createDescriptorHeaps() { d3dRtvDescriptorHeap.create(d3dDevice.v.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_RTV, MAX_DESCRIPTORS, D3D12_DESCRIPTOR_HEAP_FLAG_NONE); d3dCbvSrvUavDescriptorHeap.create( d3dDevice.v.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, MAX_DESCRIPTORS * 3, D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE); d3dSamplerDescriptorHeap.create( d3dDevice.v.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER, MAX_DESCRIPTORS, D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE); d3dDsvDescriptorHeap.create(d3dDevice.v.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_DSV, MAX_DESCRIPTORS, D3D12_DESCRIPTOR_HEAP_FLAG_NONE); } void D3DGraphicsContext::setSurface(Surface *surface) { defaultOffscreenSurfaceFormat = PIXELFORMAT_RGBA8_UNORM; if (surface && !surface->offscreen) { offscreen = false; d3dSwapchain.create(this, d3d(surface)); surfaceFormat = PixelFormat(DXGI_FORMAT_R8G8B8A8_UNORM); numDrawCommandBuffers = d3dSwapchain.numImages; } else { offscreen = true; numDrawCommandBuffers = 1; surfaceFormat = defaultOffscreenSurfaceFormat; } d3dDrawCommandLists.resize(numDrawCommandBuffers); for (auto &cmdList : d3dDrawCommandLists) { cmdList.create(d3dDevice.v.Get()); } d3dCopyCommandList.create(d3dDevice.v.Get()); d3dComputeCommandList.create(d3dDevice.v.Get()); if (surface && numSamples != 1) { NGFX_TODO(\"\"); } if (surface && enableDepthStencil) { d3dDepthStencilView.reset((D3DTexture *)Texture::create( this, nullptr, nullptr, depthFormat, surface->w * surface->h * 4, surface->w, surface->h, 1, 1, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)); if (numSamples != 1) { NGFX_TODO(\"\"); } } std::optional<AttachmentDescription> depthAttachmentDescription; if (enableDepthStencil) depthAttachmentDescription = {depthFormat}; else depthAttachmentDescription = nullopt; if (surface && !surface->offscreen) { RenderPassConfig onscreenRenderPassConfig = { {{surfaceFormat, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_PRESENT_SRC}}, depthAttachmentDescription, false, numSamples}; d3dDefaultRenderPass = (D3DRenderPass *)getRenderPass(onscreenRenderPassConfig); } defaultOffscreenSurfaceFormat = PIXELFORMAT_RGBA8_UNORM; RenderPassConfig offscreenRenderPassConfig = { {{defaultOffscreenSurfaceFormat}}, depthAttachmentDescription, false, numSamples}; d3dDefaultOffscreenRenderPass = (D3DRenderPass *)getRenderPass(offscreenRenderPassConfig); if (surface && !surface->offscreen) { createSwapchainFramebuffers(surface->w, surface->h); } // initSemaphores(vkDevice.v); createFences(d3dDevice.v.Get()); createBindings(); } RenderPass *D3DGraphicsContext::getRenderPass(RenderPassConfig config) { for (auto &r : d3dRenderPassCache) { if (r->config == config) return &r->d3dRenderPass; } auto renderPassData = make_unique<D3DRenderPassData>(); createRenderPass(config, renderPassData->d3dRenderPass); auto result = &renderPassData->d3dRenderPass; d3dRenderPassCache.emplace_back(std::move(renderPassData)); return result; } void D3DGraphicsContext::createRenderPass(const RenderPassConfig &config, D3DRenderPass &renderPass) { D3D12_RESOURCE_STATES initialResourceState = D3D12_RESOURCE_STATE_RENDER_TARGET, finalResourceState = (config.colorAttachmentDescriptions[0].finalLayout == IMAGE_LAYOUT_PRESENT_SRC) ? D3D12_RESOURCE_STATE_PRESENT : D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE; renderPass.create(this, initialResourceState, finalResourceState); } void D3DGraphicsContext::createFences(ID3D12Device *device) { d3dWaitFences.resize(numDrawCommandBuffers); for (auto &fence : d3dWaitFences) { fence.create(device, D3DFence::SIGNALED); } d3dComputeFence.create(device); } void D3DGraphicsContext::createSwapchainFramebuffers(int w, int h) { // Create frame buffers for every swap chain image d3dSwapchainFramebuffers.resize(d3dSwapchain.numImages); for (uint32_t i = 0; i < d3dSwapchainFramebuffers.size(); i++) { // TODO: add support for MSAA std::vector<D3DFramebuffer::D3DAttachment> attachments = { {d3dSwapchain.renderTargets[i].Get(), d3dSwapchain.renderTargetDescriptors[i].cpuHandle, 0, IMAGE_USAGE_COLOR_ATTACHMENT_BIT, 1, DXGI_FORMAT(surfaceFormat), nullptr}}; if (enableDepthStencil) { attachments.push_back({d3dDepthStencilView->v.Get(), d3dDepthStencilView->dsvDescriptor.cpuHandle, 0, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, 1, DXGI_FORMAT(depthFormat), d3dDepthStencilView.get()}); } d3dSwapchainFramebuffers[i].create(attachments, w, h); } } CommandBuffer *D3DGraphicsContext::drawCommandBuffer(int32_t index) { if (index == -1) index = currentImageIndex; return &d3dDrawCommandLists[index]; } CommandBuffer *D3DGraphicsContext::copyCommandBuffer() { return &d3dCopyCommandList; } CommandBuffer *D3DGraphicsContext::computeCommandBuffer() { return &d3dComputeCommandList; } void D3DGraphicsContext::createBindings() { device = &d3dDevice; queue = &d3dCommandQueue; defaultRenderPass = offscreen ? d3dDefaultOffscreenRenderPass : d3dDefaultRenderPass; defaultOffscreenRenderPass = d3dDefaultOffscreenRenderPass; swapchain = &d3dSwapchain; frameFences.resize(d3dWaitFences.size()); for (int j = 0; j < d3dWaitFences.size(); j++) frameFences[j] = &d3dWaitFences[j]; swapchainFramebuffers.resize(d3dSwapchainFramebuffers.size()); for (int j = 0; j < d3dSwapchainFramebuffers.size(); j++) swapchainFramebuffers[j] = &d3dSwapchainFramebuffers[j]; pipelineCache = &d3dPipelineCache; } GraphicsContext *GraphicsContext::create(const char *appName, bool enableDepthStencil, bool debug) { NGFX_LOG(\"debug: %s\", (debug) ? \"true\" : \"false\"); auto d3dGraphicsContext = new D3DGraphicsContext(); d3dGraphicsContext->create(appName, enableDepthStencil, debug); return d3dGraphicsContext; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DGraphicsContext.cpp"},{"location":"api/Files/D3DGraphicsContext_8cpp/#srcngfxportingd3dd3dgraphicscontextcpp","text":"","title":"src/ngfx/porting/d3d/D3DGraphicsContext.cpp"},{"location":"api/Files/D3DGraphicsContext_8cpp/#defines","text":"Name MAX_DESCRIPTORS","title":"Defines"},{"location":"api/Files/D3DGraphicsContext_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/D3DGraphicsContext_8cpp/#define-max_descriptors","text":"#define MAX_DESCRIPTORS 1024","title":"define MAX_DESCRIPTORS"},{"location":"api/Files/D3DGraphicsContext_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include <dxgi1_4.h> #include <wrl.h> using namespace ngfx; using namespace std; using Microsoft::WRL::ComPtr; #define MAX_DESCRIPTORS 1024 void D3DGraphicsContext::create(const char *appName, bool enableDepthStencil, bool debug) { HRESULT hResult; this->debug = debug; this->enableDepthStencil = enableDepthStencil; depthFormat = PIXELFORMAT_D16_UNORM; UINT dxgiFactoryFlags = 0; if (debug) { ComPtr<ID3D12Debug> debugController; V(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController))); debugController->EnableDebugLayer(); // Enable additional debug layers. dxgiFactoryFlags |= DXGI_CREATE_FACTORY_DEBUG; } V(CreateDXGIFactory2(dxgiFactoryFlags, IID_PPV_ARGS(&d3dFactory))); d3dDevice.create(this); d3dCommandQueue.create(this); createDescriptorHeaps(); } void D3DGraphicsContext::createDescriptorHeaps() { d3dRtvDescriptorHeap.create(d3dDevice.v.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_RTV, MAX_DESCRIPTORS, D3D12_DESCRIPTOR_HEAP_FLAG_NONE); d3dCbvSrvUavDescriptorHeap.create( d3dDevice.v.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, MAX_DESCRIPTORS * 3, D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE); d3dSamplerDescriptorHeap.create( d3dDevice.v.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER, MAX_DESCRIPTORS, D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE); d3dDsvDescriptorHeap.create(d3dDevice.v.Get(), D3D12_DESCRIPTOR_HEAP_TYPE_DSV, MAX_DESCRIPTORS, D3D12_DESCRIPTOR_HEAP_FLAG_NONE); } void D3DGraphicsContext::setSurface(Surface *surface) { defaultOffscreenSurfaceFormat = PIXELFORMAT_RGBA8_UNORM; if (surface && !surface->offscreen) { offscreen = false; d3dSwapchain.create(this, d3d(surface)); surfaceFormat = PixelFormat(DXGI_FORMAT_R8G8B8A8_UNORM); numDrawCommandBuffers = d3dSwapchain.numImages; } else { offscreen = true; numDrawCommandBuffers = 1; surfaceFormat = defaultOffscreenSurfaceFormat; } d3dDrawCommandLists.resize(numDrawCommandBuffers); for (auto &cmdList : d3dDrawCommandLists) { cmdList.create(d3dDevice.v.Get()); } d3dCopyCommandList.create(d3dDevice.v.Get()); d3dComputeCommandList.create(d3dDevice.v.Get()); if (surface && numSamples != 1) { NGFX_TODO(\"\"); } if (surface && enableDepthStencil) { d3dDepthStencilView.reset((D3DTexture *)Texture::create( this, nullptr, nullptr, depthFormat, surface->w * surface->h * 4, surface->w, surface->h, 1, 1, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)); if (numSamples != 1) { NGFX_TODO(\"\"); } } std::optional<AttachmentDescription> depthAttachmentDescription; if (enableDepthStencil) depthAttachmentDescription = {depthFormat}; else depthAttachmentDescription = nullopt; if (surface && !surface->offscreen) { RenderPassConfig onscreenRenderPassConfig = { {{surfaceFormat, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_PRESENT_SRC}}, depthAttachmentDescription, false, numSamples}; d3dDefaultRenderPass = (D3DRenderPass *)getRenderPass(onscreenRenderPassConfig); } defaultOffscreenSurfaceFormat = PIXELFORMAT_RGBA8_UNORM; RenderPassConfig offscreenRenderPassConfig = { {{defaultOffscreenSurfaceFormat}}, depthAttachmentDescription, false, numSamples}; d3dDefaultOffscreenRenderPass = (D3DRenderPass *)getRenderPass(offscreenRenderPassConfig); if (surface && !surface->offscreen) { createSwapchainFramebuffers(surface->w, surface->h); } // initSemaphores(vkDevice.v); createFences(d3dDevice.v.Get()); createBindings(); } RenderPass *D3DGraphicsContext::getRenderPass(RenderPassConfig config) { for (auto &r : d3dRenderPassCache) { if (r->config == config) return &r->d3dRenderPass; } auto renderPassData = make_unique<D3DRenderPassData>(); createRenderPass(config, renderPassData->d3dRenderPass); auto result = &renderPassData->d3dRenderPass; d3dRenderPassCache.emplace_back(std::move(renderPassData)); return result; } void D3DGraphicsContext::createRenderPass(const RenderPassConfig &config, D3DRenderPass &renderPass) { D3D12_RESOURCE_STATES initialResourceState = D3D12_RESOURCE_STATE_RENDER_TARGET, finalResourceState = (config.colorAttachmentDescriptions[0].finalLayout == IMAGE_LAYOUT_PRESENT_SRC) ? D3D12_RESOURCE_STATE_PRESENT : D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE; renderPass.create(this, initialResourceState, finalResourceState); } void D3DGraphicsContext::createFences(ID3D12Device *device) { d3dWaitFences.resize(numDrawCommandBuffers); for (auto &fence : d3dWaitFences) { fence.create(device, D3DFence::SIGNALED); } d3dComputeFence.create(device); } void D3DGraphicsContext::createSwapchainFramebuffers(int w, int h) { // Create frame buffers for every swap chain image d3dSwapchainFramebuffers.resize(d3dSwapchain.numImages); for (uint32_t i = 0; i < d3dSwapchainFramebuffers.size(); i++) { // TODO: add support for MSAA std::vector<D3DFramebuffer::D3DAttachment> attachments = { {d3dSwapchain.renderTargets[i].Get(), d3dSwapchain.renderTargetDescriptors[i].cpuHandle, 0, IMAGE_USAGE_COLOR_ATTACHMENT_BIT, 1, DXGI_FORMAT(surfaceFormat), nullptr}}; if (enableDepthStencil) { attachments.push_back({d3dDepthStencilView->v.Get(), d3dDepthStencilView->dsvDescriptor.cpuHandle, 0, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, 1, DXGI_FORMAT(depthFormat), d3dDepthStencilView.get()}); } d3dSwapchainFramebuffers[i].create(attachments, w, h); } } CommandBuffer *D3DGraphicsContext::drawCommandBuffer(int32_t index) { if (index == -1) index = currentImageIndex; return &d3dDrawCommandLists[index]; } CommandBuffer *D3DGraphicsContext::copyCommandBuffer() { return &d3dCopyCommandList; } CommandBuffer *D3DGraphicsContext::computeCommandBuffer() { return &d3dComputeCommandList; } void D3DGraphicsContext::createBindings() { device = &d3dDevice; queue = &d3dCommandQueue; defaultRenderPass = offscreen ? d3dDefaultOffscreenRenderPass : d3dDefaultRenderPass; defaultOffscreenRenderPass = d3dDefaultOffscreenRenderPass; swapchain = &d3dSwapchain; frameFences.resize(d3dWaitFences.size()); for (int j = 0; j < d3dWaitFences.size(); j++) frameFences[j] = &d3dWaitFences[j]; swapchainFramebuffers.resize(d3dSwapchainFramebuffers.size()); for (int j = 0; j < d3dSwapchainFramebuffers.size(); j++) swapchainFramebuffers[j] = &d3dSwapchainFramebuffers[j]; pipelineCache = &d3dPipelineCache; } GraphicsContext *GraphicsContext::create(const char *appName, bool enableDepthStencil, bool debug) { NGFX_LOG(\"debug: %s\", (debug) ? \"true\" : \"false\"); auto d3dGraphicsContext = new D3DGraphicsContext(); d3dGraphicsContext->create(appName, enableDepthStencil, debug); return d3dGraphicsContext; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DGraphicsContext_8h/","text":"src/ngfx/porting/d3d/D3DGraphicsContext.h Namespaces Name ngfx Classes Name class ngfx::D3DGraphicsContext struct ngfx::D3DGraphicsContext::D3DRenderPassData Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DCommandQueue.h\" #include \"ngfx/porting/d3d/D3DComputePass.h\" #include \"ngfx/porting/d3d/D3DDescriptorHeap.h\" #include \"ngfx/porting/d3d/D3DDevice.h\" #include \"ngfx/porting/d3d/D3DFence.h\" #include \"ngfx/porting/d3d/D3DFramebuffer.h\" #include \"ngfx/porting/d3d/D3DPipelineCache.h\" #include \"ngfx/porting/d3d/D3DRenderPass.h\" #include \"ngfx/porting/d3d/D3DSwapchain.h\" #include \"ngfx/porting/d3d/D3DTexture.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" #include <memory> namespace ngfx { class D3DGraphicsContext : public GraphicsContext { public: void create(const char *appName, bool enableDepthStencil, bool debug); virtual ~D3DGraphicsContext() {} void setSurface(Surface *surface) override; CommandBuffer *drawCommandBuffer(int32_t index = -1) override; CommandBuffer *copyCommandBuffer() override; CommandBuffer *computeCommandBuffer() override; struct D3DRenderPassData { RenderPassConfig config; D3DRenderPass d3dRenderPass; }; RenderPass *getRenderPass(RenderPassConfig config) override; std::vector<std::unique_ptr<D3DRenderPassData>> d3dRenderPassCache; ComPtr<IDXGIFactory4> d3dFactory; D3DDevice d3dDevice; D3DCommandQueue d3dCommandQueue; D3DDescriptorHeap d3dRtvDescriptorHeap, d3dCbvSrvUavDescriptorHeap, d3dSamplerDescriptorHeap, d3dDsvDescriptorHeap; D3DPipelineCache d3dPipelineCache; D3DSwapchain d3dSwapchain; std::vector<D3DCommandList> d3dDrawCommandLists; D3DCommandList d3dCopyCommandList, d3dComputeCommandList; D3DRenderPass *d3dDefaultRenderPass = nullptr, *d3dDefaultOffscreenRenderPass = nullptr; std::vector<D3DFramebuffer> d3dSwapchainFramebuffers; std::vector<D3DFence> d3dWaitFences; D3DFence d3dComputeFence; D3DComputePass d3dComputePass; std::unique_ptr<D3DTexture> d3dDepthStencilView; bool offscreen = true; uint32_t numSamples = 1; private: void createBindings(); void createDescriptorHeaps(); void createRenderPass(const RenderPassConfig &config, D3DRenderPass &renderPass); void createFences(ID3D12Device *device); void createSwapchainFramebuffers(int w, int h); }; D3D_CAST(GraphicsContext); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DGraphicsContext.h"},{"location":"api/Files/D3DGraphicsContext_8h/#srcngfxportingd3dd3dgraphicscontexth","text":"","title":"src/ngfx/porting/d3d/D3DGraphicsContext.h"},{"location":"api/Files/D3DGraphicsContext_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DGraphicsContext_8h/#classes","text":"Name class ngfx::D3DGraphicsContext struct ngfx::D3DGraphicsContext::D3DRenderPassData","title":"Classes"},{"location":"api/Files/D3DGraphicsContext_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DCommandQueue.h\" #include \"ngfx/porting/d3d/D3DComputePass.h\" #include \"ngfx/porting/d3d/D3DDescriptorHeap.h\" #include \"ngfx/porting/d3d/D3DDevice.h\" #include \"ngfx/porting/d3d/D3DFence.h\" #include \"ngfx/porting/d3d/D3DFramebuffer.h\" #include \"ngfx/porting/d3d/D3DPipelineCache.h\" #include \"ngfx/porting/d3d/D3DRenderPass.h\" #include \"ngfx/porting/d3d/D3DSwapchain.h\" #include \"ngfx/porting/d3d/D3DTexture.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" #include <memory> namespace ngfx { class D3DGraphicsContext : public GraphicsContext { public: void create(const char *appName, bool enableDepthStencil, bool debug); virtual ~D3DGraphicsContext() {} void setSurface(Surface *surface) override; CommandBuffer *drawCommandBuffer(int32_t index = -1) override; CommandBuffer *copyCommandBuffer() override; CommandBuffer *computeCommandBuffer() override; struct D3DRenderPassData { RenderPassConfig config; D3DRenderPass d3dRenderPass; }; RenderPass *getRenderPass(RenderPassConfig config) override; std::vector<std::unique_ptr<D3DRenderPassData>> d3dRenderPassCache; ComPtr<IDXGIFactory4> d3dFactory; D3DDevice d3dDevice; D3DCommandQueue d3dCommandQueue; D3DDescriptorHeap d3dRtvDescriptorHeap, d3dCbvSrvUavDescriptorHeap, d3dSamplerDescriptorHeap, d3dDsvDescriptorHeap; D3DPipelineCache d3dPipelineCache; D3DSwapchain d3dSwapchain; std::vector<D3DCommandList> d3dDrawCommandLists; D3DCommandList d3dCopyCommandList, d3dComputeCommandList; D3DRenderPass *d3dDefaultRenderPass = nullptr, *d3dDefaultOffscreenRenderPass = nullptr; std::vector<D3DFramebuffer> d3dSwapchainFramebuffers; std::vector<D3DFence> d3dWaitFences; D3DFence d3dComputeFence; D3DComputePass d3dComputePass; std::unique_ptr<D3DTexture> d3dDepthStencilView; bool offscreen = true; uint32_t numSamples = 1; private: void createBindings(); void createDescriptorHeaps(); void createRenderPass(const RenderPassConfig &config, D3DRenderPass &renderPass); void createFences(ID3D12Device *device); void createSwapchainFramebuffers(int w, int h); }; D3D_CAST(GraphicsContext); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DGraphicsCore_8h/","text":"src/ngfx/porting/d3d/D3DGraphicsCore.h Namespaces Name ngfx Defines Name NOMINMAX DEFINE_PIXELFORMATS (s, t0, t1) DEFINE_VERTEXFORMATS (s, t0, t1) Macro Documentation define NOMINMAX #define NOMINMAX define DEFINE_PIXELFORMATS #define DEFINE_PIXELFORMATS( s, t0, t1 ) PIXELFORMAT_R##s##_##t0 = DXGI_FORMAT_R##s##_##t1, \\ PIXELFORMAT_RG##s##_##t0 = DXGI_FORMAT_R##s##G##s##_##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = DXGI_FORMAT_R##s##G##s##B##s##A##s##_##t1 define DEFINE_VERTEXFORMATS #define DEFINE_VERTEXFORMATS( s, t0, t1 ) VERTEXFORMAT_##t0 = DXGI_FORMAT_R##s##_##t1, \\ VERTEXFORMAT_##t0##2 = DXGI_FORMAT_R##s##G##s##_##t1, \\ VERTEXFORMAT_##t0##3 = DXGI_FORMAT_R##s##G##s##B##s##_##t1, \\ VERTEXFORMAT_##t0##4 = DXGI_FORMAT_R##s##G##s##B##s##A##s##_##t1 Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #define NOMINMAX #include <d3d12.h> namespace ngfx { enum PrimitiveTopology { PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP }; enum PolygonMode { POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME }; enum BlendFactor { BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR }; enum BufferUsageFlagBits { BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32 }; enum BlendOp { BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX }; enum ColorComponentFlagBits { COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA }; enum CommandBufferLevel { COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE }; enum CullModeFlags { CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK }; enum FrontFace { FRONT_FACE_COUNTER_CLOCKWISE, FRONT_FACE_CLOCKWISE }; enum TextureType { TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY }; enum ImageUsageFlagBits { IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, }; enum PipelineStageFlagBits { PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT }; enum ShaderStageFlagBits { SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF }; #define DEFINE_PIXELFORMATS(s, t0, t1) \\ PIXELFORMAT_R##s##_##t0 = DXGI_FORMAT_R##s##_##t1, \\ PIXELFORMAT_RG##s##_##t0 = DXGI_FORMAT_R##s##G##s##_##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = DXGI_FORMAT_R##s##G##s##B##s##A##s##_##t1 enum PixelFormat { PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS(8, UNORM, UNORM), DEFINE_PIXELFORMATS(16, UINT, UINT), DEFINE_PIXELFORMATS(16, SFLOAT, FLOAT), DEFINE_PIXELFORMATS(32, UINT, UINT), DEFINE_PIXELFORMATS(32, SFLOAT, FLOAT), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT }; enum IndexFormat { INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT }; #define DEFINE_VERTEXFORMATS(s, t0, t1) \\ VERTEXFORMAT_##t0 = DXGI_FORMAT_R##s##_##t1, \\ VERTEXFORMAT_##t0##2 = DXGI_FORMAT_R##s##G##s##_##t1, \\ VERTEXFORMAT_##t0##3 = DXGI_FORMAT_R##s##G##s##B##s##_##t1, \\ VERTEXFORMAT_##t0##4 = DXGI_FORMAT_R##s##G##s##B##s##A##s##_##t1 enum VertexFormat { DEFINE_VERTEXFORMATS(32, FLOAT, FLOAT) }; enum DescriptorType { DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER }; enum VertexInputRate { VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA }; enum FilterMode { FILTER_NEAREST, FILTER_LINEAR }; enum ImageLayout { IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DGraphicsCore.h"},{"location":"api/Files/D3DGraphicsCore_8h/#srcngfxportingd3dd3dgraphicscoreh","text":"","title":"src/ngfx/porting/d3d/D3DGraphicsCore.h"},{"location":"api/Files/D3DGraphicsCore_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DGraphicsCore_8h/#defines","text":"Name NOMINMAX DEFINE_PIXELFORMATS (s, t0, t1) DEFINE_VERTEXFORMATS (s, t0, t1)","title":"Defines"},{"location":"api/Files/D3DGraphicsCore_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/D3DGraphicsCore_8h/#define-nominmax","text":"#define NOMINMAX","title":"define NOMINMAX"},{"location":"api/Files/D3DGraphicsCore_8h/#define-define_pixelformats","text":"#define DEFINE_PIXELFORMATS( s, t0, t1 ) PIXELFORMAT_R##s##_##t0 = DXGI_FORMAT_R##s##_##t1, \\ PIXELFORMAT_RG##s##_##t0 = DXGI_FORMAT_R##s##G##s##_##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = DXGI_FORMAT_R##s##G##s##B##s##A##s##_##t1","title":"define DEFINE_PIXELFORMATS"},{"location":"api/Files/D3DGraphicsCore_8h/#define-define_vertexformats","text":"#define DEFINE_VERTEXFORMATS( s, t0, t1 ) VERTEXFORMAT_##t0 = DXGI_FORMAT_R##s##_##t1, \\ VERTEXFORMAT_##t0##2 = DXGI_FORMAT_R##s##G##s##_##t1, \\ VERTEXFORMAT_##t0##3 = DXGI_FORMAT_R##s##G##s##B##s##_##t1, \\ VERTEXFORMAT_##t0##4 = DXGI_FORMAT_R##s##G##s##B##s##A##s##_##t1","title":"define DEFINE_VERTEXFORMATS"},{"location":"api/Files/D3DGraphicsCore_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #define NOMINMAX #include <d3d12.h> namespace ngfx { enum PrimitiveTopology { PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP }; enum PolygonMode { POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME }; enum BlendFactor { BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR }; enum BufferUsageFlagBits { BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32 }; enum BlendOp { BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX }; enum ColorComponentFlagBits { COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA }; enum CommandBufferLevel { COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE }; enum CullModeFlags { CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK }; enum FrontFace { FRONT_FACE_COUNTER_CLOCKWISE, FRONT_FACE_CLOCKWISE }; enum TextureType { TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY }; enum ImageUsageFlagBits { IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, }; enum PipelineStageFlagBits { PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT }; enum ShaderStageFlagBits { SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF }; #define DEFINE_PIXELFORMATS(s, t0, t1) \\ PIXELFORMAT_R##s##_##t0 = DXGI_FORMAT_R##s##_##t1, \\ PIXELFORMAT_RG##s##_##t0 = DXGI_FORMAT_R##s##G##s##_##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = DXGI_FORMAT_R##s##G##s##B##s##A##s##_##t1 enum PixelFormat { PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS(8, UNORM, UNORM), DEFINE_PIXELFORMATS(16, UINT, UINT), DEFINE_PIXELFORMATS(16, SFLOAT, FLOAT), DEFINE_PIXELFORMATS(32, UINT, UINT), DEFINE_PIXELFORMATS(32, SFLOAT, FLOAT), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT }; enum IndexFormat { INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT }; #define DEFINE_VERTEXFORMATS(s, t0, t1) \\ VERTEXFORMAT_##t0 = DXGI_FORMAT_R##s##_##t1, \\ VERTEXFORMAT_##t0##2 = DXGI_FORMAT_R##s##G##s##_##t1, \\ VERTEXFORMAT_##t0##3 = DXGI_FORMAT_R##s##G##s##B##s##_##t1, \\ VERTEXFORMAT_##t0##4 = DXGI_FORMAT_R##s##G##s##B##s##A##s##_##t1 enum VertexFormat { DEFINE_VERTEXFORMATS(32, FLOAT, FLOAT) }; enum DescriptorType { DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER }; enum VertexInputRate { VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA }; enum FilterMode { FILTER_NEAREST, FILTER_LINEAR }; enum ImageLayout { IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DGraphicsPipeline_8cpp/","text":"src/ngfx/porting/d3d/D3DGraphicsPipeline.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DGraphicsPipeline.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DShaderModule.h\" #include <d3dx12.h> using namespace ngfx; using namespace std; D3D12_PRIMITIVE_TOPOLOGY_TYPE D3DGraphicsPipeline::getPrimitiveTopologyType(D3D_PRIMITIVE_TOPOLOGY topology) { switch (topology) { case D3D_PRIMITIVE_TOPOLOGY_LINELIST: case D3D_PRIMITIVE_TOPOLOGY_LINESTRIP: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE; break; case D3D_PRIMITIVE_TOPOLOGY_POINTLIST: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT; break; case D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST: case D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE; break; default: NGFX_ERR(\"topology: %d unsupported\", topology); return D3D12_PRIMITIVE_TOPOLOGY_TYPE_UNDEFINED; break; } } void D3DGraphicsPipeline::create( D3DGraphicsContext *ctx, const State &state, const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, const std::vector<D3D12_INPUT_ELEMENT_DESC> &inputElements, const Shaders &shaders, DXGI_FORMAT colorFormat, DXGI_FORMAT depthFormat) { D3DPipeline::create(ctx); HRESULT hResult; d3dPrimitiveTopology = state.primitiveTopology; auto d3dDevice = ctx->d3dDevice.v; createRootSignature( rootParameters, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT); D3D12_RASTERIZER_DESC rasterizerState = { state.fillMode, state.cullMode, state.frontFaceCounterClockwise, 0, 0.0f, 0.0f, state.depthTestEnable, FALSE, FALSE, 0, D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF}; D3D12_RENDER_TARGET_BLEND_DESC renderTargetBlendDesc = { state.blendEnable, FALSE, state.blendSrcColorFactor, state.blendDstColorFactor, state.blendColorOp, state.blendSrcAlphaFactor, state.blendDstAlphaFactor, state.blendAlphaOp, D3D12_LOGIC_OP_NOOP, state.colorWriteMask}; D3D12_BLEND_DESC blendDesc = {}; blendDesc.AlphaToCoverageEnable = FALSE; blendDesc.IndependentBlendEnable = FALSE; blendDesc.RenderTarget[0] = renderTargetBlendDesc; CD3DX12_DEPTH_STENCIL_DESC depthStencilDesc(D3D12_DEFAULT); depthStencilDesc.DepthEnable = state.depthTestEnable; D3D12_GRAPHICS_PIPELINE_STATE_DESC desc = {}; desc.InputLayout = {inputElements.data(), UINT(inputElements.size())}; desc.pRootSignature = d3dRootSignature.Get(); desc.VS = shaders.VS; desc.PS = shaders.PS; desc.GS = shaders.GS; desc.RasterizerState = rasterizerState; desc.BlendState = blendDesc; desc.DepthStencilState = depthStencilDesc; desc.DSVFormat = depthFormat; desc.SampleMask = UINT_MAX; desc.PrimitiveTopologyType = getPrimitiveTopologyType(state.primitiveTopology); desc.NumRenderTargets = state.numColorAttachments; for (uint32_t j = 0; j < desc.NumRenderTargets; j++) desc.RTVFormats[j] = colorFormat; desc.SampleDesc.Count = state.numSamples; V(d3dDevice->CreateGraphicsPipelineState(&desc, IID_PPV_ARGS(&d3dPipelineState))); } GraphicsPipeline * GraphicsPipeline::create(GraphicsContext *graphicsContext, const State &state, VertexShaderModule *vs, FragmentShaderModule *fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes) { D3DGraphicsPipeline *d3dGraphicsPipeline = new D3DGraphicsPipeline(); auto getAlphaBlendFactor = [](BlendFactor blendFactor) -> BlendFactor { switch (blendFactor) { case BLEND_FACTOR_SRC_COLOR: return BLEND_FACTOR_SRC_ALPHA; break; case BLEND_FACTOR_DST_COLOR: return BLEND_FACTOR_DST_ALPHA; break; case BLEND_FACTOR_ONE_MINUS_SRC_COLOR: return BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; break; case BLEND_FACTOR_ONE_MINUS_DST_COLOR: return BLEND_FACTOR_ONE_MINUS_DST_ALPHA; break; default: return blendFactor; break; }; }; struct State { D3D12_PRIMITIVE_TOPOLOGY primitiveTopology = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST; D3D12_FILL_MODE fillMode = D3D12_FILL_MODE_SOLID; bool blendEnable = false; D3D12_BLEND blendSrcColorFactor = D3D12_BLEND_SRC_ALPHA; D3D12_BLEND blendDstColorFactor = D3D12_BLEND_INV_SRC_ALPHA; D3D12_BLEND_OP blendColorOp = D3D12_BLEND_OP_ADD; D3D12_BLEND blendSrcAlphaFactor = D3D12_BLEND_SRC_ALPHA; D3D12_BLEND blendDstAlphaFactor = D3D12_BLEND_INV_SRC_ALPHA; D3D12_BLEND_OP blendAlphaOp = D3D12_BLEND_OP_ADD; D3D12_COLOR_WRITE_ENABLE colorWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; D3D12_CULL_MODE cullMode = D3D12_CULL_MODE_BACK; bool frontFaceCounterClockwise = false; float lineWidth = 1.0f; bool depthTestEnable = false, depthWriteEnable = false; D3DRenderPass *renderPass = nullptr; uint32_t numSamples = 1, numColorAttachments = 1; }; D3DGraphicsPipeline::State d3dState = { D3D_PRIMITIVE_TOPOLOGY(state.primitiveTopology), D3D12_FILL_MODE(state.polygonMode), state.blendEnable, D3D12_BLEND(state.srcColorBlendFactor), D3D12_BLEND(state.dstColorBlendFactor), D3D12_BLEND_OP(state.colorBlendOp), D3D12_BLEND(getAlphaBlendFactor(state.srcAlphaBlendFactor)), D3D12_BLEND(getAlphaBlendFactor(state.dstAlphaBlendFactor)), D3D12_BLEND_OP(state.alphaBlendOp), state.colorWriteMask, D3D12_CULL_MODE(state.cullModeFlags), (state.frontFace == FRONT_FACE_COUNTER_CLOCKWISE), state.lineWidth, state.depthTestEnable, state.depthWriteEnable, d3d(state.renderPass), state.numSamples, state.numColorAttachments}; auto &descriptorBindings = d3dGraphicsPipeline->descriptorBindings; std::vector<CD3DX12_ROOT_PARAMETER1> d3dRootParams; std::vector<std::unique_ptr<CD3DX12_DESCRIPTOR_RANGE1>> d3dDescriptorRanges; std::map<uint32_t, ShaderModule::DescriptorInfo> descriptors; for (auto &descriptor : vs->descriptors) descriptors[descriptor.set] = descriptor; for (auto &descriptor : fs->descriptors) descriptors[descriptor.set] = descriptor; uint32_t numDescriptors = uint32_t(descriptors.size()); descriptorBindings.resize(numDescriptors); D3DPipelineUtil::parseDescriptors(descriptors, descriptorBindings, d3dRootParams, d3dDescriptorRanges, D3DPipelineUtil::PIPELINE_TYPE_GRAPHICS); std::vector<D3D12_INPUT_ELEMENT_DESC> d3dVertexInputAttributes( vs->attributes.size()); auto &vertexAttributeBindings = d3dGraphicsPipeline->vertexAttributeBindings; vertexAttributeBindings.resize(vs->attributes.size()); struct SemanticData { string name; uint32_t index; }; std::vector<SemanticData> semanticData(vs->attributes.size()); for (int j = 0; j < vs->attributes.size(); j++) { const auto &va = vs->attributes[j]; uint32_t binding = va.location, offset = 0; // TODO: va.count D3D12_INPUT_CLASSIFICATION inputRate = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA; if (instanceAttributes.find(va.name) != instanceAttributes.end()) inputRate = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA; uint32_t semanticIndexOffset = uint32_t(va.semantic.find_first_of(\"0123456789\")); string &semanticName = semanticData[j].name; uint32_t &semanticIndex = semanticData[j].index; if (semanticIndexOffset != string::npos) { semanticName = va.semantic.substr(0, semanticIndexOffset); string semanticIndexStr = va.semantic.substr(semanticIndexOffset); semanticIndex = atoi(semanticIndexStr.c_str()); } else { semanticName = va.semantic; semanticIndex = 0; } d3dVertexInputAttributes[j] = { semanticName.c_str(), semanticIndex, DXGI_FORMAT(va.format), binding, offset, inputRate, (inputRate == D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA) ? UINT(0) : UINT(1)}; vertexAttributeBindings[j] = j; } D3DGraphicsPipeline::Shaders shaders; shaders.VS = d3d(vs)->d3dShaderByteCode; shaders.PS = d3d(fs)->d3dShaderByteCode; d3dGraphicsPipeline->create( d3d(graphicsContext), d3dState, d3dRootParams, d3dVertexInputAttributes, shaders, DXGI_FORMAT(colorFormat), DXGI_FORMAT(depthFormat)); return d3dGraphicsPipeline; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DGraphicsPipeline.cpp"},{"location":"api/Files/D3DGraphicsPipeline_8cpp/#srcngfxportingd3dd3dgraphicspipelinecpp","text":"","title":"src/ngfx/porting/d3d/D3DGraphicsPipeline.cpp"},{"location":"api/Files/D3DGraphicsPipeline_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DGraphicsPipeline.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DShaderModule.h\" #include <d3dx12.h> using namespace ngfx; using namespace std; D3D12_PRIMITIVE_TOPOLOGY_TYPE D3DGraphicsPipeline::getPrimitiveTopologyType(D3D_PRIMITIVE_TOPOLOGY topology) { switch (topology) { case D3D_PRIMITIVE_TOPOLOGY_LINELIST: case D3D_PRIMITIVE_TOPOLOGY_LINESTRIP: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE; break; case D3D_PRIMITIVE_TOPOLOGY_POINTLIST: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT; break; case D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST: case D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE; break; default: NGFX_ERR(\"topology: %d unsupported\", topology); return D3D12_PRIMITIVE_TOPOLOGY_TYPE_UNDEFINED; break; } } void D3DGraphicsPipeline::create( D3DGraphicsContext *ctx, const State &state, const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, const std::vector<D3D12_INPUT_ELEMENT_DESC> &inputElements, const Shaders &shaders, DXGI_FORMAT colorFormat, DXGI_FORMAT depthFormat) { D3DPipeline::create(ctx); HRESULT hResult; d3dPrimitiveTopology = state.primitiveTopology; auto d3dDevice = ctx->d3dDevice.v; createRootSignature( rootParameters, D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT); D3D12_RASTERIZER_DESC rasterizerState = { state.fillMode, state.cullMode, state.frontFaceCounterClockwise, 0, 0.0f, 0.0f, state.depthTestEnable, FALSE, FALSE, 0, D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF}; D3D12_RENDER_TARGET_BLEND_DESC renderTargetBlendDesc = { state.blendEnable, FALSE, state.blendSrcColorFactor, state.blendDstColorFactor, state.blendColorOp, state.blendSrcAlphaFactor, state.blendDstAlphaFactor, state.blendAlphaOp, D3D12_LOGIC_OP_NOOP, state.colorWriteMask}; D3D12_BLEND_DESC blendDesc = {}; blendDesc.AlphaToCoverageEnable = FALSE; blendDesc.IndependentBlendEnable = FALSE; blendDesc.RenderTarget[0] = renderTargetBlendDesc; CD3DX12_DEPTH_STENCIL_DESC depthStencilDesc(D3D12_DEFAULT); depthStencilDesc.DepthEnable = state.depthTestEnable; D3D12_GRAPHICS_PIPELINE_STATE_DESC desc = {}; desc.InputLayout = {inputElements.data(), UINT(inputElements.size())}; desc.pRootSignature = d3dRootSignature.Get(); desc.VS = shaders.VS; desc.PS = shaders.PS; desc.GS = shaders.GS; desc.RasterizerState = rasterizerState; desc.BlendState = blendDesc; desc.DepthStencilState = depthStencilDesc; desc.DSVFormat = depthFormat; desc.SampleMask = UINT_MAX; desc.PrimitiveTopologyType = getPrimitiveTopologyType(state.primitiveTopology); desc.NumRenderTargets = state.numColorAttachments; for (uint32_t j = 0; j < desc.NumRenderTargets; j++) desc.RTVFormats[j] = colorFormat; desc.SampleDesc.Count = state.numSamples; V(d3dDevice->CreateGraphicsPipelineState(&desc, IID_PPV_ARGS(&d3dPipelineState))); } GraphicsPipeline * GraphicsPipeline::create(GraphicsContext *graphicsContext, const State &state, VertexShaderModule *vs, FragmentShaderModule *fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes) { D3DGraphicsPipeline *d3dGraphicsPipeline = new D3DGraphicsPipeline(); auto getAlphaBlendFactor = [](BlendFactor blendFactor) -> BlendFactor { switch (blendFactor) { case BLEND_FACTOR_SRC_COLOR: return BLEND_FACTOR_SRC_ALPHA; break; case BLEND_FACTOR_DST_COLOR: return BLEND_FACTOR_DST_ALPHA; break; case BLEND_FACTOR_ONE_MINUS_SRC_COLOR: return BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; break; case BLEND_FACTOR_ONE_MINUS_DST_COLOR: return BLEND_FACTOR_ONE_MINUS_DST_ALPHA; break; default: return blendFactor; break; }; }; struct State { D3D12_PRIMITIVE_TOPOLOGY primitiveTopology = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST; D3D12_FILL_MODE fillMode = D3D12_FILL_MODE_SOLID; bool blendEnable = false; D3D12_BLEND blendSrcColorFactor = D3D12_BLEND_SRC_ALPHA; D3D12_BLEND blendDstColorFactor = D3D12_BLEND_INV_SRC_ALPHA; D3D12_BLEND_OP blendColorOp = D3D12_BLEND_OP_ADD; D3D12_BLEND blendSrcAlphaFactor = D3D12_BLEND_SRC_ALPHA; D3D12_BLEND blendDstAlphaFactor = D3D12_BLEND_INV_SRC_ALPHA; D3D12_BLEND_OP blendAlphaOp = D3D12_BLEND_OP_ADD; D3D12_COLOR_WRITE_ENABLE colorWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; D3D12_CULL_MODE cullMode = D3D12_CULL_MODE_BACK; bool frontFaceCounterClockwise = false; float lineWidth = 1.0f; bool depthTestEnable = false, depthWriteEnable = false; D3DRenderPass *renderPass = nullptr; uint32_t numSamples = 1, numColorAttachments = 1; }; D3DGraphicsPipeline::State d3dState = { D3D_PRIMITIVE_TOPOLOGY(state.primitiveTopology), D3D12_FILL_MODE(state.polygonMode), state.blendEnable, D3D12_BLEND(state.srcColorBlendFactor), D3D12_BLEND(state.dstColorBlendFactor), D3D12_BLEND_OP(state.colorBlendOp), D3D12_BLEND(getAlphaBlendFactor(state.srcAlphaBlendFactor)), D3D12_BLEND(getAlphaBlendFactor(state.dstAlphaBlendFactor)), D3D12_BLEND_OP(state.alphaBlendOp), state.colorWriteMask, D3D12_CULL_MODE(state.cullModeFlags), (state.frontFace == FRONT_FACE_COUNTER_CLOCKWISE), state.lineWidth, state.depthTestEnable, state.depthWriteEnable, d3d(state.renderPass), state.numSamples, state.numColorAttachments}; auto &descriptorBindings = d3dGraphicsPipeline->descriptorBindings; std::vector<CD3DX12_ROOT_PARAMETER1> d3dRootParams; std::vector<std::unique_ptr<CD3DX12_DESCRIPTOR_RANGE1>> d3dDescriptorRanges; std::map<uint32_t, ShaderModule::DescriptorInfo> descriptors; for (auto &descriptor : vs->descriptors) descriptors[descriptor.set] = descriptor; for (auto &descriptor : fs->descriptors) descriptors[descriptor.set] = descriptor; uint32_t numDescriptors = uint32_t(descriptors.size()); descriptorBindings.resize(numDescriptors); D3DPipelineUtil::parseDescriptors(descriptors, descriptorBindings, d3dRootParams, d3dDescriptorRanges, D3DPipelineUtil::PIPELINE_TYPE_GRAPHICS); std::vector<D3D12_INPUT_ELEMENT_DESC> d3dVertexInputAttributes( vs->attributes.size()); auto &vertexAttributeBindings = d3dGraphicsPipeline->vertexAttributeBindings; vertexAttributeBindings.resize(vs->attributes.size()); struct SemanticData { string name; uint32_t index; }; std::vector<SemanticData> semanticData(vs->attributes.size()); for (int j = 0; j < vs->attributes.size(); j++) { const auto &va = vs->attributes[j]; uint32_t binding = va.location, offset = 0; // TODO: va.count D3D12_INPUT_CLASSIFICATION inputRate = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA; if (instanceAttributes.find(va.name) != instanceAttributes.end()) inputRate = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA; uint32_t semanticIndexOffset = uint32_t(va.semantic.find_first_of(\"0123456789\")); string &semanticName = semanticData[j].name; uint32_t &semanticIndex = semanticData[j].index; if (semanticIndexOffset != string::npos) { semanticName = va.semantic.substr(0, semanticIndexOffset); string semanticIndexStr = va.semantic.substr(semanticIndexOffset); semanticIndex = atoi(semanticIndexStr.c_str()); } else { semanticName = va.semantic; semanticIndex = 0; } d3dVertexInputAttributes[j] = { semanticName.c_str(), semanticIndex, DXGI_FORMAT(va.format), binding, offset, inputRate, (inputRate == D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA) ? UINT(0) : UINT(1)}; vertexAttributeBindings[j] = j; } D3DGraphicsPipeline::Shaders shaders; shaders.VS = d3d(vs)->d3dShaderByteCode; shaders.PS = d3d(fs)->d3dShaderByteCode; d3dGraphicsPipeline->create( d3d(graphicsContext), d3dState, d3dRootParams, d3dVertexInputAttributes, shaders, DXGI_FORMAT(colorFormat), DXGI_FORMAT(depthFormat)); return d3dGraphicsPipeline; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DGraphicsPipeline_8h/","text":"src/ngfx/porting/d3d/D3DGraphicsPipeline.h Namespaces Name ngfx Classes Name class ngfx::D3DGraphicsPipeline struct ngfx::D3DGraphicsPipeline::State struct ngfx::D3DGraphicsPipeline::Shaders Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DPipeline.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DGraphicsPipeline : public GraphicsPipeline, public D3DPipeline { public: struct State { D3D12_PRIMITIVE_TOPOLOGY primitiveTopology = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST; D3D12_FILL_MODE fillMode = D3D12_FILL_MODE_SOLID; bool blendEnable = false; D3D12_BLEND blendSrcColorFactor = D3D12_BLEND_SRC_ALPHA; D3D12_BLEND blendDstColorFactor = D3D12_BLEND_INV_SRC_ALPHA; D3D12_BLEND_OP blendColorOp = D3D12_BLEND_OP_ADD; D3D12_BLEND blendSrcAlphaFactor = D3D12_BLEND_SRC_ALPHA; D3D12_BLEND blendDstAlphaFactor = D3D12_BLEND_INV_SRC_ALPHA; D3D12_BLEND_OP blendAlphaOp = D3D12_BLEND_OP_ADD; UINT8 colorWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; D3D12_CULL_MODE cullMode = D3D12_CULL_MODE_BACK; bool frontFaceCounterClockwise = false; float lineWidth = 1.0f; bool depthTestEnable = false, depthWriteEnable = false; D3DRenderPass *renderPass = nullptr; uint32_t numSamples = 1, numColorAttachments = 1; }; struct Shaders { D3D12_SHADER_BYTECODE VS{}, PS{}, DS{}, HS{}, GS{}; }; void create(D3DGraphicsContext *ctx, const State &state, const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, const std::vector<D3D12_INPUT_ELEMENT_DESC> &inputElements, const Shaders &shaders, DXGI_FORMAT colorFormat, DXGI_FORMAT depthFormat); D3D_PRIMITIVE_TOPOLOGY d3dPrimitiveTopology; private: D3D12_PRIMITIVE_TOPOLOGY_TYPE getPrimitiveTopologyType(D3D_PRIMITIVE_TOPOLOGY topology); }; D3D_CAST(GraphicsPipeline); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DGraphicsPipeline.h"},{"location":"api/Files/D3DGraphicsPipeline_8h/#srcngfxportingd3dd3dgraphicspipelineh","text":"","title":"src/ngfx/porting/d3d/D3DGraphicsPipeline.h"},{"location":"api/Files/D3DGraphicsPipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DGraphicsPipeline_8h/#classes","text":"Name class ngfx::D3DGraphicsPipeline struct ngfx::D3DGraphicsPipeline::State struct ngfx::D3DGraphicsPipeline::Shaders","title":"Classes"},{"location":"api/Files/D3DGraphicsPipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include \"ngfx/porting/d3d/D3DPipeline.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DGraphicsPipeline : public GraphicsPipeline, public D3DPipeline { public: struct State { D3D12_PRIMITIVE_TOPOLOGY primitiveTopology = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST; D3D12_FILL_MODE fillMode = D3D12_FILL_MODE_SOLID; bool blendEnable = false; D3D12_BLEND blendSrcColorFactor = D3D12_BLEND_SRC_ALPHA; D3D12_BLEND blendDstColorFactor = D3D12_BLEND_INV_SRC_ALPHA; D3D12_BLEND_OP blendColorOp = D3D12_BLEND_OP_ADD; D3D12_BLEND blendSrcAlphaFactor = D3D12_BLEND_SRC_ALPHA; D3D12_BLEND blendDstAlphaFactor = D3D12_BLEND_INV_SRC_ALPHA; D3D12_BLEND_OP blendAlphaOp = D3D12_BLEND_OP_ADD; UINT8 colorWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL; D3D12_CULL_MODE cullMode = D3D12_CULL_MODE_BACK; bool frontFaceCounterClockwise = false; float lineWidth = 1.0f; bool depthTestEnable = false, depthWriteEnable = false; D3DRenderPass *renderPass = nullptr; uint32_t numSamples = 1, numColorAttachments = 1; }; struct Shaders { D3D12_SHADER_BYTECODE VS{}, PS{}, DS{}, HS{}, GS{}; }; void create(D3DGraphicsContext *ctx, const State &state, const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, const std::vector<D3D12_INPUT_ELEMENT_DESC> &inputElements, const Shaders &shaders, DXGI_FORMAT colorFormat, DXGI_FORMAT depthFormat); D3D_PRIMITIVE_TOPOLOGY d3dPrimitiveTopology; private: D3D12_PRIMITIVE_TOPOLOGY_TYPE getPrimitiveTopologyType(D3D_PRIMITIVE_TOPOLOGY topology); }; D3D_CAST(GraphicsPipeline); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DGraphics_8cpp/","text":"src/ngfx/porting/d3d/D3DGraphics.cpp Functions Name void resourceBarrier ( D3DCommandList * cmdList, D3DFramebuffer::D3DAttachment * p, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES newState, UINT subresourceIndex =D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES) Functions Documentation function resourceBarrier static void resourceBarrier( D3DCommandList * cmdList, D3DFramebuffer::D3DAttachment * p, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES newState, UINT subresourceIndex =D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES ) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DGraphics.h\" #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DComputePipeline.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsPipeline.h\" #include \"ngfx/porting/d3d/D3DTexture.h\" #include <glm/gtc/type_ptr.hpp> using namespace ngfx; void D3DGraphics::bindComputePipeline(CommandBuffer *commandBuffer, ComputePipeline *computePipeline) { auto d3dCtx = d3d(ctx); auto d3dCommandList = d3d(commandBuffer)->v; auto d3dComputePipeline = d3d(computePipeline); D3D_TRACE(d3dCommandList->SetPipelineState( d3dComputePipeline->d3dPipelineState.Get())); D3D_TRACE(d3dCommandList->SetComputeRootSignature( d3dComputePipeline->d3dRootSignature.Get())); auto cbvSrvUavHeap = d3dCtx->d3dCbvSrvUavDescriptorHeap.v.Get(); auto samplerDescriptorHeap = d3dCtx->d3dSamplerDescriptorHeap.v.Get(); std::vector<ID3D12DescriptorHeap *> descriptorHeaps = {cbvSrvUavHeap, samplerDescriptorHeap}; D3D_TRACE(d3dCommandList->SetDescriptorHeaps(UINT(descriptorHeaps.size()), descriptorHeaps.data())); currentPipeline = computePipeline; } void D3DGraphics::bindGraphicsPipeline(CommandBuffer *commandBuffer, GraphicsPipeline *graphicsPipeline) { auto d3dCommandList = d3d(commandBuffer)->v; auto d3dGraphicsPipeline = d3d(graphicsPipeline); D3D_TRACE(d3dCommandList->SetPipelineState( d3dGraphicsPipeline->d3dPipelineState.Get())); D3D_TRACE(d3dCommandList->IASetPrimitiveTopology( d3dGraphicsPipeline->d3dPrimitiveTopology)); D3D_TRACE(d3dCommandList->SetGraphicsRootSignature( d3dGraphicsPipeline->d3dRootSignature.Get())); currentPipeline = graphicsPipeline; } void D3DGraphics::bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) { auto d3dCommandList = d3d(commandBuffer)->v.Get(); auto d3dBuffer = d3d(buffer); if (D3DGraphicsPipeline *graphicsPipeline = dynamic_cast<D3DGraphicsPipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetGraphicsRootConstantBufferView( binding, d3dBuffer->v->GetGPUVirtualAddress())); } else if (D3DComputePipeline *computePipeline = dynamic_cast<D3DComputePipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetComputeRootConstantBufferView( binding, d3dBuffer->v->GetGPUVirtualAddress())); } } void D3DGraphics::bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat) { auto d3dBuffer = d3d(buffer); D3D12_INDEX_BUFFER_VIEW ib; ib.BufferLocation = d3dBuffer->v->GetGPUVirtualAddress(); ib.Format = DXGI_FORMAT(indexFormat); ib.SizeInBytes = d3dBuffer->size; d3d(commandBuffer)->v->IASetIndexBuffer(&ib); } void D3DGraphics::bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) { auto d3dBuffer = d3d(buffer); D3D12_VERTEX_BUFFER_VIEW vb; vb.BufferLocation = d3dBuffer->v->GetGPUVirtualAddress(); vb.StrideInBytes = stride; vb.SizeInBytes = d3dBuffer->size; d3d(commandBuffer)->v->IASetVertexBuffers(location, 1, &vb); } void D3DGraphics::bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) { auto d3dCommandList = d3d(commandBuffer)->v.Get(); auto d3dBuffer = d3d(buffer); // TODO encode access flags as read-only or read-write if (D3DGraphicsPipeline *graphicsPipeline = dynamic_cast<D3DGraphicsPipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetGraphicsRootShaderResourceView( binding, d3dBuffer->v->GetGPUVirtualAddress())); } else if (D3DComputePipeline *computePipeline = dynamic_cast<D3DComputePipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetComputeRootUnorderedAccessView( binding, d3dBuffer->v->GetGPUVirtualAddress())); } } void D3DGraphics::bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) { auto d3dCommandList = d3d(commandBuffer)->v.Get(); auto d3dTexture = d3d(texture); if (D3DGraphicsPipeline *graphicsPipeline = dynamic_cast<D3DGraphicsPipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetGraphicsRootDescriptorTable( set, d3dTexture->defaultSrvDescriptor.gpuHandle)); D3D_TRACE(d3dCommandList->SetGraphicsRootDescriptorTable( set + 1, d3dTexture->defaultSamplerDescriptor.gpuHandle)); } else if (D3DComputePipeline *computePipeline = dynamic_cast<D3DComputePipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetComputeRootDescriptorTable( set, d3dTexture->defaultSrvDescriptor.gpuHandle)); D3D_TRACE(d3dCommandList->SetComputeRootDescriptorTable( set + 1, d3dTexture->defaultSamplerDescriptor.gpuHandle)); } } static void resourceBarrier( D3DCommandList *cmdList, D3DFramebuffer::D3DAttachment *p, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES newState, UINT subresourceIndex = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES) { if (p->texture) p->texture->resourceBarrier(cmdList, newState, subresourceIndex); else { CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition(p->resource, currentState, newState, p->subresourceIndex); D3D_TRACE(cmdList->v->ResourceBarrier(1, &resourceBarrier)); } } void D3DGraphics::beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil) { auto d3dCtx = d3d(ctx); auto d3dRenderPass = d3d(renderPass); auto d3dCommandList = d3d(commandBuffer); auto d3dFramebuffer = d3d(framebuffer); auto &colorAttachments = d3dFramebuffer->colorAttachments; auto &resolveAttachments = d3dFramebuffer->resolveAttachments; auto depthStencilAttachment = d3dFramebuffer->depthStencilAttachment; if (!resolveAttachments.empty()) { for (auto &colorAttachment : colorAttachments) { resourceBarrier(d3dCommandList, colorAttachment, D3D12_RESOURCE_STATE_RESOLVE_SOURCE, D3D12_RESOURCE_STATE_RENDER_TARGET, colorAttachment->subresourceIndex); } } else { for (auto &colorAttachment : colorAttachments) { resourceBarrier(d3dCommandList, colorAttachment, d3dRenderPass->finalResourceState, d3dRenderPass->initialResourceState, colorAttachment->subresourceIndex); } } auto cbvSrvUavHeap = d3dCtx->d3dCbvSrvUavDescriptorHeap.v.Get(); auto samplerDescriptorHeap = d3dCtx->d3dSamplerDescriptorHeap.v.Get(); std::vector<ID3D12DescriptorHeap *> descriptorHeaps = {cbvSrvUavHeap, samplerDescriptorHeap}; D3D_TRACE(d3dCommandList->v->SetDescriptorHeaps(UINT(descriptorHeaps.size()), descriptorHeaps.data())); std::vector<D3D12_CPU_DESCRIPTOR_HANDLE> colorAttachmentHandles( colorAttachments.size()); for (uint32_t j = 0; j < colorAttachments.size(); j++) colorAttachmentHandles[j] = colorAttachments[j]->cpuDescriptor; D3D_TRACE(d3dCommandList->v->OMSetRenderTargets( UINT(colorAttachments.size()), colorAttachmentHandles.data(), FALSE, depthStencilAttachment ? &depthStencilAttachment->cpuDescriptor : nullptr)); for (auto &colorAttachment : colorAttachments) { D3D_TRACE(d3dCommandList->v->ClearRenderTargetView( colorAttachment->cpuDescriptor, glm::value_ptr(clearColor), 0, nullptr)); } if (depthStencilAttachment) { D3D_TRACE(d3dCommandList->v->ClearDepthStencilView( depthStencilAttachment->cpuDescriptor, D3D12_CLEAR_FLAG_DEPTH | D3D12_CLEAR_FLAG_STENCIL, clearDepth, clearStencil, 0, nullptr)); } currentRenderPass = renderPass; currentFramebuffer = framebuffer; } void D3DGraphics::endRenderPass(CommandBuffer *commandBuffer) { auto d3dCommandList = d3d(commandBuffer); auto d3dFramebuffer = d3d(currentFramebuffer); auto &colorAttachments = d3dFramebuffer->colorAttachments; auto &resolveAttachments = d3dFramebuffer->resolveAttachments; auto d3dRenderPass = d3d(currentRenderPass); if (!resolveAttachments.empty()) { for (uint32_t j = 0; j < colorAttachments.size(); j++) { auto &colorAttachment = colorAttachments[j]; auto &resolveAttachment = resolveAttachments[j]; resourceBarrier(d3dCommandList, colorAttachment, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_RESOLVE_SOURCE); resourceBarrier(d3dCommandList, resolveAttachment, D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RESOLVE_DEST); D3D_TRACE(d3dCommandList->v->ResolveSubresource( resolveAttachment->resource, resolveAttachment->subresourceIndex, colorAttachment->resource, colorAttachment->subresourceIndex, colorAttachment->format)); resourceBarrier(d3dCommandList, resolveAttachment, D3D12_RESOURCE_STATE_RESOLVE_DEST, d3dRenderPass->finalResourceState, resolveAttachment->subresourceIndex); } } else { for (auto &colorAttachment : colorAttachments) { resourceBarrier( d3dCommandList, colorAttachment, d3dRenderPass->initialResourceState, d3dRenderPass->finalResourceState, colorAttachment->subresourceIndex); } } currentRenderPass = nullptr; currentFramebuffer = nullptr; } void D3DGraphics::dispatch(CommandBuffer *commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) { D3D_TRACE( d3d(commandBuffer)->v->Dispatch(groupCountX, groupCountY, groupCountZ)); } void D3DGraphics::draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) { D3D_TRACE(d3d(cmdBuffer)->v->DrawInstanced(vertexCount, instanceCount, firstVertex, firstInstance)); } void D3DGraphics::drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) { D3D_TRACE(d3d(cmdBuffer)->v->DrawIndexedInstanced( indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)); } void D3DGraphics::setViewport(CommandBuffer *cmdBuffer, Rect2D r) { viewport = r; D3D12_VIEWPORT d3dViewport = {float(r.x), float(r.y), float(r.w), float(r.h), 0.0f, 1.0f}; D3D_TRACE(d3d(cmdBuffer)->v->RSSetViewports(1, &d3dViewport)); } void D3DGraphics::setScissor(CommandBuffer *cmdBuffer, Rect2D r) { scissorRect = r; #ifdef ORIGIN_BOTTOM_LEFT auto &v = viewport; D3D12_RECT d3dScissorRect = {long(r.x), long(v.h - r.y - r.h), long(r.x + r.w), long(v.h - r.y)}; #else D3D12_RECT d3dScissorRect = {long(r.x), long(r.y), long(r.x + r.w), long(r.y + r.h)}; #endif D3D_TRACE(d3d(cmdBuffer)->v->RSSetScissorRects(1, &d3dScissorRect)); } Graphics *Graphics::create(GraphicsContext *ctx) { D3DGraphics *d3dGraphics = new D3DGraphics(); d3dGraphics->ctx = ctx; d3dGraphics->create(); return d3dGraphics; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DGraphics.cpp"},{"location":"api/Files/D3DGraphics_8cpp/#srcngfxportingd3dd3dgraphicscpp","text":"","title":"src/ngfx/porting/d3d/D3DGraphics.cpp"},{"location":"api/Files/D3DGraphics_8cpp/#functions","text":"Name void resourceBarrier ( D3DCommandList * cmdList, D3DFramebuffer::D3DAttachment * p, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES newState, UINT subresourceIndex =D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES)","title":"Functions"},{"location":"api/Files/D3DGraphics_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/D3DGraphics_8cpp/#function-resourcebarrier","text":"static void resourceBarrier( D3DCommandList * cmdList, D3DFramebuffer::D3DAttachment * p, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES newState, UINT subresourceIndex =D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES )","title":"function resourceBarrier"},{"location":"api/Files/D3DGraphics_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DGraphics.h\" #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DComputePipeline.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsPipeline.h\" #include \"ngfx/porting/d3d/D3DTexture.h\" #include <glm/gtc/type_ptr.hpp> using namespace ngfx; void D3DGraphics::bindComputePipeline(CommandBuffer *commandBuffer, ComputePipeline *computePipeline) { auto d3dCtx = d3d(ctx); auto d3dCommandList = d3d(commandBuffer)->v; auto d3dComputePipeline = d3d(computePipeline); D3D_TRACE(d3dCommandList->SetPipelineState( d3dComputePipeline->d3dPipelineState.Get())); D3D_TRACE(d3dCommandList->SetComputeRootSignature( d3dComputePipeline->d3dRootSignature.Get())); auto cbvSrvUavHeap = d3dCtx->d3dCbvSrvUavDescriptorHeap.v.Get(); auto samplerDescriptorHeap = d3dCtx->d3dSamplerDescriptorHeap.v.Get(); std::vector<ID3D12DescriptorHeap *> descriptorHeaps = {cbvSrvUavHeap, samplerDescriptorHeap}; D3D_TRACE(d3dCommandList->SetDescriptorHeaps(UINT(descriptorHeaps.size()), descriptorHeaps.data())); currentPipeline = computePipeline; } void D3DGraphics::bindGraphicsPipeline(CommandBuffer *commandBuffer, GraphicsPipeline *graphicsPipeline) { auto d3dCommandList = d3d(commandBuffer)->v; auto d3dGraphicsPipeline = d3d(graphicsPipeline); D3D_TRACE(d3dCommandList->SetPipelineState( d3dGraphicsPipeline->d3dPipelineState.Get())); D3D_TRACE(d3dCommandList->IASetPrimitiveTopology( d3dGraphicsPipeline->d3dPrimitiveTopology)); D3D_TRACE(d3dCommandList->SetGraphicsRootSignature( d3dGraphicsPipeline->d3dRootSignature.Get())); currentPipeline = graphicsPipeline; } void D3DGraphics::bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) { auto d3dCommandList = d3d(commandBuffer)->v.Get(); auto d3dBuffer = d3d(buffer); if (D3DGraphicsPipeline *graphicsPipeline = dynamic_cast<D3DGraphicsPipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetGraphicsRootConstantBufferView( binding, d3dBuffer->v->GetGPUVirtualAddress())); } else if (D3DComputePipeline *computePipeline = dynamic_cast<D3DComputePipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetComputeRootConstantBufferView( binding, d3dBuffer->v->GetGPUVirtualAddress())); } } void D3DGraphics::bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat) { auto d3dBuffer = d3d(buffer); D3D12_INDEX_BUFFER_VIEW ib; ib.BufferLocation = d3dBuffer->v->GetGPUVirtualAddress(); ib.Format = DXGI_FORMAT(indexFormat); ib.SizeInBytes = d3dBuffer->size; d3d(commandBuffer)->v->IASetIndexBuffer(&ib); } void D3DGraphics::bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) { auto d3dBuffer = d3d(buffer); D3D12_VERTEX_BUFFER_VIEW vb; vb.BufferLocation = d3dBuffer->v->GetGPUVirtualAddress(); vb.StrideInBytes = stride; vb.SizeInBytes = d3dBuffer->size; d3d(commandBuffer)->v->IASetVertexBuffers(location, 1, &vb); } void D3DGraphics::bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) { auto d3dCommandList = d3d(commandBuffer)->v.Get(); auto d3dBuffer = d3d(buffer); // TODO encode access flags as read-only or read-write if (D3DGraphicsPipeline *graphicsPipeline = dynamic_cast<D3DGraphicsPipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetGraphicsRootShaderResourceView( binding, d3dBuffer->v->GetGPUVirtualAddress())); } else if (D3DComputePipeline *computePipeline = dynamic_cast<D3DComputePipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetComputeRootUnorderedAccessView( binding, d3dBuffer->v->GetGPUVirtualAddress())); } } void D3DGraphics::bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) { auto d3dCommandList = d3d(commandBuffer)->v.Get(); auto d3dTexture = d3d(texture); if (D3DGraphicsPipeline *graphicsPipeline = dynamic_cast<D3DGraphicsPipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetGraphicsRootDescriptorTable( set, d3dTexture->defaultSrvDescriptor.gpuHandle)); D3D_TRACE(d3dCommandList->SetGraphicsRootDescriptorTable( set + 1, d3dTexture->defaultSamplerDescriptor.gpuHandle)); } else if (D3DComputePipeline *computePipeline = dynamic_cast<D3DComputePipeline *>(currentPipeline)) { D3D_TRACE(d3dCommandList->SetComputeRootDescriptorTable( set, d3dTexture->defaultSrvDescriptor.gpuHandle)); D3D_TRACE(d3dCommandList->SetComputeRootDescriptorTable( set + 1, d3dTexture->defaultSamplerDescriptor.gpuHandle)); } } static void resourceBarrier( D3DCommandList *cmdList, D3DFramebuffer::D3DAttachment *p, D3D12_RESOURCE_STATES currentState, D3D12_RESOURCE_STATES newState, UINT subresourceIndex = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES) { if (p->texture) p->texture->resourceBarrier(cmdList, newState, subresourceIndex); else { CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition(p->resource, currentState, newState, p->subresourceIndex); D3D_TRACE(cmdList->v->ResourceBarrier(1, &resourceBarrier)); } } void D3DGraphics::beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil) { auto d3dCtx = d3d(ctx); auto d3dRenderPass = d3d(renderPass); auto d3dCommandList = d3d(commandBuffer); auto d3dFramebuffer = d3d(framebuffer); auto &colorAttachments = d3dFramebuffer->colorAttachments; auto &resolveAttachments = d3dFramebuffer->resolveAttachments; auto depthStencilAttachment = d3dFramebuffer->depthStencilAttachment; if (!resolveAttachments.empty()) { for (auto &colorAttachment : colorAttachments) { resourceBarrier(d3dCommandList, colorAttachment, D3D12_RESOURCE_STATE_RESOLVE_SOURCE, D3D12_RESOURCE_STATE_RENDER_TARGET, colorAttachment->subresourceIndex); } } else { for (auto &colorAttachment : colorAttachments) { resourceBarrier(d3dCommandList, colorAttachment, d3dRenderPass->finalResourceState, d3dRenderPass->initialResourceState, colorAttachment->subresourceIndex); } } auto cbvSrvUavHeap = d3dCtx->d3dCbvSrvUavDescriptorHeap.v.Get(); auto samplerDescriptorHeap = d3dCtx->d3dSamplerDescriptorHeap.v.Get(); std::vector<ID3D12DescriptorHeap *> descriptorHeaps = {cbvSrvUavHeap, samplerDescriptorHeap}; D3D_TRACE(d3dCommandList->v->SetDescriptorHeaps(UINT(descriptorHeaps.size()), descriptorHeaps.data())); std::vector<D3D12_CPU_DESCRIPTOR_HANDLE> colorAttachmentHandles( colorAttachments.size()); for (uint32_t j = 0; j < colorAttachments.size(); j++) colorAttachmentHandles[j] = colorAttachments[j]->cpuDescriptor; D3D_TRACE(d3dCommandList->v->OMSetRenderTargets( UINT(colorAttachments.size()), colorAttachmentHandles.data(), FALSE, depthStencilAttachment ? &depthStencilAttachment->cpuDescriptor : nullptr)); for (auto &colorAttachment : colorAttachments) { D3D_TRACE(d3dCommandList->v->ClearRenderTargetView( colorAttachment->cpuDescriptor, glm::value_ptr(clearColor), 0, nullptr)); } if (depthStencilAttachment) { D3D_TRACE(d3dCommandList->v->ClearDepthStencilView( depthStencilAttachment->cpuDescriptor, D3D12_CLEAR_FLAG_DEPTH | D3D12_CLEAR_FLAG_STENCIL, clearDepth, clearStencil, 0, nullptr)); } currentRenderPass = renderPass; currentFramebuffer = framebuffer; } void D3DGraphics::endRenderPass(CommandBuffer *commandBuffer) { auto d3dCommandList = d3d(commandBuffer); auto d3dFramebuffer = d3d(currentFramebuffer); auto &colorAttachments = d3dFramebuffer->colorAttachments; auto &resolveAttachments = d3dFramebuffer->resolveAttachments; auto d3dRenderPass = d3d(currentRenderPass); if (!resolveAttachments.empty()) { for (uint32_t j = 0; j < colorAttachments.size(); j++) { auto &colorAttachment = colorAttachments[j]; auto &resolveAttachment = resolveAttachments[j]; resourceBarrier(d3dCommandList, colorAttachment, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_RESOLVE_SOURCE); resourceBarrier(d3dCommandList, resolveAttachment, D3D12_RESOURCE_STATE_PRESENT, D3D12_RESOURCE_STATE_RESOLVE_DEST); D3D_TRACE(d3dCommandList->v->ResolveSubresource( resolveAttachment->resource, resolveAttachment->subresourceIndex, colorAttachment->resource, colorAttachment->subresourceIndex, colorAttachment->format)); resourceBarrier(d3dCommandList, resolveAttachment, D3D12_RESOURCE_STATE_RESOLVE_DEST, d3dRenderPass->finalResourceState, resolveAttachment->subresourceIndex); } } else { for (auto &colorAttachment : colorAttachments) { resourceBarrier( d3dCommandList, colorAttachment, d3dRenderPass->initialResourceState, d3dRenderPass->finalResourceState, colorAttachment->subresourceIndex); } } currentRenderPass = nullptr; currentFramebuffer = nullptr; } void D3DGraphics::dispatch(CommandBuffer *commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) { D3D_TRACE( d3d(commandBuffer)->v->Dispatch(groupCountX, groupCountY, groupCountZ)); } void D3DGraphics::draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) { D3D_TRACE(d3d(cmdBuffer)->v->DrawInstanced(vertexCount, instanceCount, firstVertex, firstInstance)); } void D3DGraphics::drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) { D3D_TRACE(d3d(cmdBuffer)->v->DrawIndexedInstanced( indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)); } void D3DGraphics::setViewport(CommandBuffer *cmdBuffer, Rect2D r) { viewport = r; D3D12_VIEWPORT d3dViewport = {float(r.x), float(r.y), float(r.w), float(r.h), 0.0f, 1.0f}; D3D_TRACE(d3d(cmdBuffer)->v->RSSetViewports(1, &d3dViewport)); } void D3DGraphics::setScissor(CommandBuffer *cmdBuffer, Rect2D r) { scissorRect = r; #ifdef ORIGIN_BOTTOM_LEFT auto &v = viewport; D3D12_RECT d3dScissorRect = {long(r.x), long(v.h - r.y - r.h), long(r.x + r.w), long(v.h - r.y)}; #else D3D12_RECT d3dScissorRect = {long(r.x), long(r.y), long(r.x + r.w), long(r.y + r.h)}; #endif D3D_TRACE(d3d(cmdBuffer)->v->RSSetScissorRects(1, &d3dScissorRect)); } Graphics *Graphics::create(GraphicsContext *ctx) { D3DGraphics *d3dGraphics = new D3DGraphics(); d3dGraphics->ctx = ctx; d3dGraphics->create(); return d3dGraphics; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DGraphics_8h/","text":"src/ngfx/porting/d3d/D3DGraphics.h Namespaces Name ngfx Classes Name class ngfx::D3DGraphics Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" namespace ngfx { class D3DGraphics : public Graphics { public: void create() {} virtual ~D3DGraphics() {} void beginComputePass(CommandBuffer *commandBuffer) override {} void endComputePass(CommandBuffer *commandBuffer) override {} void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) override; void endRenderPass(CommandBuffer *commandBuffer) override; void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) override; void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat = INDEXFORMAT_UINT32) override; void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) override; void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) override; void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) override; // TODO: copyBuffer: ToBuffer, copyBuffer: ToTexture, copyTexture: ToBuffer, // blit void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) override; void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) override; void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override; void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) override; void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) override; void waitIdle(CommandBuffer *cmdBuffer) override { d3d(ctx)->d3dDevice.waitIdle(); } }; D3D_CAST(Graphics); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DGraphics.h"},{"location":"api/Files/D3DGraphics_8h/#srcngfxportingd3dd3dgraphicsh","text":"","title":"src/ngfx/porting/d3d/D3DGraphics.h"},{"location":"api/Files/D3DGraphics_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DGraphics_8h/#classes","text":"Name class ngfx::D3DGraphics","title":"Classes"},{"location":"api/Files/D3DGraphics_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" namespace ngfx { class D3DGraphics : public Graphics { public: void create() {} virtual ~D3DGraphics() {} void beginComputePass(CommandBuffer *commandBuffer) override {} void endComputePass(CommandBuffer *commandBuffer) override {} void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) override; void endRenderPass(CommandBuffer *commandBuffer) override; void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) override; void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat = INDEXFORMAT_UINT32) override; void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) override; void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) override; void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) override; // TODO: copyBuffer: ToBuffer, copyBuffer: ToTexture, copyTexture: ToBuffer, // blit void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) override; void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) override; void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override; void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) override; void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) override; void waitIdle(CommandBuffer *cmdBuffer) override { d3d(ctx)->d3dDevice.waitIdle(); } }; D3D_CAST(Graphics); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DPipelineCache_8h/","text":"src/ngfx/porting/d3d/D3DPipelineCache.h Namespaces Name ngfx Classes Name class ngfx::D3DPipelineCache Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/PipelineCache.h\" namespace ngfx { class D3DPipelineCache : public PipelineCache { public: virtual ~D3DPipelineCache() {} }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DPipelineCache.h"},{"location":"api/Files/D3DPipelineCache_8h/#srcngfxportingd3dd3dpipelinecacheh","text":"","title":"src/ngfx/porting/d3d/D3DPipelineCache.h"},{"location":"api/Files/D3DPipelineCache_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DPipelineCache_8h/#classes","text":"Name class ngfx::D3DPipelineCache","title":"Classes"},{"location":"api/Files/D3DPipelineCache_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/PipelineCache.h\" namespace ngfx { class D3DPipelineCache : public PipelineCache { public: virtual ~D3DPipelineCache() {} }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DPipeline_8cpp/","text":"src/ngfx/porting/d3d/D3DPipeline.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DPipeline.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" using namespace ngfx; void D3DPipeline::create(D3DGraphicsContext *ctx) { this->ctx = ctx; } void D3DPipeline::createRootSignature( const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags) { HRESULT hResult; auto d3dDevice = ctx->d3dDevice.v; CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc; rootSignatureDesc.Init_1_1(UINT(rootParameters.size()), rootParameters.data(), 0, nullptr, rootSignatureFlags); ComPtr<ID3DBlob> error, signature; D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {}; featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1; if (FAILED(d3dDevice->CheckFeatureSupport( D3D12_FEATURE_ROOT_SIGNATURE, &featureData, sizeof(featureData)))) { featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0; } V(D3DX12SerializeVersionedRootSignature( &rootSignatureDesc, featureData.HighestVersion, &signature, &error)); V(d3dDevice->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&d3dRootSignature))); } void D3DPipelineUtil::parseDescriptors( std::map<uint32_t, ShaderModule::DescriptorInfo> &descriptors, std::vector<uint32_t> &descriptorBindings, std::vector<CD3DX12_ROOT_PARAMETER1> &d3dRootParams, std::vector<std::unique_ptr<CD3DX12_DESCRIPTOR_RANGE1>> &d3dDescriptorRanges, PipelineType pipelineType) { int registerSpace = 0; for (const auto &it : descriptors) { auto &descriptor = it.second; descriptorBindings[registerSpace] = uint32_t(d3dRootParams.size()); if (descriptor.type == DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) { CD3DX12_ROOT_PARAMETER1 d3dSrvDescriptor, d3dSamplerDescriptor; auto d3dSrvDescriptorRange = std::make_unique<CD3DX12_DESCRIPTOR_RANGE1>(); d3dSrvDescriptorRange->Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0, registerSpace); d3dSrvDescriptor.InitAsDescriptorTable(1, d3dSrvDescriptorRange.get()); d3dDescriptorRanges.emplace_back(std::move(d3dSrvDescriptorRange)); d3dRootParams.emplace_back(std::move(d3dSrvDescriptor)); auto d3dSamplerDescriptorRange = std::make_unique<CD3DX12_DESCRIPTOR_RANGE1>(); d3dSamplerDescriptorRange->Init(D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER, 1, 0, registerSpace); d3dSamplerDescriptor.InitAsDescriptorTable( 1, d3dSamplerDescriptorRange.get()); d3dDescriptorRanges.emplace_back(std::move(d3dSamplerDescriptorRange)); d3dRootParams.emplace_back(std::move(d3dSamplerDescriptor)); } else if (descriptor.type == DESCRIPTOR_TYPE_UNIFORM_BUFFER) { CD3DX12_ROOT_PARAMETER1 d3dDescriptor; d3dDescriptor.InitAsConstantBufferView(0, registerSpace); d3dRootParams.emplace_back(std::move(d3dDescriptor)); } else if (descriptor.type == DESCRIPTOR_TYPE_STORAGE_BUFFER) { CD3DX12_ROOT_PARAMETER1 d3dDescriptor; // TODO encode access flags as read-only or read-write if (pipelineType == PIPELINE_TYPE_GRAPHICS) d3dDescriptor.InitAsShaderResourceView(0, registerSpace); else d3dDescriptor.InitAsUnorderedAccessView(0, registerSpace); d3dRootParams.emplace_back(std::move(d3dDescriptor)); } else { CD3DX12_ROOT_PARAMETER1 d3dDescriptor; d3dDescriptor.InitAsUnorderedAccessView(0, registerSpace); d3dRootParams.emplace_back(std::move(d3dDescriptor)); } registerSpace++; } } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DPipeline.cpp"},{"location":"api/Files/D3DPipeline_8cpp/#srcngfxportingd3dd3dpipelinecpp","text":"","title":"src/ngfx/porting/d3d/D3DPipeline.cpp"},{"location":"api/Files/D3DPipeline_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DPipeline.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" using namespace ngfx; void D3DPipeline::create(D3DGraphicsContext *ctx) { this->ctx = ctx; } void D3DPipeline::createRootSignature( const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags) { HRESULT hResult; auto d3dDevice = ctx->d3dDevice.v; CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc; rootSignatureDesc.Init_1_1(UINT(rootParameters.size()), rootParameters.data(), 0, nullptr, rootSignatureFlags); ComPtr<ID3DBlob> error, signature; D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {}; featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1; if (FAILED(d3dDevice->CheckFeatureSupport( D3D12_FEATURE_ROOT_SIGNATURE, &featureData, sizeof(featureData)))) { featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0; } V(D3DX12SerializeVersionedRootSignature( &rootSignatureDesc, featureData.HighestVersion, &signature, &error)); V(d3dDevice->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&d3dRootSignature))); } void D3DPipelineUtil::parseDescriptors( std::map<uint32_t, ShaderModule::DescriptorInfo> &descriptors, std::vector<uint32_t> &descriptorBindings, std::vector<CD3DX12_ROOT_PARAMETER1> &d3dRootParams, std::vector<std::unique_ptr<CD3DX12_DESCRIPTOR_RANGE1>> &d3dDescriptorRanges, PipelineType pipelineType) { int registerSpace = 0; for (const auto &it : descriptors) { auto &descriptor = it.second; descriptorBindings[registerSpace] = uint32_t(d3dRootParams.size()); if (descriptor.type == DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) { CD3DX12_ROOT_PARAMETER1 d3dSrvDescriptor, d3dSamplerDescriptor; auto d3dSrvDescriptorRange = std::make_unique<CD3DX12_DESCRIPTOR_RANGE1>(); d3dSrvDescriptorRange->Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0, registerSpace); d3dSrvDescriptor.InitAsDescriptorTable(1, d3dSrvDescriptorRange.get()); d3dDescriptorRanges.emplace_back(std::move(d3dSrvDescriptorRange)); d3dRootParams.emplace_back(std::move(d3dSrvDescriptor)); auto d3dSamplerDescriptorRange = std::make_unique<CD3DX12_DESCRIPTOR_RANGE1>(); d3dSamplerDescriptorRange->Init(D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER, 1, 0, registerSpace); d3dSamplerDescriptor.InitAsDescriptorTable( 1, d3dSamplerDescriptorRange.get()); d3dDescriptorRanges.emplace_back(std::move(d3dSamplerDescriptorRange)); d3dRootParams.emplace_back(std::move(d3dSamplerDescriptor)); } else if (descriptor.type == DESCRIPTOR_TYPE_UNIFORM_BUFFER) { CD3DX12_ROOT_PARAMETER1 d3dDescriptor; d3dDescriptor.InitAsConstantBufferView(0, registerSpace); d3dRootParams.emplace_back(std::move(d3dDescriptor)); } else if (descriptor.type == DESCRIPTOR_TYPE_STORAGE_BUFFER) { CD3DX12_ROOT_PARAMETER1 d3dDescriptor; // TODO encode access flags as read-only or read-write if (pipelineType == PIPELINE_TYPE_GRAPHICS) d3dDescriptor.InitAsShaderResourceView(0, registerSpace); else d3dDescriptor.InitAsUnorderedAccessView(0, registerSpace); d3dRootParams.emplace_back(std::move(d3dDescriptor)); } else { CD3DX12_ROOT_PARAMETER1 d3dDescriptor; d3dDescriptor.InitAsUnorderedAccessView(0, registerSpace); d3dRootParams.emplace_back(std::move(d3dDescriptor)); } registerSpace++; } } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DPipeline_8h/","text":"src/ngfx/porting/d3d/D3DPipeline.h Namespaces Name ngfx Classes Name class ngfx::D3DPipeline struct ngfx::D3DPipelineUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" namespace ngfx { class D3DPipeline { public: void create(D3DGraphicsContext *ctx); virtual ~D3DPipeline() {} ComPtr<ID3D12PipelineState> d3dPipelineState; ComPtr<ID3D12RootSignature> d3dRootSignature; protected: void createRootSignature( const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags = D3D12_ROOT_SIGNATURE_FLAG_NONE); D3DGraphicsContext *ctx; }; struct D3DPipelineUtil { enum PipelineType { PIPELINE_TYPE_COMPUTE, PIPELINE_TYPE_GRAPHICS }; static void parseDescriptors(std::map<uint32_t, ShaderModule::DescriptorInfo> &uniforms, std::vector<uint32_t> &uniformBindings, std::vector<CD3DX12_ROOT_PARAMETER1> &d3dRootParams, std::vector<std::unique_ptr<CD3DX12_DESCRIPTOR_RANGE1>> &d3dDescriptorRanges, PipelineType pipelineType); }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DPipeline.h"},{"location":"api/Files/D3DPipeline_8h/#srcngfxportingd3dd3dpipelineh","text":"","title":"src/ngfx/porting/d3d/D3DPipeline.h"},{"location":"api/Files/D3DPipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DPipeline_8h/#classes","text":"Name class ngfx::D3DPipeline struct ngfx::D3DPipelineUtil","title":"Classes"},{"location":"api/Files/D3DPipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" namespace ngfx { class D3DPipeline { public: void create(D3DGraphicsContext *ctx); virtual ~D3DPipeline() {} ComPtr<ID3D12PipelineState> d3dPipelineState; ComPtr<ID3D12RootSignature> d3dRootSignature; protected: void createRootSignature( const std::vector<CD3DX12_ROOT_PARAMETER1> &rootParameters, D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags = D3D12_ROOT_SIGNATURE_FLAG_NONE); D3DGraphicsContext *ctx; }; struct D3DPipelineUtil { enum PipelineType { PIPELINE_TYPE_COMPUTE, PIPELINE_TYPE_GRAPHICS }; static void parseDescriptors(std::map<uint32_t, ShaderModule::DescriptorInfo> &uniforms, std::vector<uint32_t> &uniformBindings, std::vector<CD3DX12_ROOT_PARAMETER1> &d3dRootParams, std::vector<std::unique_ptr<CD3DX12_DESCRIPTOR_RANGE1>> &d3dDescriptorRanges, PipelineType pipelineType); }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DReadbackBuffer_8cpp/","text":"src/ngfx/porting/d3d/D3DReadbackBuffer.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DReadbackBuffer.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" using namespace ngfx; void D3DReadbackBuffer::create(D3DGraphicsContext *ctx, uint32_t size) { D3DBuffer::create(ctx, nullptr, size, D3D12_HEAP_TYPE_READBACK, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COPY_DEST); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DReadbackBuffer.cpp"},{"location":"api/Files/D3DReadbackBuffer_8cpp/#srcngfxportingd3dd3dreadbackbuffercpp","text":"","title":"src/ngfx/porting/d3d/D3DReadbackBuffer.cpp"},{"location":"api/Files/D3DReadbackBuffer_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DReadbackBuffer.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" using namespace ngfx; void D3DReadbackBuffer::create(D3DGraphicsContext *ctx, uint32_t size) { D3DBuffer::create(ctx, nullptr, size, D3D12_HEAP_TYPE_READBACK, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COPY_DEST); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DReadbackBuffer_8h/","text":"src/ngfx/porting/d3d/D3DReadbackBuffer.h Namespaces Name ngfx Classes Name class ngfx::D3DReadbackBuffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" namespace ngfx { class D3DReadbackBuffer : public D3DBuffer { public: void create(D3DGraphicsContext *ctx, uint32_t size); virtual ~D3DReadbackBuffer() {} D3D12_CPU_DESCRIPTOR_HANDLE descriptor; private: D3DGraphicsContext *ctx; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DReadbackBuffer.h"},{"location":"api/Files/D3DReadbackBuffer_8h/#srcngfxportingd3dd3dreadbackbufferh","text":"","title":"src/ngfx/porting/d3d/D3DReadbackBuffer.h"},{"location":"api/Files/D3DReadbackBuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DReadbackBuffer_8h/#classes","text":"Name class ngfx::D3DReadbackBuffer","title":"Classes"},{"location":"api/Files/D3DReadbackBuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" namespace ngfx { class D3DReadbackBuffer : public D3DBuffer { public: void create(D3DGraphicsContext *ctx, uint32_t size); virtual ~D3DReadbackBuffer() {} D3D12_CPU_DESCRIPTOR_HANDLE descriptor; private: D3DGraphicsContext *ctx; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DRenderPass_8cpp/","text":"src/ngfx/porting/d3d/D3DRenderPass.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DRenderPass.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include <d3dx12.h> #include <glm/gtc/type_ptr.hpp> using namespace ngfx; void D3DRenderPass::create(D3DGraphicsContext *ctx, D3D12_RESOURCE_STATES initialResourceState, D3D12_RESOURCE_STATES finalResourceState) { this->ctx = ctx; this->initialResourceState = initialResourceState; this->finalResourceState = finalResourceState; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DRenderPass.cpp"},{"location":"api/Files/D3DRenderPass_8cpp/#srcngfxportingd3dd3drenderpasscpp","text":"","title":"src/ngfx/porting/d3d/D3DRenderPass.cpp"},{"location":"api/Files/D3DRenderPass_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DRenderPass.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/porting/d3d/D3DCommandList.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" #include <d3dx12.h> #include <glm/gtc/type_ptr.hpp> using namespace ngfx; void D3DRenderPass::create(D3DGraphicsContext *ctx, D3D12_RESOURCE_STATES initialResourceState, D3D12_RESOURCE_STATES finalResourceState) { this->ctx = ctx; this->initialResourceState = initialResourceState; this->finalResourceState = finalResourceState; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DRenderPass_8h/","text":"src/ngfx/porting/d3d/D3DRenderPass.h Namespaces Name ngfx Classes Name class ngfx::D3DRenderPass Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DGraphicsContext; class D3DRenderPass : public RenderPass { public: void create(D3DGraphicsContext *ctx, D3D12_RESOURCE_STATES initialResourceState, D3D12_RESOURCE_STATES finalResourceState); virtual ~D3DRenderPass() {} D3D12_RESOURCE_STATES initialResourceState, finalResourceState; private: D3DGraphicsContext *ctx; Framebuffer *currentFramebuffer = nullptr; }; D3D_CAST(RenderPass); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DRenderPass.h"},{"location":"api/Files/D3DRenderPass_8h/#srcngfxportingd3dd3drenderpassh","text":"","title":"src/ngfx/porting/d3d/D3DRenderPass.h"},{"location":"api/Files/D3DRenderPass_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DRenderPass_8h/#classes","text":"Name class ngfx::D3DRenderPass","title":"Classes"},{"location":"api/Files/D3DRenderPass_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DGraphicsContext; class D3DRenderPass : public RenderPass { public: void create(D3DGraphicsContext *ctx, D3D12_RESOURCE_STATES initialResourceState, D3D12_RESOURCE_STATES finalResourceState); virtual ~D3DRenderPass() {} D3D12_RESOURCE_STATES initialResourceState, finalResourceState; private: D3DGraphicsContext *ctx; Framebuffer *currentFramebuffer = nullptr; }; D3D_CAST(RenderPass); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DSamplerDesc_8h/","text":"src/ngfx/porting/d3d/D3DSamplerDesc.h Namespaces Name ngfx Classes Name struct ngfx::D3DSamplerDesc Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <d3d12.h> namespace ngfx { struct D3DSamplerDesc : public D3D12_SAMPLER_DESC { D3DSamplerDesc() { Filter = D3D12_FILTER_MIN_MAG_MIP_POINT; AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP; AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP; AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP; MipLODBias = 0; MaxAnisotropy = 0; ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER; MinLOD = 0.0f; MaxLOD = D3D12_FLOAT32_MAX; } }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DSamplerDesc.h"},{"location":"api/Files/D3DSamplerDesc_8h/#srcngfxportingd3dd3dsamplerdesch","text":"","title":"src/ngfx/porting/d3d/D3DSamplerDesc.h"},{"location":"api/Files/D3DSamplerDesc_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DSamplerDesc_8h/#classes","text":"Name struct ngfx::D3DSamplerDesc","title":"Classes"},{"location":"api/Files/D3DSamplerDesc_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <d3d12.h> namespace ngfx { struct D3DSamplerDesc : public D3D12_SAMPLER_DESC { D3DSamplerDesc() { Filter = D3D12_FILTER_MIN_MAG_MIP_POINT; AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP; AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP; AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP; MipLODBias = 0; MaxAnisotropy = 0; ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER; MinLOD = 0.0f; MaxLOD = D3D12_FLOAT32_MAX; } }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DShaderModule_8cpp/","text":"src/ngfx/porting/d3d/D3DShaderModule.cpp Functions Name template <typename T > std::unique_ptr< T > createShaderModule ( Device * device, const std::string & filename) Functions Documentation function createShaderModule template <typename T > static std::unique_ptr< T > createShaderModule( Device * device, const std::string & filename ) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DShaderModule.h\" #include \"ngfx/core/File.h\" #include \"ngfx/core/StringUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include <d3dcompiler.h> #include <memory> using namespace ngfx; using namespace std; void D3DShaderModule::initFromFile(const std::string &filename) { File file; #ifdef USE_PRECOMPILED_SHADERS file.read(filename + \".dxc\"); initFromByteCode(file.data.get(), file.size); #else compile(filename + \".hlsl\"); #endif } void D3DShaderModule::compile(const std::string &filename) { HRESULT hResult; UINT compileFlags = 0; if (DEBUG_SHADERS) compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION; ComPtr<ID3DBlob> byteCode; ComPtr<ID3DBlob> errorBlob; std::string target; if (strstr(filename.c_str(), \"vert\")) target = \"vs_5_1\"; else if (strstr(filename.c_str(), \"frag\")) target = \"ps_5_1\"; else if (strstr(filename.c_str(), \"comp\")) target = \"cs_5_1\"; hResult = D3DCompileFromFile(StringUtil::toWString(filename).c_str(), nullptr, nullptr, \"main\", target.c_str(), compileFlags, 0, &byteCode, &errorBlob); if (errorBlob) { NGFX_ERR(\"%s %s\", (char *)errorBlob->GetBufferPointer(), filename.c_str()); } V0(hResult, \"%s\", filename.c_str()); initFromByteCode(byteCode->GetBufferPointer(), uint32_t(byteCode->GetBufferSize())); } void D3DShaderModule::initFromByteCode(void *bytecodeData, uint32_t bytecodeSize) { d3dShaderByteCode.pShaderBytecode = malloc(bytecodeSize); d3dShaderByteCode.BytecodeLength = bytecodeSize; memcpy((void *)d3dShaderByteCode.pShaderBytecode, bytecodeData, bytecodeSize); } D3DShaderModule::~D3DShaderModule() { if (d3dShaderByteCode.pShaderBytecode) { free((void *)d3dShaderByteCode.pShaderBytecode); } } template <typename T> static std::unique_ptr<T> createShaderModule(Device *device, const std::string &filename) { auto d3dShaderModule = make_unique<T>(); d3dShaderModule->initFromFile(filename); d3dShaderModule->initBindings(filename + \".hlsl.map\"); return d3dShaderModule; } unique_ptr<VertexShaderModule> VertexShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<D3DVertexShaderModule>(device, filename); } unique_ptr<FragmentShaderModule> FragmentShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<D3DFragmentShaderModule>(device, filename); } unique_ptr<ComputeShaderModule> ComputeShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<D3DComputeShaderModule>(device, filename); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DShaderModule.cpp"},{"location":"api/Files/D3DShaderModule_8cpp/#srcngfxportingd3dd3dshadermodulecpp","text":"","title":"src/ngfx/porting/d3d/D3DShaderModule.cpp"},{"location":"api/Files/D3DShaderModule_8cpp/#functions","text":"Name template <typename T > std::unique_ptr< T > createShaderModule ( Device * device, const std::string & filename)","title":"Functions"},{"location":"api/Files/D3DShaderModule_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/D3DShaderModule_8cpp/#function-createshadermodule","text":"template <typename T > static std::unique_ptr< T > createShaderModule( Device * device, const std::string & filename )","title":"function createShaderModule"},{"location":"api/Files/D3DShaderModule_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DShaderModule.h\" #include \"ngfx/core/File.h\" #include \"ngfx/core/StringUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include <d3dcompiler.h> #include <memory> using namespace ngfx; using namespace std; void D3DShaderModule::initFromFile(const std::string &filename) { File file; #ifdef USE_PRECOMPILED_SHADERS file.read(filename + \".dxc\"); initFromByteCode(file.data.get(), file.size); #else compile(filename + \".hlsl\"); #endif } void D3DShaderModule::compile(const std::string &filename) { HRESULT hResult; UINT compileFlags = 0; if (DEBUG_SHADERS) compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION; ComPtr<ID3DBlob> byteCode; ComPtr<ID3DBlob> errorBlob; std::string target; if (strstr(filename.c_str(), \"vert\")) target = \"vs_5_1\"; else if (strstr(filename.c_str(), \"frag\")) target = \"ps_5_1\"; else if (strstr(filename.c_str(), \"comp\")) target = \"cs_5_1\"; hResult = D3DCompileFromFile(StringUtil::toWString(filename).c_str(), nullptr, nullptr, \"main\", target.c_str(), compileFlags, 0, &byteCode, &errorBlob); if (errorBlob) { NGFX_ERR(\"%s %s\", (char *)errorBlob->GetBufferPointer(), filename.c_str()); } V0(hResult, \"%s\", filename.c_str()); initFromByteCode(byteCode->GetBufferPointer(), uint32_t(byteCode->GetBufferSize())); } void D3DShaderModule::initFromByteCode(void *bytecodeData, uint32_t bytecodeSize) { d3dShaderByteCode.pShaderBytecode = malloc(bytecodeSize); d3dShaderByteCode.BytecodeLength = bytecodeSize; memcpy((void *)d3dShaderByteCode.pShaderBytecode, bytecodeData, bytecodeSize); } D3DShaderModule::~D3DShaderModule() { if (d3dShaderByteCode.pShaderBytecode) { free((void *)d3dShaderByteCode.pShaderBytecode); } } template <typename T> static std::unique_ptr<T> createShaderModule(Device *device, const std::string &filename) { auto d3dShaderModule = make_unique<T>(); d3dShaderModule->initFromFile(filename); d3dShaderModule->initBindings(filename + \".hlsl.map\"); return d3dShaderModule; } unique_ptr<VertexShaderModule> VertexShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<D3DVertexShaderModule>(device, filename); } unique_ptr<FragmentShaderModule> FragmentShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<D3DFragmentShaderModule>(device, filename); } unique_ptr<ComputeShaderModule> ComputeShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<D3DComputeShaderModule>(device, filename); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DShaderModule_8h/","text":"src/ngfx/porting/d3d/D3DShaderModule.h Namespaces Name ngfx Classes Name class ngfx::D3DShaderModule class ngfx::D3DVertexShaderModule class ngfx::D3DFragmentShaderModule class ngfx::D3DComputeShaderModule Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DShaderModule { public: void initFromFile(const std::string &filename); virtual ~D3DShaderModule(); D3D12_SHADER_BYTECODE d3dShaderByteCode{}; void initFromByteCode(void *bytecodeData, uint32_t bytecodeSize); void compile(const std::string &filename); }; D3D_CAST(ShaderModule); class D3DVertexShaderModule : public VertexShaderModule, public D3DShaderModule { public: virtual ~D3DVertexShaderModule() {} }; D3D_CAST(VertexShaderModule); class D3DFragmentShaderModule : public FragmentShaderModule, public D3DShaderModule { public: virtual ~D3DFragmentShaderModule() {} }; D3D_CAST(FragmentShaderModule); class D3DComputeShaderModule : public ComputeShaderModule, public D3DShaderModule { public: virtual ~D3DComputeShaderModule() {} }; D3D_CAST(ComputeShaderModule); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DShaderModule.h"},{"location":"api/Files/D3DShaderModule_8h/#srcngfxportingd3dd3dshadermoduleh","text":"","title":"src/ngfx/porting/d3d/D3DShaderModule.h"},{"location":"api/Files/D3DShaderModule_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DShaderModule_8h/#classes","text":"Name class ngfx::D3DShaderModule class ngfx::D3DVertexShaderModule class ngfx::D3DFragmentShaderModule class ngfx::D3DComputeShaderModule","title":"Classes"},{"location":"api/Files/D3DShaderModule_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DShaderModule { public: void initFromFile(const std::string &filename); virtual ~D3DShaderModule(); D3D12_SHADER_BYTECODE d3dShaderByteCode{}; void initFromByteCode(void *bytecodeData, uint32_t bytecodeSize); void compile(const std::string &filename); }; D3D_CAST(ShaderModule); class D3DVertexShaderModule : public VertexShaderModule, public D3DShaderModule { public: virtual ~D3DVertexShaderModule() {} }; D3D_CAST(VertexShaderModule); class D3DFragmentShaderModule : public FragmentShaderModule, public D3DShaderModule { public: virtual ~D3DFragmentShaderModule() {} }; D3D_CAST(FragmentShaderModule); class D3DComputeShaderModule : public ComputeShaderModule, public D3DShaderModule { public: virtual ~D3DComputeShaderModule() {} }; D3D_CAST(ComputeShaderModule); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DSurface_8h/","text":"src/ngfx/porting/d3d/D3DSurface.h Namespaces Name ngfx Classes Name class ngfx::D3DSurface Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DSurface : public Surface { public: virtual ~D3DSurface() {} void destroy(); HWND v; }; D3D_CAST(Surface); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DSurface.h"},{"location":"api/Files/D3DSurface_8h/#srcngfxportingd3dd3dsurfaceh","text":"","title":"src/ngfx/porting/d3d/D3DSurface.h"},{"location":"api/Files/D3DSurface_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DSurface_8h/#classes","text":"Name class ngfx::D3DSurface","title":"Classes"},{"location":"api/Files/D3DSurface_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DSurface : public Surface { public: virtual ~D3DSurface() {} void destroy(); HWND v; }; D3D_CAST(Surface); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DSwapchain_8cpp/","text":"src/ngfx/porting/d3d/D3DSwapchain.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DSwapchain.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" using namespace ngfx; void D3DSwapchain::create(D3DGraphicsContext *ctx, D3DSurface *surface) { HRESULT hResult; this->ctx = ctx; auto d3dFactory = ctx->d3dFactory.Get(); auto d3dCommandQueue = ctx->d3dCommandQueue.v.Get(); numImages = PREFERRED_NUM_SWAPCHAIN_IMAGES; UINT w = surface->w, h = surface->h; DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {w, h, DXGI_FORMAT_R8G8B8A8_UNORM, FALSE, {1, 0}, DXGI_USAGE_RENDER_TARGET_OUTPUT, numImages, DXGI_SCALING_STRETCH, DXGI_SWAP_EFFECT_FLIP_DISCARD, DXGI_ALPHA_MODE_UNSPECIFIED, 0}; ComPtr<IDXGISwapChain1> swapchain; V(d3dFactory->CreateSwapChainForHwnd(d3dCommandQueue, surface->v, &swapChainDesc, nullptr, nullptr, &swapchain)); V(swapchain.As(&v)); getSwapchainRenderTargets(); createSwapchainRenderTargetViews(w, h); } void D3DSwapchain::getSwapchainRenderTargets() { HRESULT hResult; renderTargets.resize(numImages); for (UINT j = 0; j < numImages; j++) { V(v->GetBuffer(j, IID_PPV_ARGS(&renderTargets[j]))); } } void D3DSwapchain::createSwapchainRenderTargetViews(uint32_t w, uint32_t h) { HRESULT hResult; auto d3dDevice = ctx->d3dDevice.v.Get(); auto rtvDescriptorHeap = &ctx->d3dRtvDescriptorHeap; renderTargetDescriptors.resize(numImages); for (UINT n = 0; n < numImages; n++) { V(v->GetBuffer(n, IID_PPV_ARGS(&renderTargets[n]))); D3D_TRACE(d3dDevice->CreateRenderTargetView( renderTargets[n].Get(), nullptr, rtvDescriptorHeap->handle.cpuHandle)); renderTargetDescriptors[n] = rtvDescriptorHeap->handle; ++rtvDescriptorHeap->handle; } } void D3DSwapchain::acquireNextImage() { ctx->currentImageIndex = v->GetCurrentBackBufferIndex(); auto waitFence = ctx->frameFences[ctx->currentImageIndex]; waitFence->wait(); waitFence->reset(); } void D3DSwapchain::present() { HRESULT hResult; V(v->Present(1, 0)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DSwapchain.cpp"},{"location":"api/Files/D3DSwapchain_8cpp/#srcngfxportingd3dd3dswapchaincpp","text":"","title":"src/ngfx/porting/d3d/D3DSwapchain.cpp"},{"location":"api/Files/D3DSwapchain_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DSwapchain.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" using namespace ngfx; void D3DSwapchain::create(D3DGraphicsContext *ctx, D3DSurface *surface) { HRESULT hResult; this->ctx = ctx; auto d3dFactory = ctx->d3dFactory.Get(); auto d3dCommandQueue = ctx->d3dCommandQueue.v.Get(); numImages = PREFERRED_NUM_SWAPCHAIN_IMAGES; UINT w = surface->w, h = surface->h; DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {w, h, DXGI_FORMAT_R8G8B8A8_UNORM, FALSE, {1, 0}, DXGI_USAGE_RENDER_TARGET_OUTPUT, numImages, DXGI_SCALING_STRETCH, DXGI_SWAP_EFFECT_FLIP_DISCARD, DXGI_ALPHA_MODE_UNSPECIFIED, 0}; ComPtr<IDXGISwapChain1> swapchain; V(d3dFactory->CreateSwapChainForHwnd(d3dCommandQueue, surface->v, &swapChainDesc, nullptr, nullptr, &swapchain)); V(swapchain.As(&v)); getSwapchainRenderTargets(); createSwapchainRenderTargetViews(w, h); } void D3DSwapchain::getSwapchainRenderTargets() { HRESULT hResult; renderTargets.resize(numImages); for (UINT j = 0; j < numImages; j++) { V(v->GetBuffer(j, IID_PPV_ARGS(&renderTargets[j]))); } } void D3DSwapchain::createSwapchainRenderTargetViews(uint32_t w, uint32_t h) { HRESULT hResult; auto d3dDevice = ctx->d3dDevice.v.Get(); auto rtvDescriptorHeap = &ctx->d3dRtvDescriptorHeap; renderTargetDescriptors.resize(numImages); for (UINT n = 0; n < numImages; n++) { V(v->GetBuffer(n, IID_PPV_ARGS(&renderTargets[n]))); D3D_TRACE(d3dDevice->CreateRenderTargetView( renderTargets[n].Get(), nullptr, rtvDescriptorHeap->handle.cpuHandle)); renderTargetDescriptors[n] = rtvDescriptorHeap->handle; ++rtvDescriptorHeap->handle; } } void D3DSwapchain::acquireNextImage() { ctx->currentImageIndex = v->GetCurrentBackBufferIndex(); auto waitFence = ctx->frameFences[ctx->currentImageIndex]; waitFence->wait(); waitFence->reset(); } void D3DSwapchain::present() { HRESULT hResult; V(v->Present(1, 0)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DSwapchain_8h/","text":"src/ngfx/porting/d3d/D3DSwapchain.h Namespaces Name ngfx Classes Name class ngfx::D3DSwapchain Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Swapchain.h\" #include \"ngfx/porting/d3d/D3DDescriptorHeap.h\" #include \"ngfx/porting/d3d/D3DDevice.h\" #include \"ngfx/porting/d3d/D3DSurface.h\" namespace ngfx { class D3DGraphicsContext; class D3DSwapchain : public Swapchain { public: void create(D3DGraphicsContext *ctx, D3DSurface *surface); virtual ~D3DSwapchain() {} void acquireNextImage() override; void present(); ComPtr<IDXGISwapChain3> v; std::vector<ComPtr<ID3D12Resource>> renderTargets; std::vector<D3DDescriptorHandle> renderTargetDescriptors; private: void getSwapchainRenderTargets(); void createSwapchainRenderTargetViews(uint32_t w, uint32_t h); D3DGraphicsContext *ctx; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DSwapchain.h"},{"location":"api/Files/D3DSwapchain_8h/#srcngfxportingd3dd3dswapchainh","text":"","title":"src/ngfx/porting/d3d/D3DSwapchain.h"},{"location":"api/Files/D3DSwapchain_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DSwapchain_8h/#classes","text":"Name class ngfx::D3DSwapchain","title":"Classes"},{"location":"api/Files/D3DSwapchain_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Swapchain.h\" #include \"ngfx/porting/d3d/D3DDescriptorHeap.h\" #include \"ngfx/porting/d3d/D3DDevice.h\" #include \"ngfx/porting/d3d/D3DSurface.h\" namespace ngfx { class D3DGraphicsContext; class D3DSwapchain : public Swapchain { public: void create(D3DGraphicsContext *ctx, D3DSurface *surface); virtual ~D3DSwapchain() {} void acquireNextImage() override; void present(); ComPtr<IDXGISwapChain3> v; std::vector<ComPtr<ID3D12Resource>> renderTargets; std::vector<D3DDescriptorHandle> renderTargetDescriptors; private: void getSwapchainRenderTargets(); void createSwapchainRenderTargetViews(uint32_t w, uint32_t h); D3DGraphicsContext *ctx; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DTexture_8cpp/","text":"src/ngfx/porting/d3d/D3DTexture.cpp Functions Name D3D12_RENDER_TARGET_VIEW_DESC getRtvDesc (TextureType textureType, DXGI_FORMAT format, uint32_t numSamples, uint32_t level, uint32_t baseLayer, uint32_t layerCount) Functions Documentation function getRtvDesc D3D12_RENDER_TARGET_VIEW_DESC getRtvDesc( TextureType textureType, DXGI_FORMAT format, uint32_t numSamples, uint32_t level, uint32_t baseLayer, uint32_t layerCount ) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DTexture.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/porting/d3d/D3DBlitOp.h\" #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" using namespace ngfx; using namespace std; void D3DTexture::create(D3DGraphicsContext *ctx, D3DGraphics *graphics, void *data, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, DXGI_FORMAT format, ImageUsageFlags usageFlags, TextureType textureType, bool genMipmaps, uint32_t numSamples, const D3DSamplerDesc &samplerDesc) { this->ctx = ctx; this->graphics = graphics; this->w = w; this->h = h; this->d = d; this->arrayLayers = arrayLayers; this->size = size; this->format = PixelFormat(format); this->textureType = textureType; this->mipLevels = genMipmaps ? uint32_t(floor(log2(float(glm::min(w, h))))) + 1 : 1; if (genMipmaps) usageFlags |= IMAGE_USAGE_COLOR_ATTACHMENT_BIT; this->imageUsageFlags = usageFlags; this->numSamples = numSamples; numSubresources = arrayLayers * mipLevels; currentResourceState.resize(numSubresources); HRESULT hResult; D3D12_RESOURCE_FLAGS resourceFlags = D3D12_RESOURCE_FLAG_NONE; if (imageUsageFlags & IMAGE_USAGE_COLOR_ATTACHMENT_BIT) resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET; if (imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL; auto d3dDevice = ctx->d3dDevice.v.Get(); if (textureType == TEXTURE_TYPE_3D) { resourceDesc = CD3DX12_RESOURCE_DESC::Tex3D(format, w, h, d, 1, resourceFlags); } else { auto texFormat = format; if (texFormat == DXGI_FORMAT_D16_UNORM && (usageFlags & IMAGE_USAGE_SAMPLED_BIT)) texFormat = DXGI_FORMAT_R16_TYPELESS; else if (texFormat == DXGI_FORMAT_D24_UNORM_S8_UINT && (usageFlags & IMAGE_USAGE_SAMPLED_BIT)) texFormat = DXGI_FORMAT_R24G8_TYPELESS; resourceDesc = CD3DX12_RESOURCE_DESC::Tex2D(texFormat, w, h, d * arrayLayers, mipLevels, numSamples, 0, resourceFlags); } bool isRenderTarget = (resourceFlags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET); D3D12_CLEAR_VALUE clearValue = {format, {0.0f, 0.0f, 0.0f, 0.0f}}; CD3DX12_HEAP_PROPERTIES heapProperties(D3D12_HEAP_TYPE_DEFAULT); V(d3dDevice->CreateCommittedResource( &heapProperties, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_COPY_DEST, isRenderTarget ? &clearValue : nullptr, IID_PPV_ARGS(&v))); for (auto &s : currentResourceState) s = D3D12_RESOURCE_STATE_COPY_DEST; if (imageUsageFlags & IMAGE_USAGE_SAMPLED_BIT) { defaultSrvDescriptor = getSrvDescriptor(0, mipLevels); defaultSamplerDescriptor = getSamplerDescriptor(samplerDesc.Filter); } if (isRenderTarget) { defaultRtvDescriptor = getRtvDescriptor(); } if (imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) { // Create depth stencil view auto dsvDescriptorHeap = &ctx->d3dDsvDescriptorHeap; D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = {}; dsvDesc.Format = format; dsvDesc.ViewDimension = (numSamples > 1) ? D3D12_DSV_DIMENSION_TEXTURE2DMS : D3D12_DSV_DIMENSION_TEXTURE2D; D3D_TRACE(d3dDevice->CreateDepthStencilView( v.Get(), &dsvDesc, dsvDescriptorHeap->handle.cpuHandle)); dsvDescriptor = dsvDescriptorHeap->handle; ++dsvDescriptorHeap->handle; } upload(data, size); } D3DDescriptorHandle D3DTexture::getSamplerDescriptor(D3D12_FILTER filter) { for (auto &samplerData : samplerDescriptorCache) { if (samplerData.desc.Filter == filter) return samplerData.handle; } // Create sampler D3DSamplerDesc samplerDesc; samplerDesc.Filter = filter; auto &samplerDescriptorHeap = ctx->d3dSamplerDescriptorHeap; auto d3dDevice = ctx->d3dDevice.v.Get(); D3D_TRACE(d3dDevice->CreateSampler(&samplerDesc, samplerDescriptorHeap.handle.cpuHandle)); SamplerData samplerData; samplerData.desc = samplerDesc; samplerData.handle = samplerDescriptorHeap.handle; ++samplerDescriptorHeap.handle; auto result = samplerData.handle; samplerDescriptorCache.emplace_back(std::move(samplerData)); return result; } D3DDescriptorHandle D3DTexture::getSrvDescriptor(uint32_t baseMipLevel, uint32_t numMipLevels) { for (auto &srvData : srvDescriptorCache) { if (textureType == TEXTURE_TYPE_2D && srvData.desc.Texture2D.MostDetailedMip == baseMipLevel && srvData.desc.Texture2D.MipLevels == numMipLevels) return srvData.handle; else if (textureType == TEXTURE_TYPE_2D_ARRAY && srvData.desc.Texture2DArray.MostDetailedMip == baseMipLevel && srvData.desc.Texture2DArray.MipLevels == numMipLevels) return srvData.handle; if (textureType == TEXTURE_TYPE_3D && srvData.desc.Texture3D.MostDetailedMip == baseMipLevel && srvData.desc.Texture3D.MipLevels == numMipLevels) return srvData.handle; else if (textureType == TEXTURE_TYPE_CUBE && srvData.desc.TextureCube.MostDetailedMip == baseMipLevel && srvData.desc.TextureCube.MipLevels == numMipLevels) return srvData.handle; } // Create a shader resource view D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {}; srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING; srvDesc.Format = resourceDesc.Format; if (srvDesc.Format == DXGI_FORMAT_R16_TYPELESS) srvDesc.Format = DXGI_FORMAT_R16_UNORM; else if (srvDesc.Format == DXGI_FORMAT_R24G8_TYPELESS) srvDesc.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS; srvDesc.ViewDimension = D3D12_SRV_DIMENSION(textureType); if (textureType == TEXTURE_TYPE_2D) { srvDesc.Texture2D.MostDetailedMip = baseMipLevel; srvDesc.Texture2D.MipLevels = numMipLevels; } else if (textureType == TEXTURE_TYPE_2D_ARRAY) { srvDesc.Texture2DArray.MostDetailedMip = baseMipLevel; srvDesc.Texture2DArray.MipLevels = numMipLevels; } else if (textureType == TEXTURE_TYPE_3D) { srvDesc.Texture3D.MostDetailedMip = baseMipLevel; srvDesc.Texture3D.MipLevels = numMipLevels; } else if (textureType == TEXTURE_TYPE_CUBE) { srvDesc.TextureCube.MostDetailedMip = baseMipLevel; srvDesc.TextureCube.MipLevels = numMipLevels; } auto &cbvSrvUavDescriptorHeap = ctx->d3dCbvSrvUavDescriptorHeap; auto d3dDevice = ctx->d3dDevice.v.Get(); D3D_TRACE(d3dDevice->CreateShaderResourceView( v.Get(), &srvDesc, cbvSrvUavDescriptorHeap.handle.cpuHandle)); SrvData srvData; srvData.desc = srvDesc; srvData.handle = cbvSrvUavDescriptorHeap.handle; ++cbvSrvUavDescriptorHeap.handle; auto result = srvData.handle; srvDescriptorCache.emplace_back(std::move(srvData)); return result; } D3D12_RENDER_TARGET_VIEW_DESC getRtvDesc(TextureType textureType, DXGI_FORMAT format, uint32_t numSamples, uint32_t level, uint32_t baseLayer, uint32_t layerCount) { D3D12_RENDER_TARGET_VIEW_DESC rtvDesc = {}; rtvDesc.Format = DXGI_FORMAT(format); if (textureType == TEXTURE_TYPE_2D) { if (numSamples > 1) { rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DMS; } else { rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D; rtvDesc.Texture2D.MipSlice = level; } } else if (textureType == TEXTURE_TYPE_2D_ARRAY || textureType == TEXTURE_TYPE_CUBE) { if (numSamples > 1) { rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DMSARRAY; rtvDesc.Texture2DMSArray.FirstArraySlice = baseLayer; rtvDesc.Texture2DMSArray.ArraySize = layerCount; } else { rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DARRAY; rtvDesc.Texture2DArray.MipSlice = level; rtvDesc.Texture2DArray.FirstArraySlice = baseLayer; rtvDesc.Texture2DArray.ArraySize = layerCount; } } else if (textureType == TEXTURE_TYPE_3D) { rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE3D; rtvDesc.Texture3D.MipSlice = level; } return rtvDesc; } D3DDescriptorHandle D3DTexture::getRtvDescriptor(uint32_t level, uint32_t baseLayer, uint32_t layerCount) { for (auto &rtvData : rtvDescriptorCache) { if (textureType == TEXTURE_TYPE_2D && numSamples > 1) return rtvData.handle; else if (textureType == TEXTURE_TYPE_2D && rtvData.desc.Texture2D.MipSlice == level) return rtvData.handle; else if ((textureType == TEXTURE_TYPE_2D_ARRAY || textureType == TEXTURE_TYPE_CUBE) && numSamples > 1 && rtvData.desc.Texture2DMSArray.FirstArraySlice == baseLayer && rtvData.desc.Texture2DMSArray.ArraySize == layerCount) return rtvData.handle; else if ((textureType == TEXTURE_TYPE_2D_ARRAY || textureType == TEXTURE_TYPE_CUBE) && rtvData.desc.Texture2DArray.MipSlice == level && rtvData.desc.Texture2DArray.FirstArraySlice == baseLayer && rtvData.desc.Texture2DArray.ArraySize == layerCount) return rtvData.handle; else if (textureType == TEXTURE_TYPE_3D && rtvData.desc.Texture3D.MipSlice == level) return rtvData.handle; } // Create render target view auto rtvDescriptorHeap = &ctx->d3dRtvDescriptorHeap; auto d3dDevice = ctx->d3dDevice.v.Get(); D3D12_RENDER_TARGET_VIEW_DESC rtvDesc = getRtvDesc(textureType, DXGI_FORMAT(format), numSamples, level, baseLayer, layerCount); D3D_TRACE(d3dDevice->CreateRenderTargetView( v.Get(), &rtvDesc, rtvDescriptorHeap->handle.cpuHandle)); RtvData rtvData; rtvData.desc = rtvDesc; rtvData.handle = rtvDescriptorHeap->handle; ++rtvDescriptorHeap->handle; auto result = rtvData.handle; rtvDescriptorCache.emplace_back(std::move(rtvData)); return result; } void D3DTexture::generateMipmapsFn(D3DCommandList *cmdList) { genMipmapData.reset(new GenMipmapData()); for (uint32_t j = 1; j < mipLevels; j++) { D3DBlitOp op( ctx, this, j - 1, this, j, {{0, 0, 0}, {int32_t(glm::max(w >> (j - 1), 1u)), int32_t(glm::max(h >> (j - 1), 1u)), 1}}, {{0, 0, 0}, {int32_t(glm::max(w >> j, 1u)), int32_t(glm::max(h >> j, 1u)), 1}}, 0, arrayLayers, 0, arrayLayers); op.apply(ctx, cmdList, graphics); genMipmapData->ops.emplace_back(std::move(op)); } } void D3DTexture::upload(void *data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { auto &copyCommandList = ctx->d3dCopyCommandList; std::unique_ptr<D3DBuffer> stagingBuffer; if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; if (arrayLayers == -1) arrayLayers = this->arrayLayers; if (data) { uint64_t stagingBufferSize; D3D_TRACE(stagingBufferSize = GetRequiredIntermediateSize(v.Get(), 0, arrayLayers)); stagingBuffer.reset(new D3DBuffer()); stagingBuffer->create(ctx, nullptr, uint32_t(stagingBufferSize), D3D12_HEAP_TYPE_UPLOAD); } copyCommandList.begin(); uploadFn(&copyCommandList, data, size, stagingBuffer.get(), x, y, z, w, h, d, arrayLayers); D3D12_RESOURCE_STATES resourceState = (imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) ? D3D12_RESOURCE_STATE_DEPTH_WRITE : D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE; resourceBarrier(&copyCommandList, resourceState); copyCommandList.end(); ctx->d3dCommandQueue.submit(copyCommandList.v.Get(), nullptr); ctx->d3dCommandQueue.waitIdle(); if (data && mipLevels != 1) { D3DCommandList cmdList; ComPtr<ID3D12CommandAllocator> cmdAllocator; HRESULT hResult; auto d3dDevice = ctx->d3dDevice.v.Get(); cmdList.create(d3dDevice); cmdList.begin(); generateMipmapsFn(&cmdList); cmdList.end(); ctx->d3dCommandQueue.submit(cmdList.v.Get(), nullptr); ctx->d3dCommandQueue.waitIdle(); } } void D3DTexture::generateMipmaps(CommandBuffer *commandBuffer) { generateMipmapsFn((D3DCommandList *)commandBuffer); } void D3DTexture::uploadFn(D3DCommandList *cmdList, void *data, uint32_t size, D3DBuffer *stagingBuffer, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { if (data) { if (x != 0 || y != 0 || z != 0) NGFX_LOG_TRACE(\"TODO: support sub-region update\"); resourceBarrier(cmdList, D3D12_RESOURCE_STATE_COPY_DEST); uint32_t rowPitch = size / (h * d * arrayLayers); uint32_t slicePitch = size / (d * arrayLayers); vector<D3D12_SUBRESOURCE_DATA> textureData(arrayLayers); uint8_t *srcData = (uint8_t *)data; for (uint32_t j = 0; j < uint32_t(arrayLayers); j++) { textureData[j] = {srcData, long(rowPitch), slicePitch}; srcData += slicePitch; } uint64_t bufferSize = UpdateSubresources(cmdList->v.Get(), v.Get(), stagingBuffer->v.Get(), 0, 0, arrayLayers, textureData.data()); assert(bufferSize); } } void D3DTexture::download(void *data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { auto &copyCommandList = ctx->d3dCopyCommandList; const bool flipY = true; //TODO:move to param if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; D3D12_PLACED_SUBRESOURCE_FOOTPRINT footprint; uint32_t numRows; uint64_t srcSize, rowSizeBytes; D3D12_RESOURCE_DESC desc = v->GetDesc(); D3D_TRACE(ctx->d3dDevice.v->GetCopyableFootprints( &desc, 0, 1, 0, &footprint, &numRows, &rowSizeBytes, &srcSize)); D3DReadbackBuffer readbackBuffer; readbackBuffer.create(ctx, uint32_t(srcSize)); D3D12_BOX srcRegion = {0, 0, 0, UINT(w), UINT(h), 1}; copyCommandList.begin(); downloadFn(&copyCommandList, readbackBuffer, srcRegion, footprint); copyCommandList.end(); ctx->d3dCommandQueue.submit(&copyCommandList); ctx->d3dCommandQueue.waitIdle(); void *readbackBufferPtr = readbackBuffer.map(); uint8_t *srcPtr = (uint8_t *)readbackBufferPtr, *dstPtr = &((uint8_t *)data)[flipY ? (uint64_t(h) - 1) * rowSizeBytes : 0]; int64_t dstInc = flipY ? -rowSizeBytes : rowSizeBytes; for (uint32_t j = 0; j < uint32_t(h); j++) { memcpy(dstPtr, srcPtr, rowSizeBytes); srcPtr += footprint.Footprint.RowPitch; dstPtr += dstInc; } readbackBuffer.unmap(); } void D3DTexture::downloadFn(D3DCommandList *cmdList, D3DReadbackBuffer &readbackBuffer, D3D12_BOX &srcRegion, D3D12_PLACED_SUBRESOURCE_FOOTPRINT &dstFootprint) { resourceBarrier(cmdList, D3D12_RESOURCE_STATE_COPY_SOURCE); D3D12_TEXTURE_COPY_LOCATION dstLocation = { readbackBuffer.v.Get(), D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT, {dstFootprint}}; D3D12_TEXTURE_COPY_LOCATION srcLocation = { v.Get(), D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX, 0}; D3D_TRACE(cmdList->v->CopyTextureRegion(&dstLocation, 0, 0, 0, &srcLocation, &srcRegion)); D3D12_RESOURCE_STATES resourceState = (imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) ? D3D12_RESOURCE_STATE_DEPTH_WRITE : D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE; resourceBarrier(cmdList, resourceState); for (auto &s : currentResourceState) s = resourceState; } void D3DTexture::changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) { D3D12_RESOURCE_STATES resourceState; switch (imageLayout) { case IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: resourceState = D3D12_RESOURCE_STATE_RENDER_TARGET; break; case IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: resourceState = D3D12_RESOURCE_STATE_DEPTH_WRITE; break; case IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: resourceState = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE; break; case IMAGE_LAYOUT_GENERAL: resourceState = D3D12_RESOURCE_STATE_COMMON; break; }; resourceBarrier(d3d(commandBuffer), resourceState); } void D3DTexture::resourceBarrier(D3DCommandList *cmdList, D3D12_RESOURCE_STATES newState, UINT subresource) { uint32_t j0, j1; if (subresource == D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES) { j0 = 0; j1 = numSubresources; } else { j0 = subresource; j1 = j0 + 1; } for (uint32_t j = j0; j < j1; j++) { if (currentResourceState[j] == newState) continue; CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition(v.Get(), currentResourceState[j], newState, j); D3D_TRACE(cmdList->v->ResourceBarrier(1, &resourceBarrier)); currentResourceState[j] = newState; } } Texture *Texture::create(GraphicsContext *ctx, Graphics *graphics, void *data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { D3DTexture *d3dTexture = new D3DTexture(); D3DSamplerDesc samplerDesc; uint32_t filter = minFilter << 2 | magFilter << 1 | mipFilter; static D3D12_FILTER filterMap[] = { D3D12_FILTER_MIN_MAG_MIP_POINT, D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR, D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT, D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR, D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT, D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR, D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT, D3D12_FILTER_MIN_MAG_MIP_LINEAR}; samplerDesc.Filter = filterMap[filter]; d3dTexture->create(d3d(ctx), (D3DGraphics *)graphics, data, size, w, h, d, arrayLayers, DXGI_FORMAT(format), imageUsageFlags, textureType, genMipmaps, numSamples, samplerDesc); return d3dTexture; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DTexture.cpp"},{"location":"api/Files/D3DTexture_8cpp/#srcngfxportingd3dd3dtexturecpp","text":"","title":"src/ngfx/porting/d3d/D3DTexture.cpp"},{"location":"api/Files/D3DTexture_8cpp/#functions","text":"Name D3D12_RENDER_TARGET_VIEW_DESC getRtvDesc (TextureType textureType, DXGI_FORMAT format, uint32_t numSamples, uint32_t level, uint32_t baseLayer, uint32_t layerCount)","title":"Functions"},{"location":"api/Files/D3DTexture_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/D3DTexture_8cpp/#function-getrtvdesc","text":"D3D12_RENDER_TARGET_VIEW_DESC getRtvDesc( TextureType textureType, DXGI_FORMAT format, uint32_t numSamples, uint32_t level, uint32_t baseLayer, uint32_t layerCount )","title":"function getRtvDesc"},{"location":"api/Files/D3DTexture_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/d3d/D3DTexture.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/porting/d3d/D3DBlitOp.h\" #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DDebugUtil.h\" #include \"ngfx/porting/d3d/D3DGraphicsContext.h\" using namespace ngfx; using namespace std; void D3DTexture::create(D3DGraphicsContext *ctx, D3DGraphics *graphics, void *data, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, DXGI_FORMAT format, ImageUsageFlags usageFlags, TextureType textureType, bool genMipmaps, uint32_t numSamples, const D3DSamplerDesc &samplerDesc) { this->ctx = ctx; this->graphics = graphics; this->w = w; this->h = h; this->d = d; this->arrayLayers = arrayLayers; this->size = size; this->format = PixelFormat(format); this->textureType = textureType; this->mipLevels = genMipmaps ? uint32_t(floor(log2(float(glm::min(w, h))))) + 1 : 1; if (genMipmaps) usageFlags |= IMAGE_USAGE_COLOR_ATTACHMENT_BIT; this->imageUsageFlags = usageFlags; this->numSamples = numSamples; numSubresources = arrayLayers * mipLevels; currentResourceState.resize(numSubresources); HRESULT hResult; D3D12_RESOURCE_FLAGS resourceFlags = D3D12_RESOURCE_FLAG_NONE; if (imageUsageFlags & IMAGE_USAGE_COLOR_ATTACHMENT_BIT) resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET; if (imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) resourceFlags |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL; auto d3dDevice = ctx->d3dDevice.v.Get(); if (textureType == TEXTURE_TYPE_3D) { resourceDesc = CD3DX12_RESOURCE_DESC::Tex3D(format, w, h, d, 1, resourceFlags); } else { auto texFormat = format; if (texFormat == DXGI_FORMAT_D16_UNORM && (usageFlags & IMAGE_USAGE_SAMPLED_BIT)) texFormat = DXGI_FORMAT_R16_TYPELESS; else if (texFormat == DXGI_FORMAT_D24_UNORM_S8_UINT && (usageFlags & IMAGE_USAGE_SAMPLED_BIT)) texFormat = DXGI_FORMAT_R24G8_TYPELESS; resourceDesc = CD3DX12_RESOURCE_DESC::Tex2D(texFormat, w, h, d * arrayLayers, mipLevels, numSamples, 0, resourceFlags); } bool isRenderTarget = (resourceFlags & D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET); D3D12_CLEAR_VALUE clearValue = {format, {0.0f, 0.0f, 0.0f, 0.0f}}; CD3DX12_HEAP_PROPERTIES heapProperties(D3D12_HEAP_TYPE_DEFAULT); V(d3dDevice->CreateCommittedResource( &heapProperties, D3D12_HEAP_FLAG_NONE, &resourceDesc, D3D12_RESOURCE_STATE_COPY_DEST, isRenderTarget ? &clearValue : nullptr, IID_PPV_ARGS(&v))); for (auto &s : currentResourceState) s = D3D12_RESOURCE_STATE_COPY_DEST; if (imageUsageFlags & IMAGE_USAGE_SAMPLED_BIT) { defaultSrvDescriptor = getSrvDescriptor(0, mipLevels); defaultSamplerDescriptor = getSamplerDescriptor(samplerDesc.Filter); } if (isRenderTarget) { defaultRtvDescriptor = getRtvDescriptor(); } if (imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) { // Create depth stencil view auto dsvDescriptorHeap = &ctx->d3dDsvDescriptorHeap; D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc = {}; dsvDesc.Format = format; dsvDesc.ViewDimension = (numSamples > 1) ? D3D12_DSV_DIMENSION_TEXTURE2DMS : D3D12_DSV_DIMENSION_TEXTURE2D; D3D_TRACE(d3dDevice->CreateDepthStencilView( v.Get(), &dsvDesc, dsvDescriptorHeap->handle.cpuHandle)); dsvDescriptor = dsvDescriptorHeap->handle; ++dsvDescriptorHeap->handle; } upload(data, size); } D3DDescriptorHandle D3DTexture::getSamplerDescriptor(D3D12_FILTER filter) { for (auto &samplerData : samplerDescriptorCache) { if (samplerData.desc.Filter == filter) return samplerData.handle; } // Create sampler D3DSamplerDesc samplerDesc; samplerDesc.Filter = filter; auto &samplerDescriptorHeap = ctx->d3dSamplerDescriptorHeap; auto d3dDevice = ctx->d3dDevice.v.Get(); D3D_TRACE(d3dDevice->CreateSampler(&samplerDesc, samplerDescriptorHeap.handle.cpuHandle)); SamplerData samplerData; samplerData.desc = samplerDesc; samplerData.handle = samplerDescriptorHeap.handle; ++samplerDescriptorHeap.handle; auto result = samplerData.handle; samplerDescriptorCache.emplace_back(std::move(samplerData)); return result; } D3DDescriptorHandle D3DTexture::getSrvDescriptor(uint32_t baseMipLevel, uint32_t numMipLevels) { for (auto &srvData : srvDescriptorCache) { if (textureType == TEXTURE_TYPE_2D && srvData.desc.Texture2D.MostDetailedMip == baseMipLevel && srvData.desc.Texture2D.MipLevels == numMipLevels) return srvData.handle; else if (textureType == TEXTURE_TYPE_2D_ARRAY && srvData.desc.Texture2DArray.MostDetailedMip == baseMipLevel && srvData.desc.Texture2DArray.MipLevels == numMipLevels) return srvData.handle; if (textureType == TEXTURE_TYPE_3D && srvData.desc.Texture3D.MostDetailedMip == baseMipLevel && srvData.desc.Texture3D.MipLevels == numMipLevels) return srvData.handle; else if (textureType == TEXTURE_TYPE_CUBE && srvData.desc.TextureCube.MostDetailedMip == baseMipLevel && srvData.desc.TextureCube.MipLevels == numMipLevels) return srvData.handle; } // Create a shader resource view D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {}; srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING; srvDesc.Format = resourceDesc.Format; if (srvDesc.Format == DXGI_FORMAT_R16_TYPELESS) srvDesc.Format = DXGI_FORMAT_R16_UNORM; else if (srvDesc.Format == DXGI_FORMAT_R24G8_TYPELESS) srvDesc.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS; srvDesc.ViewDimension = D3D12_SRV_DIMENSION(textureType); if (textureType == TEXTURE_TYPE_2D) { srvDesc.Texture2D.MostDetailedMip = baseMipLevel; srvDesc.Texture2D.MipLevels = numMipLevels; } else if (textureType == TEXTURE_TYPE_2D_ARRAY) { srvDesc.Texture2DArray.MostDetailedMip = baseMipLevel; srvDesc.Texture2DArray.MipLevels = numMipLevels; } else if (textureType == TEXTURE_TYPE_3D) { srvDesc.Texture3D.MostDetailedMip = baseMipLevel; srvDesc.Texture3D.MipLevels = numMipLevels; } else if (textureType == TEXTURE_TYPE_CUBE) { srvDesc.TextureCube.MostDetailedMip = baseMipLevel; srvDesc.TextureCube.MipLevels = numMipLevels; } auto &cbvSrvUavDescriptorHeap = ctx->d3dCbvSrvUavDescriptorHeap; auto d3dDevice = ctx->d3dDevice.v.Get(); D3D_TRACE(d3dDevice->CreateShaderResourceView( v.Get(), &srvDesc, cbvSrvUavDescriptorHeap.handle.cpuHandle)); SrvData srvData; srvData.desc = srvDesc; srvData.handle = cbvSrvUavDescriptorHeap.handle; ++cbvSrvUavDescriptorHeap.handle; auto result = srvData.handle; srvDescriptorCache.emplace_back(std::move(srvData)); return result; } D3D12_RENDER_TARGET_VIEW_DESC getRtvDesc(TextureType textureType, DXGI_FORMAT format, uint32_t numSamples, uint32_t level, uint32_t baseLayer, uint32_t layerCount) { D3D12_RENDER_TARGET_VIEW_DESC rtvDesc = {}; rtvDesc.Format = DXGI_FORMAT(format); if (textureType == TEXTURE_TYPE_2D) { if (numSamples > 1) { rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DMS; } else { rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D; rtvDesc.Texture2D.MipSlice = level; } } else if (textureType == TEXTURE_TYPE_2D_ARRAY || textureType == TEXTURE_TYPE_CUBE) { if (numSamples > 1) { rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DMSARRAY; rtvDesc.Texture2DMSArray.FirstArraySlice = baseLayer; rtvDesc.Texture2DMSArray.ArraySize = layerCount; } else { rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2DARRAY; rtvDesc.Texture2DArray.MipSlice = level; rtvDesc.Texture2DArray.FirstArraySlice = baseLayer; rtvDesc.Texture2DArray.ArraySize = layerCount; } } else if (textureType == TEXTURE_TYPE_3D) { rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE3D; rtvDesc.Texture3D.MipSlice = level; } return rtvDesc; } D3DDescriptorHandle D3DTexture::getRtvDescriptor(uint32_t level, uint32_t baseLayer, uint32_t layerCount) { for (auto &rtvData : rtvDescriptorCache) { if (textureType == TEXTURE_TYPE_2D && numSamples > 1) return rtvData.handle; else if (textureType == TEXTURE_TYPE_2D && rtvData.desc.Texture2D.MipSlice == level) return rtvData.handle; else if ((textureType == TEXTURE_TYPE_2D_ARRAY || textureType == TEXTURE_TYPE_CUBE) && numSamples > 1 && rtvData.desc.Texture2DMSArray.FirstArraySlice == baseLayer && rtvData.desc.Texture2DMSArray.ArraySize == layerCount) return rtvData.handle; else if ((textureType == TEXTURE_TYPE_2D_ARRAY || textureType == TEXTURE_TYPE_CUBE) && rtvData.desc.Texture2DArray.MipSlice == level && rtvData.desc.Texture2DArray.FirstArraySlice == baseLayer && rtvData.desc.Texture2DArray.ArraySize == layerCount) return rtvData.handle; else if (textureType == TEXTURE_TYPE_3D && rtvData.desc.Texture3D.MipSlice == level) return rtvData.handle; } // Create render target view auto rtvDescriptorHeap = &ctx->d3dRtvDescriptorHeap; auto d3dDevice = ctx->d3dDevice.v.Get(); D3D12_RENDER_TARGET_VIEW_DESC rtvDesc = getRtvDesc(textureType, DXGI_FORMAT(format), numSamples, level, baseLayer, layerCount); D3D_TRACE(d3dDevice->CreateRenderTargetView( v.Get(), &rtvDesc, rtvDescriptorHeap->handle.cpuHandle)); RtvData rtvData; rtvData.desc = rtvDesc; rtvData.handle = rtvDescriptorHeap->handle; ++rtvDescriptorHeap->handle; auto result = rtvData.handle; rtvDescriptorCache.emplace_back(std::move(rtvData)); return result; } void D3DTexture::generateMipmapsFn(D3DCommandList *cmdList) { genMipmapData.reset(new GenMipmapData()); for (uint32_t j = 1; j < mipLevels; j++) { D3DBlitOp op( ctx, this, j - 1, this, j, {{0, 0, 0}, {int32_t(glm::max(w >> (j - 1), 1u)), int32_t(glm::max(h >> (j - 1), 1u)), 1}}, {{0, 0, 0}, {int32_t(glm::max(w >> j, 1u)), int32_t(glm::max(h >> j, 1u)), 1}}, 0, arrayLayers, 0, arrayLayers); op.apply(ctx, cmdList, graphics); genMipmapData->ops.emplace_back(std::move(op)); } } void D3DTexture::upload(void *data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { auto &copyCommandList = ctx->d3dCopyCommandList; std::unique_ptr<D3DBuffer> stagingBuffer; if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; if (arrayLayers == -1) arrayLayers = this->arrayLayers; if (data) { uint64_t stagingBufferSize; D3D_TRACE(stagingBufferSize = GetRequiredIntermediateSize(v.Get(), 0, arrayLayers)); stagingBuffer.reset(new D3DBuffer()); stagingBuffer->create(ctx, nullptr, uint32_t(stagingBufferSize), D3D12_HEAP_TYPE_UPLOAD); } copyCommandList.begin(); uploadFn(&copyCommandList, data, size, stagingBuffer.get(), x, y, z, w, h, d, arrayLayers); D3D12_RESOURCE_STATES resourceState = (imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) ? D3D12_RESOURCE_STATE_DEPTH_WRITE : D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE; resourceBarrier(&copyCommandList, resourceState); copyCommandList.end(); ctx->d3dCommandQueue.submit(copyCommandList.v.Get(), nullptr); ctx->d3dCommandQueue.waitIdle(); if (data && mipLevels != 1) { D3DCommandList cmdList; ComPtr<ID3D12CommandAllocator> cmdAllocator; HRESULT hResult; auto d3dDevice = ctx->d3dDevice.v.Get(); cmdList.create(d3dDevice); cmdList.begin(); generateMipmapsFn(&cmdList); cmdList.end(); ctx->d3dCommandQueue.submit(cmdList.v.Get(), nullptr); ctx->d3dCommandQueue.waitIdle(); } } void D3DTexture::generateMipmaps(CommandBuffer *commandBuffer) { generateMipmapsFn((D3DCommandList *)commandBuffer); } void D3DTexture::uploadFn(D3DCommandList *cmdList, void *data, uint32_t size, D3DBuffer *stagingBuffer, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { if (data) { if (x != 0 || y != 0 || z != 0) NGFX_LOG_TRACE(\"TODO: support sub-region update\"); resourceBarrier(cmdList, D3D12_RESOURCE_STATE_COPY_DEST); uint32_t rowPitch = size / (h * d * arrayLayers); uint32_t slicePitch = size / (d * arrayLayers); vector<D3D12_SUBRESOURCE_DATA> textureData(arrayLayers); uint8_t *srcData = (uint8_t *)data; for (uint32_t j = 0; j < uint32_t(arrayLayers); j++) { textureData[j] = {srcData, long(rowPitch), slicePitch}; srcData += slicePitch; } uint64_t bufferSize = UpdateSubresources(cmdList->v.Get(), v.Get(), stagingBuffer->v.Get(), 0, 0, arrayLayers, textureData.data()); assert(bufferSize); } } void D3DTexture::download(void *data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { auto &copyCommandList = ctx->d3dCopyCommandList; const bool flipY = true; //TODO:move to param if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; D3D12_PLACED_SUBRESOURCE_FOOTPRINT footprint; uint32_t numRows; uint64_t srcSize, rowSizeBytes; D3D12_RESOURCE_DESC desc = v->GetDesc(); D3D_TRACE(ctx->d3dDevice.v->GetCopyableFootprints( &desc, 0, 1, 0, &footprint, &numRows, &rowSizeBytes, &srcSize)); D3DReadbackBuffer readbackBuffer; readbackBuffer.create(ctx, uint32_t(srcSize)); D3D12_BOX srcRegion = {0, 0, 0, UINT(w), UINT(h), 1}; copyCommandList.begin(); downloadFn(&copyCommandList, readbackBuffer, srcRegion, footprint); copyCommandList.end(); ctx->d3dCommandQueue.submit(&copyCommandList); ctx->d3dCommandQueue.waitIdle(); void *readbackBufferPtr = readbackBuffer.map(); uint8_t *srcPtr = (uint8_t *)readbackBufferPtr, *dstPtr = &((uint8_t *)data)[flipY ? (uint64_t(h) - 1) * rowSizeBytes : 0]; int64_t dstInc = flipY ? -rowSizeBytes : rowSizeBytes; for (uint32_t j = 0; j < uint32_t(h); j++) { memcpy(dstPtr, srcPtr, rowSizeBytes); srcPtr += footprint.Footprint.RowPitch; dstPtr += dstInc; } readbackBuffer.unmap(); } void D3DTexture::downloadFn(D3DCommandList *cmdList, D3DReadbackBuffer &readbackBuffer, D3D12_BOX &srcRegion, D3D12_PLACED_SUBRESOURCE_FOOTPRINT &dstFootprint) { resourceBarrier(cmdList, D3D12_RESOURCE_STATE_COPY_SOURCE); D3D12_TEXTURE_COPY_LOCATION dstLocation = { readbackBuffer.v.Get(), D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT, {dstFootprint}}; D3D12_TEXTURE_COPY_LOCATION srcLocation = { v.Get(), D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX, 0}; D3D_TRACE(cmdList->v->CopyTextureRegion(&dstLocation, 0, 0, 0, &srcLocation, &srcRegion)); D3D12_RESOURCE_STATES resourceState = (imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) ? D3D12_RESOURCE_STATE_DEPTH_WRITE : D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE; resourceBarrier(cmdList, resourceState); for (auto &s : currentResourceState) s = resourceState; } void D3DTexture::changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) { D3D12_RESOURCE_STATES resourceState; switch (imageLayout) { case IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: resourceState = D3D12_RESOURCE_STATE_RENDER_TARGET; break; case IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: resourceState = D3D12_RESOURCE_STATE_DEPTH_WRITE; break; case IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: resourceState = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE; break; case IMAGE_LAYOUT_GENERAL: resourceState = D3D12_RESOURCE_STATE_COMMON; break; }; resourceBarrier(d3d(commandBuffer), resourceState); } void D3DTexture::resourceBarrier(D3DCommandList *cmdList, D3D12_RESOURCE_STATES newState, UINT subresource) { uint32_t j0, j1; if (subresource == D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES) { j0 = 0; j1 = numSubresources; } else { j0 = subresource; j1 = j0 + 1; } for (uint32_t j = j0; j < j1; j++) { if (currentResourceState[j] == newState) continue; CD3DX12_RESOURCE_BARRIER resourceBarrier = CD3DX12_RESOURCE_BARRIER::Transition(v.Get(), currentResourceState[j], newState, j); D3D_TRACE(cmdList->v->ResourceBarrier(1, &resourceBarrier)); currentResourceState[j] = newState; } } Texture *Texture::create(GraphicsContext *ctx, Graphics *graphics, void *data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { D3DTexture *d3dTexture = new D3DTexture(); D3DSamplerDesc samplerDesc; uint32_t filter = minFilter << 2 | magFilter << 1 | mipFilter; static D3D12_FILTER filterMap[] = { D3D12_FILTER_MIN_MAG_MIP_POINT, D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR, D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT, D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR, D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT, D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR, D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT, D3D12_FILTER_MIN_MAG_MIP_LINEAR}; samplerDesc.Filter = filterMap[filter]; d3dTexture->create(d3d(ctx), (D3DGraphics *)graphics, data, size, w, h, d, arrayLayers, DXGI_FORMAT(format), imageUsageFlags, textureType, genMipmaps, numSamples, samplerDesc); return d3dTexture; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DTexture_8h/","text":"src/ngfx/porting/d3d/D3DTexture.h Namespaces Name ngfx Classes Name class ngfx::D3DTexture struct ngfx::D3DTexture::RtvData struct ngfx::D3DTexture::SamplerData struct ngfx::D3DTexture::SrvData Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Texture.h\" #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DDescriptorHandle.h\" #include \"ngfx/porting/d3d/D3DReadbackBuffer.h\" #include \"ngfx/porting/d3d/D3DSamplerDesc.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DGraphics; class D3DGraphicsContext; class D3DBlitOp; class D3DTexture : public Texture { public: void create(D3DGraphicsContext *ctx, D3DGraphics *graphics, void *data, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, DXGI_FORMAT format, ImageUsageFlags usageFlags, TextureType textureType, bool genMipmaps, uint32_t numSamples, const D3DSamplerDesc &samplerDesc); void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) override; void resourceBarrier(D3DCommandList *cmdList, D3D12_RESOURCE_STATES newState, UINT subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES); void generateMipmaps(CommandBuffer *commandBuffer) override; ComPtr<ID3D12Resource> v; D3DDescriptorHandle getRtvDescriptor(uint32_t level = 0, uint32_t baseLayer = 0, uint32_t layerCount = 1); D3DDescriptorHandle getSamplerDescriptor(D3D12_FILTER filter = D3D12_FILTER_MIN_MAG_MIP_POINT); D3DDescriptorHandle getSrvDescriptor(uint32_t baseMipLevel, uint32_t numMipLevels); struct RtvData { D3D12_RENDER_TARGET_VIEW_DESC desc; D3DDescriptorHandle handle; }; std::vector<RtvData> rtvDescriptorCache; struct SamplerData { D3DSamplerDesc desc; D3DDescriptorHandle handle; }; std::vector<SamplerData> samplerDescriptorCache; D3DDescriptorHandle defaultSrvDescriptor{}, defaultRtvDescriptor{}, dsvDescriptor{}, defaultSamplerDescriptor{}; struct SrvData { D3D12_SHADER_RESOURCE_VIEW_DESC desc; D3DDescriptorHandle handle; }; std::vector<SrvData> srvDescriptorCache; D3D12_RESOURCE_DESC resourceDesc; private: void downloadFn(D3DCommandList *cmdList, D3DReadbackBuffer &readbackBuffer, D3D12_BOX &srcRegion, D3D12_PLACED_SUBRESOURCE_FOOTPRINT &dstFootprint); void uploadFn(D3DCommandList *cmdList, void *data, uint32_t size, D3DBuffer *stagingBuffer, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1); void generateMipmapsFn(D3DCommandList *cmdList); D3DGraphicsContext *ctx; D3DGraphics *graphics; uint32_t size; std::vector<D3D12_RESOURCE_STATES> currentResourceState; uint32_t numSubresources = 0; struct GenMipmapData { std::vector<D3DBlitOp> ops; }; std::unique_ptr<GenMipmapData> genMipmapData; }; D3D_CAST(Texture); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DTexture.h"},{"location":"api/Files/D3DTexture_8h/#srcngfxportingd3dd3dtextureh","text":"","title":"src/ngfx/porting/d3d/D3DTexture.h"},{"location":"api/Files/D3DTexture_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DTexture_8h/#classes","text":"Name class ngfx::D3DTexture struct ngfx::D3DTexture::RtvData struct ngfx::D3DTexture::SamplerData struct ngfx::D3DTexture::SrvData","title":"Classes"},{"location":"api/Files/D3DTexture_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Texture.h\" #include \"ngfx/porting/d3d/D3DBuffer.h\" #include \"ngfx/porting/d3d/D3DDescriptorHandle.h\" #include \"ngfx/porting/d3d/D3DReadbackBuffer.h\" #include \"ngfx/porting/d3d/D3DSamplerDesc.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" namespace ngfx { class D3DGraphics; class D3DGraphicsContext; class D3DBlitOp; class D3DTexture : public Texture { public: void create(D3DGraphicsContext *ctx, D3DGraphics *graphics, void *data, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, DXGI_FORMAT format, ImageUsageFlags usageFlags, TextureType textureType, bool genMipmaps, uint32_t numSamples, const D3DSamplerDesc &samplerDesc); void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) override; void resourceBarrier(D3DCommandList *cmdList, D3D12_RESOURCE_STATES newState, UINT subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES); void generateMipmaps(CommandBuffer *commandBuffer) override; ComPtr<ID3D12Resource> v; D3DDescriptorHandle getRtvDescriptor(uint32_t level = 0, uint32_t baseLayer = 0, uint32_t layerCount = 1); D3DDescriptorHandle getSamplerDescriptor(D3D12_FILTER filter = D3D12_FILTER_MIN_MAG_MIP_POINT); D3DDescriptorHandle getSrvDescriptor(uint32_t baseMipLevel, uint32_t numMipLevels); struct RtvData { D3D12_RENDER_TARGET_VIEW_DESC desc; D3DDescriptorHandle handle; }; std::vector<RtvData> rtvDescriptorCache; struct SamplerData { D3DSamplerDesc desc; D3DDescriptorHandle handle; }; std::vector<SamplerData> samplerDescriptorCache; D3DDescriptorHandle defaultSrvDescriptor{}, defaultRtvDescriptor{}, dsvDescriptor{}, defaultSamplerDescriptor{}; struct SrvData { D3D12_SHADER_RESOURCE_VIEW_DESC desc; D3DDescriptorHandle handle; }; std::vector<SrvData> srvDescriptorCache; D3D12_RESOURCE_DESC resourceDesc; private: void downloadFn(D3DCommandList *cmdList, D3DReadbackBuffer &readbackBuffer, D3D12_BOX &srcRegion, D3D12_PLACED_SUBRESOURCE_FOOTPRINT &dstFootprint); void uploadFn(D3DCommandList *cmdList, void *data, uint32_t size, D3DBuffer *stagingBuffer, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1); void generateMipmapsFn(D3DCommandList *cmdList); D3DGraphicsContext *ctx; D3DGraphics *graphics; uint32_t size; std::vector<D3D12_RESOURCE_STATES> currentResourceState; uint32_t numSubresources = 0; struct GenMipmapData { std::vector<D3DBlitOp> ops; }; std::unique_ptr<GenMipmapData> genMipmapData; }; D3D_CAST(Texture); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DUtil_8h/","text":"src/ngfx/porting/d3d/D3DUtil.h Defines Name D3D_CAST (name) Macro Documentation define D3D_CAST #define D3D_CAST( name ) inline D3D##name *d3d(name *g) { return (D3D##name *)g; } Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <d3dx12.h> #include <dxgi1_4.h> #include <wrl.h> using Microsoft::WRL::ComPtr; #define D3D_CAST(name) \\ inline D3D##name *d3d(name *g) { return (D3D##name *)g; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DUtil.h"},{"location":"api/Files/D3DUtil_8h/#srcngfxportingd3dd3dutilh","text":"","title":"src/ngfx/porting/d3d/D3DUtil.h"},{"location":"api/Files/D3DUtil_8h/#defines","text":"Name D3D_CAST (name)","title":"Defines"},{"location":"api/Files/D3DUtil_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/D3DUtil_8h/#define-d3d_cast","text":"#define D3D_CAST( name ) inline D3D##name *d3d(name *g) { return (D3D##name *)g; }","title":"define D3D_CAST"},{"location":"api/Files/D3DUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <d3dx12.h> #include <dxgi1_4.h> #include <wrl.h> using Microsoft::WRL::ComPtr; #define D3D_CAST(name) \\ inline D3D##name *d3d(name *g) { return (D3D##name *)g; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/D3DWindow_8h/","text":"src/ngfx/porting/d3d/D3DWindow.h Namespaces Name ngfx Classes Name class ngfx::D3DWindow Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Window.h\" #include \"ngfx/porting/d3d/D3DSurface.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" #include <d3d12.h> namespace ngfx { class D3DWindow : public Window { public: virtual ~D3DWindow() {} D3DSurface d3dSurface; }; D3D_CAST(Window); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d/D3DWindow.h"},{"location":"api/Files/D3DWindow_8h/#srcngfxportingd3dd3dwindowh","text":"","title":"src/ngfx/porting/d3d/D3DWindow.h"},{"location":"api/Files/D3DWindow_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/D3DWindow_8h/#classes","text":"Name class ngfx::D3DWindow","title":"Classes"},{"location":"api/Files/D3DWindow_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Window.h\" #include \"ngfx/porting/d3d/D3DSurface.h\" #include \"ngfx/porting/d3d/D3DUtil.h\" #include <d3d12.h> namespace ngfx { class D3DWindow : public Window { public: virtual ~D3DWindow() {} D3DSurface d3dSurface; }; D3D_CAST(Window); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/DebugUtil_8h/","text":"src/ngfx/core/DebugUtil.h Classes Name struct DebugUtil Defines Name PRETTY_FUNCTION NGFX_LOG (fmt, ...) NGFX_LOG_TRACE (fmt, ...) NGFX_TODO (fmt, ...) NGFX_ERR (fmt, ...) Macro Documentation define PRETTY_FUNCTION #define __PRETTY_FUNCTION__ __FUNCTION__ define NGFX_LOG #define NGFX_LOG( fmt, ... ) fprintf(stderr, fmt \"\\n\", ##__VA_ARGS__) define NGFX_LOG_TRACE #define NGFX_LOG_TRACE( fmt, ... ) NGFX_LOG(\"[%s][%s][%d] \" fmt, __FILE__, __PRETTY_FUNCTION__, __LINE__, \\ ##__VA_ARGS__) define NGFX_TODO #define NGFX_TODO( fmt, ... ) NGFX_LOG(\"[%s][%s][%d] TODO: \" fmt, __FILE__, __FUNCTION__, __LINE__, \\ ##__VA_ARGS__) define NGFX_ERR #define NGFX_ERR( fmt, ... ) { \\ fprintf(stderr, \"ERROR: [%s][%s][%d] \" fmt \"\\n\", __FILE__, \\ __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \\ DebugUtil::Exit(1); \\ } Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdio> #include <cstdlib> #ifndef __PRETTY_FUNCTION__ #define __PRETTY_FUNCTION__ __FUNCTION__ #endif #define NGFX_LOG(fmt, ...) fprintf(stderr, fmt \"\\n\", ##__VA_ARGS__) #define NGFX_LOG_TRACE(fmt, ...) \\ NGFX_LOG(\"[%s][%s][%d] \" fmt, __FILE__, __PRETTY_FUNCTION__, __LINE__, \\ ##__VA_ARGS__) #define NGFX_TODO(fmt, ...) \\ NGFX_LOG(\"[%s][%s][%d] TODO: \" fmt, __FILE__, __FUNCTION__, __LINE__, \\ ##__VA_ARGS__) #include <cstdint> struct DebugUtil { static inline void Exit(uint32_t code) { exit(code); }; }; #define NGFX_ERR(fmt, ...) \\ { \\ fprintf(stderr, \"ERROR: [%s][%s][%d] \" fmt \"\\n\", __FILE__, \\ __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \\ DebugUtil::Exit(1); \\ } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/DebugUtil.h"},{"location":"api/Files/DebugUtil_8h/#srcngfxcoredebugutilh","text":"","title":"src/ngfx/core/DebugUtil.h"},{"location":"api/Files/DebugUtil_8h/#classes","text":"Name struct DebugUtil","title":"Classes"},{"location":"api/Files/DebugUtil_8h/#defines","text":"Name PRETTY_FUNCTION NGFX_LOG (fmt, ...) NGFX_LOG_TRACE (fmt, ...) NGFX_TODO (fmt, ...) NGFX_ERR (fmt, ...)","title":"Defines"},{"location":"api/Files/DebugUtil_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/DebugUtil_8h/#define-pretty_function","text":"#define __PRETTY_FUNCTION__ __FUNCTION__","title":"define PRETTY_FUNCTION"},{"location":"api/Files/DebugUtil_8h/#define-ngfx_log","text":"#define NGFX_LOG( fmt, ... ) fprintf(stderr, fmt \"\\n\", ##__VA_ARGS__)","title":"define NGFX_LOG"},{"location":"api/Files/DebugUtil_8h/#define-ngfx_log_trace","text":"#define NGFX_LOG_TRACE( fmt, ... ) NGFX_LOG(\"[%s][%s][%d] \" fmt, __FILE__, __PRETTY_FUNCTION__, __LINE__, \\ ##__VA_ARGS__)","title":"define NGFX_LOG_TRACE"},{"location":"api/Files/DebugUtil_8h/#define-ngfx_todo","text":"#define NGFX_TODO( fmt, ... ) NGFX_LOG(\"[%s][%s][%d] TODO: \" fmt, __FILE__, __FUNCTION__, __LINE__, \\ ##__VA_ARGS__)","title":"define NGFX_TODO"},{"location":"api/Files/DebugUtil_8h/#define-ngfx_err","text":"#define NGFX_ERR( fmt, ... ) { \\ fprintf(stderr, \"ERROR: [%s][%s][%d] \" fmt \"\\n\", __FILE__, \\ __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \\ DebugUtil::Exit(1); \\ }","title":"define NGFX_ERR"},{"location":"api/Files/DebugUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdio> #include <cstdlib> #ifndef __PRETTY_FUNCTION__ #define __PRETTY_FUNCTION__ __FUNCTION__ #endif #define NGFX_LOG(fmt, ...) fprintf(stderr, fmt \"\\n\", ##__VA_ARGS__) #define NGFX_LOG_TRACE(fmt, ...) \\ NGFX_LOG(\"[%s][%s][%d] \" fmt, __FILE__, __PRETTY_FUNCTION__, __LINE__, \\ ##__VA_ARGS__) #define NGFX_TODO(fmt, ...) \\ NGFX_LOG(\"[%s][%s][%d] TODO: \" fmt, __FILE__, __FUNCTION__, __LINE__, \\ ##__VA_ARGS__) #include <cstdint> struct DebugUtil { static inline void Exit(uint32_t code) { exit(code); }; }; #define NGFX_ERR(fmt, ...) \\ { \\ fprintf(stderr, \"ERROR: [%s][%s][%d] \" fmt \"\\n\", __FILE__, \\ __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__); \\ DebugUtil::Exit(1); \\ } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Device_8h/","text":"src/ngfx/graphics/Device.h Namespaces Name ngfx Classes Name class ngfx::Device Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Device {}; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Device.h"},{"location":"api/Files/Device_8h/#srcngfxgraphicsdeviceh","text":"","title":"src/ngfx/graphics/Device.h"},{"location":"api/Files/Device_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Device_8h/#classes","text":"Name class ngfx::Device","title":"Classes"},{"location":"api/Files/Device_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Device {}; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/DrawColorOp_8cpp/","text":"src/ngfx/drawOps/DrawColorOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawColorOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawColorOp::DrawColorOp(GraphicsContext *ctx, const std::vector<glm::vec2> &pos, const glm::vec4 &color) : DrawOp(ctx) { bPos.reset(createVertexBuffer<vec2>(ctx, pos)); bUbo.reset(createUniformBuffer(ctx, &color, sizeof(color))); numVerts = uint32_t(pos.size()); createPipeline(); graphicsPipeline->getBindings({&U_UBO}, {&B_POS}); } void DrawColorOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec2)); graphics->bindUniformBuffer(commandBuffer, bUbo.get(), U_UBO, SHADER_STAGE_FRAGMENT_BIT); graphics->draw(commandBuffer, numVerts); } void DrawColorOp::createPipeline() { const std::string key = \"drawColorOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawColor.vert\").get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawColor.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/drawOps/DrawColorOp.cpp"},{"location":"api/Files/DrawColorOp_8cpp/#srcngfxdrawopsdrawcoloropcpp","text":"","title":"src/ngfx/drawOps/DrawColorOp.cpp"},{"location":"api/Files/DrawColorOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawColorOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawColorOp::DrawColorOp(GraphicsContext *ctx, const std::vector<glm::vec2> &pos, const glm::vec4 &color) : DrawOp(ctx) { bPos.reset(createVertexBuffer<vec2>(ctx, pos)); bUbo.reset(createUniformBuffer(ctx, &color, sizeof(color))); numVerts = uint32_t(pos.size()); createPipeline(); graphicsPipeline->getBindings({&U_UBO}, {&B_POS}); } void DrawColorOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec2)); graphics->bindUniformBuffer(commandBuffer, bUbo.get(), U_UBO, SHADER_STAGE_FRAGMENT_BIT); graphics->draw(commandBuffer, numVerts); } void DrawColorOp::createPipeline() { const std::string key = \"drawColorOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawColor.vert\").get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawColor.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/DrawColorOp_8h/","text":"src/ngfx/drawOps/DrawColorOp.h Namespaces Name ngfx Classes Name class ngfx::DrawColorOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/Graphics.h\" #include <memory> namespace ngfx { class DrawColorOp : public DrawOp { public: DrawColorOp(GraphicsContext *ctx, const std::vector<glm::vec2> &pos, const glm::vec4 &color); virtual ~DrawColorOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; std::unique_ptr<Buffer> bPos; std::unique_ptr<Buffer> bUbo; protected: virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t B_POS, U_UBO; uint32_t numVerts; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/drawOps/DrawColorOp.h"},{"location":"api/Files/DrawColorOp_8h/#srcngfxdrawopsdrawcoloroph","text":"","title":"src/ngfx/drawOps/DrawColorOp.h"},{"location":"api/Files/DrawColorOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/DrawColorOp_8h/#classes","text":"Name class ngfx::DrawColorOp","title":"Classes"},{"location":"api/Files/DrawColorOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/Graphics.h\" #include <memory> namespace ngfx { class DrawColorOp : public DrawOp { public: DrawColorOp(GraphicsContext *ctx, const std::vector<glm::vec2> &pos, const glm::vec4 &color); virtual ~DrawColorOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; std::unique_ptr<Buffer> bPos; std::unique_ptr<Buffer> bUbo; protected: virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t B_POS, U_UBO; uint32_t numVerts; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/DrawMeshOp_8cpp/","text":"src/ngfx/drawOps/DrawMeshOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawMeshOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawMeshOp::DrawMeshOp(GraphicsContext *ctx, MeshData &meshData) : DrawOp(ctx) { bPos.reset(createVertexBuffer<vec3>(ctx, meshData.pos)); bNormals.reset(createVertexBuffer<vec3>(ctx, meshData.normal)); bFaces.reset(createIndexBuffer<ivec3>(ctx, meshData.faces)); bUboVS.reset(createUniformBuffer(ctx, nullptr, sizeof(UBO_VS_Data))); bUboFS.reset(createUniformBuffer(ctx, nullptr, sizeof(UBO_FS_Data))); numVerts = uint32_t(meshData.pos.size()); numNormals = uint32_t(meshData.normal.size()); numFaces = uint32_t(meshData.faces.size()); createPipeline(); graphicsPipeline->getBindings({&U_UBO_VS, &U_UBO_FS}, {&B_POS, &B_NORMALS}); } void DrawMeshOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec3)); graphics->bindVertexBuffer(commandBuffer, bNormals.get(), B_NORMALS, sizeof(vec3)); graphics->bindIndexBuffer(commandBuffer, bFaces.get()); graphics->bindUniformBuffer(commandBuffer, bUboVS.get(), U_UBO_VS, SHADER_STAGE_VERTEX_BIT); graphics->bindUniformBuffer(commandBuffer, bUboFS.get(), U_UBO_FS, SHADER_STAGE_FRAGMENT_BIT); graphics->drawIndexed(commandBuffer, numFaces * 3); } void DrawMeshOp::update(mat4 &modelView, mat4 &modelViewInverseTranspose, mat4 &modelViewProj, LightData &lightData) { UBO_VS_Data uboVSData = {modelView, modelViewInverseTranspose, modelViewProj}; UBO_FS_Data uboFSData = {lightData}; bUboVS->upload(&uboVSData, sizeof(uboVSData)); bUboFS->upload(&uboFSData, sizeof(uboFSData)); } void DrawMeshOp::createPipeline() { const std::string key = \"drawMeshOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; state.depthTestEnable = true; state.depthWriteEnable = true; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawMesh.vert\").get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawMesh.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/drawOps/DrawMeshOp.cpp"},{"location":"api/Files/DrawMeshOp_8cpp/#srcngfxdrawopsdrawmeshopcpp","text":"","title":"src/ngfx/drawOps/DrawMeshOp.cpp"},{"location":"api/Files/DrawMeshOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawMeshOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawMeshOp::DrawMeshOp(GraphicsContext *ctx, MeshData &meshData) : DrawOp(ctx) { bPos.reset(createVertexBuffer<vec3>(ctx, meshData.pos)); bNormals.reset(createVertexBuffer<vec3>(ctx, meshData.normal)); bFaces.reset(createIndexBuffer<ivec3>(ctx, meshData.faces)); bUboVS.reset(createUniformBuffer(ctx, nullptr, sizeof(UBO_VS_Data))); bUboFS.reset(createUniformBuffer(ctx, nullptr, sizeof(UBO_FS_Data))); numVerts = uint32_t(meshData.pos.size()); numNormals = uint32_t(meshData.normal.size()); numFaces = uint32_t(meshData.faces.size()); createPipeline(); graphicsPipeline->getBindings({&U_UBO_VS, &U_UBO_FS}, {&B_POS, &B_NORMALS}); } void DrawMeshOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec3)); graphics->bindVertexBuffer(commandBuffer, bNormals.get(), B_NORMALS, sizeof(vec3)); graphics->bindIndexBuffer(commandBuffer, bFaces.get()); graphics->bindUniformBuffer(commandBuffer, bUboVS.get(), U_UBO_VS, SHADER_STAGE_VERTEX_BIT); graphics->bindUniformBuffer(commandBuffer, bUboFS.get(), U_UBO_FS, SHADER_STAGE_FRAGMENT_BIT); graphics->drawIndexed(commandBuffer, numFaces * 3); } void DrawMeshOp::update(mat4 &modelView, mat4 &modelViewInverseTranspose, mat4 &modelViewProj, LightData &lightData) { UBO_VS_Data uboVSData = {modelView, modelViewInverseTranspose, modelViewProj}; UBO_FS_Data uboFSData = {lightData}; bUboVS->upload(&uboVSData, sizeof(uboVSData)); bUboFS->upload(&uboFSData, sizeof(uboFSData)); } void DrawMeshOp::createPipeline() { const std::string key = \"drawMeshOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; state.depthTestEnable = true; state.depthWriteEnable = true; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawMesh.vert\").get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawMesh.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/DrawMeshOp_8h/","text":"src/ngfx/drawOps/DrawMeshOp.h Namespaces Name ngfx Classes Name class ngfx::DrawMeshOp struct ngfx::DrawMeshOp::LightData Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/graphics/MeshData.h\" #include <memory> namespace ngfx { class DrawMeshOp : public DrawOp { public: DrawMeshOp(GraphicsContext *ctx, MeshData &meshData); virtual ~DrawMeshOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; struct LightData { vec4 ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f); vec4 diffuse = vec4(1.0f); vec4 specular = vec4(1.0f); vec4 lightViewPos = vec4(0.0f, 0.0f, 1.0f, 1.0f); vec2 shininess = vec2(10.0f, 0.0f), padding; }; virtual void update(mat4 &modelView, mat4 &modelViewInverseTranspose, mat4 &modelViewProj, LightData &lightData); std::unique_ptr<Buffer> bPos, bNormals; std::unique_ptr<Buffer> bFaces; std::unique_ptr<Buffer> bUboVS, bUboFS; protected: struct UBO_VS_Data { mat4 modelView; mat4 modelViewInverseTranspose; mat4 modelViewProj; }; struct UBO_FS_Data { LightData light0; }; virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t B_POS, B_NORMALS, U_UBO_VS, U_UBO_FS; uint32_t numVerts, numNormals; uint32_t numFaces; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/drawOps/DrawMeshOp.h"},{"location":"api/Files/DrawMeshOp_8h/#srcngfxdrawopsdrawmeshoph","text":"","title":"src/ngfx/drawOps/DrawMeshOp.h"},{"location":"api/Files/DrawMeshOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/DrawMeshOp_8h/#classes","text":"Name class ngfx::DrawMeshOp struct ngfx::DrawMeshOp::LightData","title":"Classes"},{"location":"api/Files/DrawMeshOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/graphics/MeshData.h\" #include <memory> namespace ngfx { class DrawMeshOp : public DrawOp { public: DrawMeshOp(GraphicsContext *ctx, MeshData &meshData); virtual ~DrawMeshOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; struct LightData { vec4 ambient = vec4(0.2f, 0.2f, 0.2f, 1.0f); vec4 diffuse = vec4(1.0f); vec4 specular = vec4(1.0f); vec4 lightViewPos = vec4(0.0f, 0.0f, 1.0f, 1.0f); vec2 shininess = vec2(10.0f, 0.0f), padding; }; virtual void update(mat4 &modelView, mat4 &modelViewInverseTranspose, mat4 &modelViewProj, LightData &lightData); std::unique_ptr<Buffer> bPos, bNormals; std::unique_ptr<Buffer> bFaces; std::unique_ptr<Buffer> bUboVS, bUboFS; protected: struct UBO_VS_Data { mat4 modelView; mat4 modelViewInverseTranspose; mat4 modelViewProj; }; struct UBO_FS_Data { LightData light0; }; virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t B_POS, B_NORMALS, U_UBO_VS, U_UBO_FS; uint32_t numVerts, numNormals; uint32_t numFaces; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/DrawOp_8h/","text":"src/ngfx/graphics/DrawOp.h Namespaces Name ngfx Classes Name class ngfx::DrawOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class DrawOp { public: DrawOp(GraphicsContext *ctx) : ctx(ctx) {} virtual ~DrawOp() {} virtual void draw(CommandBuffer *commandBuffer, Graphics *graphics) = 0; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/DrawOp.h"},{"location":"api/Files/DrawOp_8h/#srcngfxgraphicsdrawoph","text":"","title":"src/ngfx/graphics/DrawOp.h"},{"location":"api/Files/DrawOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/DrawOp_8h/#classes","text":"Name class ngfx::DrawOp","title":"Classes"},{"location":"api/Files/DrawOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class DrawOp { public: DrawOp(GraphicsContext *ctx) : ctx(ctx) {} virtual ~DrawOp() {} virtual void draw(CommandBuffer *commandBuffer, Graphics *graphics) = 0; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/DrawTextureOp_8cpp/","text":"src/ngfx/drawOps/DrawTextureOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawTextureOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawTextureOp::DrawTextureOp(GraphicsContext *ctx, Texture *texture, const std::vector<glm::vec2> &pos, const std::vector<glm::vec2> &texCoord) : DrawOp(ctx), texture(texture) { bPos.reset(createVertexBuffer<vec2>(ctx, pos)); bTexCoord.reset(createVertexBuffer<vec2>(ctx, texCoord)); numVerts = uint32_t(pos.size()); createPipeline(); graphicsPipeline->getBindings({&U_TEXTURE}, {&B_POS, &B_TEXCOORD}); } void DrawTextureOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec2)); graphics->bindVertexBuffer(commandBuffer, bTexCoord.get(), B_TEXCOORD, sizeof(vec2)); graphics->bindTexture(commandBuffer, texture, U_TEXTURE); graphics->draw(commandBuffer, numVerts); } void DrawTextureOp::createPipeline() { const std::string key = \"drawTextureOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawTexture.vert\") .get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawTexture.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/drawOps/DrawTextureOp.cpp"},{"location":"api/Files/DrawTextureOp_8cpp/#srcngfxdrawopsdrawtextureopcpp","text":"","title":"src/ngfx/drawOps/DrawTextureOp.cpp"},{"location":"api/Files/DrawTextureOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/drawOps/DrawTextureOp.h\" #include \"ngfx/graphics/BufferUtil.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/ShaderModule.h\" using namespace ngfx; using namespace glm; DrawTextureOp::DrawTextureOp(GraphicsContext *ctx, Texture *texture, const std::vector<glm::vec2> &pos, const std::vector<glm::vec2> &texCoord) : DrawOp(ctx), texture(texture) { bPos.reset(createVertexBuffer<vec2>(ctx, pos)); bTexCoord.reset(createVertexBuffer<vec2>(ctx, texCoord)); numVerts = uint32_t(pos.size()); createPipeline(); graphicsPipeline->getBindings({&U_TEXTURE}, {&B_POS, &B_TEXCOORD}); } void DrawTextureOp::draw(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindGraphicsPipeline(commandBuffer, graphicsPipeline); graphics->bindVertexBuffer(commandBuffer, bPos.get(), B_POS, sizeof(vec2)); graphics->bindVertexBuffer(commandBuffer, bTexCoord.get(), B_TEXCOORD, sizeof(vec2)); graphics->bindTexture(commandBuffer, texture, U_TEXTURE); graphics->draw(commandBuffer, numVerts); } void DrawTextureOp::createPipeline() { const std::string key = \"drawTextureOp\"; graphicsPipeline = (GraphicsPipeline *)ctx->pipelineCache->get(key); if (graphicsPipeline) return; GraphicsPipeline::State state; state.renderPass = ctx->defaultRenderPass; state.primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP; auto device = ctx->device; graphicsPipeline = GraphicsPipeline::create( ctx, state, VertexShaderModule::create(device, NGFX_DATA_DIR \"/drawTexture.vert\") .get(), FragmentShaderModule::create(device, NGFX_DATA_DIR \"/drawTexture.frag\") .get(), ctx->surfaceFormat, ctx->depthFormat); ctx->pipelineCache->add(key, graphicsPipeline); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/DrawTextureOp_8h/","text":"src/ngfx/drawOps/DrawTextureOp.h Namespaces Name ngfx Classes Name class ngfx::DrawTextureOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/DrawOp.h\" #include <memory> namespace ngfx { class DrawTextureOp : public DrawOp { public: DrawTextureOp(GraphicsContext *ctx, Texture *texture) : DrawTextureOp(ctx, texture, {glm::vec2(-1, 1), glm::vec2(-1, -1), glm::vec2(1, 1), glm::vec2(1, -1)}, {glm::vec2(0, 0), glm::vec2(0, 1), glm::vec2(1, 0), glm::vec2(1, 1)}) {} DrawTextureOp(GraphicsContext *ctx, Texture *texture, const std::vector<glm::vec2> &pos, const std::vector<glm::vec2> &texCoord); virtual ~DrawTextureOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; std::unique_ptr<Buffer> bPos, bTexCoord; Texture *texture; protected: virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t numVerts; uint32_t B_POS, B_TEXCOORD, U_TEXTURE; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/drawOps/DrawTextureOp.h"},{"location":"api/Files/DrawTextureOp_8h/#srcngfxdrawopsdrawtextureoph","text":"","title":"src/ngfx/drawOps/DrawTextureOp.h"},{"location":"api/Files/DrawTextureOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/DrawTextureOp_8h/#classes","text":"Name class ngfx::DrawTextureOp","title":"Classes"},{"location":"api/Files/DrawTextureOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/DrawOp.h\" #include <memory> namespace ngfx { class DrawTextureOp : public DrawOp { public: DrawTextureOp(GraphicsContext *ctx, Texture *texture) : DrawTextureOp(ctx, texture, {glm::vec2(-1, 1), glm::vec2(-1, -1), glm::vec2(1, 1), glm::vec2(1, -1)}, {glm::vec2(0, 0), glm::vec2(0, 1), glm::vec2(1, 0), glm::vec2(1, 1)}) {} DrawTextureOp(GraphicsContext *ctx, Texture *texture, const std::vector<glm::vec2> &pos, const std::vector<glm::vec2> &texCoord); virtual ~DrawTextureOp() {} void draw(CommandBuffer *commandBuffer, Graphics *graphics) override; std::unique_ptr<Buffer> bPos, bTexCoord; Texture *texture; protected: virtual void createPipeline(); GraphicsPipeline *graphicsPipeline; uint32_t numVerts; uint32_t B_POS, B_TEXCOORD, U_TEXTURE; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/FPSCounter_8cpp/","text":"src/ngfx/core/FPSCounter.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/FPSCounter.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void FPSCounter::update() { numFrames++; if (numFrames == 100) { timer.update(); fps = 100 / timer.elapsed; NGFX_LOG(\"FPS: %3.2f\", fps); numFrames = 0; } } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/FPSCounter.cpp"},{"location":"api/Files/FPSCounter_8cpp/#srcngfxcorefpscountercpp","text":"","title":"src/ngfx/core/FPSCounter.cpp"},{"location":"api/Files/FPSCounter_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/FPSCounter.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void FPSCounter::update() { numFrames++; if (numFrames == 100) { timer.update(); fps = 100 / timer.elapsed; NGFX_LOG(\"FPS: %3.2f\", fps); numFrames = 0; } } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/FPSCounter_8h/","text":"src/ngfx/core/FPSCounter.h Namespaces Name ngfx Classes Name class ngfx::FPSCounter Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/Timer.h\" namespace ngfx { class FPSCounter { public: FPSCounter() {} void update(); float fps = 0.0f; private: int numFrames = 0; Timer timer; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/FPSCounter.h"},{"location":"api/Files/FPSCounter_8h/#srcngfxcorefpscounterh","text":"","title":"src/ngfx/core/FPSCounter.h"},{"location":"api/Files/FPSCounter_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/FPSCounter_8h/#classes","text":"Name class ngfx::FPSCounter","title":"Classes"},{"location":"api/Files/FPSCounter_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/Timer.h\" namespace ngfx { class FPSCounter { public: FPSCounter() {} void update(); float fps = 0.0f; private: int numFrames = 0; Timer timer; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Fence_8h/","text":"src/ngfx/graphics/Fence.h Namespaces Name ngfx Classes Name class ngfx::Fence Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class Fence { public: static Fence *create(Device *device, FenceCreateFlags flags = 0); virtual ~Fence() {} virtual void wait() = 0; virtual void reset() = 0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Fence.h"},{"location":"api/Files/Fence_8h/#srcngfxgraphicsfenceh","text":"","title":"src/ngfx/graphics/Fence.h"},{"location":"api/Files/Fence_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Fence_8h/#classes","text":"Name class ngfx::Fence","title":"Classes"},{"location":"api/Files/Fence_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" namespace ngfx { class Fence { public: static Fence *create(Device *device, FenceCreateFlags flags = 0); virtual ~Fence() {} virtual void wait() = 0; virtual void reset() = 0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/FileUtil_8cpp/","text":"src/ngfx/core/FileUtil.cpp Namespaces Name std std::chrono Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"FileUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/File.h\" #include <cassert> #include <chrono> #include <cstring> #include <fstream> using namespace std; namespace fs = std::filesystem; using namespace ngfx; using namespace std::chrono; bool FileUtil::getmtime(const string &filename, fs::file_time_type &mtime) { if (!fs::exists(filename)) { return false; } mtime = fs::last_write_time(filename); return true; } bool FileUtil::srcFileNewerThanOutFile(const string &srcFileName, const string &targetFileName) { fs::file_time_type srcTimeStamp, targetTimeStamp; getmtime(srcFileName, srcTimeStamp); if (!getmtime(targetFileName, targetTimeStamp)) return true; if (srcTimeStamp > targetTimeStamp) return true; return false; } string FileUtil::tempDir() { return fs::canonical(fs::temp_directory_path()).string(); } FileUtil::Lock::Lock(const std::string &path, uint32_t timeoutMs) : lockPath(path + \".lock\"), timeoutMs(timeoutMs) { fs::path fpath(path); auto t0 = system_clock::now(); while (fs::exists(lockPath)) { std::this_thread::sleep_for(milliseconds(10)); auto t1 = system_clock::now(); if (duration_cast<milliseconds>(t1 - t0).count() > timeoutMs) { NGFX_ERR(\"file locked: %s, timeoutMs: %d\", path.c_str(), timeoutMs); } } writeFile(lockPath, \"\"); } FileUtil::Lock::~Lock() { fs::remove(lockPath); } string FileUtil::readFile(const string &path) { File file; file.read(path); return string(file.data.get(), file.size); } void FileUtil::writeFile(const string &path, const string &contents) { ofstream out(path, ofstream::binary); assert(out); out.write(contents.data(), contents.size()); out.close(); } vector<string> FileUtil::splitExt(const string &filename) { auto it = filename.find_last_of('.'); return {filename.substr(0, it), filename.substr(it)}; } vector<string> FileUtil::findFiles(const string &path) { vector<string> files; for (auto &entry : fs::directory_iterator(path)) { fs::path filePath = entry.path(); files.push_back(filePath.make_preferred().string()); } return files; } vector<string> FileUtil::findFiles(const string &path, const string &ext) { vector<string> files; for (auto &entry : fs::directory_iterator(path)) { fs::path filePath = entry.path(); if (filePath.extension() != ext) continue; files.push_back(filePath.make_preferred().string()); } return files; } vector<string> FileUtil::filterFiles(const vector<string> &files, const string &fileFilter) { vector<string> filteredFiles; for (const string &file : files) { if (strstr(file.c_str(), fileFilter.c_str())) filteredFiles.push_back(file); } return filteredFiles; } vector<string> FileUtil::findFiles(const vector<string> &paths, const vector<string> &extensions) { vector<string> files; for (const string &path : paths) { for (const string &ext : extensions) { vector<string> filteredFiles = findFiles(path, ext); files.insert(files.end(), filteredFiles.begin(), filteredFiles.end()); } } return files; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/FileUtil.cpp"},{"location":"api/Files/FileUtil_8cpp/#srcngfxcorefileutilcpp","text":"","title":"src/ngfx/core/FileUtil.cpp"},{"location":"api/Files/FileUtil_8cpp/#namespaces","text":"Name std std::chrono","title":"Namespaces"},{"location":"api/Files/FileUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"FileUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/File.h\" #include <cassert> #include <chrono> #include <cstring> #include <fstream> using namespace std; namespace fs = std::filesystem; using namespace ngfx; using namespace std::chrono; bool FileUtil::getmtime(const string &filename, fs::file_time_type &mtime) { if (!fs::exists(filename)) { return false; } mtime = fs::last_write_time(filename); return true; } bool FileUtil::srcFileNewerThanOutFile(const string &srcFileName, const string &targetFileName) { fs::file_time_type srcTimeStamp, targetTimeStamp; getmtime(srcFileName, srcTimeStamp); if (!getmtime(targetFileName, targetTimeStamp)) return true; if (srcTimeStamp > targetTimeStamp) return true; return false; } string FileUtil::tempDir() { return fs::canonical(fs::temp_directory_path()).string(); } FileUtil::Lock::Lock(const std::string &path, uint32_t timeoutMs) : lockPath(path + \".lock\"), timeoutMs(timeoutMs) { fs::path fpath(path); auto t0 = system_clock::now(); while (fs::exists(lockPath)) { std::this_thread::sleep_for(milliseconds(10)); auto t1 = system_clock::now(); if (duration_cast<milliseconds>(t1 - t0).count() > timeoutMs) { NGFX_ERR(\"file locked: %s, timeoutMs: %d\", path.c_str(), timeoutMs); } } writeFile(lockPath, \"\"); } FileUtil::Lock::~Lock() { fs::remove(lockPath); } string FileUtil::readFile(const string &path) { File file; file.read(path); return string(file.data.get(), file.size); } void FileUtil::writeFile(const string &path, const string &contents) { ofstream out(path, ofstream::binary); assert(out); out.write(contents.data(), contents.size()); out.close(); } vector<string> FileUtil::splitExt(const string &filename) { auto it = filename.find_last_of('.'); return {filename.substr(0, it), filename.substr(it)}; } vector<string> FileUtil::findFiles(const string &path) { vector<string> files; for (auto &entry : fs::directory_iterator(path)) { fs::path filePath = entry.path(); files.push_back(filePath.make_preferred().string()); } return files; } vector<string> FileUtil::findFiles(const string &path, const string &ext) { vector<string> files; for (auto &entry : fs::directory_iterator(path)) { fs::path filePath = entry.path(); if (filePath.extension() != ext) continue; files.push_back(filePath.make_preferred().string()); } return files; } vector<string> FileUtil::filterFiles(const vector<string> &files, const string &fileFilter) { vector<string> filteredFiles; for (const string &file : files) { if (strstr(file.c_str(), fileFilter.c_str())) filteredFiles.push_back(file); } return filteredFiles; } vector<string> FileUtil::findFiles(const vector<string> &paths, const vector<string> &extensions) { vector<string> files; for (const string &path : paths) { for (const string &ext : extensions) { vector<string> filteredFiles = findFiles(path, ext); files.insert(files.end(), filteredFiles.begin(), filteredFiles.end()); } } return files; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/FileUtil_8h/","text":"src/ngfx/core/FileUtil.h Namespaces Name ngfx Classes Name class ngfx::FileUtil struct ngfx::FileUtil::Lock Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include <filesystem> #include <string> #include <thread> #include <vector> namespace ngfx { class FileUtil { public: static bool getmtime(const std::string &filename, std::filesystem::file_time_type &mtime); static bool srcFileNewerThanOutFile(const std::string &srcFileName, const std::string &targetFileName); static std::string tempDir(); struct Lock { Lock(const std::string &path, uint32_t timeoutMs = 3000); ~Lock(); std::string lockPath; uint32_t timeoutMs; }; static std::string readFile(const std::string &path); static void writeFile(const std::string &path, const std::string &contents); static std::vector<std::string> splitExt(const std::string &filename); static std::vector<std::string> findFiles(const std::string &path); static std::vector<std::string> findFiles(const std::string &path, const std::string &ext); static std::vector<std::string> filterFiles(const std::vector<std::string> &files, const std::string &fileFilter); static std::vector<std::string> findFiles(const std::vector<std::string> &paths, const std::vector<std::string> &extensions); }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/FileUtil.h"},{"location":"api/Files/FileUtil_8h/#srcngfxcorefileutilh","text":"","title":"src/ngfx/core/FileUtil.h"},{"location":"api/Files/FileUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/FileUtil_8h/#classes","text":"Name class ngfx::FileUtil struct ngfx::FileUtil::Lock","title":"Classes"},{"location":"api/Files/FileUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include <filesystem> #include <string> #include <thread> #include <vector> namespace ngfx { class FileUtil { public: static bool getmtime(const std::string &filename, std::filesystem::file_time_type &mtime); static bool srcFileNewerThanOutFile(const std::string &srcFileName, const std::string &targetFileName); static std::string tempDir(); struct Lock { Lock(const std::string &path, uint32_t timeoutMs = 3000); ~Lock(); std::string lockPath; uint32_t timeoutMs; }; static std::string readFile(const std::string &path); static void writeFile(const std::string &path, const std::string &contents); static std::vector<std::string> splitExt(const std::string &filename); static std::vector<std::string> findFiles(const std::string &path); static std::vector<std::string> findFiles(const std::string &path, const std::string &ext); static std::vector<std::string> filterFiles(const std::vector<std::string> &files, const std::string &fileFilter); static std::vector<std::string> findFiles(const std::vector<std::string> &paths, const std::vector<std::string> &extensions); }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/File_8cpp/","text":"src/ngfx/core/File.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/File.h\" #include \"ngfx/core/DebugUtil.h\" #include <cstdlib> #include <fstream> using namespace ngfx; void File::read(const std::string &filename) { std::ifstream in(filename.c_str(), std::ios::binary | std::ios::in | std::ios::ate); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); size = int(in.tellg()); in.seekg(0, std::ios::beg); data.reset(new char[size]); in.read(data.get(), size); in.close(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/File.cpp"},{"location":"api/Files/File_8cpp/#srcngfxcorefilecpp","text":"","title":"src/ngfx/core/File.cpp"},{"location":"api/Files/File_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/File.h\" #include \"ngfx/core/DebugUtil.h\" #include <cstdlib> #include <fstream> using namespace ngfx; void File::read(const std::string &filename) { std::ifstream in(filename.c_str(), std::ios::binary | std::ios::in | std::ios::ate); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); size = int(in.tellg()); in.seekg(0, std::ios::beg); data.reset(new char[size]); in.read(data.get(), size); in.close(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/File_8h/","text":"src/ngfx/core/File.h Namespaces Name ngfx Classes Name class ngfx::File Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <memory> #include <string> namespace ngfx { class File { public: void read(const std::string &filename); std::unique_ptr<char[]> data; int size; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/File.h"},{"location":"api/Files/File_8h/#srcngfxcorefileh","text":"","title":"src/ngfx/core/File.h"},{"location":"api/Files/File_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/File_8h/#classes","text":"Name class ngfx::File","title":"Classes"},{"location":"api/Files/File_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <memory> #include <string> namespace ngfx { class File { public: void read(const std::string &filename); std::unique_ptr<char[]> data; int size; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/FilterOp_8cpp/","text":"src/ngfx/graphics/FilterOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/FilterOp.h\" using namespace ngfx; FilterOp::FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight) : DrawOp(ctx) { uint32_t w = dstWidth, h = dstHeight, size = w * h * 4; outputTexture.reset(Texture::create( ctx, graphics, nullptr, PIXELFORMAT_RGBA8_UNORM, size, w, h, 1, 1, ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_DST_BIT | IMAGE_USAGE_COLOR_ATTACHMENT_BIT))); outputFramebuffer.reset(Framebuffer::create(ctx->device, ctx->defaultOffscreenRenderPass, {{outputTexture.get()}}, w, h)); } void FilterOp::apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics) { outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL); ctx->beginOffscreenRenderPass(commandBuffer, graphics, outputFramebuffer.get()); draw(commandBuffer, graphics); ctx->endOffscreenRenderPass(commandBuffer, graphics); outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/FilterOp.cpp"},{"location":"api/Files/FilterOp_8cpp/#srcngfxgraphicsfilteropcpp","text":"","title":"src/ngfx/graphics/FilterOp.cpp"},{"location":"api/Files/FilterOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/FilterOp.h\" using namespace ngfx; FilterOp::FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight) : DrawOp(ctx) { uint32_t w = dstWidth, h = dstHeight, size = w * h * 4; outputTexture.reset(Texture::create( ctx, graphics, nullptr, PIXELFORMAT_RGBA8_UNORM, size, w, h, 1, 1, ImageUsageFlags(IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_DST_BIT | IMAGE_USAGE_COLOR_ATTACHMENT_BIT))); outputFramebuffer.reset(Framebuffer::create(ctx->device, ctx->defaultOffscreenRenderPass, {{outputTexture.get()}}, w, h)); } void FilterOp::apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics) { outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL); ctx->beginOffscreenRenderPass(commandBuffer, graphics, outputFramebuffer.get()); draw(commandBuffer, graphics); ctx->endOffscreenRenderPass(commandBuffer, graphics); outputTexture->changeLayout(commandBuffer, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/FilterOp_8h/","text":"src/ngfx/graphics/FilterOp.h Namespaces Name ngfx Classes Name class ngfx::FilterOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class FilterOp : public DrawOp { public: FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight); virtual ~FilterOp() {} void apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics); std::unique_ptr<Texture> outputTexture; std::unique_ptr<Framebuffer> outputFramebuffer; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/FilterOp.h"},{"location":"api/Files/FilterOp_8h/#srcngfxgraphicsfilteroph","text":"","title":"src/ngfx/graphics/FilterOp.h"},{"location":"api/Files/FilterOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/FilterOp_8h/#classes","text":"Name class ngfx::FilterOp","title":"Classes"},{"location":"api/Files/FilterOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/DrawOp.h\" #include \"ngfx/graphics/GraphicsContext.h\" namespace ngfx { class FilterOp : public DrawOp { public: FilterOp(GraphicsContext *ctx, Graphics *graphics, uint32_t dstWidth, uint32_t dstHeight); virtual ~FilterOp() {} void apply(GraphicsContext *ctx, CommandBuffer *commandBuffer, Graphics *graphics); std::unique_ptr<Texture> outputTexture; std::unique_ptr<Framebuffer> outputFramebuffer; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Framebuffer_8h/","text":"src/ngfx/graphics/Framebuffer.h Namespaces Name ngfx Classes Name class ngfx::Framebuffer struct ngfx::Framebuffer::Attachment Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Texture.h\" #include <vector> namespace ngfx { class Framebuffer { public: struct Attachment { Texture *texture = nullptr; uint32_t level = 0, layer = 0; }; static Framebuffer *create(Device *device, RenderPass *renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers = 1); virtual ~Framebuffer() {} uint32_t w, h, layers, numAttachments; std::vector<Attachment> attachments; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Framebuffer.h"},{"location":"api/Files/Framebuffer_8h/#srcngfxgraphicsframebufferh","text":"","title":"src/ngfx/graphics/Framebuffer.h"},{"location":"api/Files/Framebuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Framebuffer_8h/#classes","text":"Name class ngfx::Framebuffer struct ngfx::Framebuffer::Attachment","title":"Classes"},{"location":"api/Files/Framebuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Texture.h\" #include <vector> namespace ngfx { class Framebuffer { public: struct Attachment { Texture *texture = nullptr; uint32_t level = 0, layer = 0; }; static Framebuffer *create(Device *device, RenderPass *renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers = 1); virtual ~Framebuffer() {} uint32_t w, h, layers, numAttachments; std::vector<Attachment> attachments; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/GLFWInputMap_8h/","text":"src/ngfx/porting/glfw/GLFWInputMap.h Namespaces Name ngfx Defines Name GLFW (v) Macro Documentation define GLFW #define GLFW( v ) v = GLFW_##v Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <GLFW/glfw3.h> #define GLFW(v) v = GLFW_##v namespace ngfx { enum KeyCode { GLFW(KEY_UP), GLFW(KEY_DOWN), GLFW(KEY_LEFT), GLFW(KEY_RIGHT) }; enum InputAction { GLFW(RELEASE), GLFW(PRESS) }; enum MouseButton { GLFW(MOUSE_BUTTON_LEFT), GLFW(MOUSE_BUTTON_MIDDLE), GLFW(MOUSE_BUTTON_RIGHT) }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/glfw/GLFWInputMap.h"},{"location":"api/Files/GLFWInputMap_8h/#srcngfxportingglfwglfwinputmaph","text":"","title":"src/ngfx/porting/glfw/GLFWInputMap.h"},{"location":"api/Files/GLFWInputMap_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GLFWInputMap_8h/#defines","text":"Name GLFW (v)","title":"Defines"},{"location":"api/Files/GLFWInputMap_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/GLFWInputMap_8h/#define-glfw","text":"#define GLFW( v ) v = GLFW_##v","title":"define GLFW"},{"location":"api/Files/GLFWInputMap_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <GLFW/glfw3.h> #define GLFW(v) v = GLFW_##v namespace ngfx { enum KeyCode { GLFW(KEY_UP), GLFW(KEY_DOWN), GLFW(KEY_LEFT), GLFW(KEY_RIGHT) }; enum InputAction { GLFW(RELEASE), GLFW(PRESS) }; enum MouseButton { GLFW(MOUSE_BUTTON_LEFT), GLFW(MOUSE_BUTTON_MIDDLE), GLFW(MOUSE_BUTTON_RIGHT) }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/GLFWWindow_8cpp/","text":"src/ngfx/porting/glfw/GLFWWindow.cpp Functions Name void glfwOnError (int errorCode, const char * msg) void glfwOnKey (GLFWwindow * window, int key, int scancode, int action, int mods) void glfwOnScroll (GLFWwindow * window, double xoffset, double yoffset) void glfwOnCursorPos (GLFWwindow * window, double x, double y) void glfwOnMouseButton (GLFWwindow * window, int button, int action, int mods) Functions Documentation function glfwOnError static void glfwOnError( int errorCode, const char * msg ) function glfwOnKey static void glfwOnKey( GLFWwindow * window, int key, int scancode, int action, int mods ) function glfwOnScroll static void glfwOnScroll( GLFWwindow * window, double xoffset, double yoffset ) function glfwOnCursorPos static void glfwOnCursorPos( GLFWwindow * window, double x, double y ) function glfwOnMouseButton static void glfwOnMouseButton( GLFWwindow * window, int button, int action, int mods ) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/glfw/GLFWWindow.h\" #include \"ngfx/input/InputMap.h\" #ifdef NGFX_GRAPHICS_BACKEND_VULKAN #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #endif using namespace ngfx; static void glfwOnError(int errorCode, const char *msg) { NGFX_LOG(\"[%d]: %s\", errorCode, msg); } static void glfwOnKey(GLFWwindow *window, int key, int scancode, int action, int mods) { GLFWWindow *thiz = (GLFWWindow *)glfwGetWindowUserPointer(window); if (thiz->onKey) thiz->onKey(ngfx::KeyCode(key), InputAction(action)); } static void glfwOnScroll(GLFWwindow *window, double xoffset, double yoffset) { GLFWWindow *thiz = (GLFWWindow *)glfwGetWindowUserPointer(window); if (thiz->onScroll) thiz->onScroll(xoffset, yoffset); } static void glfwOnCursorPos(GLFWwindow *window, double x, double y) { GLFWWindow *thiz = (GLFWWindow *)glfwGetWindowUserPointer(window); if (thiz->onCursorPos) thiz->onCursorPos(x, y); } static void glfwOnMouseButton(GLFWwindow *window, int button, int action, int mods) { GLFWWindow *thiz = (GLFWWindow *)glfwGetWindowUserPointer(window); if (thiz->onMouseButton) thiz->onMouseButton(MouseButton(button), InputAction(action)); } void GLFWWindow::create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w, int h) { #ifdef NGFX_GRAPHICS_BACKEND_VULKAN this->instance = vk(graphicsContext)->vkInstance.v; VkResult vkResult; #endif glfwSetErrorCallback(glfwOnError); int result = glfwInit(); if (result != GLFW_TRUE) NGFX_ERR(\"glfwInit failed\"); #ifdef NGFX_GRAPHICS_BACKEND_VULKAN glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); #endif glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); auto monitor = glfwGetPrimaryMonitor(); auto videoMode = glfwGetVideoMode(monitor); if (w == Window::DISPLAY_WIDTH) w = videoMode->width; if (h == Window::DISPLAY_HEIGHT) h = videoMode->height; v = glfwCreateWindow(w, h, title, nullptr, nullptr); glfwGetFramebufferSize(v, &w, &h); glfwSetWindowUserPointer(v, this); glfwSetKeyCallback(v, ::glfwOnKey); glfwSetScrollCallback(v, ::glfwOnScroll); glfwSetCursorPosCallback(v, ::glfwOnCursorPos); glfwSetMouseButtonCallback(v, ::glfwOnMouseButton); this->w = w; this->h = h; #ifdef NGFX_GRAPHICS_BACKEND_VULKAN V(glfwCreateWindowSurface(instance, v, NULL, &vkSurface.v)); vkSurface.instance = instance; vkSurface.w = w; vkSurface.h = h; surface = &vkSurface; #endif onWindowCreated(this); } GLFWWindow::~GLFWWindow() {} ngfx::Window * ngfx::Window::create(GraphicsContext *graphicsContext, const char *title, std::function<void(ngfx::Window *thiz)> setWindow, int w, int h) { auto window = new GLFWWindow(); window->create(graphicsContext, title, setWindow, w, h); return window; } bool GLFWWindow::shouldClose() { return glfwWindowShouldClose(v); } void GLFWWindow::pollEvents() { glfwPollEvents(); onUpdate(); onPaint(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/glfw/GLFWWindow.cpp"},{"location":"api/Files/GLFWWindow_8cpp/#srcngfxportingglfwglfwwindowcpp","text":"","title":"src/ngfx/porting/glfw/GLFWWindow.cpp"},{"location":"api/Files/GLFWWindow_8cpp/#functions","text":"Name void glfwOnError (int errorCode, const char * msg) void glfwOnKey (GLFWwindow * window, int key, int scancode, int action, int mods) void glfwOnScroll (GLFWwindow * window, double xoffset, double yoffset) void glfwOnCursorPos (GLFWwindow * window, double x, double y) void glfwOnMouseButton (GLFWwindow * window, int button, int action, int mods)","title":"Functions"},{"location":"api/Files/GLFWWindow_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/GLFWWindow_8cpp/#function-glfwonerror","text":"static void glfwOnError( int errorCode, const char * msg )","title":"function glfwOnError"},{"location":"api/Files/GLFWWindow_8cpp/#function-glfwonkey","text":"static void glfwOnKey( GLFWwindow * window, int key, int scancode, int action, int mods )","title":"function glfwOnKey"},{"location":"api/Files/GLFWWindow_8cpp/#function-glfwonscroll","text":"static void glfwOnScroll( GLFWwindow * window, double xoffset, double yoffset )","title":"function glfwOnScroll"},{"location":"api/Files/GLFWWindow_8cpp/#function-glfwoncursorpos","text":"static void glfwOnCursorPos( GLFWwindow * window, double x, double y )","title":"function glfwOnCursorPos"},{"location":"api/Files/GLFWWindow_8cpp/#function-glfwonmousebutton","text":"static void glfwOnMouseButton( GLFWwindow * window, int button, int action, int mods )","title":"function glfwOnMouseButton"},{"location":"api/Files/GLFWWindow_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/glfw/GLFWWindow.h\" #include \"ngfx/input/InputMap.h\" #ifdef NGFX_GRAPHICS_BACKEND_VULKAN #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #endif using namespace ngfx; static void glfwOnError(int errorCode, const char *msg) { NGFX_LOG(\"[%d]: %s\", errorCode, msg); } static void glfwOnKey(GLFWwindow *window, int key, int scancode, int action, int mods) { GLFWWindow *thiz = (GLFWWindow *)glfwGetWindowUserPointer(window); if (thiz->onKey) thiz->onKey(ngfx::KeyCode(key), InputAction(action)); } static void glfwOnScroll(GLFWwindow *window, double xoffset, double yoffset) { GLFWWindow *thiz = (GLFWWindow *)glfwGetWindowUserPointer(window); if (thiz->onScroll) thiz->onScroll(xoffset, yoffset); } static void glfwOnCursorPos(GLFWwindow *window, double x, double y) { GLFWWindow *thiz = (GLFWWindow *)glfwGetWindowUserPointer(window); if (thiz->onCursorPos) thiz->onCursorPos(x, y); } static void glfwOnMouseButton(GLFWwindow *window, int button, int action, int mods) { GLFWWindow *thiz = (GLFWWindow *)glfwGetWindowUserPointer(window); if (thiz->onMouseButton) thiz->onMouseButton(MouseButton(button), InputAction(action)); } void GLFWWindow::create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w, int h) { #ifdef NGFX_GRAPHICS_BACKEND_VULKAN this->instance = vk(graphicsContext)->vkInstance.v; VkResult vkResult; #endif glfwSetErrorCallback(glfwOnError); int result = glfwInit(); if (result != GLFW_TRUE) NGFX_ERR(\"glfwInit failed\"); #ifdef NGFX_GRAPHICS_BACKEND_VULKAN glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); #endif glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); auto monitor = glfwGetPrimaryMonitor(); auto videoMode = glfwGetVideoMode(monitor); if (w == Window::DISPLAY_WIDTH) w = videoMode->width; if (h == Window::DISPLAY_HEIGHT) h = videoMode->height; v = glfwCreateWindow(w, h, title, nullptr, nullptr); glfwGetFramebufferSize(v, &w, &h); glfwSetWindowUserPointer(v, this); glfwSetKeyCallback(v, ::glfwOnKey); glfwSetScrollCallback(v, ::glfwOnScroll); glfwSetCursorPosCallback(v, ::glfwOnCursorPos); glfwSetMouseButtonCallback(v, ::glfwOnMouseButton); this->w = w; this->h = h; #ifdef NGFX_GRAPHICS_BACKEND_VULKAN V(glfwCreateWindowSurface(instance, v, NULL, &vkSurface.v)); vkSurface.instance = instance; vkSurface.w = w; vkSurface.h = h; surface = &vkSurface; #endif onWindowCreated(this); } GLFWWindow::~GLFWWindow() {} ngfx::Window * ngfx::Window::create(GraphicsContext *graphicsContext, const char *title, std::function<void(ngfx::Window *thiz)> setWindow, int w, int h) { auto window = new GLFWWindow(); window->create(graphicsContext, title, setWindow, w, h); return window; } bool GLFWWindow::shouldClose() { return glfwWindowShouldClose(v); } void GLFWWindow::pollEvents() { glfwPollEvents(); onUpdate(); onPaint(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/GLFWWindow_8h/","text":"src/ngfx/porting/glfw/GLFWWindow.h Namespaces Name ngfx Classes Name class ngfx::GLFWWindow Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsContext.h\" #ifdef NGFX_GRAPHICS_BACKEND_VULKAN #include \"ngfx/porting/vulkan/VKWindow.h\" #endif #include <GLFW/glfw3.h> namespace ngfx { #ifdef NGFX_GRAPHICS_BACKEND_VULKAN class GLFWWindow : public VKWindow { #else class GLFWWindow { #endif public: void create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> setWindow, int w, int h); virtual bool shouldClose(); virtual void pollEvents(); virtual ~GLFWWindow(); GLFWwindow *v; protected: }; inline GLFWWindow *glfw(Window *window) { return (GLFWWindow *)window; } } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/glfw/GLFWWindow.h"},{"location":"api/Files/GLFWWindow_8h/#srcngfxportingglfwglfwwindowh","text":"","title":"src/ngfx/porting/glfw/GLFWWindow.h"},{"location":"api/Files/GLFWWindow_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GLFWWindow_8h/#classes","text":"Name class ngfx::GLFWWindow","title":"Classes"},{"location":"api/Files/GLFWWindow_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsContext.h\" #ifdef NGFX_GRAPHICS_BACKEND_VULKAN #include \"ngfx/porting/vulkan/VKWindow.h\" #endif #include <GLFW/glfw3.h> namespace ngfx { #ifdef NGFX_GRAPHICS_BACKEND_VULKAN class GLFWWindow : public VKWindow { #else class GLFWWindow { #endif public: void create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> setWindow, int w, int h); virtual bool shouldClose(); virtual void pollEvents(); virtual ~GLFWWindow(); GLFWwindow *v; protected: }; inline GLFWWindow *glfw(Window *window) { return (GLFWWindow *)window; } } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/GraphicsContext_8h/","text":"src/ngfx/graphics/GraphicsContext.h Namespaces Name ngfx Classes Name class ngfx::GraphicsContext struct ngfx::GraphicsContext::AttachmentDescription struct ngfx::GraphicsContext::RenderPassConfig Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePass.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/PipelineCache.h\" #include \"ngfx/graphics/Queue.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Surface.h\" #include \"ngfx/graphics/Swapchain.h\" #include <optional> #include <vector> namespace ngfx { class GraphicsContext { public: static GraphicsContext *create(const char *appName, bool enableDepthStencil = false, bool debug = true); virtual ~GraphicsContext() {} virtual void setSurface(Surface *surface) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { auto framebuffer = swapchainFramebuffers[currentImageIndex]; uint32_t w = framebuffer->w, h = framebuffer->h; graphics->beginRenderPass(commandBuffer, defaultRenderPass, framebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, w, h}); graphics->setScissor(commandBuffer, {0, 0, w, h}); } virtual void beginOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics, Framebuffer *outputFramebuffer) { graphics->beginRenderPass(commandBuffer, defaultOffscreenRenderPass, outputFramebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); graphics->setScissor(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); } virtual void endRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void endOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void submit(CommandBuffer *commandBuffer) { queue->submit(commandBuffer); } Device *device; uint32_t numDrawCommandBuffers = 0; virtual CommandBuffer *drawCommandBuffer(int32_t index = -1) = 0; virtual CommandBuffer *copyCommandBuffer() = 0; virtual CommandBuffer *computeCommandBuffer() = 0; struct AttachmentDescription { bool operator==(const AttachmentDescription &rhs) const { return rhs.format == format && rhs.initialLayout == initialLayout && rhs.finalLayout == finalLayout; } PixelFormat format; std::optional<ImageLayout> initialLayout, finalLayout; }; struct RenderPassConfig { bool operator==(const RenderPassConfig &rhs) const { return rhs.colorAttachmentDescriptions == colorAttachmentDescriptions && rhs.depthStencilAttachmentDescription == depthStencilAttachmentDescription && rhs.enableDepthStencilResolve == enableDepthStencilResolve && rhs.numSamples == numSamples; }; uint32_t numColorAttachments() const { return uint32_t(colorAttachmentDescriptions.size()); } std::vector<AttachmentDescription> colorAttachmentDescriptions; std::optional<AttachmentDescription> depthStencilAttachmentDescription; bool enableDepthStencilResolve = false; uint32_t numSamples = 1; }; virtual RenderPass *getRenderPass(RenderPassConfig config) = 0; std::vector<Framebuffer *> swapchainFramebuffers; Queue *queue = nullptr; RenderPass *defaultRenderPass = nullptr, *defaultOffscreenRenderPass = nullptr; Swapchain *swapchain = nullptr; Surface *surface = nullptr; uint32_t currentImageIndex = 0; std::vector<Fence *> frameFences; Fence *computeFence = nullptr; Semaphore *presentCompleteSemaphore = nullptr, *renderCompleteSemaphore = nullptr; PipelineCache *pipelineCache = nullptr; PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED, defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED, depthFormat = PIXELFORMAT_UNDEFINED; glm::vec4 clearColor = glm::vec4(0.0f); protected: bool debug = false, enableDepthStencil = false; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/GraphicsContext.h"},{"location":"api/Files/GraphicsContext_8h/#srcngfxgraphicsgraphicscontexth","text":"","title":"src/ngfx/graphics/GraphicsContext.h"},{"location":"api/Files/GraphicsContext_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GraphicsContext_8h/#classes","text":"Name class ngfx::GraphicsContext struct ngfx::GraphicsContext::AttachmentDescription struct ngfx::GraphicsContext::RenderPassConfig","title":"Classes"},{"location":"api/Files/GraphicsContext_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePass.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/graphics/PipelineCache.h\" #include \"ngfx/graphics/Queue.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/Surface.h\" #include \"ngfx/graphics/Swapchain.h\" #include <optional> #include <vector> namespace ngfx { class GraphicsContext { public: static GraphicsContext *create(const char *appName, bool enableDepthStencil = false, bool debug = true); virtual ~GraphicsContext() {} virtual void setSurface(Surface *surface) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { auto framebuffer = swapchainFramebuffers[currentImageIndex]; uint32_t w = framebuffer->w, h = framebuffer->h; graphics->beginRenderPass(commandBuffer, defaultRenderPass, framebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, w, h}); graphics->setScissor(commandBuffer, {0, 0, w, h}); } virtual void beginOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics, Framebuffer *outputFramebuffer) { graphics->beginRenderPass(commandBuffer, defaultOffscreenRenderPass, outputFramebuffer, clearColor); graphics->setViewport(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); graphics->setScissor(commandBuffer, {0, 0, outputFramebuffer->w, outputFramebuffer->h}); } virtual void endRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void endOffscreenRenderPass(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->endRenderPass(commandBuffer); } virtual void submit(CommandBuffer *commandBuffer) { queue->submit(commandBuffer); } Device *device; uint32_t numDrawCommandBuffers = 0; virtual CommandBuffer *drawCommandBuffer(int32_t index = -1) = 0; virtual CommandBuffer *copyCommandBuffer() = 0; virtual CommandBuffer *computeCommandBuffer() = 0; struct AttachmentDescription { bool operator==(const AttachmentDescription &rhs) const { return rhs.format == format && rhs.initialLayout == initialLayout && rhs.finalLayout == finalLayout; } PixelFormat format; std::optional<ImageLayout> initialLayout, finalLayout; }; struct RenderPassConfig { bool operator==(const RenderPassConfig &rhs) const { return rhs.colorAttachmentDescriptions == colorAttachmentDescriptions && rhs.depthStencilAttachmentDescription == depthStencilAttachmentDescription && rhs.enableDepthStencilResolve == enableDepthStencilResolve && rhs.numSamples == numSamples; }; uint32_t numColorAttachments() const { return uint32_t(colorAttachmentDescriptions.size()); } std::vector<AttachmentDescription> colorAttachmentDescriptions; std::optional<AttachmentDescription> depthStencilAttachmentDescription; bool enableDepthStencilResolve = false; uint32_t numSamples = 1; }; virtual RenderPass *getRenderPass(RenderPassConfig config) = 0; std::vector<Framebuffer *> swapchainFramebuffers; Queue *queue = nullptr; RenderPass *defaultRenderPass = nullptr, *defaultOffscreenRenderPass = nullptr; Swapchain *swapchain = nullptr; Surface *surface = nullptr; uint32_t currentImageIndex = 0; std::vector<Fence *> frameFences; Fence *computeFence = nullptr; Semaphore *presentCompleteSemaphore = nullptr, *renderCompleteSemaphore = nullptr; PipelineCache *pipelineCache = nullptr; PixelFormat surfaceFormat = PIXELFORMAT_UNDEFINED, defaultOffscreenSurfaceFormat = PIXELFORMAT_UNDEFINED, depthFormat = PIXELFORMAT_UNDEFINED; glm::vec4 clearColor = glm::vec4(0.0f); protected: bool debug = false, enableDepthStencil = false; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/GraphicsCore_8h/","text":"src/ngfx/graphics/GraphicsCore.h Namespaces Name ngfx Classes Name struct ngfx::Rect2D Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> #include <string> #ifdef NGFX_GRAPHICS_BACKEND_VULKAN #include \"ngfx/porting/vulkan/VKGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_DIRECT3D12 #include \"ngfx/porting/d3d/D3DGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_METAL #include \"ngfx/porting/metal/MTLGraphicsCore.h\" #endif namespace ngfx { typedef uint32_t Flags; typedef Flags PipelineStageFlags; typedef Flags ShaderStageFlags; typedef Flags FenceCreateFlags; typedef Flags ImageUsageFlags; typedef Flags ColorComponentFlags; typedef Flags BufferUsageFlags; struct Rect2D { int32_t x, y; uint32_t w, h; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/GraphicsCore.h"},{"location":"api/Files/GraphicsCore_8h/#srcngfxgraphicsgraphicscoreh","text":"","title":"src/ngfx/graphics/GraphicsCore.h"},{"location":"api/Files/GraphicsCore_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GraphicsCore_8h/#classes","text":"Name struct ngfx::Rect2D","title":"Classes"},{"location":"api/Files/GraphicsCore_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> #include <string> #ifdef NGFX_GRAPHICS_BACKEND_VULKAN #include \"ngfx/porting/vulkan/VKGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_DIRECT3D12 #include \"ngfx/porting/d3d/D3DGraphicsCore.h\" #endif #ifdef NGFX_GRAPHICS_BACKEND_METAL #include \"ngfx/porting/metal/MTLGraphicsCore.h\" #endif namespace ngfx { typedef uint32_t Flags; typedef Flags PipelineStageFlags; typedef Flags ShaderStageFlags; typedef Flags FenceCreateFlags; typedef Flags ImageUsageFlags; typedef Flags ColorComponentFlags; typedef Flags BufferUsageFlags; struct Rect2D { int32_t x, y; uint32_t w, h; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/GraphicsPipeline_8cpp/","text":"src/ngfx/graphics/GraphicsPipeline.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/GraphicsPipeline.h\" #include <set> using namespace ngfx; void GraphicsPipeline::getBindings( std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings) { for (uint32_t j = 0; j < pDescriptorBindings.size(); j++) *pDescriptorBindings[j] = descriptorBindings[j]; for (uint32_t j = 0; j < pVertexAttribBindings.size(); j++) *pVertexAttribBindings[j] = vertexAttributeBindings[j]; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/GraphicsPipeline.cpp"},{"location":"api/Files/GraphicsPipeline_8cpp/#srcngfxgraphicsgraphicspipelinecpp","text":"","title":"src/ngfx/graphics/GraphicsPipeline.cpp"},{"location":"api/Files/GraphicsPipeline_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/GraphicsPipeline.h\" #include <set> using namespace ngfx; void GraphicsPipeline::getBindings( std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings) { for (uint32_t j = 0; j < pDescriptorBindings.size(); j++) *pDescriptorBindings[j] = descriptorBindings[j]; for (uint32_t j = 0; j < pVertexAttribBindings.size(); j++) *pVertexAttribBindings[j] = vertexAttributeBindings[j]; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/GraphicsPipeline_8h/","text":"src/ngfx/graphics/GraphicsPipeline.h Namespaces Name ngfx Classes Name class ngfx::GraphicsPipeline struct ngfx::GraphicsPipeline::State struct ngfx::GraphicsPipeline::Descriptor Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Pipeline.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/ShaderModule.h\" #include <set> #include <vector> namespace ngfx { class GraphicsContext; class GraphicsPipeline : public Pipeline { public: struct State { PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; PolygonMode polygonMode = POLYGON_MODE_FILL; bool blendEnable = false; BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendOp colorBlendOp = BLEND_OP_ADD, alphaBlendOp = BLEND_OP_ADD; uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT; CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT; FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE; float lineWidth = 1.0f; bool depthTestEnable = false, depthWriteEnable = false; RenderPass *renderPass = nullptr; uint32_t numSamples = 1, numColorAttachments = 1; }; struct Descriptor { DescriptorType type; ShaderStageFlags stageFlags = SHADER_STAGE_ALL; }; static GraphicsPipeline * create(GraphicsContext *graphicsContext, const State &state, VertexShaderModule *vs, FragmentShaderModule *fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes = {}); virtual ~GraphicsPipeline() {} void getBindings(std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings); std::vector<uint32_t> descriptorBindings, vertexAttributeBindings; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/GraphicsPipeline.h"},{"location":"api/Files/GraphicsPipeline_8h/#srcngfxgraphicsgraphicspipelineh","text":"","title":"src/ngfx/graphics/GraphicsPipeline.h"},{"location":"api/Files/GraphicsPipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/GraphicsPipeline_8h/#classes","text":"Name class ngfx::GraphicsPipeline struct ngfx::GraphicsPipeline::State struct ngfx::GraphicsPipeline::Descriptor","title":"Classes"},{"location":"api/Files/GraphicsPipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Pipeline.h\" #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/graphics/ShaderModule.h\" #include <set> #include <vector> namespace ngfx { class GraphicsContext; class GraphicsPipeline : public Pipeline { public: struct State { PrimitiveTopology primitiveTopology = PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; PolygonMode polygonMode = POLYGON_MODE_FILL; bool blendEnable = false; BlendFactor srcColorBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstColorBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendFactor srcAlphaBlendFactor = BLEND_FACTOR_SRC_ALPHA; BlendFactor dstAlphaBlendFactor = BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; BlendOp colorBlendOp = BLEND_OP_ADD, alphaBlendOp = BLEND_OP_ADD; uint8_t colorWriteMask = COLOR_COMPONENT_R_BIT | COLOR_COMPONENT_G_BIT | COLOR_COMPONENT_B_BIT | COLOR_COMPONENT_A_BIT; CullModeFlags cullModeFlags = CULL_MODE_BACK_BIT; FrontFace frontFace = FRONT_FACE_COUNTER_CLOCKWISE; float lineWidth = 1.0f; bool depthTestEnable = false, depthWriteEnable = false; RenderPass *renderPass = nullptr; uint32_t numSamples = 1, numColorAttachments = 1; }; struct Descriptor { DescriptorType type; ShaderStageFlags stageFlags = SHADER_STAGE_ALL; }; static GraphicsPipeline * create(GraphicsContext *graphicsContext, const State &state, VertexShaderModule *vs, FragmentShaderModule *fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes = {}); virtual ~GraphicsPipeline() {} void getBindings(std::vector<uint32_t *> pDescriptorBindings, std::vector<uint32_t *> pVertexAttribBindings); std::vector<uint32_t> descriptorBindings, vertexAttributeBindings; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Graphics_8h/","text":"src/ngfx/graphics/Graphics.h Namespaces Name ngfx Classes Name class ngfx::Graphics Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/graphics/Texture.h\" #include <cstdint> #include <glm/glm.hpp> namespace ngfx { class Graphics { public: static Graphics *create(GraphicsContext *ctx); virtual ~Graphics() {} virtual void beginComputePass(CommandBuffer *commandBuffer) = 0; virtual void endComputePass(CommandBuffer *commandBuffer) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) = 0; virtual void endRenderPass(CommandBuffer *commandBuffer) = 0; virtual void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) = 0; virtual void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat = INDEXFORMAT_UINT32) = 0; virtual void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) = 0; virtual void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) = 0; virtual void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) = 0; // TODO: copyBuffer: ToBuffer, copyBuffer: ToTexture, copyTexture: ToBuffer, // blit virtual void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) = 0; virtual void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) = 0; virtual void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) = 0; virtual void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void waitIdle(CommandBuffer *cmdBuffer) = 0; Rect2D scissorRect; Rect2D viewport; Pipeline *currentPipeline = nullptr; RenderPass *currentRenderPass = nullptr; Framebuffer *currentFramebuffer = nullptr; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Graphics.h"},{"location":"api/Files/Graphics_8h/#srcngfxgraphicsgraphicsh","text":"","title":"src/ngfx/graphics/Graphics.h"},{"location":"api/Files/Graphics_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Graphics_8h/#classes","text":"Name class ngfx::Graphics","title":"Classes"},{"location":"api/Files/Graphics_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/graphics/Texture.h\" #include <cstdint> #include <glm/glm.hpp> namespace ngfx { class Graphics { public: static Graphics *create(GraphicsContext *ctx); virtual ~Graphics() {} virtual void beginComputePass(CommandBuffer *commandBuffer) = 0; virtual void endComputePass(CommandBuffer *commandBuffer) = 0; virtual void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) = 0; virtual void endRenderPass(CommandBuffer *commandBuffer) = 0; virtual void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) = 0; virtual void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat = INDEXFORMAT_UINT32) = 0; virtual void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) = 0; virtual void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) = 0; virtual void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) = 0; virtual void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) = 0; // TODO: copyBuffer: ToBuffer, copyBuffer: ToTexture, copyTexture: ToBuffer, // blit virtual void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) = 0; virtual void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) = 0; virtual void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) = 0; virtual void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) = 0; virtual void waitIdle(CommandBuffer *cmdBuffer) = 0; Rect2D scissorRect; Rect2D viewport; Pipeline *currentPipeline = nullptr; RenderPass *currentRenderPass = nullptr; Framebuffer *currentFramebuffer = nullptr; protected: GraphicsContext *ctx; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/InputListener_8h/","text":"src/ngfx/input/InputListener.h Namespaces Name ngfx Classes Name class ngfx::InputListener Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/input/InputMap.h\" namespace ngfx { class InputListener { public: virtual void onKey(KeyCode code, InputAction action) {} virtual void onScroll(double xoffset, double yoffset) {} virtual void onCursorPos(double x, double y) {} virtual void onMouseButton(MouseButton button, InputAction action) {} }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/input/InputListener.h"},{"location":"api/Files/InputListener_8h/#srcngfxinputinputlistenerh","text":"","title":"src/ngfx/input/InputListener.h"},{"location":"api/Files/InputListener_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/InputListener_8h/#classes","text":"Name class ngfx::InputListener","title":"Classes"},{"location":"api/Files/InputListener_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/input/InputMap.h\" namespace ngfx { class InputListener { public: virtual void onKey(KeyCode code, InputAction action) {} virtual void onScroll(double xoffset, double yoffset) {} virtual void onCursorPos(double x, double y) {} virtual void onMouseButton(MouseButton button, InputAction action) {} }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/InputMap_8h/","text":"src/ngfx/input/InputMap.h Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #ifdef NGFX_WINDOW_BACKEND_GLFW #include \"ngfx/porting/glfw/GLFWInputMap.h\" #endif #ifdef NGFX_WINDOW_BACKEND_WINDOWS #include \"ngfx/porting/windows/WInputMap.h\" #endif #ifdef NGFX_WINDOW_BACKEND_APPKIT #include \"ngfx/porting/appkit/AppKitInputMap.h\" #endif Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/input/InputMap.h"},{"location":"api/Files/InputMap_8h/#srcngfxinputinputmaph","text":"","title":"src/ngfx/input/InputMap.h"},{"location":"api/Files/InputMap_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #ifdef NGFX_WINDOW_BACKEND_GLFW #include \"ngfx/porting/glfw/GLFWInputMap.h\" #endif #ifdef NGFX_WINDOW_BACKEND_WINDOWS #include \"ngfx/porting/windows/WInputMap.h\" #endif #ifdef NGFX_WINDOW_BACKEND_APPKIT #include \"ngfx/porting/appkit/AppKitInputMap.h\" #endif Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLApplication_8h/","text":"src/ngfx/porting/metal/MTLApplication.h Namespaces Name ngfx Classes Name class ngfx::MTLApplication Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/BaseApplication.h\" namespace ngfx { class MTLApplication : public BaseApplication { public: MTLApplication(const std::string &appName, int w = Window::DISPLAY_WIDTH, int h = Window::DISPLAY_HEIGHT, bool enableDepthStencil = false, bool offscreen = false); virtual ~MTLApplication() {} void init() override; void run() override; protected: void paint() override; private: std::string appName; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLApplication.h"},{"location":"api/Files/MTLApplication_8h/#srcngfxportingmetalmtlapplicationh","text":"","title":"src/ngfx/porting/metal/MTLApplication.h"},{"location":"api/Files/MTLApplication_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLApplication_8h/#classes","text":"Name class ngfx::MTLApplication","title":"Classes"},{"location":"api/Files/MTLApplication_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/BaseApplication.h\" namespace ngfx { class MTLApplication : public BaseApplication { public: MTLApplication(const std::string &appName, int w = Window::DISPLAY_WIDTH, int h = Window::DISPLAY_HEIGHT, bool enableDepthStencil = false, bool offscreen = false); virtual ~MTLApplication() {} void init() override; void run() override; protected: void paint() override; private: std::string appName; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLApplication_8mm/","text":"src/ngfx/porting/metal/MTLApplication.mm Attributes Name std::function< void(void *)> appInit std::function< void(void *)> appPaint std::function< void(void *)> appUpdate Attributes Documentation variable appInit std::function< void(void *)> appInit; variable appPaint std::function< void(void *)> appPaint; variable appUpdate std::function< void(void *)> appUpdate; Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"MTLApplication.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLSurface.h\" #include <functional> using namespace ngfx; using namespace std::placeholders; extern std::function<void(void*)> appInit, appPaint, appUpdate; MTLApplication::MTLApplication(const std::string& appName, int width, int height, bool enableDepthStencil, bool offscreen) : BaseApplication(appName, width, height, enableDepthStencil, offscreen) {} void MTLApplication::init() { if (offscreen) BaseApplication::init(); else { appInit = [&](void* view) { graphicsContext.reset(GraphicsContext::create(appName.c_str(), enableDepthStencil, true)); MTLSurface surface; MTKView* mtkView = (MTKView*)view; surface.view = mtkView; if (w != -1 && h != -1) { [mtkView setFrame: NSMakeRect(0, 0, w, h)]; } CGSize mtkViewSize = [mtkView drawableSize]; surface.w = mtkViewSize.width; surface.h = mtkViewSize.height; graphicsContext->setSurface(&surface); graphics.reset(Graphics::create(graphicsContext.get())); onInit(); }; appPaint = [&](void* view) { paint(); }; appUpdate = [&](void*) { onUpdate(); }; } } void MTLApplication::run() { init(); const char* argv[] = {\"\"}; NSApplicationMain(1, argv); } void MTLApplication::paint() { auto ctx = mtl(graphicsContext.get()); MTLCommandBuffer commandBuffer; commandBuffer.v = [ctx->mtlCommandQueue commandBuffer]; onRecordCommandBuffer(&commandBuffer); if (!offscreen) { MTKView* mtkView = (MTKView*)mtl(ctx->surface)->view; [commandBuffer.v presentDrawable:mtkView.currentDrawable]; } commandBuffer.commit(); if (offscreen) graphics->waitIdle(&commandBuffer); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLApplication.mm"},{"location":"api/Files/MTLApplication_8mm/#srcngfxportingmetalmtlapplicationmm","text":"","title":"src/ngfx/porting/metal/MTLApplication.mm"},{"location":"api/Files/MTLApplication_8mm/#attributes","text":"Name std::function< void(void *)> appInit std::function< void(void *)> appPaint std::function< void(void *)> appUpdate","title":"Attributes"},{"location":"api/Files/MTLApplication_8mm/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/MTLApplication_8mm/#variable-appinit","text":"std::function< void(void *)> appInit;","title":"variable appInit"},{"location":"api/Files/MTLApplication_8mm/#variable-apppaint","text":"std::function< void(void *)> appPaint;","title":"variable appPaint"},{"location":"api/Files/MTLApplication_8mm/#variable-appupdate","text":"std::function< void(void *)> appUpdate;","title":"variable appUpdate"},{"location":"api/Files/MTLApplication_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"MTLApplication.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLSurface.h\" #include <functional> using namespace ngfx; using namespace std::placeholders; extern std::function<void(void*)> appInit, appPaint, appUpdate; MTLApplication::MTLApplication(const std::string& appName, int width, int height, bool enableDepthStencil, bool offscreen) : BaseApplication(appName, width, height, enableDepthStencil, offscreen) {} void MTLApplication::init() { if (offscreen) BaseApplication::init(); else { appInit = [&](void* view) { graphicsContext.reset(GraphicsContext::create(appName.c_str(), enableDepthStencil, true)); MTLSurface surface; MTKView* mtkView = (MTKView*)view; surface.view = mtkView; if (w != -1 && h != -1) { [mtkView setFrame: NSMakeRect(0, 0, w, h)]; } CGSize mtkViewSize = [mtkView drawableSize]; surface.w = mtkViewSize.width; surface.h = mtkViewSize.height; graphicsContext->setSurface(&surface); graphics.reset(Graphics::create(graphicsContext.get())); onInit(); }; appPaint = [&](void* view) { paint(); }; appUpdate = [&](void*) { onUpdate(); }; } } void MTLApplication::run() { init(); const char* argv[] = {\"\"}; NSApplicationMain(1, argv); } void MTLApplication::paint() { auto ctx = mtl(graphicsContext.get()); MTLCommandBuffer commandBuffer; commandBuffer.v = [ctx->mtlCommandQueue commandBuffer]; onRecordCommandBuffer(&commandBuffer); if (!offscreen) { MTKView* mtkView = (MTKView*)mtl(ctx->surface)->view; [commandBuffer.v presentDrawable:mtkView.currentDrawable]; } commandBuffer.commit(); if (offscreen) graphics->waitIdle(&commandBuffer); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLBuffer_8h/","text":"src/ngfx/porting/metal/MTLBuffer.h Namespaces Name ngfx Classes Name class ngfx::MTLBuffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLGraphicsContext; class MTLBuffer : public Buffer { public: void create(MTLGraphicsContext *ctx, const void *data, uint32_t size, MTLResourceOptions resourceOptions); virtual ~MTLBuffer() {} void *map() override; void unmap() override; void upload(const void *data, uint32_t size, uint32_t offset = 0) override; void download(void *data, uint32_t size, uint32_t offset = 0) override; id<MTLBuffer> v; }; MTL_CAST(Buffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLBuffer.h"},{"location":"api/Files/MTLBuffer_8h/#srcngfxportingmetalmtlbufferh","text":"","title":"src/ngfx/porting/metal/MTLBuffer.h"},{"location":"api/Files/MTLBuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLBuffer_8h/#classes","text":"Name class ngfx::MTLBuffer","title":"Classes"},{"location":"api/Files/MTLBuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLGraphicsContext; class MTLBuffer : public Buffer { public: void create(MTLGraphicsContext *ctx, const void *data, uint32_t size, MTLResourceOptions resourceOptions); virtual ~MTLBuffer() {} void *map() override; void unmap() override; void upload(const void *data, uint32_t size, uint32_t offset = 0) override; void download(void *data, uint32_t size, uint32_t offset = 0) override; id<MTLBuffer> v; }; MTL_CAST(Buffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLBuffer_8mm/","text":"src/ngfx/porting/metal/MTLBuffer.mm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLBuffer.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void MTLBuffer::create(MTLGraphicsContext* ctx, const void* data, uint32_t size, MTLResourceOptions resourceOptions) { if (!data) v = [ctx->mtlDevice.v newBufferWithLength:size options:resourceOptions]; else v = [ctx->mtlDevice.v newBufferWithBytes:data length:size options:resourceOptions]; } Buffer* Buffer::create(GraphicsContext* ctx, const void* data, uint32_t size, BufferUsageFlags usageFlags) { MTLBuffer* buffer = new MTLBuffer(); buffer->create(mtl(ctx), data, size, MTLResourceStorageModeShared); return buffer; } void* MTLBuffer::map() { return v.contents; } void MTLBuffer::unmap() {} void MTLBuffer::upload(const void* data, uint32_t size, uint32_t offset) { memcpy((uint8_t*)(v.contents) + offset, data, size); } void MTLBuffer::download(void* data, uint32_t size, uint32_t offset) { memcpy(data, (uint8_t*)(v.contents) + offset, size); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLBuffer.mm"},{"location":"api/Files/MTLBuffer_8mm/#srcngfxportingmetalmtlbuffermm","text":"","title":"src/ngfx/porting/metal/MTLBuffer.mm"},{"location":"api/Files/MTLBuffer_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLBuffer.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void MTLBuffer::create(MTLGraphicsContext* ctx, const void* data, uint32_t size, MTLResourceOptions resourceOptions) { if (!data) v = [ctx->mtlDevice.v newBufferWithLength:size options:resourceOptions]; else v = [ctx->mtlDevice.v newBufferWithBytes:data length:size options:resourceOptions]; } Buffer* Buffer::create(GraphicsContext* ctx, const void* data, uint32_t size, BufferUsageFlags usageFlags) { MTLBuffer* buffer = new MTLBuffer(); buffer->create(mtl(ctx), data, size, MTLResourceStorageModeShared); return buffer; } void* MTLBuffer::map() { return v.contents; } void MTLBuffer::unmap() {} void MTLBuffer::upload(const void* data, uint32_t size, uint32_t offset) { memcpy((uint8_t*)(v.contents) + offset, data, size); } void MTLBuffer::download(void* data, uint32_t size, uint32_t offset) { memcpy(data, (uint8_t*)(v.contents) + offset, size); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLCommandBuffer_8h/","text":"src/ngfx/porting/metal/MTLCommandBuffer.h Namespaces Name ngfx Classes Name class ngfx::MTLCommandBuffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/porting/metal/MTLCommandEncoder.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLCommandBuffer : public CommandBuffer { public: virtual ~MTLCommandBuffer() {} void begin() override {} void end() override {} void commit(); void waitUntilCompleted(); id<MTLCommandBuffer> v; }; MTL_CAST(CommandBuffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLCommandBuffer.h"},{"location":"api/Files/MTLCommandBuffer_8h/#srcngfxportingmetalmtlcommandbufferh","text":"","title":"src/ngfx/porting/metal/MTLCommandBuffer.h"},{"location":"api/Files/MTLCommandBuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLCommandBuffer_8h/#classes","text":"Name class ngfx::MTLCommandBuffer","title":"Classes"},{"location":"api/Files/MTLCommandBuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/porting/metal/MTLCommandEncoder.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLCommandBuffer : public CommandBuffer { public: virtual ~MTLCommandBuffer() {} void begin() override {} void end() override {} void commit(); void waitUntilCompleted(); id<MTLCommandBuffer> v; }; MTL_CAST(CommandBuffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLCommandBuffer_8mm/","text":"src/ngfx/porting/metal/MTLCommandBuffer.mm Source code /* * Copyright 2021 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLCommandBuffer.h\" using namespace ngfx; void MTLCommandBuffer::commit() { [v commit]; } void MTLCommandBuffer::waitUntilCompleted() { if (v.status == MTLCommandBufferStatusCommitted) { [v waitUntilCompleted]; } } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLCommandBuffer.mm"},{"location":"api/Files/MTLCommandBuffer_8mm/#srcngfxportingmetalmtlcommandbuffermm","text":"","title":"src/ngfx/porting/metal/MTLCommandBuffer.mm"},{"location":"api/Files/MTLCommandBuffer_8mm/#source-code","text":"/* * Copyright 2021 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLCommandBuffer.h\" using namespace ngfx; void MTLCommandBuffer::commit() { [v commit]; } void MTLCommandBuffer::waitUntilCompleted() { if (v.status == MTLCommandBufferStatusCommitted) { [v waitUntilCompleted]; } } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLCommandEncoder_8h/","text":"src/ngfx/porting/metal/MTLCommandEncoder.h Namespaces Name ngfx Classes Name class ngfx::MTLCommandEncoder Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class MTLCommandEncoder { public: virtual ~MTLCommandEncoder() {} }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLCommandEncoder.h"},{"location":"api/Files/MTLCommandEncoder_8h/#srcngfxportingmetalmtlcommandencoderh","text":"","title":"src/ngfx/porting/metal/MTLCommandEncoder.h"},{"location":"api/Files/MTLCommandEncoder_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLCommandEncoder_8h/#classes","text":"Name class ngfx::MTLCommandEncoder","title":"Classes"},{"location":"api/Files/MTLCommandEncoder_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class MTLCommandEncoder { public: virtual ~MTLCommandEncoder() {} }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLComputeCommandEncoder_8h/","text":"src/ngfx/porting/metal/MTLComputeCommandEncoder.h Namespaces Name ngfx Classes Name class ngfx::MTLComputeCommandEncoder Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/metal/MTLCommandEncoder.h\" #include <Metal/Metal.h> namespace ngfx { class MTLComputeCommandEncoder : public MTLCommandEncoder { public: virtual ~MTLComputeCommandEncoder() {} id<MTLComputeCommandEncoder> v; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLComputeCommandEncoder.h"},{"location":"api/Files/MTLComputeCommandEncoder_8h/#srcngfxportingmetalmtlcomputecommandencoderh","text":"","title":"src/ngfx/porting/metal/MTLComputeCommandEncoder.h"},{"location":"api/Files/MTLComputeCommandEncoder_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLComputeCommandEncoder_8h/#classes","text":"Name class ngfx::MTLComputeCommandEncoder","title":"Classes"},{"location":"api/Files/MTLComputeCommandEncoder_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/metal/MTLCommandEncoder.h\" #include <Metal/Metal.h> namespace ngfx { class MTLComputeCommandEncoder : public MTLCommandEncoder { public: virtual ~MTLComputeCommandEncoder() {} id<MTLComputeCommandEncoder> v; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLComputePipeline_8h/","text":"src/ngfx/porting/metal/MTLComputePipeline.h Namespaces Name ngfx Classes Name class ngfx::MTLComputePipeline Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLGraphicsContext; class MTLComputePipeline : public ComputePipeline { public: void create(MTLGraphicsContext *ctx, id<MTLFunction> computeFunction); virtual ~MTLComputePipeline() {} id<MTLComputePipelineState> mtlPipelineState; }; MTL_CAST(ComputePipeline); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLComputePipeline.h"},{"location":"api/Files/MTLComputePipeline_8h/#srcngfxportingmetalmtlcomputepipelineh","text":"","title":"src/ngfx/porting/metal/MTLComputePipeline.h"},{"location":"api/Files/MTLComputePipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLComputePipeline_8h/#classes","text":"Name class ngfx::MTLComputePipeline","title":"Classes"},{"location":"api/Files/MTLComputePipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLGraphicsContext; class MTLComputePipeline : public ComputePipeline { public: void create(MTLGraphicsContext *ctx, id<MTLFunction> computeFunction); virtual ~MTLComputePipeline() {} id<MTLComputePipelineState> mtlPipelineState; }; MTL_CAST(ComputePipeline); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLComputePipeline_8mm/","text":"src/ngfx/porting/metal/MTLComputePipeline.mm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLComputePipeline.h\" #include \"ngfx/porting/metal/MTLComputeCommandEncoder.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLPipelineUtil.h\" #include \"ngfx/porting/metal/MTLShaderModule.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" using namespace ngfx; void MTLComputePipeline::create(ngfx::MTLGraphicsContext *ctx, id<MTLFunction> computeFunction) { NSError* error; auto device = ctx->mtlDevice.v; mtlPipelineState = [device newComputePipelineStateWithFunction:computeFunction error:&error]; NSCAssert(mtlPipelineState, @\"Failed to create pipeline state: %@\", error); } ComputePipeline* ComputePipeline::create(GraphicsContext* graphicsContext, ComputeShaderModule* cs) { MTLComputePipeline* mtlComputePipeline = new MTLComputePipeline(); auto& descriptorBindings = mtlComputePipeline->descriptorBindings; uint32_t numDescriptors = cs->descriptors.empty() ? 0 : cs->descriptors.back().set + 1; descriptorBindings.resize(numDescriptors); MTLPipelineUtil::parseDescriptors(cs->descriptors, descriptorBindings); mtlComputePipeline->create(mtl(graphicsContext), mtl(cs)->mtlFunction); return mtlComputePipeline; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLComputePipeline.mm"},{"location":"api/Files/MTLComputePipeline_8mm/#srcngfxportingmetalmtlcomputepipelinemm","text":"","title":"src/ngfx/porting/metal/MTLComputePipeline.mm"},{"location":"api/Files/MTLComputePipeline_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLComputePipeline.h\" #include \"ngfx/porting/metal/MTLComputeCommandEncoder.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLPipelineUtil.h\" #include \"ngfx/porting/metal/MTLShaderModule.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" using namespace ngfx; void MTLComputePipeline::create(ngfx::MTLGraphicsContext *ctx, id<MTLFunction> computeFunction) { NSError* error; auto device = ctx->mtlDevice.v; mtlPipelineState = [device newComputePipelineStateWithFunction:computeFunction error:&error]; NSCAssert(mtlPipelineState, @\"Failed to create pipeline state: %@\", error); } ComputePipeline* ComputePipeline::create(GraphicsContext* graphicsContext, ComputeShaderModule* cs) { MTLComputePipeline* mtlComputePipeline = new MTLComputePipeline(); auto& descriptorBindings = mtlComputePipeline->descriptorBindings; uint32_t numDescriptors = cs->descriptors.empty() ? 0 : cs->descriptors.back().set + 1; descriptorBindings.resize(numDescriptors); MTLPipelineUtil::parseDescriptors(cs->descriptors, descriptorBindings); mtlComputePipeline->create(mtl(graphicsContext), mtl(cs)->mtlFunction); return mtlComputePipeline; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLDepthStencilTexture_8h/","text":"src/ngfx/porting/metal/MTLDepthStencilTexture.h Namespaces Name ngfx Classes Name class ngfx::MTLDepthStencilTexture Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <Metal/Metal.h> namespace ngfx { class MTLGraphicsContext; class MTLDepthStencilTexture { public: void create(MTLGraphicsContext *ctx, uint32_t w, uint32_t h, ::MTLPixelFormat fmt = ::MTLPixelFormatDepth24Unorm_Stencil8); id<MTLTexture> v; ::MTLPixelFormat format; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLDepthStencilTexture.h"},{"location":"api/Files/MTLDepthStencilTexture_8h/#srcngfxportingmetalmtldepthstenciltextureh","text":"","title":"src/ngfx/porting/metal/MTLDepthStencilTexture.h"},{"location":"api/Files/MTLDepthStencilTexture_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLDepthStencilTexture_8h/#classes","text":"Name class ngfx::MTLDepthStencilTexture","title":"Classes"},{"location":"api/Files/MTLDepthStencilTexture_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <Metal/Metal.h> namespace ngfx { class MTLGraphicsContext; class MTLDepthStencilTexture { public: void create(MTLGraphicsContext *ctx, uint32_t w, uint32_t h, ::MTLPixelFormat fmt = ::MTLPixelFormatDepth24Unorm_Stencil8); id<MTLTexture> v; ::MTLPixelFormat format; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLDepthStencilTexture_8mm/","text":"src/ngfx/porting/metal/MTLDepthStencilTexture.mm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLDepthStencilTexture.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" using namespace ngfx; void MTLDepthStencilTexture::create(MTLGraphicsContext* ctx, uint32_t w, uint32_t h, ::MTLPixelFormat fmt) { this->format = fmt; auto device = ctx->mtlDevice.v; MTLTextureDescriptor *desc = [MTLTextureDescriptor new]; desc.width = w; desc.height = h; desc.mipmapLevelCount = 1; desc.storageMode = MTLStorageModePrivate; desc.usage = MTLTextureUsageShaderRead | MTLTextureUsageRenderTarget; desc.pixelFormat = fmt; v = [device newTextureWithDescriptor:desc]; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLDepthStencilTexture.mm"},{"location":"api/Files/MTLDepthStencilTexture_8mm/#srcngfxportingmetalmtldepthstenciltexturemm","text":"","title":"src/ngfx/porting/metal/MTLDepthStencilTexture.mm"},{"location":"api/Files/MTLDepthStencilTexture_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLDepthStencilTexture.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" using namespace ngfx; void MTLDepthStencilTexture::create(MTLGraphicsContext* ctx, uint32_t w, uint32_t h, ::MTLPixelFormat fmt) { this->format = fmt; auto device = ctx->mtlDevice.v; MTLTextureDescriptor *desc = [MTLTextureDescriptor new]; desc.width = w; desc.height = h; desc.mipmapLevelCount = 1; desc.storageMode = MTLStorageModePrivate; desc.usage = MTLTextureUsageShaderRead | MTLTextureUsageRenderTarget; desc.pixelFormat = fmt; v = [device newTextureWithDescriptor:desc]; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLDevice_8h/","text":"src/ngfx/porting/metal/MTLDevice.h Namespaces Name ngfx Classes Name class ngfx::MTLDevice Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLDevice : public Device { public: void create(); id<MTLDevice> v; }; MTL_CAST(Device); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLDevice.h"},{"location":"api/Files/MTLDevice_8h/#srcngfxportingmetalmtldeviceh","text":"","title":"src/ngfx/porting/metal/MTLDevice.h"},{"location":"api/Files/MTLDevice_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLDevice_8h/#classes","text":"Name class ngfx::MTLDevice","title":"Classes"},{"location":"api/Files/MTLDevice_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLDevice : public Device { public: void create(); id<MTLDevice> v; }; MTL_CAST(Device); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLDevice_8mm/","text":"src/ngfx/porting/metal/MTLDevice.mm Attributes Name id< MTLDevice > _ngfx_mtl_device Attributes Documentation variable _ngfx_mtl_device id< MTLDevice > _ngfx_mtl_device; Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLDevice.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; id<MTLDevice> _ngfx_mtl_device; void MTLDevice::create() { v = MTLCreateSystemDefaultDevice(); NSCAssert(v, @\"Failed to create metal device\"); _ngfx_mtl_device = v; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLDevice.mm"},{"location":"api/Files/MTLDevice_8mm/#srcngfxportingmetalmtldevicemm","text":"","title":"src/ngfx/porting/metal/MTLDevice.mm"},{"location":"api/Files/MTLDevice_8mm/#attributes","text":"Name id< MTLDevice > _ngfx_mtl_device","title":"Attributes"},{"location":"api/Files/MTLDevice_8mm/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/MTLDevice_8mm/#variable-_ngfx_mtl_device","text":"id< MTLDevice > _ngfx_mtl_device;","title":"variable _ngfx_mtl_device"},{"location":"api/Files/MTLDevice_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLDevice.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; id<MTLDevice> _ngfx_mtl_device; void MTLDevice::create() { v = MTLCreateSystemDefaultDevice(); NSCAssert(v, @\"Failed to create metal device\"); _ngfx_mtl_device = v; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLFramebuffer_8h/","text":"src/ngfx/porting/metal/MTLFramebuffer.h Namespaces Name ngfx Classes Name class ngfx::MTLFramebuffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLFramebuffer : public Framebuffer { public: typedef std::vector<MTLRenderPassColorAttachmentDescriptor *> ColorAttachments; void create(uint32_t w, uint32_t h, const ColorAttachments &colorAttachments, MTLRenderPassDepthAttachmentDescriptor *depthAttachment = nullptr, MTLRenderPassStencilAttachmentDescriptor *stencilAttachment = nullptr); virtual ~MTLFramebuffer(); ColorAttachments colorAttachments; MTLRenderPassDepthAttachmentDescriptor *depthAttachment = nullptr; MTLRenderPassStencilAttachmentDescriptor *stencilAttachment = nullptr; }; MTL_CAST(Framebuffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLFramebuffer.h"},{"location":"api/Files/MTLFramebuffer_8h/#srcngfxportingmetalmtlframebufferh","text":"","title":"src/ngfx/porting/metal/MTLFramebuffer.h"},{"location":"api/Files/MTLFramebuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLFramebuffer_8h/#classes","text":"Name class ngfx::MTLFramebuffer","title":"Classes"},{"location":"api/Files/MTLFramebuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLFramebuffer : public Framebuffer { public: typedef std::vector<MTLRenderPassColorAttachmentDescriptor *> ColorAttachments; void create(uint32_t w, uint32_t h, const ColorAttachments &colorAttachments, MTLRenderPassDepthAttachmentDescriptor *depthAttachment = nullptr, MTLRenderPassStencilAttachmentDescriptor *stencilAttachment = nullptr); virtual ~MTLFramebuffer(); ColorAttachments colorAttachments; MTLRenderPassDepthAttachmentDescriptor *depthAttachment = nullptr; MTLRenderPassStencilAttachmentDescriptor *stencilAttachment = nullptr; }; MTL_CAST(Framebuffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLFramebuffer_8mm/","text":"src/ngfx/porting/metal/MTLFramebuffer.mm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLFramebuffer.h\" #include \"ngfx/porting/metal/MTLTexture.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void MTLFramebuffer::create(uint32_t w, uint32_t h, const ColorAttachments &colorAttachments, MTLRenderPassDepthAttachmentDescriptor* depthAttachment, MTLRenderPassStencilAttachmentDescriptor* stencilAttachment) { this->w = w; this->h = h; this->colorAttachments = colorAttachments; this->depthAttachment = depthAttachment; this->stencilAttachment = stencilAttachment; } MTLFramebuffer::~MTLFramebuffer() { for (auto& colorAttachment : colorAttachments) { [colorAttachment release]; } if (depthAttachment) [depthAttachment release]; if (stencilAttachment) [stencilAttachment release]; } Framebuffer* Framebuffer::create(Device* device, RenderPass* renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers) { MTLFramebuffer* mtlFramebuffer = new MTLFramebuffer(); mtlFramebuffer->attachments = attachments; MTLFramebuffer::ColorAttachments colorAttachments; MTLRenderPassDepthAttachmentDescriptor* depthAttachment = nullptr; MTLRenderPassStencilAttachmentDescriptor* stencilAttachment = nullptr; auto attachmentsIt = attachments.begin(); while (attachmentsIt != attachments.end()) { auto& attachment = *attachmentsIt++; auto mtlTexture = mtl(attachment.texture); if (!mtlTexture->depthTexture && !mtlTexture->stencilTexture) { MTLRenderPassColorAttachmentDescriptor* colorAttachment = [MTLRenderPassColorAttachmentDescriptor new]; if (mtlTexture->numSamples > 1) { colorAttachment.texture = mtlTexture->v; auto& resolveAttachment = *attachmentsIt++; auto mtlResolveTexture = mtl(resolveAttachment.texture); colorAttachment.resolveTexture = mtlResolveTexture->v; colorAttachment.resolveSlice = attachment.layer; colorAttachment.resolveLevel = attachment.level; } else { colorAttachment.texture = mtlTexture->v; } colorAttachment.slice = attachment.layer; colorAttachment.level = attachment.level; colorAttachments.emplace_back(std::move(colorAttachment)); continue; } if (mtlTexture->depthTexture) { if (!depthAttachment) depthAttachment = [MTLRenderPassDepthAttachmentDescriptor new]; if (mtlTexture->numSamples > 1) depthAttachment.texture = mtlTexture->v; else if (depthAttachment.texture) depthAttachment.resolveTexture = mtlTexture->v; else depthAttachment.texture = mtlTexture->v; } if (mtlTexture->stencilTexture) { if (!stencilAttachment) stencilAttachment = [MTLRenderPassStencilAttachmentDescriptor new]; if (mtlTexture->numSamples > 1) stencilAttachment.texture = mtlTexture->v; else if (stencilAttachment.texture) stencilAttachment.resolveTexture = mtlTexture->v; else stencilAttachment.texture = mtlTexture->v; } } mtlFramebuffer->create(w, h, colorAttachments, depthAttachment, stencilAttachment); return mtlFramebuffer; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLFramebuffer.mm"},{"location":"api/Files/MTLFramebuffer_8mm/#srcngfxportingmetalmtlframebuffermm","text":"","title":"src/ngfx/porting/metal/MTLFramebuffer.mm"},{"location":"api/Files/MTLFramebuffer_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLFramebuffer.h\" #include \"ngfx/porting/metal/MTLTexture.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void MTLFramebuffer::create(uint32_t w, uint32_t h, const ColorAttachments &colorAttachments, MTLRenderPassDepthAttachmentDescriptor* depthAttachment, MTLRenderPassStencilAttachmentDescriptor* stencilAttachment) { this->w = w; this->h = h; this->colorAttachments = colorAttachments; this->depthAttachment = depthAttachment; this->stencilAttachment = stencilAttachment; } MTLFramebuffer::~MTLFramebuffer() { for (auto& colorAttachment : colorAttachments) { [colorAttachment release]; } if (depthAttachment) [depthAttachment release]; if (stencilAttachment) [stencilAttachment release]; } Framebuffer* Framebuffer::create(Device* device, RenderPass* renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers) { MTLFramebuffer* mtlFramebuffer = new MTLFramebuffer(); mtlFramebuffer->attachments = attachments; MTLFramebuffer::ColorAttachments colorAttachments; MTLRenderPassDepthAttachmentDescriptor* depthAttachment = nullptr; MTLRenderPassStencilAttachmentDescriptor* stencilAttachment = nullptr; auto attachmentsIt = attachments.begin(); while (attachmentsIt != attachments.end()) { auto& attachment = *attachmentsIt++; auto mtlTexture = mtl(attachment.texture); if (!mtlTexture->depthTexture && !mtlTexture->stencilTexture) { MTLRenderPassColorAttachmentDescriptor* colorAttachment = [MTLRenderPassColorAttachmentDescriptor new]; if (mtlTexture->numSamples > 1) { colorAttachment.texture = mtlTexture->v; auto& resolveAttachment = *attachmentsIt++; auto mtlResolveTexture = mtl(resolveAttachment.texture); colorAttachment.resolveTexture = mtlResolveTexture->v; colorAttachment.resolveSlice = attachment.layer; colorAttachment.resolveLevel = attachment.level; } else { colorAttachment.texture = mtlTexture->v; } colorAttachment.slice = attachment.layer; colorAttachment.level = attachment.level; colorAttachments.emplace_back(std::move(colorAttachment)); continue; } if (mtlTexture->depthTexture) { if (!depthAttachment) depthAttachment = [MTLRenderPassDepthAttachmentDescriptor new]; if (mtlTexture->numSamples > 1) depthAttachment.texture = mtlTexture->v; else if (depthAttachment.texture) depthAttachment.resolveTexture = mtlTexture->v; else depthAttachment.texture = mtlTexture->v; } if (mtlTexture->stencilTexture) { if (!stencilAttachment) stencilAttachment = [MTLRenderPassStencilAttachmentDescriptor new]; if (mtlTexture->numSamples > 1) stencilAttachment.texture = mtlTexture->v; else if (stencilAttachment.texture) stencilAttachment.resolveTexture = mtlTexture->v; else stencilAttachment.texture = mtlTexture->v; } } mtlFramebuffer->create(w, h, colorAttachments, depthAttachment, stencilAttachment); return mtlFramebuffer; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLGraphicsContext_8h/","text":"src/ngfx/porting/metal/MTLGraphicsContext.h Namespaces Name ngfx Classes Name class ngfx::MTLGraphicsContext struct ngfx::MTLGraphicsContext::MTLRenderPassData Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLDepthStencilTexture.h\" #include \"ngfx/porting/metal/MTLDevice.h\" #include \"ngfx/porting/metal/MTLFramebuffer.h\" #include \"ngfx/porting/metal/MTLPipelineCache.h\" #include \"ngfx/porting/metal/MTLRenderPass.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <MetalKit/MetalKit.h> namespace ngfx { class MTLGraphicsContext : public GraphicsContext { public: void create(const char *appName, bool enableDepthStencil, bool debug); virtual ~MTLGraphicsContext(); void setSurface(Surface *surface) override; CommandBuffer *drawCommandBuffer(int32_t index = -1) override; CommandBuffer *copyCommandBuffer() override; CommandBuffer *computeCommandBuffer() override; void submit(CommandBuffer *commandBuffer) override; struct MTLRenderPassData { RenderPassConfig config; MTLRenderPass mtlRenderPass; }; RenderPass *getRenderPass(RenderPassConfig config) override; std::vector<std::unique_ptr<MTLRenderPassData>> mtlRenderPassCache; MTLCommandBuffer mtlDrawCommandBuffer; MTLCommandBuffer mtlCopyCommandBuffer; MTLCommandBuffer mtlComputeCommandBuffer; MTLDevice mtlDevice; id<MTLCommandQueue> mtlCommandQueue; MTLPipelineCache mtlPipelineCache; ::MTLPixelFormat mtlSurfaceFormat; uint32_t numSwapchainImages; std::vector<MTLFramebuffer> mtlSwapchainFramebuffers; MTLRenderPass *mtlDefaultRenderPass = nullptr, *mtlDefaultOffscreenRenderPass = nullptr; bool offscreen = true; uint32_t numSamples = 1; private: void createBindings(); void createSwapchainFramebuffers(uint32_t w, uint32_t h); }; MTL_CAST(GraphicsContext); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLGraphicsContext.h"},{"location":"api/Files/MTLGraphicsContext_8h/#srcngfxportingmetalmtlgraphicscontexth","text":"","title":"src/ngfx/porting/metal/MTLGraphicsContext.h"},{"location":"api/Files/MTLGraphicsContext_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLGraphicsContext_8h/#classes","text":"Name class ngfx::MTLGraphicsContext struct ngfx::MTLGraphicsContext::MTLRenderPassData","title":"Classes"},{"location":"api/Files/MTLGraphicsContext_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLDepthStencilTexture.h\" #include \"ngfx/porting/metal/MTLDevice.h\" #include \"ngfx/porting/metal/MTLFramebuffer.h\" #include \"ngfx/porting/metal/MTLPipelineCache.h\" #include \"ngfx/porting/metal/MTLRenderPass.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <MetalKit/MetalKit.h> namespace ngfx { class MTLGraphicsContext : public GraphicsContext { public: void create(const char *appName, bool enableDepthStencil, bool debug); virtual ~MTLGraphicsContext(); void setSurface(Surface *surface) override; CommandBuffer *drawCommandBuffer(int32_t index = -1) override; CommandBuffer *copyCommandBuffer() override; CommandBuffer *computeCommandBuffer() override; void submit(CommandBuffer *commandBuffer) override; struct MTLRenderPassData { RenderPassConfig config; MTLRenderPass mtlRenderPass; }; RenderPass *getRenderPass(RenderPassConfig config) override; std::vector<std::unique_ptr<MTLRenderPassData>> mtlRenderPassCache; MTLCommandBuffer mtlDrawCommandBuffer; MTLCommandBuffer mtlCopyCommandBuffer; MTLCommandBuffer mtlComputeCommandBuffer; MTLDevice mtlDevice; id<MTLCommandQueue> mtlCommandQueue; MTLPipelineCache mtlPipelineCache; ::MTLPixelFormat mtlSurfaceFormat; uint32_t numSwapchainImages; std::vector<MTLFramebuffer> mtlSwapchainFramebuffers; MTLRenderPass *mtlDefaultRenderPass = nullptr, *mtlDefaultOffscreenRenderPass = nullptr; bool offscreen = true; uint32_t numSamples = 1; private: void createBindings(); void createSwapchainFramebuffers(uint32_t w, uint32_t h); }; MTL_CAST(GraphicsContext); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLGraphicsContext_8mm/","text":"src/ngfx/porting/metal/MTLGraphicsContext.mm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLSurface.h\" #include \"ngfx/core/DebugUtil.h\" #include <Foundation/Foundation.h> using namespace ngfx; using namespace std; void MTLGraphicsContext::create(const char* appName, bool enableDepthStencil, bool debug) { this->enableDepthStencil = enableDepthStencil; this->debug = debug; mtlDevice.create(); mtlCommandQueue = [mtlDevice.v newCommandQueue]; } MTLGraphicsContext::~MTLGraphicsContext() {} void MTLGraphicsContext::setSurface(Surface *surface) { defaultOffscreenSurfaceFormat = PixelFormat(MTLPixelFormatRGBA8Unorm); MTLSurface *mtl_surface = mtl(surface); MTKView *mtkView = nullptr; if (surface && !surface->offscreen) { offscreen = false; NSView *view = mtl_surface->view; if ([view class] == [MTKView class]) { mtkView = (MTKView*)view; mtkView.device = mtlDevice.v; } CAMetalLayer *layer = mtl_surface->getMetalLayer(); mtlSurfaceFormat = layer.pixelFormat; surfaceFormat = PixelFormat(mtlSurfaceFormat); } else { offscreen = true; surfaceFormat = defaultOffscreenSurfaceFormat; } if (surface && numSamples != 1) { NGFX_TODO(\"\"); } if (surface && enableDepthStencil) { depthFormat = PixelFormat(MTLPixelFormatDepth24Unorm_Stencil8); if (!surface->offscreen && mtkView) mtkView.depthStencilPixelFormat = ::MTLPixelFormat(depthFormat); else if (!surface->offscreen) { mtl_surface->depthStencilTexture.reset(new MTLDepthStencilTexture); mtl_surface->depthStencilTexture->create(this, mtl_surface->w, mtl_surface->h); } if (numSamples != 1) { NGFX_TODO(\"\"); } } std::optional<AttachmentDescription> depthAttachmentDescription; if (enableDepthStencil) depthAttachmentDescription = { depthFormat }; else depthAttachmentDescription = nullopt; if (surface && !surface->offscreen) { RenderPassConfig onscreenRenderPassConfig = { { { surfaceFormat, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_PRESENT_SRC } }, depthAttachmentDescription, false, numSamples }; mtlDefaultRenderPass = (MTLRenderPass*)getRenderPass(onscreenRenderPassConfig); } defaultOffscreenSurfaceFormat = PixelFormat(MTLPixelFormatRGBA8Unorm); RenderPassConfig offscreenRenderPassConfig = { { { defaultOffscreenSurfaceFormat } }, depthAttachmentDescription, false, numSamples }; mtlDefaultOffscreenRenderPass = (MTLRenderPass*)getRenderPass(offscreenRenderPassConfig); if (surface && !surface->offscreen) { CAMetalLayer* metalLayer = mtl_surface->getMetalLayer(); numSwapchainImages = metalLayer.maximumDrawableCount; createSwapchainFramebuffers(metalLayer.drawableSize.width, metalLayer.drawableSize.height); } createBindings(); this->surface = surface; } RenderPass* MTLGraphicsContext::getRenderPass(RenderPassConfig config) { for (auto& r : mtlRenderPassCache) { if (r->config == config) return &r->mtlRenderPass; } auto renderPassData = make_unique<MTLRenderPassData>(); auto result = &renderPassData->mtlRenderPass; mtlRenderPassCache.emplace_back(std::move(renderPassData)); return result; } void MTLGraphicsContext::createSwapchainFramebuffers(uint32_t w, uint32_t h) { mtlSwapchainFramebuffers.resize(numSwapchainImages); for (auto& fb : mtlSwapchainFramebuffers) { fb.w = w; fb.h = h; } } void MTLGraphicsContext::createBindings() { device = &mtlDevice; pipelineCache = &mtlPipelineCache; swapchainFramebuffers.resize(numSwapchainImages); for (int j = 0; j<mtlSwapchainFramebuffers.size(); j++) swapchainFramebuffers[j] = &mtlSwapchainFramebuffers[j]; defaultRenderPass = mtlDefaultRenderPass; defaultOffscreenRenderPass = mtlDefaultOffscreenRenderPass; } CommandBuffer* MTLGraphicsContext::drawCommandBuffer(int32_t index) { mtlDrawCommandBuffer.v = [mtlCommandQueue commandBuffer]; return &mtlDrawCommandBuffer; } CommandBuffer* MTLGraphicsContext::copyCommandBuffer() { mtlCopyCommandBuffer.v = [mtlCommandQueue commandBuffer]; return &mtlCopyCommandBuffer; } CommandBuffer* MTLGraphicsContext::computeCommandBuffer() { mtlComputeCommandBuffer.v = [mtlCommandQueue commandBuffer]; return &mtlComputeCommandBuffer; } void MTLGraphicsContext::submit(CommandBuffer* commandBuffer) { auto mtlCommandBuffer = mtl(commandBuffer); mtlCommandBuffer->commit(); if (commandBuffer == &mtlComputeCommandBuffer) { mtlCommandBuffer->waitUntilCompleted(); } } GraphicsContext* GraphicsContext::create(const char* appName, bool enableDepthStencil, bool debug) { NGFX_LOG(\"debug: %s\", (debug)?\"true\": \"false\"); auto mtlGraphicsContext = new MTLGraphicsContext(); mtlGraphicsContext->create(appName, enableDepthStencil, debug); return mtlGraphicsContext; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLGraphicsContext.mm"},{"location":"api/Files/MTLGraphicsContext_8mm/#srcngfxportingmetalmtlgraphicscontextmm","text":"","title":"src/ngfx/porting/metal/MTLGraphicsContext.mm"},{"location":"api/Files/MTLGraphicsContext_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLSurface.h\" #include \"ngfx/core/DebugUtil.h\" #include <Foundation/Foundation.h> using namespace ngfx; using namespace std; void MTLGraphicsContext::create(const char* appName, bool enableDepthStencil, bool debug) { this->enableDepthStencil = enableDepthStencil; this->debug = debug; mtlDevice.create(); mtlCommandQueue = [mtlDevice.v newCommandQueue]; } MTLGraphicsContext::~MTLGraphicsContext() {} void MTLGraphicsContext::setSurface(Surface *surface) { defaultOffscreenSurfaceFormat = PixelFormat(MTLPixelFormatRGBA8Unorm); MTLSurface *mtl_surface = mtl(surface); MTKView *mtkView = nullptr; if (surface && !surface->offscreen) { offscreen = false; NSView *view = mtl_surface->view; if ([view class] == [MTKView class]) { mtkView = (MTKView*)view; mtkView.device = mtlDevice.v; } CAMetalLayer *layer = mtl_surface->getMetalLayer(); mtlSurfaceFormat = layer.pixelFormat; surfaceFormat = PixelFormat(mtlSurfaceFormat); } else { offscreen = true; surfaceFormat = defaultOffscreenSurfaceFormat; } if (surface && numSamples != 1) { NGFX_TODO(\"\"); } if (surface && enableDepthStencil) { depthFormat = PixelFormat(MTLPixelFormatDepth24Unorm_Stencil8); if (!surface->offscreen && mtkView) mtkView.depthStencilPixelFormat = ::MTLPixelFormat(depthFormat); else if (!surface->offscreen) { mtl_surface->depthStencilTexture.reset(new MTLDepthStencilTexture); mtl_surface->depthStencilTexture->create(this, mtl_surface->w, mtl_surface->h); } if (numSamples != 1) { NGFX_TODO(\"\"); } } std::optional<AttachmentDescription> depthAttachmentDescription; if (enableDepthStencil) depthAttachmentDescription = { depthFormat }; else depthAttachmentDescription = nullopt; if (surface && !surface->offscreen) { RenderPassConfig onscreenRenderPassConfig = { { { surfaceFormat, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_PRESENT_SRC } }, depthAttachmentDescription, false, numSamples }; mtlDefaultRenderPass = (MTLRenderPass*)getRenderPass(onscreenRenderPassConfig); } defaultOffscreenSurfaceFormat = PixelFormat(MTLPixelFormatRGBA8Unorm); RenderPassConfig offscreenRenderPassConfig = { { { defaultOffscreenSurfaceFormat } }, depthAttachmentDescription, false, numSamples }; mtlDefaultOffscreenRenderPass = (MTLRenderPass*)getRenderPass(offscreenRenderPassConfig); if (surface && !surface->offscreen) { CAMetalLayer* metalLayer = mtl_surface->getMetalLayer(); numSwapchainImages = metalLayer.maximumDrawableCount; createSwapchainFramebuffers(metalLayer.drawableSize.width, metalLayer.drawableSize.height); } createBindings(); this->surface = surface; } RenderPass* MTLGraphicsContext::getRenderPass(RenderPassConfig config) { for (auto& r : mtlRenderPassCache) { if (r->config == config) return &r->mtlRenderPass; } auto renderPassData = make_unique<MTLRenderPassData>(); auto result = &renderPassData->mtlRenderPass; mtlRenderPassCache.emplace_back(std::move(renderPassData)); return result; } void MTLGraphicsContext::createSwapchainFramebuffers(uint32_t w, uint32_t h) { mtlSwapchainFramebuffers.resize(numSwapchainImages); for (auto& fb : mtlSwapchainFramebuffers) { fb.w = w; fb.h = h; } } void MTLGraphicsContext::createBindings() { device = &mtlDevice; pipelineCache = &mtlPipelineCache; swapchainFramebuffers.resize(numSwapchainImages); for (int j = 0; j<mtlSwapchainFramebuffers.size(); j++) swapchainFramebuffers[j] = &mtlSwapchainFramebuffers[j]; defaultRenderPass = mtlDefaultRenderPass; defaultOffscreenRenderPass = mtlDefaultOffscreenRenderPass; } CommandBuffer* MTLGraphicsContext::drawCommandBuffer(int32_t index) { mtlDrawCommandBuffer.v = [mtlCommandQueue commandBuffer]; return &mtlDrawCommandBuffer; } CommandBuffer* MTLGraphicsContext::copyCommandBuffer() { mtlCopyCommandBuffer.v = [mtlCommandQueue commandBuffer]; return &mtlCopyCommandBuffer; } CommandBuffer* MTLGraphicsContext::computeCommandBuffer() { mtlComputeCommandBuffer.v = [mtlCommandQueue commandBuffer]; return &mtlComputeCommandBuffer; } void MTLGraphicsContext::submit(CommandBuffer* commandBuffer) { auto mtlCommandBuffer = mtl(commandBuffer); mtlCommandBuffer->commit(); if (commandBuffer == &mtlComputeCommandBuffer) { mtlCommandBuffer->waitUntilCompleted(); } } GraphicsContext* GraphicsContext::create(const char* appName, bool enableDepthStencil, bool debug) { NGFX_LOG(\"debug: %s\", (debug)?\"true\": \"false\"); auto mtlGraphicsContext = new MTLGraphicsContext(); mtlGraphicsContext->create(appName, enableDepthStencil, debug); return mtlGraphicsContext; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLGraphicsCoreDefines_8h/","text":"src/ngfx/porting/metal/MTLGraphicsCoreDefines.h Namespaces Name ngfx Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { enum MTLPrimitiveType { MTLPrimitiveTypePoint = 0, MTLPrimitiveTypeLine = 1, MTLPrimitiveTypeLineStrip = 2, MTLPrimitiveTypeTriangle = 3, MTLPrimitiveTypeTriangleStrip = 4 }; enum MTLTriangleFillMode { MTLTriangleFillModeFill = 0, MTLTriangleFillModeLines = 1 }; enum MTLBlendFactor { MTLBlendFactorZero = 0, MTLBlendFactorOne = 1, MTLBlendFactorSourceColor = 2, MTLBlendFactorOneMinusSourceColor = 3, MTLBlendFactorSourceAlpha = 4, MTLBlendFactorOneMinusSourceAlpha = 5, MTLBlendFactorDestinationColor = 6, MTLBlendFactorOneMinusDestinationColor = 7, MTLBlendFactorDestinationAlpha = 8, MTLBlendFactorOneMinusDestinationAlpha = 9, MTLBlendFactorSourceAlphaSaturated = 10, MTLBlendFactorBlendColor = 11, MTLBlendFactorOneMinusBlendColor = 12, MTLBlendFactorBlendAlpha = 13, MTLBlendFactorOneMinusBlendAlpha = 14 }; enum MTLBlendOperation { MTLBlendOperationAdd = 0, MTLBlendOperationSubtract = 1, MTLBlendOperationReverseSubtract = 2, MTLBlendOperationMin = 3, MTLBlendOperationMax = 4, }; enum MTLColorWriteMask { MTLColorWriteMaskNone = 0, MTLColorWriteMaskRed = 0x1 << 3, MTLColorWriteMaskGreen = 0x1 << 2, MTLColorWriteMaskBlue = 0x1 << 1, MTLColorWriteMaskAlpha = 0x1 << 0, MTLColorWriteMaskAll = 0xf }; enum MTLCullMode { MTLCullModeNone = 0, MTLCullModeFront = 1, MTLCullModeBack = 2 }; enum MTLWinding { MTLWindingClockwise = 0, MTLWindingCounterClockwise = 1 }; enum MTLPixelFormat { MTLPixelFormatInvalid = 0, /* Normal 8 bit formats */ MTLPixelFormatA8Unorm = 1, MTLPixelFormatR8Unorm = 10, MTLPixelFormatR8Unorm_sRGB = 11, MTLPixelFormatR8Snorm = 12, MTLPixelFormatR8Uint = 13, MTLPixelFormatR8Sint = 14, /* Normal 16 bit formats */ MTLPixelFormatR16Unorm = 20, MTLPixelFormatR16Snorm = 22, MTLPixelFormatR16Uint = 23, MTLPixelFormatR16Sint = 24, MTLPixelFormatR16Float = 25, MTLPixelFormatRG8Unorm = 30, MTLPixelFormatRG8Unorm_sRGB = 31, MTLPixelFormatRG8Snorm = 32, MTLPixelFormatRG8Uint = 33, MTLPixelFormatRG8Sint = 34, /* Packed 16 bit formats */ MTLPixelFormatB5G6R5Unorm = 40, MTLPixelFormatA1BGR5Unorm = 41, MTLPixelFormatABGR4Unorm = 42, MTLPixelFormatBGR5A1Unorm = 43, /* Normal 32 bit formats */ MTLPixelFormatR32Uint = 53, MTLPixelFormatR32Sint = 54, MTLPixelFormatR32Float = 55, MTLPixelFormatRG16Unorm = 60, MTLPixelFormatRG16Snorm = 62, MTLPixelFormatRG16Uint = 63, MTLPixelFormatRG16Sint = 64, MTLPixelFormatRG16Float = 65, MTLPixelFormatRGBA8Unorm = 70, MTLPixelFormatRGBA8Unorm_sRGB = 71, MTLPixelFormatRGBA8Snorm = 72, MTLPixelFormatRGBA8Uint = 73, MTLPixelFormatRGBA8Sint = 74, MTLPixelFormatBGRA8Unorm = 80, MTLPixelFormatBGRA8Unorm_sRGB = 81, /* Packed 32 bit formats */ MTLPixelFormatRGB10A2Unorm = 90, MTLPixelFormatRGB10A2Uint = 91, MTLPixelFormatRG11B10Float = 92, MTLPixelFormatRGB9E5Float = 93, MTLPixelFormatBGR10A2Unorm = 94, MTLPixelFormatBGR10_XR = 554, MTLPixelFormatBGR10_XR_sRGB = 555, /* Normal 64 bit formats */ MTLPixelFormatRG32Uint = 103, MTLPixelFormatRG32Sint = 104, MTLPixelFormatRG32Float = 105, MTLPixelFormatRGBA16Unorm = 110, MTLPixelFormatRGBA16Snorm = 112, MTLPixelFormatRGBA16Uint = 113, MTLPixelFormatRGBA16Sint = 114, MTLPixelFormatRGBA16Float = 115, MTLPixelFormatBGRA10_XR = 552, MTLPixelFormatBGRA10_XR_sRGB = 553, /* Normal 128 bit formats */ MTLPixelFormatRGBA32Uint = 123, MTLPixelFormatRGBA32Sint = 124, MTLPixelFormatRGBA32Float = 125, /* Compressed formats. */ /* S3TC/DXT */ MTLPixelFormatBC1_RGBA = 130, MTLPixelFormatBC1_RGBA_sRGB = 131, MTLPixelFormatBC2_RGBA = 132, MTLPixelFormatBC2_RGBA_sRGB = 133, MTLPixelFormatBC3_RGBA = 134, MTLPixelFormatBC3_RGBA_sRGB = 135, /* RGTC */ MTLPixelFormatBC4_RUnorm = 140, MTLPixelFormatBC4_RSnorm = 141, MTLPixelFormatBC5_RGUnorm = 142, MTLPixelFormatBC5_RGSnorm = 143, /* BPTC */ MTLPixelFormatBC6H_RGBFloat = 150, MTLPixelFormatBC6H_RGBUfloat = 151, MTLPixelFormatBC7_RGBAUnorm = 152, MTLPixelFormatBC7_RGBAUnorm_sRGB = 153, /* PVRTC */ MTLPixelFormatPVRTC_RGB_2BPP = 160, MTLPixelFormatPVRTC_RGB_2BPP_sRGB = 161, MTLPixelFormatPVRTC_RGB_4BPP = 162, MTLPixelFormatPVRTC_RGB_4BPP_sRGB = 163, MTLPixelFormatPVRTC_RGBA_2BPP = 164, MTLPixelFormatPVRTC_RGBA_2BPP_sRGB = 165, MTLPixelFormatPVRTC_RGBA_4BPP = 166, MTLPixelFormatPVRTC_RGBA_4BPP_sRGB = 167, /* ETC2 */ MTLPixelFormatEAC_R11Unorm = 170, MTLPixelFormatEAC_R11Snorm = 172, MTLPixelFormatEAC_RG11Unorm = 174, MTLPixelFormatEAC_RG11Snorm = 176, MTLPixelFormatEAC_RGBA8 = 178, MTLPixelFormatEAC_RGBA8_sRGB = 179, MTLPixelFormatETC2_RGB8 = 180, MTLPixelFormatETC2_RGB8_sRGB = 181, MTLPixelFormatETC2_RGB8A1 = 182, MTLPixelFormatETC2_RGB8A1_sRGB = 183, /* ASTC */ MTLPixelFormatASTC_4x4_sRGB = 186, MTLPixelFormatASTC_5x4_sRGB = 187, MTLPixelFormatASTC_5x5_sRGB = 188, MTLPixelFormatASTC_6x5_sRGB = 189, MTLPixelFormatASTC_6x6_sRGB = 190, MTLPixelFormatASTC_8x5_sRGB = 192, MTLPixelFormatASTC_8x6_sRGB = 193, MTLPixelFormatASTC_8x8_sRGB = 194, MTLPixelFormatASTC_10x5_sRGB = 195, MTLPixelFormatASTC_10x6_sRGB = 196, MTLPixelFormatASTC_10x8_sRGB = 197, MTLPixelFormatASTC_10x10_sRGB = 198, MTLPixelFormatASTC_12x10_sRGB = 199, MTLPixelFormatASTC_12x12_sRGB = 200, MTLPixelFormatASTC_4x4_LDR = 204, MTLPixelFormatASTC_5x4_LDR = 205, MTLPixelFormatASTC_5x5_LDR = 206, MTLPixelFormatASTC_6x5_LDR = 207, MTLPixelFormatASTC_6x6_LDR = 208, MTLPixelFormatASTC_8x5_LDR = 210, MTLPixelFormatASTC_8x6_LDR = 211, MTLPixelFormatASTC_8x8_LDR = 212, MTLPixelFormatASTC_10x5_LDR = 213, MTLPixelFormatASTC_10x6_LDR = 214, MTLPixelFormatASTC_10x8_LDR = 215, MTLPixelFormatASTC_10x10_LDR = 216, MTLPixelFormatASTC_12x10_LDR = 217, MTLPixelFormatASTC_12x12_LDR = 218, MTLPixelFormatGBGR422 = 240, MTLPixelFormatBGRG422 = 241, /* Depth */ MTLPixelFormatDepth16Unorm = 250, MTLPixelFormatDepth32Float = 252, /* Stencil */ MTLPixelFormatStencil8 = 253, /* Depth Stencil */ MTLPixelFormatDepth24Unorm_Stencil8 = 255, MTLPixelFormatDepth32Float_Stencil8 = 260, MTLPixelFormatX32_Stencil8 = 261, MTLPixelFormatX24_Stencil8 = 262, }; enum MTLIndexType { MTLIndexTypeUInt16 = 0, MTLIndexTypeUInt32 = 1, }; enum MTLTextureType { MTLTextureType1D = 0, MTLTextureType1DArray = 1, MTLTextureType2D = 2, MTLTextureType2DArray = 3, MTLTextureType2DMultisample = 4, MTLTextureTypeCube = 5, MTLTextureTypeCubeArray = 6, MTLTextureType3D = 7, MTLTextureType2DMultisampleArray = 8, MTLTextureTypeTextureBuffer = 9 }; enum MTLVertexFormat { MTLVertexFormatInvalid = 0, MTLVertexFormatUChar2 = 1, MTLVertexFormatUChar3 = 2, MTLVertexFormatUChar4 = 3, MTLVertexFormatChar2 = 4, MTLVertexFormatChar3 = 5, MTLVertexFormatChar4 = 6, MTLVertexFormatUChar2Normalized = 7, MTLVertexFormatUChar3Normalized = 8, MTLVertexFormatUChar4Normalized = 9, MTLVertexFormatChar2Normalized = 10, MTLVertexFormatChar3Normalized = 11, MTLVertexFormatChar4Normalized = 12, MTLVertexFormatUShort2 = 13, MTLVertexFormatUShort3 = 14, MTLVertexFormatUShort4 = 15, MTLVertexFormatShort2 = 16, MTLVertexFormatShort3 = 17, MTLVertexFormatShort4 = 18, MTLVertexFormatUShort2Normalized = 19, MTLVertexFormatUShort3Normalized = 20, MTLVertexFormatUShort4Normalized = 21, MTLVertexFormatShort2Normalized = 22, MTLVertexFormatShort3Normalized = 23, MTLVertexFormatShort4Normalized = 24, MTLVertexFormatHalf2 = 25, MTLVertexFormatHalf3 = 26, MTLVertexFormatHalf4 = 27, MTLVertexFormatFloat = 28, MTLVertexFormatFloat2 = 29, MTLVertexFormatFloat3 = 30, MTLVertexFormatFloat4 = 31, MTLVertexFormatInt = 32, MTLVertexFormatInt2 = 33, MTLVertexFormatInt3 = 34, MTLVertexFormatInt4 = 35, MTLVertexFormatUInt = 36, MTLVertexFormatUInt2 = 37, MTLVertexFormatUInt3 = 38, MTLVertexFormatUInt4 = 39, MTLVertexFormatInt1010102Normalized = 40, MTLVertexFormatUInt1010102Normalized = 41 }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLGraphicsCoreDefines.h"},{"location":"api/Files/MTLGraphicsCoreDefines_8h/#srcngfxportingmetalmtlgraphicscoredefinesh","text":"","title":"src/ngfx/porting/metal/MTLGraphicsCoreDefines.h"},{"location":"api/Files/MTLGraphicsCoreDefines_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLGraphicsCoreDefines_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { enum MTLPrimitiveType { MTLPrimitiveTypePoint = 0, MTLPrimitiveTypeLine = 1, MTLPrimitiveTypeLineStrip = 2, MTLPrimitiveTypeTriangle = 3, MTLPrimitiveTypeTriangleStrip = 4 }; enum MTLTriangleFillMode { MTLTriangleFillModeFill = 0, MTLTriangleFillModeLines = 1 }; enum MTLBlendFactor { MTLBlendFactorZero = 0, MTLBlendFactorOne = 1, MTLBlendFactorSourceColor = 2, MTLBlendFactorOneMinusSourceColor = 3, MTLBlendFactorSourceAlpha = 4, MTLBlendFactorOneMinusSourceAlpha = 5, MTLBlendFactorDestinationColor = 6, MTLBlendFactorOneMinusDestinationColor = 7, MTLBlendFactorDestinationAlpha = 8, MTLBlendFactorOneMinusDestinationAlpha = 9, MTLBlendFactorSourceAlphaSaturated = 10, MTLBlendFactorBlendColor = 11, MTLBlendFactorOneMinusBlendColor = 12, MTLBlendFactorBlendAlpha = 13, MTLBlendFactorOneMinusBlendAlpha = 14 }; enum MTLBlendOperation { MTLBlendOperationAdd = 0, MTLBlendOperationSubtract = 1, MTLBlendOperationReverseSubtract = 2, MTLBlendOperationMin = 3, MTLBlendOperationMax = 4, }; enum MTLColorWriteMask { MTLColorWriteMaskNone = 0, MTLColorWriteMaskRed = 0x1 << 3, MTLColorWriteMaskGreen = 0x1 << 2, MTLColorWriteMaskBlue = 0x1 << 1, MTLColorWriteMaskAlpha = 0x1 << 0, MTLColorWriteMaskAll = 0xf }; enum MTLCullMode { MTLCullModeNone = 0, MTLCullModeFront = 1, MTLCullModeBack = 2 }; enum MTLWinding { MTLWindingClockwise = 0, MTLWindingCounterClockwise = 1 }; enum MTLPixelFormat { MTLPixelFormatInvalid = 0, /* Normal 8 bit formats */ MTLPixelFormatA8Unorm = 1, MTLPixelFormatR8Unorm = 10, MTLPixelFormatR8Unorm_sRGB = 11, MTLPixelFormatR8Snorm = 12, MTLPixelFormatR8Uint = 13, MTLPixelFormatR8Sint = 14, /* Normal 16 bit formats */ MTLPixelFormatR16Unorm = 20, MTLPixelFormatR16Snorm = 22, MTLPixelFormatR16Uint = 23, MTLPixelFormatR16Sint = 24, MTLPixelFormatR16Float = 25, MTLPixelFormatRG8Unorm = 30, MTLPixelFormatRG8Unorm_sRGB = 31, MTLPixelFormatRG8Snorm = 32, MTLPixelFormatRG8Uint = 33, MTLPixelFormatRG8Sint = 34, /* Packed 16 bit formats */ MTLPixelFormatB5G6R5Unorm = 40, MTLPixelFormatA1BGR5Unorm = 41, MTLPixelFormatABGR4Unorm = 42, MTLPixelFormatBGR5A1Unorm = 43, /* Normal 32 bit formats */ MTLPixelFormatR32Uint = 53, MTLPixelFormatR32Sint = 54, MTLPixelFormatR32Float = 55, MTLPixelFormatRG16Unorm = 60, MTLPixelFormatRG16Snorm = 62, MTLPixelFormatRG16Uint = 63, MTLPixelFormatRG16Sint = 64, MTLPixelFormatRG16Float = 65, MTLPixelFormatRGBA8Unorm = 70, MTLPixelFormatRGBA8Unorm_sRGB = 71, MTLPixelFormatRGBA8Snorm = 72, MTLPixelFormatRGBA8Uint = 73, MTLPixelFormatRGBA8Sint = 74, MTLPixelFormatBGRA8Unorm = 80, MTLPixelFormatBGRA8Unorm_sRGB = 81, /* Packed 32 bit formats */ MTLPixelFormatRGB10A2Unorm = 90, MTLPixelFormatRGB10A2Uint = 91, MTLPixelFormatRG11B10Float = 92, MTLPixelFormatRGB9E5Float = 93, MTLPixelFormatBGR10A2Unorm = 94, MTLPixelFormatBGR10_XR = 554, MTLPixelFormatBGR10_XR_sRGB = 555, /* Normal 64 bit formats */ MTLPixelFormatRG32Uint = 103, MTLPixelFormatRG32Sint = 104, MTLPixelFormatRG32Float = 105, MTLPixelFormatRGBA16Unorm = 110, MTLPixelFormatRGBA16Snorm = 112, MTLPixelFormatRGBA16Uint = 113, MTLPixelFormatRGBA16Sint = 114, MTLPixelFormatRGBA16Float = 115, MTLPixelFormatBGRA10_XR = 552, MTLPixelFormatBGRA10_XR_sRGB = 553, /* Normal 128 bit formats */ MTLPixelFormatRGBA32Uint = 123, MTLPixelFormatRGBA32Sint = 124, MTLPixelFormatRGBA32Float = 125, /* Compressed formats. */ /* S3TC/DXT */ MTLPixelFormatBC1_RGBA = 130, MTLPixelFormatBC1_RGBA_sRGB = 131, MTLPixelFormatBC2_RGBA = 132, MTLPixelFormatBC2_RGBA_sRGB = 133, MTLPixelFormatBC3_RGBA = 134, MTLPixelFormatBC3_RGBA_sRGB = 135, /* RGTC */ MTLPixelFormatBC4_RUnorm = 140, MTLPixelFormatBC4_RSnorm = 141, MTLPixelFormatBC5_RGUnorm = 142, MTLPixelFormatBC5_RGSnorm = 143, /* BPTC */ MTLPixelFormatBC6H_RGBFloat = 150, MTLPixelFormatBC6H_RGBUfloat = 151, MTLPixelFormatBC7_RGBAUnorm = 152, MTLPixelFormatBC7_RGBAUnorm_sRGB = 153, /* PVRTC */ MTLPixelFormatPVRTC_RGB_2BPP = 160, MTLPixelFormatPVRTC_RGB_2BPP_sRGB = 161, MTLPixelFormatPVRTC_RGB_4BPP = 162, MTLPixelFormatPVRTC_RGB_4BPP_sRGB = 163, MTLPixelFormatPVRTC_RGBA_2BPP = 164, MTLPixelFormatPVRTC_RGBA_2BPP_sRGB = 165, MTLPixelFormatPVRTC_RGBA_4BPP = 166, MTLPixelFormatPVRTC_RGBA_4BPP_sRGB = 167, /* ETC2 */ MTLPixelFormatEAC_R11Unorm = 170, MTLPixelFormatEAC_R11Snorm = 172, MTLPixelFormatEAC_RG11Unorm = 174, MTLPixelFormatEAC_RG11Snorm = 176, MTLPixelFormatEAC_RGBA8 = 178, MTLPixelFormatEAC_RGBA8_sRGB = 179, MTLPixelFormatETC2_RGB8 = 180, MTLPixelFormatETC2_RGB8_sRGB = 181, MTLPixelFormatETC2_RGB8A1 = 182, MTLPixelFormatETC2_RGB8A1_sRGB = 183, /* ASTC */ MTLPixelFormatASTC_4x4_sRGB = 186, MTLPixelFormatASTC_5x4_sRGB = 187, MTLPixelFormatASTC_5x5_sRGB = 188, MTLPixelFormatASTC_6x5_sRGB = 189, MTLPixelFormatASTC_6x6_sRGB = 190, MTLPixelFormatASTC_8x5_sRGB = 192, MTLPixelFormatASTC_8x6_sRGB = 193, MTLPixelFormatASTC_8x8_sRGB = 194, MTLPixelFormatASTC_10x5_sRGB = 195, MTLPixelFormatASTC_10x6_sRGB = 196, MTLPixelFormatASTC_10x8_sRGB = 197, MTLPixelFormatASTC_10x10_sRGB = 198, MTLPixelFormatASTC_12x10_sRGB = 199, MTLPixelFormatASTC_12x12_sRGB = 200, MTLPixelFormatASTC_4x4_LDR = 204, MTLPixelFormatASTC_5x4_LDR = 205, MTLPixelFormatASTC_5x5_LDR = 206, MTLPixelFormatASTC_6x5_LDR = 207, MTLPixelFormatASTC_6x6_LDR = 208, MTLPixelFormatASTC_8x5_LDR = 210, MTLPixelFormatASTC_8x6_LDR = 211, MTLPixelFormatASTC_8x8_LDR = 212, MTLPixelFormatASTC_10x5_LDR = 213, MTLPixelFormatASTC_10x6_LDR = 214, MTLPixelFormatASTC_10x8_LDR = 215, MTLPixelFormatASTC_10x10_LDR = 216, MTLPixelFormatASTC_12x10_LDR = 217, MTLPixelFormatASTC_12x12_LDR = 218, MTLPixelFormatGBGR422 = 240, MTLPixelFormatBGRG422 = 241, /* Depth */ MTLPixelFormatDepth16Unorm = 250, MTLPixelFormatDepth32Float = 252, /* Stencil */ MTLPixelFormatStencil8 = 253, /* Depth Stencil */ MTLPixelFormatDepth24Unorm_Stencil8 = 255, MTLPixelFormatDepth32Float_Stencil8 = 260, MTLPixelFormatX32_Stencil8 = 261, MTLPixelFormatX24_Stencil8 = 262, }; enum MTLIndexType { MTLIndexTypeUInt16 = 0, MTLIndexTypeUInt32 = 1, }; enum MTLTextureType { MTLTextureType1D = 0, MTLTextureType1DArray = 1, MTLTextureType2D = 2, MTLTextureType2DArray = 3, MTLTextureType2DMultisample = 4, MTLTextureTypeCube = 5, MTLTextureTypeCubeArray = 6, MTLTextureType3D = 7, MTLTextureType2DMultisampleArray = 8, MTLTextureTypeTextureBuffer = 9 }; enum MTLVertexFormat { MTLVertexFormatInvalid = 0, MTLVertexFormatUChar2 = 1, MTLVertexFormatUChar3 = 2, MTLVertexFormatUChar4 = 3, MTLVertexFormatChar2 = 4, MTLVertexFormatChar3 = 5, MTLVertexFormatChar4 = 6, MTLVertexFormatUChar2Normalized = 7, MTLVertexFormatUChar3Normalized = 8, MTLVertexFormatUChar4Normalized = 9, MTLVertexFormatChar2Normalized = 10, MTLVertexFormatChar3Normalized = 11, MTLVertexFormatChar4Normalized = 12, MTLVertexFormatUShort2 = 13, MTLVertexFormatUShort3 = 14, MTLVertexFormatUShort4 = 15, MTLVertexFormatShort2 = 16, MTLVertexFormatShort3 = 17, MTLVertexFormatShort4 = 18, MTLVertexFormatUShort2Normalized = 19, MTLVertexFormatUShort3Normalized = 20, MTLVertexFormatUShort4Normalized = 21, MTLVertexFormatShort2Normalized = 22, MTLVertexFormatShort3Normalized = 23, MTLVertexFormatShort4Normalized = 24, MTLVertexFormatHalf2 = 25, MTLVertexFormatHalf3 = 26, MTLVertexFormatHalf4 = 27, MTLVertexFormatFloat = 28, MTLVertexFormatFloat2 = 29, MTLVertexFormatFloat3 = 30, MTLVertexFormatFloat4 = 31, MTLVertexFormatInt = 32, MTLVertexFormatInt2 = 33, MTLVertexFormatInt3 = 34, MTLVertexFormatInt4 = 35, MTLVertexFormatUInt = 36, MTLVertexFormatUInt2 = 37, MTLVertexFormatUInt3 = 38, MTLVertexFormatUInt4 = 39, MTLVertexFormatInt1010102Normalized = 40, MTLVertexFormatUInt1010102Normalized = 41 }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLGraphicsCore_8h/","text":"src/ngfx/porting/metal/MTLGraphicsCore.h Namespaces Name ngfx Defines Name DEFINE_PIXELFORMATS (s, t0, t1) DEFINE_VERTEXFORMATS (t0, t1) Macro Documentation define DEFINE_PIXELFORMATS #define DEFINE_PIXELFORMATS( s, t0, t1 ) PIXELFORMAT_R##s##_##t0 = MTLPixelFormatR##s##t1, \\ PIXELFORMAT_RG##s##_##t0 = MTLPixelFormatRG##s##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = MTLPixelFormatRGBA##s##t1 define DEFINE_VERTEXFORMATS #define DEFINE_VERTEXFORMATS( t0, t1 ) VERTEXFORMAT_##t0 = MTLVertexFormat##t1, \\ VERTEXFORMAT_##t0##2 = MTLVertexFormat##t1##2, \\ VERTEXFORMAT_##t0##3 = MTLVertexFormat##t1##3, \\ VERTEXFORMAT_##t0##4 = MTLVertexFormat##t1##4 Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/metal/MTLGraphicsCoreDefines.h\" namespace ngfx { enum PrimitiveTopology { PRIMITIVE_TOPOLOGY_POINT_LIST = MTLPrimitiveTypePoint, PRIMITIVE_TOPOLOGY_LINE_LIST = MTLPrimitiveTypeLine, PRIMITIVE_TOPOLOGY_LINE_STRIP = MTLPrimitiveTypeLineStrip, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = MTLPrimitiveTypeTriangle, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = MTLPrimitiveTypeTriangleStrip }; enum PolygonMode { POLYGON_MODE_FILL = MTLTriangleFillModeFill, POLYGON_MODE_LINE = MTLTriangleFillModeLines, }; enum BlendFactor { BLEND_FACTOR_ZERO = MTLBlendFactorZero, BLEND_FACTOR_ONE = MTLBlendFactorOne, BLEND_FACTOR_SRC_COLOR = MTLBlendFactorSourceColor, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = MTLBlendFactorOneMinusSourceColor, BLEND_FACTOR_DST_COLOR = MTLBlendFactorDestinationColor, BLEND_FACTOR_ONE_MINUS_DST_COLOR = MTLBlendFactorOneMinusDestinationColor, BLEND_FACTOR_SRC_ALPHA = MTLBlendFactorSourceAlpha, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = MTLBlendFactorOneMinusSourceAlpha, BLEND_FACTOR_DST_ALPHA = MTLBlendFactorDestinationAlpha, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = MTLBlendFactorOneMinusDestinationAlpha, BLEND_FACTOR_CONSTANT_COLOR = MTLBlendFactorBlendColor, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = MTLBlendFactorOneMinusBlendColor, BLEND_FACTOR_CONSTANT_ALPHA = MTLBlendFactorBlendAlpha, BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = MTLBlendFactorOneMinusBlendAlpha, BLEND_FACTOR_SRC_ALPHA_SATURATE = MTLBlendFactorSourceAlphaSaturated }; enum BlendOp { BLEND_OP_ADD = MTLBlendOperationAdd, BLEND_OP_SUBTRACT = MTLBlendOperationSubtract, BLEND_OP_REVERSE_SUBTRACT = MTLBlendOperationReverseSubtract, BLEND_OP_MIN = MTLBlendOperationMin, BLEND_OP_MAX = MTLBlendOperationMax }; enum BufferUsageFlagBits { BUFFER_USAGE_TRANSFER_SRC_BIT, BUFFER_USAGE_TRANSFER_DST_BIT, BUFFER_USAGE_UNIFORM_BUFFER_BIT, BUFFER_USAGE_STORAGE_BUFFER_BIT, BUFFER_USAGE_VERTEX_BUFFER_BIT, BUFFER_USAGE_INDEX_BUFFER_BIT }; enum ColorComponentFlagBits { COLOR_COMPONENT_R_BIT = MTLColorWriteMaskRed, COLOR_COMPONENT_G_BIT = MTLColorWriteMaskGreen, COLOR_COMPONENT_B_BIT = MTLColorWriteMaskBlue, COLOR_COMPONENT_A_BIT = MTLColorWriteMaskAlpha }; enum CommandBufferLevel { COMMAND_BUFFER_LEVEL_PRIMARY, COMMAND_BUFFER_LEVEL_SECONDARY }; enum CullModeFlags { CULL_MODE_NONE = MTLCullModeNone, CULL_MODE_FRONT_BIT = MTLCullModeFront, CULL_MODE_BACK_BIT = MTLCullModeBack }; enum FenceCreateFlagBits { FENCE_CREATE_SIGNALED_BIT, }; enum FrontFace { FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise }; enum ImageUsageFlagBits { IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, }; enum PipelineStageFlagBits { PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT }; enum ShaderStageFlagBits { SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 31, SHADER_STAGE_ALL }; enum TextureType { TEXTURE_TYPE_2D = MTLTextureType2D, TEXTURE_TYPE_3D = MTLTextureType3D, TEXTURE_TYPE_CUBE = MTLTextureTypeCube, TEXTURE_TYPE_2D_ARRAY = MTLTextureType2DArray }; #define DEFINE_PIXELFORMATS(s, t0, t1) \\ PIXELFORMAT_R##s##_##t0 = MTLPixelFormatR##s##t1, \\ PIXELFORMAT_RG##s##_##t0 = MTLPixelFormatRG##s##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = MTLPixelFormatRGBA##s##t1 enum PixelFormat { PIXELFORMAT_UNDEFINED = MTLPixelFormatInvalid, DEFINE_PIXELFORMATS(8, UNORM, Unorm), DEFINE_PIXELFORMATS(16, UINT, Uint), DEFINE_PIXELFORMATS(16, SFLOAT, Float), DEFINE_PIXELFORMATS(32, UINT, Uint), DEFINE_PIXELFORMATS(32, SFLOAT, Float), PIXELFORMAT_BGRA8_UNORM = MTLPixelFormatBGRA8Unorm, PIXELFORMAT_D16_UNORM = MTLPixelFormatDepth16Unorm, PIXELFORMAT_D24_UNORM = MTLPixelFormatDepth24Unorm_Stencil8, PIXELFORMAT_D24_UNORM_S8 = MTLPixelFormatDepth24Unorm_Stencil8 }; enum IndexFormat { INDEXFORMAT_UINT16 = MTLIndexTypeUInt16, INDEXFORMAT_UINT32 = MTLIndexTypeUInt32 }; #define DEFINE_VERTEXFORMATS(t0, t1) \\ VERTEXFORMAT_##t0 = MTLVertexFormat##t1, \\ VERTEXFORMAT_##t0##2 = MTLVertexFormat##t1##2, \\ VERTEXFORMAT_##t0##3 = MTLVertexFormat##t1##3, \\ VERTEXFORMAT_##t0##4 = MTLVertexFormat##t1##4 enum VertexFormat { DEFINE_VERTEXFORMATS(FLOAT, Float) }; enum DescriptorType { DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER }; enum VertexInputRate { VERTEX_INPUT_RATE_VERTEX, VERTEX_INPUT_RATE_INSTANCE }; enum FilterMode { FILTER_NEAREST, FILTER_LINEAR }; enum ImageLayout { IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLGraphicsCore.h"},{"location":"api/Files/MTLGraphicsCore_8h/#srcngfxportingmetalmtlgraphicscoreh","text":"","title":"src/ngfx/porting/metal/MTLGraphicsCore.h"},{"location":"api/Files/MTLGraphicsCore_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLGraphicsCore_8h/#defines","text":"Name DEFINE_PIXELFORMATS (s, t0, t1) DEFINE_VERTEXFORMATS (t0, t1)","title":"Defines"},{"location":"api/Files/MTLGraphicsCore_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/MTLGraphicsCore_8h/#define-define_pixelformats","text":"#define DEFINE_PIXELFORMATS( s, t0, t1 ) PIXELFORMAT_R##s##_##t0 = MTLPixelFormatR##s##t1, \\ PIXELFORMAT_RG##s##_##t0 = MTLPixelFormatRG##s##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = MTLPixelFormatRGBA##s##t1","title":"define DEFINE_PIXELFORMATS"},{"location":"api/Files/MTLGraphicsCore_8h/#define-define_vertexformats","text":"#define DEFINE_VERTEXFORMATS( t0, t1 ) VERTEXFORMAT_##t0 = MTLVertexFormat##t1, \\ VERTEXFORMAT_##t0##2 = MTLVertexFormat##t1##2, \\ VERTEXFORMAT_##t0##3 = MTLVertexFormat##t1##3, \\ VERTEXFORMAT_##t0##4 = MTLVertexFormat##t1##4","title":"define DEFINE_VERTEXFORMATS"},{"location":"api/Files/MTLGraphicsCore_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/metal/MTLGraphicsCoreDefines.h\" namespace ngfx { enum PrimitiveTopology { PRIMITIVE_TOPOLOGY_POINT_LIST = MTLPrimitiveTypePoint, PRIMITIVE_TOPOLOGY_LINE_LIST = MTLPrimitiveTypeLine, PRIMITIVE_TOPOLOGY_LINE_STRIP = MTLPrimitiveTypeLineStrip, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = MTLPrimitiveTypeTriangle, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = MTLPrimitiveTypeTriangleStrip }; enum PolygonMode { POLYGON_MODE_FILL = MTLTriangleFillModeFill, POLYGON_MODE_LINE = MTLTriangleFillModeLines, }; enum BlendFactor { BLEND_FACTOR_ZERO = MTLBlendFactorZero, BLEND_FACTOR_ONE = MTLBlendFactorOne, BLEND_FACTOR_SRC_COLOR = MTLBlendFactorSourceColor, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = MTLBlendFactorOneMinusSourceColor, BLEND_FACTOR_DST_COLOR = MTLBlendFactorDestinationColor, BLEND_FACTOR_ONE_MINUS_DST_COLOR = MTLBlendFactorOneMinusDestinationColor, BLEND_FACTOR_SRC_ALPHA = MTLBlendFactorSourceAlpha, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = MTLBlendFactorOneMinusSourceAlpha, BLEND_FACTOR_DST_ALPHA = MTLBlendFactorDestinationAlpha, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = MTLBlendFactorOneMinusDestinationAlpha, BLEND_FACTOR_CONSTANT_COLOR = MTLBlendFactorBlendColor, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = MTLBlendFactorOneMinusBlendColor, BLEND_FACTOR_CONSTANT_ALPHA = MTLBlendFactorBlendAlpha, BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = MTLBlendFactorOneMinusBlendAlpha, BLEND_FACTOR_SRC_ALPHA_SATURATE = MTLBlendFactorSourceAlphaSaturated }; enum BlendOp { BLEND_OP_ADD = MTLBlendOperationAdd, BLEND_OP_SUBTRACT = MTLBlendOperationSubtract, BLEND_OP_REVERSE_SUBTRACT = MTLBlendOperationReverseSubtract, BLEND_OP_MIN = MTLBlendOperationMin, BLEND_OP_MAX = MTLBlendOperationMax }; enum BufferUsageFlagBits { BUFFER_USAGE_TRANSFER_SRC_BIT, BUFFER_USAGE_TRANSFER_DST_BIT, BUFFER_USAGE_UNIFORM_BUFFER_BIT, BUFFER_USAGE_STORAGE_BUFFER_BIT, BUFFER_USAGE_VERTEX_BUFFER_BIT, BUFFER_USAGE_INDEX_BUFFER_BIT }; enum ColorComponentFlagBits { COLOR_COMPONENT_R_BIT = MTLColorWriteMaskRed, COLOR_COMPONENT_G_BIT = MTLColorWriteMaskGreen, COLOR_COMPONENT_B_BIT = MTLColorWriteMaskBlue, COLOR_COMPONENT_A_BIT = MTLColorWriteMaskAlpha }; enum CommandBufferLevel { COMMAND_BUFFER_LEVEL_PRIMARY, COMMAND_BUFFER_LEVEL_SECONDARY }; enum CullModeFlags { CULL_MODE_NONE = MTLCullModeNone, CULL_MODE_FRONT_BIT = MTLCullModeFront, CULL_MODE_BACK_BIT = MTLCullModeBack }; enum FenceCreateFlagBits { FENCE_CREATE_SIGNALED_BIT, }; enum FrontFace { FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise }; enum ImageUsageFlagBits { IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, }; enum PipelineStageFlagBits { PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT }; enum ShaderStageFlagBits { SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 31, SHADER_STAGE_ALL }; enum TextureType { TEXTURE_TYPE_2D = MTLTextureType2D, TEXTURE_TYPE_3D = MTLTextureType3D, TEXTURE_TYPE_CUBE = MTLTextureTypeCube, TEXTURE_TYPE_2D_ARRAY = MTLTextureType2DArray }; #define DEFINE_PIXELFORMATS(s, t0, t1) \\ PIXELFORMAT_R##s##_##t0 = MTLPixelFormatR##s##t1, \\ PIXELFORMAT_RG##s##_##t0 = MTLPixelFormatRG##s##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = MTLPixelFormatRGBA##s##t1 enum PixelFormat { PIXELFORMAT_UNDEFINED = MTLPixelFormatInvalid, DEFINE_PIXELFORMATS(8, UNORM, Unorm), DEFINE_PIXELFORMATS(16, UINT, Uint), DEFINE_PIXELFORMATS(16, SFLOAT, Float), DEFINE_PIXELFORMATS(32, UINT, Uint), DEFINE_PIXELFORMATS(32, SFLOAT, Float), PIXELFORMAT_BGRA8_UNORM = MTLPixelFormatBGRA8Unorm, PIXELFORMAT_D16_UNORM = MTLPixelFormatDepth16Unorm, PIXELFORMAT_D24_UNORM = MTLPixelFormatDepth24Unorm_Stencil8, PIXELFORMAT_D24_UNORM_S8 = MTLPixelFormatDepth24Unorm_Stencil8 }; enum IndexFormat { INDEXFORMAT_UINT16 = MTLIndexTypeUInt16, INDEXFORMAT_UINT32 = MTLIndexTypeUInt32 }; #define DEFINE_VERTEXFORMATS(t0, t1) \\ VERTEXFORMAT_##t0 = MTLVertexFormat##t1, \\ VERTEXFORMAT_##t0##2 = MTLVertexFormat##t1##2, \\ VERTEXFORMAT_##t0##3 = MTLVertexFormat##t1##3, \\ VERTEXFORMAT_##t0##4 = MTLVertexFormat##t1##4 enum VertexFormat { DEFINE_VERTEXFORMATS(FLOAT, Float) }; enum DescriptorType { DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER }; enum VertexInputRate { VERTEX_INPUT_RATE_VERTEX, VERTEX_INPUT_RATE_INSTANCE }; enum FilterMode { FILTER_NEAREST, FILTER_LINEAR }; enum ImageLayout { IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLGraphicsPipeline_8h/","text":"src/ngfx/porting/metal/MTLGraphicsPipeline.h Namespaces Name ngfx Classes Name class ngfx::MTLGraphicsPipeline struct ngfx::MTLGraphicsPipeline::Shaders Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLGraphicsContext; class MTLGraphicsPipeline : public GraphicsPipeline { public: struct Shaders { id<MTLFunction> VS, PS; }; void create(MTLGraphicsContext *ctx, const State &state, MTLVertexDescriptor *vertexDescriptor, const Shaders &shaders, ::MTLPixelFormat colorFormat, ::MTLPixelFormat depthFormat); virtual ~MTLGraphicsPipeline() {} id<MTLRenderPipelineState> mtlPipelineState; id<MTLDepthStencilState> mtlDepthStencilState; MTLRenderPipelineReflection *reflection; ::MTLPrimitiveType mtlPrimitiveType; ::MTLCullMode mtlCullMode; ::MTLWinding mtlFrontFaceWinding; }; MTL_CAST(GraphicsPipeline); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLGraphicsPipeline.h"},{"location":"api/Files/MTLGraphicsPipeline_8h/#srcngfxportingmetalmtlgraphicspipelineh","text":"","title":"src/ngfx/porting/metal/MTLGraphicsPipeline.h"},{"location":"api/Files/MTLGraphicsPipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLGraphicsPipeline_8h/#classes","text":"Name class ngfx::MTLGraphicsPipeline struct ngfx::MTLGraphicsPipeline::Shaders","title":"Classes"},{"location":"api/Files/MTLGraphicsPipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLGraphicsContext; class MTLGraphicsPipeline : public GraphicsPipeline { public: struct Shaders { id<MTLFunction> VS, PS; }; void create(MTLGraphicsContext *ctx, const State &state, MTLVertexDescriptor *vertexDescriptor, const Shaders &shaders, ::MTLPixelFormat colorFormat, ::MTLPixelFormat depthFormat); virtual ~MTLGraphicsPipeline() {} id<MTLRenderPipelineState> mtlPipelineState; id<MTLDepthStencilState> mtlDepthStencilState; MTLRenderPipelineReflection *reflection; ::MTLPrimitiveType mtlPrimitiveType; ::MTLCullMode mtlCullMode; ::MTLWinding mtlFrontFaceWinding; }; MTL_CAST(GraphicsPipeline); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLGraphicsPipeline_8mm/","text":"src/ngfx/porting/metal/MTLGraphicsPipeline.mm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLGraphicsPipeline.h\" #include \"ngfx/porting/metal/MTLPipelineUtil.h\" #include \"ngfx/porting/metal/MTLShaderModule.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLRenderCommandEncoder.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void MTLGraphicsPipeline::create(MTLGraphicsContext* ctx, const State& state, MTLVertexDescriptor* vertexDescriptor, const Shaders& shaders, ::MTLPixelFormat colorFormat, ::MTLPixelFormat depthFormat) { NSError* error; auto device = ctx->mtlDevice.v; MTLRenderPipelineDescriptor *pipelineStateDescriptor = [MTLRenderPipelineDescriptor new]; pipelineStateDescriptor.label = @\"\"; pipelineStateDescriptor.vertexFunction = shaders.VS; pipelineStateDescriptor.fragmentFunction = shaders.PS; for (uint32_t j = 0; j<state.numColorAttachments; j++) { auto colorAttachment = pipelineStateDescriptor.colorAttachments[j]; colorAttachment.pixelFormat = colorFormat; colorAttachment.blendingEnabled = state.blendEnable; colorAttachment.sourceRGBBlendFactor = ::MTLBlendFactor(state.srcColorBlendFactor); colorAttachment.sourceAlphaBlendFactor = ::MTLBlendFactor(state.srcAlphaBlendFactor); colorAttachment.destinationRGBBlendFactor = ::MTLBlendFactor(state.dstColorBlendFactor); colorAttachment.destinationAlphaBlendFactor = ::MTLBlendFactor(state.dstAlphaBlendFactor); colorAttachment.rgbBlendOperation = ::MTLBlendOperation(state.colorBlendOp); colorAttachment.alphaBlendOperation = ::MTLBlendOperation(state.alphaBlendOp); colorAttachment.writeMask = state.colorWriteMask; } pipelineStateDescriptor.rasterSampleCount = state.numSamples; pipelineStateDescriptor.vertexDescriptor = vertexDescriptor; pipelineStateDescriptor.depthAttachmentPixelFormat = depthFormat; const std::vector<MTLPixelFormat> stencilFormats = { MTLPixelFormatStencil8 ,MTLPixelFormatDepth24Unorm_Stencil8, MTLPixelFormatDepth32Float_Stencil8, }; if (std::find(stencilFormats.begin(), stencilFormats.end(), depthFormat) != stencilFormats.end()) { pipelineStateDescriptor.stencilAttachmentPixelFormat = depthFormat; } MTLPipelineOption options = MTLPipelineOptionArgumentInfo | MTLPipelineOptionBufferTypeInfo; mtlPipelineState = [device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor options:options reflection:&reflection error:&error]; [pipelineStateDescriptor release]; NSCAssert(mtlPipelineState, @\"Failed to create pipeline state: %@\", error); mtlPrimitiveType = ::MTLPrimitiveType(state.primitiveTopology); mtlCullMode = ::MTLCullMode(state.cullModeFlags); mtlFrontFaceWinding = ::MTLWinding(state.frontFace); if (state.depthTestEnable) { MTLDepthStencilDescriptor *depthStencilDesc = [[MTLDepthStencilDescriptor alloc] init]; depthStencilDesc.depthCompareFunction = MTLCompareFunctionLess; depthStencilDesc.depthWriteEnabled = state.depthWriteEnable; mtlDepthStencilState = [device newDepthStencilStateWithDescriptor:depthStencilDesc]; } } GraphicsPipeline* GraphicsPipeline::create(GraphicsContext* ctx, const GraphicsPipeline::State &state, VertexShaderModule* vs, FragmentShaderModule* fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes) { MTLGraphicsPipeline* mtlGraphicsPipeline = new MTLGraphicsPipeline(); auto& descriptorBindings = mtlGraphicsPipeline->descriptorBindings; MTLPipelineUtil::parseDescriptors(vs->descriptors, descriptorBindings); MTLPipelineUtil::parseDescriptors(fs->descriptors, descriptorBindings); uint32_t numVSDescriptors = vs->descriptors.size(); MTLVertexDescriptor *vertexDescriptor = [MTLVertexDescriptor new]; auto& vertexAttributeBindings = mtlGraphicsPipeline->vertexAttributeBindings; vertexAttributeBindings.resize(vs->attributes.size()); for (uint32_t j = 0; j<vs->attributes.size(); j++) { auto& attr = vs->attributes[j]; auto mtlAttr = vertexDescriptor.attributes[attr.location - numVSDescriptors]; mtlAttr.bufferIndex = attr.location; auto mtlLayout = vertexDescriptor.layouts[mtlAttr.bufferIndex]; uint32_t stride = attr.elementSize; auto mtlVertexFormat = attr.format; mtlAttr.format = ::MTLVertexFormat(mtlVertexFormat); mtlAttr.offset = 0; mtlLayout.stride = stride; if (instanceAttributes.find(attr.name) != instanceAttributes.end()) mtlLayout.stepFunction = MTLVertexStepFunctionPerInstance; vertexAttributeBindings[j] = attr.location; } MTLGraphicsPipeline::Shaders shaders; shaders.VS = mtl(vs)->mtlFunction; shaders.PS = mtl(fs)->mtlFunction; mtlGraphicsPipeline->create(mtl(ctx), state, vertexDescriptor, shaders, ::MTLPixelFormat(colorFormat), ::MTLPixelFormat(depthFormat)); [vertexDescriptor release]; return mtlGraphicsPipeline; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLGraphicsPipeline.mm"},{"location":"api/Files/MTLGraphicsPipeline_8mm/#srcngfxportingmetalmtlgraphicspipelinemm","text":"","title":"src/ngfx/porting/metal/MTLGraphicsPipeline.mm"},{"location":"api/Files/MTLGraphicsPipeline_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLGraphicsPipeline.h\" #include \"ngfx/porting/metal/MTLPipelineUtil.h\" #include \"ngfx/porting/metal/MTLShaderModule.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLRenderCommandEncoder.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void MTLGraphicsPipeline::create(MTLGraphicsContext* ctx, const State& state, MTLVertexDescriptor* vertexDescriptor, const Shaders& shaders, ::MTLPixelFormat colorFormat, ::MTLPixelFormat depthFormat) { NSError* error; auto device = ctx->mtlDevice.v; MTLRenderPipelineDescriptor *pipelineStateDescriptor = [MTLRenderPipelineDescriptor new]; pipelineStateDescriptor.label = @\"\"; pipelineStateDescriptor.vertexFunction = shaders.VS; pipelineStateDescriptor.fragmentFunction = shaders.PS; for (uint32_t j = 0; j<state.numColorAttachments; j++) { auto colorAttachment = pipelineStateDescriptor.colorAttachments[j]; colorAttachment.pixelFormat = colorFormat; colorAttachment.blendingEnabled = state.blendEnable; colorAttachment.sourceRGBBlendFactor = ::MTLBlendFactor(state.srcColorBlendFactor); colorAttachment.sourceAlphaBlendFactor = ::MTLBlendFactor(state.srcAlphaBlendFactor); colorAttachment.destinationRGBBlendFactor = ::MTLBlendFactor(state.dstColorBlendFactor); colorAttachment.destinationAlphaBlendFactor = ::MTLBlendFactor(state.dstAlphaBlendFactor); colorAttachment.rgbBlendOperation = ::MTLBlendOperation(state.colorBlendOp); colorAttachment.alphaBlendOperation = ::MTLBlendOperation(state.alphaBlendOp); colorAttachment.writeMask = state.colorWriteMask; } pipelineStateDescriptor.rasterSampleCount = state.numSamples; pipelineStateDescriptor.vertexDescriptor = vertexDescriptor; pipelineStateDescriptor.depthAttachmentPixelFormat = depthFormat; const std::vector<MTLPixelFormat> stencilFormats = { MTLPixelFormatStencil8 ,MTLPixelFormatDepth24Unorm_Stencil8, MTLPixelFormatDepth32Float_Stencil8, }; if (std::find(stencilFormats.begin(), stencilFormats.end(), depthFormat) != stencilFormats.end()) { pipelineStateDescriptor.stencilAttachmentPixelFormat = depthFormat; } MTLPipelineOption options = MTLPipelineOptionArgumentInfo | MTLPipelineOptionBufferTypeInfo; mtlPipelineState = [device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor options:options reflection:&reflection error:&error]; [pipelineStateDescriptor release]; NSCAssert(mtlPipelineState, @\"Failed to create pipeline state: %@\", error); mtlPrimitiveType = ::MTLPrimitiveType(state.primitiveTopology); mtlCullMode = ::MTLCullMode(state.cullModeFlags); mtlFrontFaceWinding = ::MTLWinding(state.frontFace); if (state.depthTestEnable) { MTLDepthStencilDescriptor *depthStencilDesc = [[MTLDepthStencilDescriptor alloc] init]; depthStencilDesc.depthCompareFunction = MTLCompareFunctionLess; depthStencilDesc.depthWriteEnabled = state.depthWriteEnable; mtlDepthStencilState = [device newDepthStencilStateWithDescriptor:depthStencilDesc]; } } GraphicsPipeline* GraphicsPipeline::create(GraphicsContext* ctx, const GraphicsPipeline::State &state, VertexShaderModule* vs, FragmentShaderModule* fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes) { MTLGraphicsPipeline* mtlGraphicsPipeline = new MTLGraphicsPipeline(); auto& descriptorBindings = mtlGraphicsPipeline->descriptorBindings; MTLPipelineUtil::parseDescriptors(vs->descriptors, descriptorBindings); MTLPipelineUtil::parseDescriptors(fs->descriptors, descriptorBindings); uint32_t numVSDescriptors = vs->descriptors.size(); MTLVertexDescriptor *vertexDescriptor = [MTLVertexDescriptor new]; auto& vertexAttributeBindings = mtlGraphicsPipeline->vertexAttributeBindings; vertexAttributeBindings.resize(vs->attributes.size()); for (uint32_t j = 0; j<vs->attributes.size(); j++) { auto& attr = vs->attributes[j]; auto mtlAttr = vertexDescriptor.attributes[attr.location - numVSDescriptors]; mtlAttr.bufferIndex = attr.location; auto mtlLayout = vertexDescriptor.layouts[mtlAttr.bufferIndex]; uint32_t stride = attr.elementSize; auto mtlVertexFormat = attr.format; mtlAttr.format = ::MTLVertexFormat(mtlVertexFormat); mtlAttr.offset = 0; mtlLayout.stride = stride; if (instanceAttributes.find(attr.name) != instanceAttributes.end()) mtlLayout.stepFunction = MTLVertexStepFunctionPerInstance; vertexAttributeBindings[j] = attr.location; } MTLGraphicsPipeline::Shaders shaders; shaders.VS = mtl(vs)->mtlFunction; shaders.PS = mtl(fs)->mtlFunction; mtlGraphicsPipeline->create(mtl(ctx), state, vertexDescriptor, shaders, ::MTLPixelFormat(colorFormat), ::MTLPixelFormat(depthFormat)); [vertexDescriptor release]; return mtlGraphicsPipeline; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLGraphics_8h/","text":"src/ngfx/porting/metal/MTLGraphics.h Namespaces Name ngfx Classes Name class ngfx::MTLGraphics Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/porting/metal/MTLBuffer.h\" #include \"ngfx/porting/metal/MTLComputeCommandEncoder.h\" #include \"ngfx/porting/metal/MTLRenderCommandEncoder.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class GraphicsContext; class MTLGraphics : public Graphics { public: void create(); virtual ~MTLGraphics() {} void beginComputePass(CommandBuffer *commandBuffer) override; void endComputePass(CommandBuffer *commandBuffer) override; void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) override; void endRenderPass(CommandBuffer *commandBuffer) override; void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) override; void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat = INDEXFORMAT_UINT32) override; void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) override; void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) override; void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) override; void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override; void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) override; void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) override; void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) override; void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) override; void waitIdle(CommandBuffer *cmdBuffer) override; MTLComputeCommandEncoder currentComputeCommandEncoder; MTLRenderCommandEncoder currentRenderCommandEncoder; MTLCommandEncoder *currentCommandEncoder = nullptr; ::MTLPrimitiveType currentPrimitiveType; MTLBuffer *currentIndexBuffer = nullptr; IndexFormat currentIndexFormat; private: NSAutoreleasePool *autoReleasePool = nullptr; }; MTL_CAST(Graphics); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLGraphics.h"},{"location":"api/Files/MTLGraphics_8h/#srcngfxportingmetalmtlgraphicsh","text":"","title":"src/ngfx/porting/metal/MTLGraphics.h"},{"location":"api/Files/MTLGraphics_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLGraphics_8h/#classes","text":"Name class ngfx::MTLGraphics","title":"Classes"},{"location":"api/Files/MTLGraphics_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/porting/metal/MTLBuffer.h\" #include \"ngfx/porting/metal/MTLComputeCommandEncoder.h\" #include \"ngfx/porting/metal/MTLRenderCommandEncoder.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class GraphicsContext; class MTLGraphics : public Graphics { public: void create(); virtual ~MTLGraphics() {} void beginComputePass(CommandBuffer *commandBuffer) override; void endComputePass(CommandBuffer *commandBuffer) override; void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) override; void endRenderPass(CommandBuffer *commandBuffer) override; void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) override; void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat = INDEXFORMAT_UINT32) override; void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) override; void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) override; void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) override; void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override; void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) override; void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) override; void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) override; void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) override; void waitIdle(CommandBuffer *cmdBuffer) override; MTLComputeCommandEncoder currentComputeCommandEncoder; MTLRenderCommandEncoder currentRenderCommandEncoder; MTLCommandEncoder *currentCommandEncoder = nullptr; ::MTLPrimitiveType currentPrimitiveType; MTLBuffer *currentIndexBuffer = nullptr; IndexFormat currentIndexFormat; private: NSAutoreleasePool *autoReleasePool = nullptr; }; MTL_CAST(Graphics); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLGraphics_8mm/","text":"src/ngfx/porting/metal/MTLGraphics.mm Classes Name struct MTLGraphicsUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLGraphics.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLFramebuffer.h\" #include \"ngfx/porting/metal/MTLRenderPass.h\" #include \"ngfx/porting/metal/MTLTexture.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLComputePipeline.h\" #include \"ngfx/porting/metal/MTLGraphicsPipeline.h\" #include \"ngfx/porting/metal/MTLComputeCommandEncoder.h\" #include \"ngfx/porting/metal/MTLRenderCommandEncoder.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void MTLGraphics::create() {} void MTLGraphics::beginComputePass(CommandBuffer* commandBuffer) { auto mtlCommandBuffer = mtl(commandBuffer); currentComputeCommandEncoder.v = [mtlCommandBuffer->v computeCommandEncoder]; currentCommandEncoder = &currentComputeCommandEncoder; } void MTLGraphics::endComputePass(CommandBuffer* commandBuffer) { [currentComputeCommandEncoder.v endEncoding]; currentComputeCommandEncoder.v = nullptr; } struct MTLGraphicsUtil { static void setViewport(MTLGraphics* g, Rect2D& r) { [g->currentRenderCommandEncoder.v setViewport:(MTLViewport){ double(r.x), double(r.y), double(r.w), double(r.h), 0.0, 1.0 }]; } static void setScissor(MTLGraphics* g, Rect2D &r) { #ifdef ORIGIN_BOTTOM_LEFT Rect2D &vp = g->viewport; MTLScissorRect mtlScissorRect = { NSUInteger(r.x), vp.h - r.y - r.h , r.w, r.h }; #else MTLScissorRect mtlScissorRect = { NSUInteger(r.x), NSUInteger(r.y), r.w, r.h }; #endif [g->currentRenderCommandEncoder.v setScissorRect:mtlScissorRect]; } }; void MTLGraphics::beginRenderPass(CommandBuffer* commandBuffer, RenderPass* renderPass, Framebuffer* framebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil) { autoReleasePool = [[NSAutoreleasePool alloc] init]; MTLRenderPassDescriptor* mtlRenderPassDescriptor = mtl(renderPass)->getDescriptor(mtl(ctx), mtl(framebuffer), clearColor, clearDepth, clearStencil); currentRenderCommandEncoder.v = [mtl(commandBuffer)->v renderCommandEncoderWithDescriptor:mtlRenderPassDescriptor]; currentCommandEncoder = &currentRenderCommandEncoder; } void MTLGraphics::endRenderPass(CommandBuffer* commandBuffer) { [currentRenderCommandEncoder.v endEncoding]; currentRenderCommandEncoder.v = nullptr; [autoReleasePool release]; } void MTLGraphics::bindVertexBuffer(CommandBuffer* cmdBuffer, Buffer* buffer, uint32_t location, uint32_t stride) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; [renderEncoder->v setVertexBuffer:mtl(buffer)->v offset:0 atIndex:location]; } void MTLGraphics::bindIndexBuffer(CommandBuffer* cmdBuffer, Buffer* buffer, IndexFormat indexFormat) { currentIndexBuffer = mtl(buffer); currentIndexFormat = indexFormat; } void MTLGraphics::bindUniformBuffer(CommandBuffer* cmdBuffer, Buffer* buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) { if (MTLGraphicsPipeline* graphicsPipeline = dynamic_cast<MTLGraphicsPipeline*>(currentPipeline)) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; if (shaderStageFlags & SHADER_STAGE_VERTEX_BIT) { [renderEncoder->v setVertexBuffer:mtl(buffer)->v offset:0 atIndex:binding]; } if (shaderStageFlags & SHADER_STAGE_FRAGMENT_BIT) { [renderEncoder->v setFragmentBuffer:mtl(buffer)->v offset:0 atIndex:binding]; } } else if (MTLComputePipeline* computePipeline = dynamic_cast<MTLComputePipeline*>(currentPipeline)) { auto computeEncoder = (MTLComputeCommandEncoder*)currentCommandEncoder; [computeEncoder->v setBuffer:mtl(buffer)->v offset:0 atIndex:binding]; } } void MTLGraphics::bindStorageBuffer(CommandBuffer* cmdBuffer, Buffer* buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) { if (MTLGraphicsPipeline* graphicsPipeline = dynamic_cast<MTLGraphicsPipeline*>(currentPipeline)) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; if (shaderStageFlags & SHADER_STAGE_VERTEX_BIT) [renderEncoder->v setVertexBuffer:mtl(buffer)->v offset:0 atIndex:binding]; if (shaderStageFlags & SHADER_STAGE_FRAGMENT_BIT) [renderEncoder->v setFragmentBuffer:mtl(buffer)->v offset:0 atIndex:binding]; } else if (MTLComputePipeline* computePipeline = dynamic_cast<MTLComputePipeline*>(currentPipeline)) { auto computeEncoder = (MTLComputeCommandEncoder*)currentCommandEncoder; [computeEncoder->v setBuffer:mtl(buffer)->v offset:0 atIndex:binding]; } } void MTLGraphics::bindComputePipeline(CommandBuffer* cmdBuffer, ComputePipeline* computePipeline) { auto computeEncoder = (MTLComputeCommandEncoder*)currentCommandEncoder; [computeEncoder->v setComputePipelineState: mtl(computePipeline)->mtlPipelineState]; currentPipeline = computePipeline; } void MTLGraphics::bindGraphicsPipeline(CommandBuffer* cmdBuffer, GraphicsPipeline* graphicsPipeline) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; auto mtlPipeline = mtl(graphicsPipeline); [renderEncoder->v setRenderPipelineState: mtlPipeline->mtlPipelineState]; [renderEncoder->v setCullMode: mtlPipeline->mtlCullMode]; [renderEncoder->v setFrontFacingWinding: mtlPipeline->mtlFrontFaceWinding]; if (mtlPipeline->mtlDepthStencilState) { [renderEncoder->v setDepthStencilState: mtlPipeline->mtlDepthStencilState]; } currentPrimitiveType = mtl(graphicsPipeline)->mtlPrimitiveType; currentPipeline = graphicsPipeline; } void MTLGraphics::bindTexture(CommandBuffer* cmdBuffer, Texture* texture, uint32_t set) { if (MTLRenderCommandEncoder* renderEncoder = dynamic_cast<MTLRenderCommandEncoder*>(currentCommandEncoder)) { [renderEncoder->v setFragmentTexture: mtl(texture)->v atIndex: set]; [renderEncoder->v setFragmentSamplerState: mtl(texture)->mtlSamplerState atIndex: set]; } else if (MTLComputeCommandEncoder* computeEncoder = dynamic_cast<MTLComputeCommandEncoder*>(currentCommandEncoder)) { [computeEncoder->v setTexture: mtl(texture)->v atIndex: set]; [computeEncoder->v setSamplerState: mtl(texture)->mtlSamplerState atIndex: set]; } } void MTLGraphics::dispatch(CommandBuffer* cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) { auto computeEncoder = (MTLComputeCommandEncoder*)currentCommandEncoder; [computeEncoder->v dispatchThreadgroups:MTLSizeMake(groupCountX, groupCountY, groupCountZ) threadsPerThreadgroup:MTLSizeMake(threadsPerGroupX, threadsPerGroupY, threadsPerGroupZ)]; } void MTLGraphics::draw(CommandBuffer* cmdBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; [renderEncoder->v drawPrimitives: currentPrimitiveType vertexStart:firstVertex vertexCount:vertexCount instanceCount: instanceCount baseInstance: firstInstance]; } void MTLGraphics::drawIndexed(CommandBuffer* cmdBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; [renderEncoder->v drawIndexedPrimitives:currentPrimitiveType indexCount:indexCount indexType: (currentIndexFormat == INDEXFORMAT_UINT16 ? ::MTLIndexTypeUInt16 : ::MTLIndexTypeUInt32) indexBuffer:currentIndexBuffer->v indexBufferOffset:0 instanceCount: instanceCount baseVertex: 0 baseInstance: firstInstance]; } void MTLGraphics::setViewport(CommandBuffer* cmdBuffer, Rect2D r) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; if (renderEncoder) MTLGraphicsUtil::setViewport(this, r); viewport = r; } void MTLGraphics::setScissor(CommandBuffer* cmdBuffer, Rect2D r) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; if (renderEncoder) MTLGraphicsUtil::setScissor(this, r); scissorRect = r; } void MTLGraphics::waitIdle(CommandBuffer* cmdBuffer) { mtl(cmdBuffer)->waitUntilCompleted(); } Graphics* Graphics::create(GraphicsContext* ctx) { MTLGraphics* mtlGraphics = new MTLGraphics(); mtlGraphics->ctx = ctx; mtlGraphics->create(); return mtlGraphics; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLGraphics.mm"},{"location":"api/Files/MTLGraphics_8mm/#srcngfxportingmetalmtlgraphicsmm","text":"","title":"src/ngfx/porting/metal/MTLGraphics.mm"},{"location":"api/Files/MTLGraphics_8mm/#classes","text":"Name struct MTLGraphicsUtil","title":"Classes"},{"location":"api/Files/MTLGraphics_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLGraphics.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLFramebuffer.h\" #include \"ngfx/porting/metal/MTLRenderPass.h\" #include \"ngfx/porting/metal/MTLTexture.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLComputePipeline.h\" #include \"ngfx/porting/metal/MTLGraphicsPipeline.h\" #include \"ngfx/porting/metal/MTLComputeCommandEncoder.h\" #include \"ngfx/porting/metal/MTLRenderCommandEncoder.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void MTLGraphics::create() {} void MTLGraphics::beginComputePass(CommandBuffer* commandBuffer) { auto mtlCommandBuffer = mtl(commandBuffer); currentComputeCommandEncoder.v = [mtlCommandBuffer->v computeCommandEncoder]; currentCommandEncoder = &currentComputeCommandEncoder; } void MTLGraphics::endComputePass(CommandBuffer* commandBuffer) { [currentComputeCommandEncoder.v endEncoding]; currentComputeCommandEncoder.v = nullptr; } struct MTLGraphicsUtil { static void setViewport(MTLGraphics* g, Rect2D& r) { [g->currentRenderCommandEncoder.v setViewport:(MTLViewport){ double(r.x), double(r.y), double(r.w), double(r.h), 0.0, 1.0 }]; } static void setScissor(MTLGraphics* g, Rect2D &r) { #ifdef ORIGIN_BOTTOM_LEFT Rect2D &vp = g->viewport; MTLScissorRect mtlScissorRect = { NSUInteger(r.x), vp.h - r.y - r.h , r.w, r.h }; #else MTLScissorRect mtlScissorRect = { NSUInteger(r.x), NSUInteger(r.y), r.w, r.h }; #endif [g->currentRenderCommandEncoder.v setScissorRect:mtlScissorRect]; } }; void MTLGraphics::beginRenderPass(CommandBuffer* commandBuffer, RenderPass* renderPass, Framebuffer* framebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil) { autoReleasePool = [[NSAutoreleasePool alloc] init]; MTLRenderPassDescriptor* mtlRenderPassDescriptor = mtl(renderPass)->getDescriptor(mtl(ctx), mtl(framebuffer), clearColor, clearDepth, clearStencil); currentRenderCommandEncoder.v = [mtl(commandBuffer)->v renderCommandEncoderWithDescriptor:mtlRenderPassDescriptor]; currentCommandEncoder = &currentRenderCommandEncoder; } void MTLGraphics::endRenderPass(CommandBuffer* commandBuffer) { [currentRenderCommandEncoder.v endEncoding]; currentRenderCommandEncoder.v = nullptr; [autoReleasePool release]; } void MTLGraphics::bindVertexBuffer(CommandBuffer* cmdBuffer, Buffer* buffer, uint32_t location, uint32_t stride) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; [renderEncoder->v setVertexBuffer:mtl(buffer)->v offset:0 atIndex:location]; } void MTLGraphics::bindIndexBuffer(CommandBuffer* cmdBuffer, Buffer* buffer, IndexFormat indexFormat) { currentIndexBuffer = mtl(buffer); currentIndexFormat = indexFormat; } void MTLGraphics::bindUniformBuffer(CommandBuffer* cmdBuffer, Buffer* buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) { if (MTLGraphicsPipeline* graphicsPipeline = dynamic_cast<MTLGraphicsPipeline*>(currentPipeline)) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; if (shaderStageFlags & SHADER_STAGE_VERTEX_BIT) { [renderEncoder->v setVertexBuffer:mtl(buffer)->v offset:0 atIndex:binding]; } if (shaderStageFlags & SHADER_STAGE_FRAGMENT_BIT) { [renderEncoder->v setFragmentBuffer:mtl(buffer)->v offset:0 atIndex:binding]; } } else if (MTLComputePipeline* computePipeline = dynamic_cast<MTLComputePipeline*>(currentPipeline)) { auto computeEncoder = (MTLComputeCommandEncoder*)currentCommandEncoder; [computeEncoder->v setBuffer:mtl(buffer)->v offset:0 atIndex:binding]; } } void MTLGraphics::bindStorageBuffer(CommandBuffer* cmdBuffer, Buffer* buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) { if (MTLGraphicsPipeline* graphicsPipeline = dynamic_cast<MTLGraphicsPipeline*>(currentPipeline)) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; if (shaderStageFlags & SHADER_STAGE_VERTEX_BIT) [renderEncoder->v setVertexBuffer:mtl(buffer)->v offset:0 atIndex:binding]; if (shaderStageFlags & SHADER_STAGE_FRAGMENT_BIT) [renderEncoder->v setFragmentBuffer:mtl(buffer)->v offset:0 atIndex:binding]; } else if (MTLComputePipeline* computePipeline = dynamic_cast<MTLComputePipeline*>(currentPipeline)) { auto computeEncoder = (MTLComputeCommandEncoder*)currentCommandEncoder; [computeEncoder->v setBuffer:mtl(buffer)->v offset:0 atIndex:binding]; } } void MTLGraphics::bindComputePipeline(CommandBuffer* cmdBuffer, ComputePipeline* computePipeline) { auto computeEncoder = (MTLComputeCommandEncoder*)currentCommandEncoder; [computeEncoder->v setComputePipelineState: mtl(computePipeline)->mtlPipelineState]; currentPipeline = computePipeline; } void MTLGraphics::bindGraphicsPipeline(CommandBuffer* cmdBuffer, GraphicsPipeline* graphicsPipeline) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; auto mtlPipeline = mtl(graphicsPipeline); [renderEncoder->v setRenderPipelineState: mtlPipeline->mtlPipelineState]; [renderEncoder->v setCullMode: mtlPipeline->mtlCullMode]; [renderEncoder->v setFrontFacingWinding: mtlPipeline->mtlFrontFaceWinding]; if (mtlPipeline->mtlDepthStencilState) { [renderEncoder->v setDepthStencilState: mtlPipeline->mtlDepthStencilState]; } currentPrimitiveType = mtl(graphicsPipeline)->mtlPrimitiveType; currentPipeline = graphicsPipeline; } void MTLGraphics::bindTexture(CommandBuffer* cmdBuffer, Texture* texture, uint32_t set) { if (MTLRenderCommandEncoder* renderEncoder = dynamic_cast<MTLRenderCommandEncoder*>(currentCommandEncoder)) { [renderEncoder->v setFragmentTexture: mtl(texture)->v atIndex: set]; [renderEncoder->v setFragmentSamplerState: mtl(texture)->mtlSamplerState atIndex: set]; } else if (MTLComputeCommandEncoder* computeEncoder = dynamic_cast<MTLComputeCommandEncoder*>(currentCommandEncoder)) { [computeEncoder->v setTexture: mtl(texture)->v atIndex: set]; [computeEncoder->v setSamplerState: mtl(texture)->mtlSamplerState atIndex: set]; } } void MTLGraphics::dispatch(CommandBuffer* cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) { auto computeEncoder = (MTLComputeCommandEncoder*)currentCommandEncoder; [computeEncoder->v dispatchThreadgroups:MTLSizeMake(groupCountX, groupCountY, groupCountZ) threadsPerThreadgroup:MTLSizeMake(threadsPerGroupX, threadsPerGroupY, threadsPerGroupZ)]; } void MTLGraphics::draw(CommandBuffer* cmdBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; [renderEncoder->v drawPrimitives: currentPrimitiveType vertexStart:firstVertex vertexCount:vertexCount instanceCount: instanceCount baseInstance: firstInstance]; } void MTLGraphics::drawIndexed(CommandBuffer* cmdBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; [renderEncoder->v drawIndexedPrimitives:currentPrimitiveType indexCount:indexCount indexType: (currentIndexFormat == INDEXFORMAT_UINT16 ? ::MTLIndexTypeUInt16 : ::MTLIndexTypeUInt32) indexBuffer:currentIndexBuffer->v indexBufferOffset:0 instanceCount: instanceCount baseVertex: 0 baseInstance: firstInstance]; } void MTLGraphics::setViewport(CommandBuffer* cmdBuffer, Rect2D r) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; if (renderEncoder) MTLGraphicsUtil::setViewport(this, r); viewport = r; } void MTLGraphics::setScissor(CommandBuffer* cmdBuffer, Rect2D r) { auto renderEncoder = (MTLRenderCommandEncoder*)currentCommandEncoder; if (renderEncoder) MTLGraphicsUtil::setScissor(this, r); scissorRect = r; } void MTLGraphics::waitIdle(CommandBuffer* cmdBuffer) { mtl(cmdBuffer)->waitUntilCompleted(); } Graphics* Graphics::create(GraphicsContext* ctx) { MTLGraphics* mtlGraphics = new MTLGraphics(); mtlGraphics->ctx = ctx; mtlGraphics->create(); return mtlGraphics; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLPipelineCache_8h/","text":"src/ngfx/porting/metal/MTLPipelineCache.h Namespaces Name ngfx Classes Name class ngfx::MTLPipelineCache Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/PipelineCache.h\" namespace ngfx { class MTLPipelineCache : public PipelineCache { public: virtual ~MTLPipelineCache() {} }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLPipelineCache.h"},{"location":"api/Files/MTLPipelineCache_8h/#srcngfxportingmetalmtlpipelinecacheh","text":"","title":"src/ngfx/porting/metal/MTLPipelineCache.h"},{"location":"api/Files/MTLPipelineCache_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLPipelineCache_8h/#classes","text":"Name class ngfx::MTLPipelineCache","title":"Classes"},{"location":"api/Files/MTLPipelineCache_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/PipelineCache.h\" namespace ngfx { class MTLPipelineCache : public PipelineCache { public: virtual ~MTLPipelineCache() {} }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLPipelineUtil_8h/","text":"src/ngfx/porting/metal/MTLPipelineUtil.h Namespaces Name ngfx Classes Name struct ngfx::MTLPipelineUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/metal/MTLShaderModule.h\" namespace ngfx { struct MTLPipelineUtil { static void parseDescriptors(ShaderModule::DescriptorInfos &descriptorInfos, std::vector<uint32_t> &descriptorBindings); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLPipelineUtil.h"},{"location":"api/Files/MTLPipelineUtil_8h/#srcngfxportingmetalmtlpipelineutilh","text":"","title":"src/ngfx/porting/metal/MTLPipelineUtil.h"},{"location":"api/Files/MTLPipelineUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLPipelineUtil_8h/#classes","text":"Name struct ngfx::MTLPipelineUtil","title":"Classes"},{"location":"api/Files/MTLPipelineUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/metal/MTLShaderModule.h\" namespace ngfx { struct MTLPipelineUtil { static void parseDescriptors(ShaderModule::DescriptorInfos &descriptorInfos, std::vector<uint32_t> &descriptorBindings); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLPipelineUtil_8mm/","text":"src/ngfx/porting/metal/MTLPipelineUtil.mm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLPipelineUtil.h\" using namespace ngfx; void MTLPipelineUtil::parseDescriptors( ShaderModule::DescriptorInfos& descriptorInfos, std::vector<uint32_t>& descriptorBindings) { uint32_t numBuffers = 0, numTextures = 0; for (uint32_t j = 0; j<descriptorInfos.size(); j++) { auto& descriptorInfo = descriptorInfos[j]; if (descriptorInfo.type == DESCRIPTOR_TYPE_UNIFORM_BUFFER || descriptorInfo.type == DESCRIPTOR_TYPE_STORAGE_BUFFER) descriptorBindings.push_back(numBuffers++); else if (descriptorInfo.type == DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) descriptorBindings.push_back(numTextures++); } } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLPipelineUtil.mm"},{"location":"api/Files/MTLPipelineUtil_8mm/#srcngfxportingmetalmtlpipelineutilmm","text":"","title":"src/ngfx/porting/metal/MTLPipelineUtil.mm"},{"location":"api/Files/MTLPipelineUtil_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLPipelineUtil.h\" using namespace ngfx; void MTLPipelineUtil::parseDescriptors( ShaderModule::DescriptorInfos& descriptorInfos, std::vector<uint32_t>& descriptorBindings) { uint32_t numBuffers = 0, numTextures = 0; for (uint32_t j = 0; j<descriptorInfos.size(); j++) { auto& descriptorInfo = descriptorInfos[j]; if (descriptorInfo.type == DESCRIPTOR_TYPE_UNIFORM_BUFFER || descriptorInfo.type == DESCRIPTOR_TYPE_STORAGE_BUFFER) descriptorBindings.push_back(numBuffers++); else if (descriptorInfo.type == DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) descriptorBindings.push_back(numTextures++); } } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLRenderCommandEncoder_8h/","text":"src/ngfx/porting/metal/MTLRenderCommandEncoder.h Namespaces Name ngfx Classes Name class ngfx::MTLRenderCommandEncoder Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/metal/MTLCommandEncoder.h\" #include <Metal/Metal.h> namespace ngfx { class MTLRenderCommandEncoder : public MTLCommandEncoder { public: virtual ~MTLRenderCommandEncoder() {} id<MTLRenderCommandEncoder> v; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLRenderCommandEncoder.h"},{"location":"api/Files/MTLRenderCommandEncoder_8h/#srcngfxportingmetalmtlrendercommandencoderh","text":"","title":"src/ngfx/porting/metal/MTLRenderCommandEncoder.h"},{"location":"api/Files/MTLRenderCommandEncoder_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLRenderCommandEncoder_8h/#classes","text":"Name class ngfx::MTLRenderCommandEncoder","title":"Classes"},{"location":"api/Files/MTLRenderCommandEncoder_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/metal/MTLCommandEncoder.h\" #include <Metal/Metal.h> namespace ngfx { class MTLRenderCommandEncoder : public MTLCommandEncoder { public: virtual ~MTLRenderCommandEncoder() {} id<MTLRenderCommandEncoder> v; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLRenderPass_8h/","text":"src/ngfx/porting/metal/MTLRenderPass.h Namespaces Name ngfx Classes Name class ngfx::MTLRenderPass Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/porting/metal/MTLFramebuffer.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <glm/glm.hpp> namespace ngfx { class MTLGraphicsContext; class MTLRenderPass : public RenderPass { public: virtual ~MTLRenderPass() {} MTLRenderPassDescriptor *getDescriptor(MTLGraphicsContext *mtlCtx, MTLFramebuffer *mtlFramebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil); }; MTL_CAST(RenderPass); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLRenderPass.h"},{"location":"api/Files/MTLRenderPass_8h/#srcngfxportingmetalmtlrenderpassh","text":"","title":"src/ngfx/porting/metal/MTLRenderPass.h"},{"location":"api/Files/MTLRenderPass_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLRenderPass_8h/#classes","text":"Name class ngfx::MTLRenderPass","title":"Classes"},{"location":"api/Files/MTLRenderPass_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/porting/metal/MTLFramebuffer.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <glm/glm.hpp> namespace ngfx { class MTLGraphicsContext; class MTLRenderPass : public RenderPass { public: virtual ~MTLRenderPass() {} MTLRenderPassDescriptor *getDescriptor(MTLGraphicsContext *mtlCtx, MTLFramebuffer *mtlFramebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil); }; MTL_CAST(RenderPass); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLRenderPass_8mm/","text":"src/ngfx/porting/metal/MTLRenderPass.mm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLRenderPass.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLSurface.h\" using namespace ngfx; using namespace std; MTLRenderPassDescriptor* MTLRenderPass::getDescriptor(MTLGraphicsContext* mtlCtx, MTLFramebuffer* mtlFramebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil) { MTLRenderPassDescriptor* mtlRenderPassDescriptor = nullptr; vector<MTLRenderPassColorAttachmentDescriptor*> colorAttachments; if (mtlFramebuffer->colorAttachments.empty()) { MTLSurface *surface = (MTLSurface*)mtlCtx->surface; NSView *view = surface->view; MTKView *mtkView = nullptr; if ([view class] == [MTKView class]) { mtkView = (MTKView*)view; } if (mtkView) { mtlRenderPassDescriptor = mtkView.currentRenderPassDescriptor; colorAttachments.push_back(mtlRenderPassDescriptor.colorAttachments[0]); } else { mtlRenderPassDescriptor = [MTLRenderPassDescriptor renderPassDescriptor]; auto colorAttachment = mtlRenderPassDescriptor.colorAttachments[0]; colorAttachment.texture = surface->drawable.texture; colorAttachments.push_back(colorAttachment); auto depthAttachment = mtlRenderPassDescriptor.depthAttachment; depthAttachment.texture = surface->depthStencilTexture.get()->v; auto stencilAttachment = mtlRenderPassDescriptor.stencilAttachment; stencilAttachment.texture = surface->depthStencilTexture.get()->v; } } else { mtlRenderPassDescriptor = [MTLRenderPassDescriptor renderPassDescriptor]; for (uint32_t j = 0; j<mtlFramebuffer->colorAttachments.size(); j++) { auto colorAttachment = mtlRenderPassDescriptor.colorAttachments[j]; auto& fbColorAttachment = mtlFramebuffer->colorAttachments[j]; colorAttachment.texture = fbColorAttachment.texture; colorAttachment.resolveTexture = fbColorAttachment.resolveTexture; colorAttachment.slice = fbColorAttachment.slice; colorAttachment.level = fbColorAttachment.level; colorAttachment.resolveSlice = fbColorAttachment.resolveSlice; colorAttachment.resolveLevel = fbColorAttachment.resolveLevel; colorAttachments.push_back(colorAttachment); } } for (auto& colorAttachment : colorAttachments) { colorAttachment.clearColor = { clearColor[0], clearColor[1], clearColor[2], clearColor[3] }; colorAttachment.loadAction = MTLLoadActionClear; if (colorAttachment.resolveTexture) colorAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve; else colorAttachment.storeAction = MTLStoreActionStore; } auto depthAttachment = mtlRenderPassDescriptor.depthAttachment; if (mtlFramebuffer->depthAttachment) { depthAttachment.clearDepth = clearDepth; depthAttachment.loadAction = MTLLoadActionClear; depthAttachment.resolveTexture = mtlFramebuffer->depthAttachment.resolveTexture; depthAttachment.texture = mtlFramebuffer->depthAttachment.texture; if (depthAttachment.resolveTexture) depthAttachment.storeAction = MTLStoreActionMultisampleResolve; else depthAttachment.storeAction = MTLStoreActionDontCare; } auto stencilAttachment = mtlRenderPassDescriptor.stencilAttachment; if (mtlFramebuffer->stencilAttachment) { stencilAttachment.texture = mtlFramebuffer->stencilAttachment.texture; } if (mtlRenderPassDescriptor.stencilAttachment) mtlRenderPassDescriptor.stencilAttachment.clearStencil = clearStencil; return mtlRenderPassDescriptor; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLRenderPass.mm"},{"location":"api/Files/MTLRenderPass_8mm/#srcngfxportingmetalmtlrenderpassmm","text":"","title":"src/ngfx/porting/metal/MTLRenderPass.mm"},{"location":"api/Files/MTLRenderPass_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLRenderPass.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLSurface.h\" using namespace ngfx; using namespace std; MTLRenderPassDescriptor* MTLRenderPass::getDescriptor(MTLGraphicsContext* mtlCtx, MTLFramebuffer* mtlFramebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil) { MTLRenderPassDescriptor* mtlRenderPassDescriptor = nullptr; vector<MTLRenderPassColorAttachmentDescriptor*> colorAttachments; if (mtlFramebuffer->colorAttachments.empty()) { MTLSurface *surface = (MTLSurface*)mtlCtx->surface; NSView *view = surface->view; MTKView *mtkView = nullptr; if ([view class] == [MTKView class]) { mtkView = (MTKView*)view; } if (mtkView) { mtlRenderPassDescriptor = mtkView.currentRenderPassDescriptor; colorAttachments.push_back(mtlRenderPassDescriptor.colorAttachments[0]); } else { mtlRenderPassDescriptor = [MTLRenderPassDescriptor renderPassDescriptor]; auto colorAttachment = mtlRenderPassDescriptor.colorAttachments[0]; colorAttachment.texture = surface->drawable.texture; colorAttachments.push_back(colorAttachment); auto depthAttachment = mtlRenderPassDescriptor.depthAttachment; depthAttachment.texture = surface->depthStencilTexture.get()->v; auto stencilAttachment = mtlRenderPassDescriptor.stencilAttachment; stencilAttachment.texture = surface->depthStencilTexture.get()->v; } } else { mtlRenderPassDescriptor = [MTLRenderPassDescriptor renderPassDescriptor]; for (uint32_t j = 0; j<mtlFramebuffer->colorAttachments.size(); j++) { auto colorAttachment = mtlRenderPassDescriptor.colorAttachments[j]; auto& fbColorAttachment = mtlFramebuffer->colorAttachments[j]; colorAttachment.texture = fbColorAttachment.texture; colorAttachment.resolveTexture = fbColorAttachment.resolveTexture; colorAttachment.slice = fbColorAttachment.slice; colorAttachment.level = fbColorAttachment.level; colorAttachment.resolveSlice = fbColorAttachment.resolveSlice; colorAttachment.resolveLevel = fbColorAttachment.resolveLevel; colorAttachments.push_back(colorAttachment); } } for (auto& colorAttachment : colorAttachments) { colorAttachment.clearColor = { clearColor[0], clearColor[1], clearColor[2], clearColor[3] }; colorAttachment.loadAction = MTLLoadActionClear; if (colorAttachment.resolveTexture) colorAttachment.storeAction = MTLStoreActionStoreAndMultisampleResolve; else colorAttachment.storeAction = MTLStoreActionStore; } auto depthAttachment = mtlRenderPassDescriptor.depthAttachment; if (mtlFramebuffer->depthAttachment) { depthAttachment.clearDepth = clearDepth; depthAttachment.loadAction = MTLLoadActionClear; depthAttachment.resolveTexture = mtlFramebuffer->depthAttachment.resolveTexture; depthAttachment.texture = mtlFramebuffer->depthAttachment.texture; if (depthAttachment.resolveTexture) depthAttachment.storeAction = MTLStoreActionMultisampleResolve; else depthAttachment.storeAction = MTLStoreActionDontCare; } auto stencilAttachment = mtlRenderPassDescriptor.stencilAttachment; if (mtlFramebuffer->stencilAttachment) { stencilAttachment.texture = mtlFramebuffer->stencilAttachment.texture; } if (mtlRenderPassDescriptor.stencilAttachment) mtlRenderPassDescriptor.stencilAttachment.clearStencil = clearStencil; return mtlRenderPassDescriptor; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLShaderModule_8h/","text":"src/ngfx/porting/metal/MTLShaderModule.h Namespaces Name ngfx Classes Name class ngfx::MTLShaderModule class ngfx::MTLVertexShaderModule class ngfx::MTLFragmentShaderModule class ngfx::MTLComputeShaderModule Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/porting/metal/MTLDevice.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLShaderModule { public: virtual void initFromFile(id<MTLDevice> device, const std::string &filename); virtual ~MTLShaderModule() {} id<MTLLibrary> mtlLibrary; id<MTLFunction> mtlFunction; protected: virtual void initFromByteCode(id<MTLDevice> device, void *data, uint32_t size); }; MTL_CAST(ShaderModule); class MTLVertexShaderModule : public VertexShaderModule, public MTLShaderModule { public: virtual ~MTLVertexShaderModule() {} }; MTL_CAST(VertexShaderModule); class MTLFragmentShaderModule : public FragmentShaderModule, public MTLShaderModule { public: virtual ~MTLFragmentShaderModule() {} }; MTL_CAST(FragmentShaderModule); class MTLComputeShaderModule : public ComputeShaderModule, public MTLShaderModule { public: virtual ~MTLComputeShaderModule() {} }; MTL_CAST(ComputeShaderModule); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLShaderModule.h"},{"location":"api/Files/MTLShaderModule_8h/#srcngfxportingmetalmtlshadermoduleh","text":"","title":"src/ngfx/porting/metal/MTLShaderModule.h"},{"location":"api/Files/MTLShaderModule_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLShaderModule_8h/#classes","text":"Name class ngfx::MTLShaderModule class ngfx::MTLVertexShaderModule class ngfx::MTLFragmentShaderModule class ngfx::MTLComputeShaderModule","title":"Classes"},{"location":"api/Files/MTLShaderModule_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/porting/metal/MTLDevice.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLShaderModule { public: virtual void initFromFile(id<MTLDevice> device, const std::string &filename); virtual ~MTLShaderModule() {} id<MTLLibrary> mtlLibrary; id<MTLFunction> mtlFunction; protected: virtual void initFromByteCode(id<MTLDevice> device, void *data, uint32_t size); }; MTL_CAST(ShaderModule); class MTLVertexShaderModule : public VertexShaderModule, public MTLShaderModule { public: virtual ~MTLVertexShaderModule() {} }; MTL_CAST(VertexShaderModule); class MTLFragmentShaderModule : public FragmentShaderModule, public MTLShaderModule { public: virtual ~MTLFragmentShaderModule() {} }; MTL_CAST(FragmentShaderModule); class MTLComputeShaderModule : public ComputeShaderModule, public MTLShaderModule { public: virtual ~MTLComputeShaderModule() {} }; MTL_CAST(ComputeShaderModule); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLShaderModule_8mm/","text":"src/ngfx/porting/metal/MTLShaderModule.mm Functions Name template <typename T > std::unique_ptr< T > createShaderModule ( Device * device, const std::string & filename) Functions Documentation function createShaderModule template <typename T > static std::unique_ptr< T > createShaderModule( Device * device, const std::string & filename ) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLShaderModule.h\" #include \"ngfx/porting/metal/MTLDevice.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/File.h\" using namespace ngfx; using namespace std; void MTLShaderModule::initFromFile(id<MTLDevice> device, const std::string &filename) { File file; #ifdef USE_PRECOMPILED_SHADERS file.read(filename + \".metallib\"); initFromByteCode(device, file.data.get(), file.size); #else NGFX_ERR(\"TODO: Support runtime shader compilation\"); #endif } void MTLShaderModule::initFromByteCode(id<MTLDevice> device, void* data, uint32_t size) { NSError* error; dispatch_data_t dispatch_data = dispatch_data_create(data, size, NULL, DISPATCH_DATA_DESTRUCTOR_DEFAULT); mtlLibrary = [device newLibraryWithData:dispatch_data error:&error]; NSCAssert(mtlLibrary, @\"Failed to load metal library\"); mtlFunction = [mtlLibrary newFunctionWithName:@\"main0\"]; } template <typename T> static std::unique_ptr<T> createShaderModule(Device* device, const std::string& filename) { auto mtlShaderModule = make_unique<T>(); mtlShaderModule->initFromFile(mtl(device)->v, filename); mtlShaderModule->initBindings(filename+\".metal.map\"); return mtlShaderModule; } unique_ptr<VertexShaderModule> VertexShaderModule::create(Device* device, const std::string& filename) { return createShaderModule<MTLVertexShaderModule>(device, filename); } unique_ptr<FragmentShaderModule> FragmentShaderModule::create(Device* device, const std::string& filename) { return createShaderModule<MTLFragmentShaderModule>(device, filename); } unique_ptr<ComputeShaderModule> ComputeShaderModule::create(Device* device, const std::string& filename) { return createShaderModule<MTLComputeShaderModule>(device, filename); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLShaderModule.mm"},{"location":"api/Files/MTLShaderModule_8mm/#srcngfxportingmetalmtlshadermodulemm","text":"","title":"src/ngfx/porting/metal/MTLShaderModule.mm"},{"location":"api/Files/MTLShaderModule_8mm/#functions","text":"Name template <typename T > std::unique_ptr< T > createShaderModule ( Device * device, const std::string & filename)","title":"Functions"},{"location":"api/Files/MTLShaderModule_8mm/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/MTLShaderModule_8mm/#function-createshadermodule","text":"template <typename T > static std::unique_ptr< T > createShaderModule( Device * device, const std::string & filename )","title":"function createShaderModule"},{"location":"api/Files/MTLShaderModule_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLShaderModule.h\" #include \"ngfx/porting/metal/MTLDevice.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/File.h\" using namespace ngfx; using namespace std; void MTLShaderModule::initFromFile(id<MTLDevice> device, const std::string &filename) { File file; #ifdef USE_PRECOMPILED_SHADERS file.read(filename + \".metallib\"); initFromByteCode(device, file.data.get(), file.size); #else NGFX_ERR(\"TODO: Support runtime shader compilation\"); #endif } void MTLShaderModule::initFromByteCode(id<MTLDevice> device, void* data, uint32_t size) { NSError* error; dispatch_data_t dispatch_data = dispatch_data_create(data, size, NULL, DISPATCH_DATA_DESTRUCTOR_DEFAULT); mtlLibrary = [device newLibraryWithData:dispatch_data error:&error]; NSCAssert(mtlLibrary, @\"Failed to load metal library\"); mtlFunction = [mtlLibrary newFunctionWithName:@\"main0\"]; } template <typename T> static std::unique_ptr<T> createShaderModule(Device* device, const std::string& filename) { auto mtlShaderModule = make_unique<T>(); mtlShaderModule->initFromFile(mtl(device)->v, filename); mtlShaderModule->initBindings(filename+\".metal.map\"); return mtlShaderModule; } unique_ptr<VertexShaderModule> VertexShaderModule::create(Device* device, const std::string& filename) { return createShaderModule<MTLVertexShaderModule>(device, filename); } unique_ptr<FragmentShaderModule> FragmentShaderModule::create(Device* device, const std::string& filename) { return createShaderModule<MTLFragmentShaderModule>(device, filename); } unique_ptr<ComputeShaderModule> ComputeShaderModule::create(Device* device, const std::string& filename) { return createShaderModule<MTLComputeShaderModule>(device, filename); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLSurface_8h/","text":"src/ngfx/porting/metal/MTLSurface.h Namespaces Name ngfx Classes Name class ngfx::MTLSurface Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/porting/metal/MTLDepthStencilTexture.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <MetalKit/MetalKit.h> namespace ngfx { class MTLSurface : public Surface { public: virtual ~MTLSurface() {} inline CAMetalLayer *getMetalLayer() { return (CAMetalLayer *)view.layer; } NSView *view = nullptr; id<CAMetalDrawable> drawable; std::unique_ptr<MTLDepthStencilTexture> depthStencilTexture; }; MTL_CAST(Surface); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLSurface.h"},{"location":"api/Files/MTLSurface_8h/#srcngfxportingmetalmtlsurfaceh","text":"","title":"src/ngfx/porting/metal/MTLSurface.h"},{"location":"api/Files/MTLSurface_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLSurface_8h/#classes","text":"Name class ngfx::MTLSurface","title":"Classes"},{"location":"api/Files/MTLSurface_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/porting/metal/MTLDepthStencilTexture.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <MetalKit/MetalKit.h> namespace ngfx { class MTLSurface : public Surface { public: virtual ~MTLSurface() {} inline CAMetalLayer *getMetalLayer() { return (CAMetalLayer *)view.layer; } NSView *view = nullptr; id<CAMetalDrawable> drawable; std::unique_ptr<MTLDepthStencilTexture> depthStencilTexture; }; MTL_CAST(Surface); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLTexture_8h/","text":"src/ngfx/porting/metal/MTLTexture.h Namespaces Name ngfx Classes Name class ngfx::MTLTexture Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Texture.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLGraphicsContext; class MTLTexture : public Texture { public: void create(MTLGraphicsContext *ctx, void *data, ::MTLPixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, MTLTextureUsage textureUsage, ::MTLTextureType textureType, bool genMipmaps, MTLSamplerDescriptor *samplerDescriptor, uint32_t numSamples); virtual ~MTLTexture(); void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) override {} void generateMipmaps(CommandBuffer *commandBuffer) override; MTLGraphicsContext *ctx = nullptr; id<MTLTexture> v; id<MTLSamplerState> mtlSamplerState; bool depthTexture = false, stencilTexture = false; private: void generateMipmapsFn(id<MTLCommandBuffer> mtlCommandBuffer); }; MTL_CAST(Texture); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLTexture.h"},{"location":"api/Files/MTLTexture_8h/#srcngfxportingmetalmtltextureh","text":"","title":"src/ngfx/porting/metal/MTLTexture.h"},{"location":"api/Files/MTLTexture_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLTexture_8h/#classes","text":"Name class ngfx::MTLTexture","title":"Classes"},{"location":"api/Files/MTLTexture_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/graphics/Texture.h\" #include \"ngfx/porting/metal/MTLUtil.h\" #include <Metal/Metal.h> namespace ngfx { class MTLGraphicsContext; class MTLTexture : public Texture { public: void create(MTLGraphicsContext *ctx, void *data, ::MTLPixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, MTLTextureUsage textureUsage, ::MTLTextureType textureType, bool genMipmaps, MTLSamplerDescriptor *samplerDescriptor, uint32_t numSamples); virtual ~MTLTexture(); void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) override {} void generateMipmaps(CommandBuffer *commandBuffer) override; MTLGraphicsContext *ctx = nullptr; id<MTLTexture> v; id<MTLSamplerState> mtlSamplerState; bool depthTexture = false, stencilTexture = false; private: void generateMipmapsFn(id<MTLCommandBuffer> mtlCommandBuffer); }; MTL_CAST(Texture); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLTexture_8mm/","text":"src/ngfx/porting/metal/MTLTexture.mm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLTexture.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLRenderCommandEncoder.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void MTLTexture::create(MTLGraphicsContext *ctx, void* data, ::MTLPixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, MTLTextureUsage textureUsage, ::MTLTextureType textureType, bool genMipmaps, MTLSamplerDescriptor* samplerDescriptor, uint32_t numSamples) { this->ctx = ctx; this->w = w; this->h = h; this->d = d; this->arrayLayers = arrayLayers; this->textureType = ngfx::TextureType(textureType); this->format = PixelFormat(format); this->numSamples = numSamples; auto device = ctx->mtlDevice.v; MTLTextureDescriptor *textureDescriptor = [MTLTextureDescriptor new]; textureDescriptor.pixelFormat = format; textureDescriptor.width = w; textureDescriptor.height = h; textureDescriptor.depth = d; textureDescriptor.sampleCount = numSamples; if (textureType == ::MTLTextureTypeCube) textureDescriptor.arrayLength = 1; else textureDescriptor.arrayLength = arrayLayers; textureDescriptor.usage = textureUsage; if (numSamples > 1 && textureType == ::MTLTextureType2D) textureDescriptor.textureType = ::MTLTextureType2DMultisample; else if (numSamples > 1 && textureType == ::MTLTextureType2DArray) textureDescriptor.textureType = ::MTLTextureType2DMultisampleArray; else textureDescriptor.textureType = textureType; mipLevels = genMipmaps ? floor(log2(float(glm::min(w, h)))) + 1 : 1; textureDescriptor.mipmapLevelCount = mipLevels; const std::vector<MTLPixelFormat> depthFormats = { MTLPixelFormatDepth16Unorm, MTLPixelFormatDepth24Unorm_Stencil8, MTLPixelFormatDepth32Float, MTLPixelFormatDepth32Float_Stencil8 }; const std::vector<MTLPixelFormat> stencilFormats = { MTLPixelFormatStencil8 ,MTLPixelFormatDepth24Unorm_Stencil8, MTLPixelFormatDepth32Float_Stencil8, }; depthTexture = std::find(depthFormats.begin(), depthFormats.end(), format) != depthFormats.end(); if (depthTexture) textureDescriptor.storageMode = ::MTLStorageModePrivate; stencilTexture = std::find(stencilFormats.begin(), stencilFormats.end(), format) != stencilFormats.end(); bool multisampleTexture = (numSamples > 1); if (multisampleTexture) textureDescriptor.storageMode = ::MTLStorageModePrivate; v = [device newTextureWithDescriptor:textureDescriptor]; [textureDescriptor release]; upload(data, size); mtlSamplerState = [device newSamplerStateWithDescriptor:samplerDescriptor]; } MTLTexture::~MTLTexture() { [v release]; } void MTLTexture::upload(void* data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { if (!data) return; if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; if (arrayLayers == -1) arrayLayers = this->arrayLayers; NSUInteger bytesPerRow = size / (h * d * arrayLayers); NSUInteger bytesPerImage; if (MTLTextureType(textureType) == MTLTextureType3D) bytesPerImage = size / d; else if (MTLTextureType(textureType) == MTLTextureTypeCube) bytesPerImage = size / arrayLayers; else bytesPerImage = 0; MTLRegion region = MTLRegionMake3D(x, y, z, w, h, d); uint8_t* srcData = (uint8_t*)data; for (uint32_t slice = 0; slice < arrayLayers; slice++) { [v replaceRegion:region mipmapLevel:0 slice:slice withBytes: srcData bytesPerRow:bytesPerRow bytesPerImage:bytesPerImage]; srcData += bytesPerImage; } if (mipLevels != 1) { auto mtlCommandBuffer = [ctx->mtlCommandQueue commandBuffer]; generateMipmapsFn(mtlCommandBuffer); [mtlCommandBuffer commit]; [mtlCommandBuffer waitUntilCompleted]; } } void MTLTexture::generateMipmaps(CommandBuffer* commandBuffer) { generateMipmapsFn(mtl(commandBuffer)->v); } void MTLTexture::generateMipmapsFn(id<MTLCommandBuffer> mtlCommandBuffer) { id <MTLBlitCommandEncoder> encoder = [mtlCommandBuffer blitCommandEncoder]; [encoder generateMipmapsForTexture: v]; [encoder endEncoding]; } void MTLTexture::download(void* data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; id<MTLCommandBuffer> mtlCommandBuffer = [ctx->mtlCommandQueue commandBuffer]; id <MTLBlitCommandEncoder> blitCommandEncoder = [mtlCommandBuffer blitCommandEncoder]; [blitCommandEncoder synchronizeTexture:v slice:0 level:0]; [blitCommandEncoder endEncoding]; [mtlCommandBuffer commit]; [mtlCommandBuffer waitUntilCompleted]; NSUInteger bytesPerRow = 4 * w; MTLRegion region = { { x, y, z }, { NSUInteger(w), NSUInteger(h), 1 } }; [v getBytes:data bytesPerRow: bytesPerRow fromRegion: region mipmapLevel: 0]; } Texture* Texture::create(GraphicsContext* ctx, Graphics* graphics, void* data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { MTLTexture* mtlTexture = new MTLTexture(); MTLTextureUsage textureUsage = 0; if (imageUsageFlags & IMAGE_USAGE_SAMPLED_BIT) textureUsage |= MTLTextureUsageShaderRead; if (imageUsageFlags & IMAGE_USAGE_COLOR_ATTACHMENT_BIT) textureUsage |= MTLTextureUsageRenderTarget; else if (imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) textureUsage |= MTLTextureUsageRenderTarget; MTLSamplerDescriptor *mtlSamplerDescriptor = [MTLSamplerDescriptor new]; mtlSamplerDescriptor.minFilter = ::MTLSamplerMinMagFilter(minFilter); mtlSamplerDescriptor.magFilter = ::MTLSamplerMinMagFilter(magFilter); mtlSamplerDescriptor.mipFilter = (mipFilter == FILTER_NEAREST) ? MTLSamplerMipFilterNearest : MTLSamplerMipFilterLinear; mtlTexture->create(mtl(ctx), data, ::MTLPixelFormat(format), size, w, h, d, arrayLayers, textureUsage, ::MTLTextureType(textureType), genMipmaps, mtlSamplerDescriptor, numSamples); [mtlSamplerDescriptor release]; return mtlTexture; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLTexture.mm"},{"location":"api/Files/MTLTexture_8mm/#srcngfxportingmetalmtltexturemm","text":"","title":"src/ngfx/porting/metal/MTLTexture.mm"},{"location":"api/Files/MTLTexture_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLTexture.h\" #include \"ngfx/porting/metal/MTLGraphicsContext.h\" #include \"ngfx/porting/metal/MTLCommandBuffer.h\" #include \"ngfx/porting/metal/MTLRenderCommandEncoder.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; void MTLTexture::create(MTLGraphicsContext *ctx, void* data, ::MTLPixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, MTLTextureUsage textureUsage, ::MTLTextureType textureType, bool genMipmaps, MTLSamplerDescriptor* samplerDescriptor, uint32_t numSamples) { this->ctx = ctx; this->w = w; this->h = h; this->d = d; this->arrayLayers = arrayLayers; this->textureType = ngfx::TextureType(textureType); this->format = PixelFormat(format); this->numSamples = numSamples; auto device = ctx->mtlDevice.v; MTLTextureDescriptor *textureDescriptor = [MTLTextureDescriptor new]; textureDescriptor.pixelFormat = format; textureDescriptor.width = w; textureDescriptor.height = h; textureDescriptor.depth = d; textureDescriptor.sampleCount = numSamples; if (textureType == ::MTLTextureTypeCube) textureDescriptor.arrayLength = 1; else textureDescriptor.arrayLength = arrayLayers; textureDescriptor.usage = textureUsage; if (numSamples > 1 && textureType == ::MTLTextureType2D) textureDescriptor.textureType = ::MTLTextureType2DMultisample; else if (numSamples > 1 && textureType == ::MTLTextureType2DArray) textureDescriptor.textureType = ::MTLTextureType2DMultisampleArray; else textureDescriptor.textureType = textureType; mipLevels = genMipmaps ? floor(log2(float(glm::min(w, h)))) + 1 : 1; textureDescriptor.mipmapLevelCount = mipLevels; const std::vector<MTLPixelFormat> depthFormats = { MTLPixelFormatDepth16Unorm, MTLPixelFormatDepth24Unorm_Stencil8, MTLPixelFormatDepth32Float, MTLPixelFormatDepth32Float_Stencil8 }; const std::vector<MTLPixelFormat> stencilFormats = { MTLPixelFormatStencil8 ,MTLPixelFormatDepth24Unorm_Stencil8, MTLPixelFormatDepth32Float_Stencil8, }; depthTexture = std::find(depthFormats.begin(), depthFormats.end(), format) != depthFormats.end(); if (depthTexture) textureDescriptor.storageMode = ::MTLStorageModePrivate; stencilTexture = std::find(stencilFormats.begin(), stencilFormats.end(), format) != stencilFormats.end(); bool multisampleTexture = (numSamples > 1); if (multisampleTexture) textureDescriptor.storageMode = ::MTLStorageModePrivate; v = [device newTextureWithDescriptor:textureDescriptor]; [textureDescriptor release]; upload(data, size); mtlSamplerState = [device newSamplerStateWithDescriptor:samplerDescriptor]; } MTLTexture::~MTLTexture() { [v release]; } void MTLTexture::upload(void* data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { if (!data) return; if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; if (arrayLayers == -1) arrayLayers = this->arrayLayers; NSUInteger bytesPerRow = size / (h * d * arrayLayers); NSUInteger bytesPerImage; if (MTLTextureType(textureType) == MTLTextureType3D) bytesPerImage = size / d; else if (MTLTextureType(textureType) == MTLTextureTypeCube) bytesPerImage = size / arrayLayers; else bytesPerImage = 0; MTLRegion region = MTLRegionMake3D(x, y, z, w, h, d); uint8_t* srcData = (uint8_t*)data; for (uint32_t slice = 0; slice < arrayLayers; slice++) { [v replaceRegion:region mipmapLevel:0 slice:slice withBytes: srcData bytesPerRow:bytesPerRow bytesPerImage:bytesPerImage]; srcData += bytesPerImage; } if (mipLevels != 1) { auto mtlCommandBuffer = [ctx->mtlCommandQueue commandBuffer]; generateMipmapsFn(mtlCommandBuffer); [mtlCommandBuffer commit]; [mtlCommandBuffer waitUntilCompleted]; } } void MTLTexture::generateMipmaps(CommandBuffer* commandBuffer) { generateMipmapsFn(mtl(commandBuffer)->v); } void MTLTexture::generateMipmapsFn(id<MTLCommandBuffer> mtlCommandBuffer) { id <MTLBlitCommandEncoder> encoder = [mtlCommandBuffer blitCommandEncoder]; [encoder generateMipmapsForTexture: v]; [encoder endEncoding]; } void MTLTexture::download(void* data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; id<MTLCommandBuffer> mtlCommandBuffer = [ctx->mtlCommandQueue commandBuffer]; id <MTLBlitCommandEncoder> blitCommandEncoder = [mtlCommandBuffer blitCommandEncoder]; [blitCommandEncoder synchronizeTexture:v slice:0 level:0]; [blitCommandEncoder endEncoding]; [mtlCommandBuffer commit]; [mtlCommandBuffer waitUntilCompleted]; NSUInteger bytesPerRow = 4 * w; MTLRegion region = { { x, y, z }, { NSUInteger(w), NSUInteger(h), 1 } }; [v getBytes:data bytesPerRow: bytesPerRow fromRegion: region mipmapLevel: 0]; } Texture* Texture::create(GraphicsContext* ctx, Graphics* graphics, void* data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { MTLTexture* mtlTexture = new MTLTexture(); MTLTextureUsage textureUsage = 0; if (imageUsageFlags & IMAGE_USAGE_SAMPLED_BIT) textureUsage |= MTLTextureUsageShaderRead; if (imageUsageFlags & IMAGE_USAGE_COLOR_ATTACHMENT_BIT) textureUsage |= MTLTextureUsageRenderTarget; else if (imageUsageFlags & IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) textureUsage |= MTLTextureUsageRenderTarget; MTLSamplerDescriptor *mtlSamplerDescriptor = [MTLSamplerDescriptor new]; mtlSamplerDescriptor.minFilter = ::MTLSamplerMinMagFilter(minFilter); mtlSamplerDescriptor.magFilter = ::MTLSamplerMinMagFilter(magFilter); mtlSamplerDescriptor.mipFilter = (mipFilter == FILTER_NEAREST) ? MTLSamplerMipFilterNearest : MTLSamplerMipFilterLinear; mtlTexture->create(mtl(ctx), data, ::MTLPixelFormat(format), size, w, h, d, arrayLayers, textureUsage, ::MTLTextureType(textureType), genMipmaps, mtlSamplerDescriptor, numSamples); [mtlSamplerDescriptor release]; return mtlTexture; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLUtil_8h/","text":"src/ngfx/porting/metal/MTLUtil.h Defines Name MTL_CAST (name) Macro Documentation define MTL_CAST #define MTL_CAST( name ) inline MTL##name *mtl(name *g) { return (MTL##name *)g; } Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #define MTL_CAST(name) \\ inline MTL##name *mtl(name *g) { return (MTL##name *)g; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLUtil.h"},{"location":"api/Files/MTLUtil_8h/#srcngfxportingmetalmtlutilh","text":"","title":"src/ngfx/porting/metal/MTLUtil.h"},{"location":"api/Files/MTLUtil_8h/#defines","text":"Name MTL_CAST (name)","title":"Defines"},{"location":"api/Files/MTLUtil_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/MTLUtil_8h/#define-mtl_cast","text":"#define MTL_CAST( name ) inline MTL##name *mtl(name *g) { return (MTL##name *)g; }","title":"define MTL_CAST"},{"location":"api/Files/MTLUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #define MTL_CAST(name) \\ inline MTL##name *mtl(name *g) { return (MTL##name *)g; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLViewDelegate_8h/","text":"src/ngfx/porting/metal/MTLViewDelegate.h Classes Name class MTLViewDelegate Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <MetalKit/MetalKit.h> @interface MTLViewDelegate : NSObject <MTKViewDelegate> - (nonnull instancetype)create:(nonnull MTKView *)mtkView; @end Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLViewDelegate.h"},{"location":"api/Files/MTLViewDelegate_8h/#srcngfxportingmetalmtlviewdelegateh","text":"","title":"src/ngfx/porting/metal/MTLViewDelegate.h"},{"location":"api/Files/MTLViewDelegate_8h/#classes","text":"Name class MTLViewDelegate","title":"Classes"},{"location":"api/Files/MTLViewDelegate_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <MetalKit/MetalKit.h> @interface MTLViewDelegate : NSObject <MTKViewDelegate> - (nonnull instancetype)create:(nonnull MTKView *)mtkView; @end Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLViewDelegate_8mm/","text":"src/ngfx/porting/metal/MTLViewDelegate.mm Attributes Name std::function< void(void *)> appInit std::function< void(void *)> appPaint std::function< void(void *)> appUpdate Attributes Documentation variable appInit std::function< void(void *)> appInit; variable appPaint std::function< void(void *)> appPaint; variable appUpdate std::function< void(void *)> appUpdate; Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLViewDelegate.h\" #include <functional> std::function<void(void*)> appInit, appPaint, appUpdate; @implementation MTLViewDelegate {} - (nonnull instancetype)create:(nonnull MTKView *)mtkView { self = [ super init]; appInit(mtkView); return self; } - (void)drawInMTKView:(nonnull MTKView *)mtkView { appUpdate(mtkView); appPaint(mtkView); } - (void)mtkView:(nonnull MTKView *)view drawableSizeWillChange:(CGSize)size { } @end Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLViewDelegate.mm"},{"location":"api/Files/MTLViewDelegate_8mm/#srcngfxportingmetalmtlviewdelegatemm","text":"","title":"src/ngfx/porting/metal/MTLViewDelegate.mm"},{"location":"api/Files/MTLViewDelegate_8mm/#attributes","text":"Name std::function< void(void *)> appInit std::function< void(void *)> appPaint std::function< void(void *)> appUpdate","title":"Attributes"},{"location":"api/Files/MTLViewDelegate_8mm/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/MTLViewDelegate_8mm/#variable-appinit","text":"std::function< void(void *)> appInit;","title":"variable appInit"},{"location":"api/Files/MTLViewDelegate_8mm/#variable-apppaint","text":"std::function< void(void *)> appPaint;","title":"variable appPaint"},{"location":"api/Files/MTLViewDelegate_8mm/#variable-appupdate","text":"std::function< void(void *)> appUpdate;","title":"variable appUpdate"},{"location":"api/Files/MTLViewDelegate_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLViewDelegate.h\" #include <functional> std::function<void(void*)> appInit, appPaint, appUpdate; @implementation MTLViewDelegate {} - (nonnull instancetype)create:(nonnull MTKView *)mtkView { self = [ super init]; appInit(mtkView); return self; } - (void)drawInMTKView:(nonnull MTKView *)mtkView { appUpdate(mtkView); appPaint(mtkView); } - (void)mtkView:(nonnull MTKView *)view drawableSizeWillChange:(CGSize)size { } @end Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLWindow_8h/","text":"src/ngfx/porting/metal/MTLWindow.h Namespaces Name ngfx Classes Name class ngfx::MTLWindow Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Window.h\" #include \"ngfx/porting/metal/MTLSurface.h\" #include \"ngfx/porting/metal/MTLUtil.h\" namespace ngfx { class MTLWindow : public Window { public: virtual ~MTLWindow() {} bool shouldClose() override; void pollEvents() override; MTLSurface mtlSurface; }; MTL_CAST(Window); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLWindow.h"},{"location":"api/Files/MTLWindow_8h/#srcngfxportingmetalmtlwindowh","text":"","title":"src/ngfx/porting/metal/MTLWindow.h"},{"location":"api/Files/MTLWindow_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MTLWindow_8h/#classes","text":"Name class ngfx::MTLWindow","title":"Classes"},{"location":"api/Files/MTLWindow_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Window.h\" #include \"ngfx/porting/metal/MTLSurface.h\" #include \"ngfx/porting/metal/MTLUtil.h\" namespace ngfx { class MTLWindow : public Window { public: virtual ~MTLWindow() {} bool shouldClose() override; void pollEvents() override; MTLSurface mtlSurface; }; MTL_CAST(Window); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MTLWindow_8mm/","text":"src/ngfx/porting/metal/MTLWindow.mm Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLWindow.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; bool MTLWindow::shouldClose() { NGFX_LOG_TRACE(\"Not supported\"); return false; } void MTLWindow::pollEvents() { NGFX_LOG_TRACE(\"Not supported\"); } Window* Window::create(GraphicsContext* graphicsContext, const char* title, std::function<void(Window* thiz)> onWindowCreated, int w, int h) { NGFX_LOG_TRACE(\"Not supported\"); return nullptr; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal/MTLWindow.mm"},{"location":"api/Files/MTLWindow_8mm/#srcngfxportingmetalmtlwindowmm","text":"","title":"src/ngfx/porting/metal/MTLWindow.mm"},{"location":"api/Files/MTLWindow_8mm/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/metal/MTLWindow.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; bool MTLWindow::shouldClose() { NGFX_LOG_TRACE(\"Not supported\"); return false; } void MTLWindow::pollEvents() { NGFX_LOG_TRACE(\"Not supported\"); } Window* Window::create(GraphicsContext* graphicsContext, const char* title, std::function<void(Window* thiz)> onWindowCreated, int w, int h) { NGFX_LOG_TRACE(\"Not supported\"); return nullptr; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/","text":"src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp Defines Name VEC4_LOAD (src, j) Macro Documentation define VEC4_LOAD #define VEC4_LOAD( src, j ) vec4(src.data[j], src.data[j + 1], src.data[j + 2], src.data[j + 3]) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/computeOps/MatrixMultiplyCPUOp.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include <glm/glm.hpp> using namespace ngfx; using namespace glm; MatrixMultiplyCPUOp::MatrixMultiplyCPUOp(MatrixParam src0, MatrixParam src1, MatrixParam dst) : MatrixMultiplyOp(nullptr), dst(dst) { update(src0, src1); } MatrixMultiplyCPUOp::~MatrixMultiplyCPUOp() {} void MatrixMultiplyCPUOp::apply(CommandBuffer *, Graphics *) { matrixMultiply(); } void MatrixMultiplyCPUOp::update(MatrixParam src0, MatrixParam src1) { this->src0 = src0; this->src1 = src1; src1t_data.resize(src1.w * src1.h); src1t = {src1.h, src1.w, src1t_data.data()}; transpose(src1, src1t); } void MatrixMultiplyCPUOp::transpose(MatrixParam &src, MatrixParam &dst) { Timer timer; float *dst_data = dst.data; for (uint32_t dst_row = 0; dst_row < dst.h; dst_row++) { for (uint32_t dst_col = 0; dst_col < dst.w; dst_col++) { float *src_data = &src.data[dst_col * src.w + dst_row]; *dst_data++ = *src_data; } } timer.update(); NGFX_LOG(\"transpose elapsed: %f\", timer.elapsed); } #define VEC4_LOAD(src, j) \\ vec4(src.data[j], src.data[j + 1], src.data[j + 2], src.data[j + 3]) void MatrixMultiplyCPUOp::matrixMultiply() { Timer timer; float *dst_data = dst.data; for (uint32_t dst_row = 0; dst_row < dst.h; dst_row++) { uint32_t src0_offset = dst_row * src0.w; for (uint32_t dst_col = 0; dst_col < dst.w; dst_col++) { uint32_t src1t_offset = dst_col * src1t.h; float c = 0.0f; for (uint32_t j = 0; j < src0.w; j += 4) { vec4 a0 = VEC4_LOAD(src0, src0_offset + j), b0 = VEC4_LOAD(src1t, src1t_offset + j); c += dot(a0, b0); } *dst_data++ = c; } } timer.update(); NGFX_LOG(\"CPU matrix multiply elapsed: %f\", timer.elapsed); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/#srcngfxcomputeopsmatrixmultiplycpuopcpp","text":"","title":"src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/#defines","text":"Name VEC4_LOAD (src, j)","title":"Defines"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/#define-vec4_load","text":"#define VEC4_LOAD( src, j ) vec4(src.data[j], src.data[j + 1], src.data[j + 2], src.data[j + 3])","title":"define VEC4_LOAD"},{"location":"api/Files/MatrixMultiplyCPUOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/computeOps/MatrixMultiplyCPUOp.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include <glm/glm.hpp> using namespace ngfx; using namespace glm; MatrixMultiplyCPUOp::MatrixMultiplyCPUOp(MatrixParam src0, MatrixParam src1, MatrixParam dst) : MatrixMultiplyOp(nullptr), dst(dst) { update(src0, src1); } MatrixMultiplyCPUOp::~MatrixMultiplyCPUOp() {} void MatrixMultiplyCPUOp::apply(CommandBuffer *, Graphics *) { matrixMultiply(); } void MatrixMultiplyCPUOp::update(MatrixParam src0, MatrixParam src1) { this->src0 = src0; this->src1 = src1; src1t_data.resize(src1.w * src1.h); src1t = {src1.h, src1.w, src1t_data.data()}; transpose(src1, src1t); } void MatrixMultiplyCPUOp::transpose(MatrixParam &src, MatrixParam &dst) { Timer timer; float *dst_data = dst.data; for (uint32_t dst_row = 0; dst_row < dst.h; dst_row++) { for (uint32_t dst_col = 0; dst_col < dst.w; dst_col++) { float *src_data = &src.data[dst_col * src.w + dst_row]; *dst_data++ = *src_data; } } timer.update(); NGFX_LOG(\"transpose elapsed: %f\", timer.elapsed); } #define VEC4_LOAD(src, j) \\ vec4(src.data[j], src.data[j + 1], src.data[j + 2], src.data[j + 3]) void MatrixMultiplyCPUOp::matrixMultiply() { Timer timer; float *dst_data = dst.data; for (uint32_t dst_row = 0; dst_row < dst.h; dst_row++) { uint32_t src0_offset = dst_row * src0.w; for (uint32_t dst_col = 0; dst_col < dst.w; dst_col++) { uint32_t src1t_offset = dst_col * src1t.h; float c = 0.0f; for (uint32_t j = 0; j < src0.w; j += 4) { vec4 a0 = VEC4_LOAD(src0, src0_offset + j), b0 = VEC4_LOAD(src1t, src1t_offset + j); c += dot(a0, b0); } *dst_data++ = c; } } timer.update(); NGFX_LOG(\"CPU matrix multiply elapsed: %f\", timer.elapsed); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MatrixMultiplyCPUOp_8h/","text":"src/ngfx/computeOps/MatrixMultiplyCPUOp.h Namespaces Name ngfx Classes Name class ngfx::MatrixMultiplyCPUOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/computeOps/MatrixMultiplyOp.h\" namespace ngfx { class MatrixMultiplyCPUOp : public MatrixMultiplyOp { public: MatrixMultiplyCPUOp(MatrixParam src0, MatrixParam src1, MatrixParam dst); virtual ~MatrixMultiplyCPUOp(); void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) override; void update(MatrixParam src0, MatrixParam src1) override; static void transpose(MatrixParam &src, MatrixParam &dst); protected: void matrixMultiply(); std::vector<float> src1t_data; MatrixParam src0, src1, src1t, dst; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/computeOps/MatrixMultiplyCPUOp.h"},{"location":"api/Files/MatrixMultiplyCPUOp_8h/#srcngfxcomputeopsmatrixmultiplycpuoph","text":"","title":"src/ngfx/computeOps/MatrixMultiplyCPUOp.h"},{"location":"api/Files/MatrixMultiplyCPUOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MatrixMultiplyCPUOp_8h/#classes","text":"Name class ngfx::MatrixMultiplyCPUOp","title":"Classes"},{"location":"api/Files/MatrixMultiplyCPUOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/computeOps/MatrixMultiplyOp.h\" namespace ngfx { class MatrixMultiplyCPUOp : public MatrixMultiplyOp { public: MatrixMultiplyCPUOp(MatrixParam src0, MatrixParam src1, MatrixParam dst); virtual ~MatrixMultiplyCPUOp(); void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) override; void update(MatrixParam src0, MatrixParam src1) override; static void transpose(MatrixParam &src, MatrixParam &dst); protected: void matrixMultiply(); std::vector<float> src1t_data; MatrixParam src0, src1, src1t, dst; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MatrixMultiplyGPUOp_8cpp/","text":"src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/computeOps/MatrixMultiplyGPUOp.h\" #include \"ngfx/computeOps/MatrixMultiplyCPUOp.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include \"ngfx/graphics/BufferUtil.h\" using namespace ngfx; MatrixMultiplyGPUOp::MatrixMultiplyGPUOp(GraphicsContext *ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst) : MatrixMultiplyOp(ctx), dst(dst) { update(src0, src1); createPipeline(); } MatrixMultiplyGPUOp::~MatrixMultiplyGPUOp() {} void MatrixMultiplyGPUOp::apply(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindComputePipeline(commandBuffer, computePipeline); graphics->bindUniformBuffer(commandBuffer, bUbo.get(), U_UBO, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bSrc0.get(), SSBO_SRC0, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bSrc1.get(), SSBO_SRC1, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bDst.get(), SSBO_DST, SHADER_STAGE_COMPUTE_BIT); graphics->dispatch(commandBuffer, dst.w, dst.h, 1, 1, 1, 1); } void MatrixMultiplyGPUOp::update(MatrixParam src0, MatrixParam src1) { std::vector<float> src1t_data(size_t(src1.w * src1.h)); MatrixParam src1t = {src1.h, src1.w, src1t_data.data()}; MatrixMultiplyCPUOp::transpose(src1, src1t); UboData uboData = {int32_t(src0.w), int32_t(src0.h), int32_t(src1t.w), int32_t(src1t.h), int32_t(dst.w), int32_t(dst.h)}; bUbo.reset(createUniformBuffer(ctx, &uboData, sizeof(uboData))); bSrc0.reset( createStorageBuffer(ctx, src0.data, src0.w * src0.h * sizeof(float))); bSrc1.reset( createStorageBuffer(ctx, src1t.data, src1.w * src1.h * sizeof(float))); bDst.reset(createStorageBuffer(ctx, dst.data, dst.w * dst.h * sizeof(float))); } void MatrixMultiplyGPUOp::createPipeline() { const std::string key = \"matrixMultiplyOp\"; computePipeline = (ComputePipeline *)ctx->pipelineCache->get(key); if (computePipeline) return; computePipeline = ComputePipeline::create( ctx, ComputeShaderModule::create(ctx->device, \"matrixMultiply.comp\").get()); ctx->pipelineCache->add(key, computePipeline); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp"},{"location":"api/Files/MatrixMultiplyGPUOp_8cpp/#srcngfxcomputeopsmatrixmultiplygpuopcpp","text":"","title":"src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp"},{"location":"api/Files/MatrixMultiplyGPUOp_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/computeOps/MatrixMultiplyGPUOp.h\" #include \"ngfx/computeOps/MatrixMultiplyCPUOp.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/Timer.h\" #include \"ngfx/graphics/BufferUtil.h\" using namespace ngfx; MatrixMultiplyGPUOp::MatrixMultiplyGPUOp(GraphicsContext *ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst) : MatrixMultiplyOp(ctx), dst(dst) { update(src0, src1); createPipeline(); } MatrixMultiplyGPUOp::~MatrixMultiplyGPUOp() {} void MatrixMultiplyGPUOp::apply(CommandBuffer *commandBuffer, Graphics *graphics) { graphics->bindComputePipeline(commandBuffer, computePipeline); graphics->bindUniformBuffer(commandBuffer, bUbo.get(), U_UBO, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bSrc0.get(), SSBO_SRC0, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bSrc1.get(), SSBO_SRC1, SHADER_STAGE_COMPUTE_BIT); graphics->bindStorageBuffer(commandBuffer, bDst.get(), SSBO_DST, SHADER_STAGE_COMPUTE_BIT); graphics->dispatch(commandBuffer, dst.w, dst.h, 1, 1, 1, 1); } void MatrixMultiplyGPUOp::update(MatrixParam src0, MatrixParam src1) { std::vector<float> src1t_data(size_t(src1.w * src1.h)); MatrixParam src1t = {src1.h, src1.w, src1t_data.data()}; MatrixMultiplyCPUOp::transpose(src1, src1t); UboData uboData = {int32_t(src0.w), int32_t(src0.h), int32_t(src1t.w), int32_t(src1t.h), int32_t(dst.w), int32_t(dst.h)}; bUbo.reset(createUniformBuffer(ctx, &uboData, sizeof(uboData))); bSrc0.reset( createStorageBuffer(ctx, src0.data, src0.w * src0.h * sizeof(float))); bSrc1.reset( createStorageBuffer(ctx, src1t.data, src1.w * src1.h * sizeof(float))); bDst.reset(createStorageBuffer(ctx, dst.data, dst.w * dst.h * sizeof(float))); } void MatrixMultiplyGPUOp::createPipeline() { const std::string key = \"matrixMultiplyOp\"; computePipeline = (ComputePipeline *)ctx->pipelineCache->get(key); if (computePipeline) return; computePipeline = ComputePipeline::create( ctx, ComputeShaderModule::create(ctx->device, \"matrixMultiply.comp\").get()); ctx->pipelineCache->add(key, computePipeline); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MatrixMultiplyGPUOp_8h/","text":"src/ngfx/computeOps/MatrixMultiplyGPUOp.h Namespaces Name ngfx Classes Name class ngfx::MatrixMultiplyGPUOp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/computeOps/MatrixMultiplyOp.h\" #include \"ngfx/graphics/Graphics.h\" namespace ngfx { class MatrixMultiplyGPUOp : public MatrixMultiplyOp { public: MatrixMultiplyGPUOp(GraphicsContext *ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst); virtual ~MatrixMultiplyGPUOp(); virtual void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr); virtual void update(MatrixParam src0, MatrixParam src1); std::unique_ptr<Buffer> bUbo; std::unique_ptr<Buffer> bSrc0, bSrc1, bDst; protected: struct UboData { int32_t src0_w, src0_h, src1t_w, src1t_h, dst_w, dst_h; }; void createPipeline(); ComputePipeline *computePipeline; uint32_t U_UBO = 0, SSBO_SRC0 = 1, SSBO_SRC1 = 2, SSBO_DST = 3; MatrixParam dst; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/computeOps/MatrixMultiplyGPUOp.h"},{"location":"api/Files/MatrixMultiplyGPUOp_8h/#srcngfxcomputeopsmatrixmultiplygpuoph","text":"","title":"src/ngfx/computeOps/MatrixMultiplyGPUOp.h"},{"location":"api/Files/MatrixMultiplyGPUOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MatrixMultiplyGPUOp_8h/#classes","text":"Name class ngfx::MatrixMultiplyGPUOp","title":"Classes"},{"location":"api/Files/MatrixMultiplyGPUOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/computeOps/MatrixMultiplyOp.h\" #include \"ngfx/graphics/Graphics.h\" namespace ngfx { class MatrixMultiplyGPUOp : public MatrixMultiplyOp { public: MatrixMultiplyGPUOp(GraphicsContext *ctx, MatrixParam src0, MatrixParam src1, MatrixParam dst); virtual ~MatrixMultiplyGPUOp(); virtual void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr); virtual void update(MatrixParam src0, MatrixParam src1); std::unique_ptr<Buffer> bUbo; std::unique_ptr<Buffer> bSrc0, bSrc1, bDst; protected: struct UboData { int32_t src0_w, src0_h, src1t_w, src1t_h, dst_w, dst_h; }; void createPipeline(); ComputePipeline *computePipeline; uint32_t U_UBO = 0, SSBO_SRC0 = 1, SSBO_SRC1 = 2, SSBO_DST = 3; MatrixParam dst; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MatrixMultiplyOp_8h/","text":"src/ngfx/computeOps/MatrixMultiplyOp.h Namespaces Name ngfx Classes Name class ngfx::MatrixMultiplyOp struct ngfx::MatrixMultiplyOp::MatrixParam Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputeOp.h\" #include <memory> namespace ngfx { class MatrixMultiplyOp : public ComputeOp { public: struct MatrixParam { uint32_t w, h; float *data; }; MatrixMultiplyOp(GraphicsContext *ctx) : ComputeOp(ctx) {} virtual ~MatrixMultiplyOp() {} void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) override = 0; virtual void update(MatrixParam src0, MatrixParam src1) = 0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/computeOps/MatrixMultiplyOp.h"},{"location":"api/Files/MatrixMultiplyOp_8h/#srcngfxcomputeopsmatrixmultiplyoph","text":"","title":"src/ngfx/computeOps/MatrixMultiplyOp.h"},{"location":"api/Files/MatrixMultiplyOp_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MatrixMultiplyOp_8h/#classes","text":"Name class ngfx::MatrixMultiplyOp struct ngfx::MatrixMultiplyOp::MatrixParam","title":"Classes"},{"location":"api/Files/MatrixMultiplyOp_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputeOp.h\" #include <memory> namespace ngfx { class MatrixMultiplyOp : public ComputeOp { public: struct MatrixParam { uint32_t w, h; float *data; }; MatrixMultiplyOp(GraphicsContext *ctx) : ComputeOp(ctx) {} virtual ~MatrixMultiplyOp() {} void apply(CommandBuffer *commandBuffer = nullptr, Graphics *graphics = nullptr) override = 0; virtual void update(MatrixParam src0, MatrixParam src1) = 0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MeshData_8h/","text":"src/ngfx/graphics/MeshData.h Namespaces Name ngfx Classes Name struct ngfx::MeshData Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <glm/glm.hpp> #include <vector> using namespace glm; namespace ngfx { struct MeshData { std::vector<vec3> pos, normal; std::vector<ivec3> faces; vec3 bounds[2] = {vec3(FLT_MAX), vec3(FLT_MIN)}; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/MeshData.h"},{"location":"api/Files/MeshData_8h/#srcngfxgraphicsmeshdatah","text":"","title":"src/ngfx/graphics/MeshData.h"},{"location":"api/Files/MeshData_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MeshData_8h/#classes","text":"Name struct ngfx::MeshData","title":"Classes"},{"location":"api/Files/MeshData_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <glm/glm.hpp> #include <vector> using namespace glm; namespace ngfx { struct MeshData { std::vector<vec3> pos, normal; std::vector<ivec3> faces; vec3 bounds[2] = {vec3(FLT_MAX), vec3(FLT_MIN)}; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MeshUtil_8cpp/","text":"src/ngfx/graphics/MeshUtil.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/MeshUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <glm/gtc/type_ptr.hpp> using namespace ngfx; using namespace std; void MeshUtil::importMesh(const std::string &file, MeshData &meshData) { ifstream in(file, ios::binary); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts, numNormals, numFaces; in.read((char *)&numVerts, sizeof(numVerts)); pos.resize(numVerts); in.read((char *)value_ptr(bounds[0]), sizeof(bounds[0])); in.read((char *)value_ptr(bounds[1]), sizeof(bounds[1])); in.read((char *)pos.data(), pos.size() * sizeof(pos[0])); in.read((char *)&numNormals, sizeof(numNormals)); normals.resize(numNormals); in.read((char *)normals.data(), normals.size() * sizeof(normals[0])); in.read((char *)&numFaces, sizeof(numFaces)); faces.resize(numFaces); in.read((char *)faces.data(), faces.size() * sizeof(faces[0])); in.close(); } void MeshUtil::exportMesh(const std::string &file, MeshData &meshData) { ofstream out(file, ios::binary); if (!out.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts = pos.size(), numNormals = normals.size(), numFaces = faces.size(); out.write((const char *)&numVerts, sizeof(numVerts)); out.write((const char *)value_ptr(bounds[0]), sizeof(bounds[0])); out.write((const char *)value_ptr(bounds[1]), sizeof(bounds[1])); out.write((const char *)pos.data(), pos.size() * sizeof(pos[0])); out.write((const char *)&numNormals, sizeof(numNormals)); out.write((const char *)normals.data(), normals.size() * sizeof(normals[0])); out.write((const char *)&numFaces, sizeof(numFaces)); out.write((const char *)faces.data(), faces.size() * sizeof(faces[0])); out.close(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/MeshUtil.cpp"},{"location":"api/Files/MeshUtil_8cpp/#srcngfxgraphicsmeshutilcpp","text":"","title":"src/ngfx/graphics/MeshUtil.cpp"},{"location":"api/Files/MeshUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/MeshUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <glm/gtc/type_ptr.hpp> using namespace ngfx; using namespace std; void MeshUtil::importMesh(const std::string &file, MeshData &meshData) { ifstream in(file, ios::binary); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts, numNormals, numFaces; in.read((char *)&numVerts, sizeof(numVerts)); pos.resize(numVerts); in.read((char *)value_ptr(bounds[0]), sizeof(bounds[0])); in.read((char *)value_ptr(bounds[1]), sizeof(bounds[1])); in.read((char *)pos.data(), pos.size() * sizeof(pos[0])); in.read((char *)&numNormals, sizeof(numNormals)); normals.resize(numNormals); in.read((char *)normals.data(), normals.size() * sizeof(normals[0])); in.read((char *)&numFaces, sizeof(numFaces)); faces.resize(numFaces); in.read((char *)faces.data(), faces.size() * sizeof(faces[0])); in.close(); } void MeshUtil::exportMesh(const std::string &file, MeshData &meshData) { ofstream out(file, ios::binary); if (!out.is_open()) NGFX_ERR(\"cannot open file: %s\", file.c_str()); auto &bounds = meshData.bounds; auto &pos = meshData.pos; auto &normals = meshData.normal; auto &faces = meshData.faces; size_t numVerts = pos.size(), numNormals = normals.size(), numFaces = faces.size(); out.write((const char *)&numVerts, sizeof(numVerts)); out.write((const char *)value_ptr(bounds[0]), sizeof(bounds[0])); out.write((const char *)value_ptr(bounds[1]), sizeof(bounds[1])); out.write((const char *)pos.data(), pos.size() * sizeof(pos[0])); out.write((const char *)&numNormals, sizeof(numNormals)); out.write((const char *)normals.data(), normals.size() * sizeof(normals[0])); out.write((const char *)&numFaces, sizeof(numFaces)); out.write((const char *)faces.data(), faces.size() * sizeof(faces[0])); out.close(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/MeshUtil_8h/","text":"src/ngfx/graphics/MeshUtil.h Namespaces Name ngfx Classes Name struct ngfx::MeshUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/MeshData.h\" #include <string> namespace ngfx { struct MeshUtil { static void importMesh(const std::string &file, MeshData &meshData); static void exportMesh(const std::string &file, MeshData &meshData); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/MeshUtil.h"},{"location":"api/Files/MeshUtil_8h/#srcngfxgraphicsmeshutilh","text":"","title":"src/ngfx/graphics/MeshUtil.h"},{"location":"api/Files/MeshUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/MeshUtil_8h/#classes","text":"Name struct ngfx::MeshUtil","title":"Classes"},{"location":"api/Files/MeshUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/MeshData.h\" #include <string> namespace ngfx { struct MeshUtil { static void importMesh(const std::string &file, MeshData &meshData); static void exportMesh(const std::string &file, MeshData &meshData); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/PipelineCache_8cpp/","text":"src/ngfx/graphics/PipelineCache.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/PipelineCache.h\" using namespace ngfx; Pipeline *PipelineCache::get(const std::string &key) { if (v.find(key) == v.end()) return nullptr; return v[key].get(); } void PipelineCache::add(const std::string &key, Pipeline *value) { v[key].reset(value); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/PipelineCache.cpp"},{"location":"api/Files/PipelineCache_8cpp/#srcngfxgraphicspipelinecachecpp","text":"","title":"src/ngfx/graphics/PipelineCache.cpp"},{"location":"api/Files/PipelineCache_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/PipelineCache.h\" using namespace ngfx; Pipeline *PipelineCache::get(const std::string &key) { if (v.find(key) == v.end()) return nullptr; return v[key].get(); } void PipelineCache::add(const std::string &key, Pipeline *value) { v[key].reset(value); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/PipelineCache_8h/","text":"src/ngfx/graphics/PipelineCache.h Namespaces Name ngfx Classes Name class ngfx::PipelineCache Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Pipeline.h\" #include <map> #include <memory> #include <string> namespace ngfx { class PipelineCache { public: virtual ~PipelineCache() {} virtual Pipeline *get(const std::string &key); virtual void add(const std::string &key, Pipeline *value); private: std::map<std::string, std::unique_ptr<Pipeline>> v; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/PipelineCache.h"},{"location":"api/Files/PipelineCache_8h/#srcngfxgraphicspipelinecacheh","text":"","title":"src/ngfx/graphics/PipelineCache.h"},{"location":"api/Files/PipelineCache_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/PipelineCache_8h/#classes","text":"Name class ngfx::PipelineCache","title":"Classes"},{"location":"api/Files/PipelineCache_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Pipeline.h\" #include <map> #include <memory> #include <string> namespace ngfx { class PipelineCache { public: virtual ~PipelineCache() {} virtual Pipeline *get(const std::string &key); virtual void add(const std::string &key, Pipeline *value); private: std::map<std::string, std::unique_ptr<Pipeline>> v; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Pipeline_8h/","text":"src/ngfx/graphics/Pipeline.h Namespaces Name ngfx Classes Name class ngfx::Pipeline Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Pipeline { public: virtual ~Pipeline() {} }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Pipeline.h"},{"location":"api/Files/Pipeline_8h/#srcngfxgraphicspipelineh","text":"","title":"src/ngfx/graphics/Pipeline.h"},{"location":"api/Files/Pipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Pipeline_8h/#classes","text":"Name class ngfx::Pipeline","title":"Classes"},{"location":"api/Files/Pipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Pipeline { public: virtual ~Pipeline() {} }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ProcessUtil_8cpp/","text":"src/ngfx/core/ProcessUtil.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ProcessUtil.h\" #ifdef _WIN32 #include <windows.h> #else #include <unistd.h> #endif using namespace ngfx; int ProcessUtil::getPID() { #ifdef _WIN32 return GetCurrentProcessId(); #else return getpid(); #endif } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/ProcessUtil.cpp"},{"location":"api/Files/ProcessUtil_8cpp/#srcngfxcoreprocessutilcpp","text":"","title":"src/ngfx/core/ProcessUtil.cpp"},{"location":"api/Files/ProcessUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ProcessUtil.h\" #ifdef _WIN32 #include <windows.h> #else #include <unistd.h> #endif using namespace ngfx; int ProcessUtil::getPID() { #ifdef _WIN32 return GetCurrentProcessId(); #else return getpid(); #endif } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ProcessUtil_8h/","text":"src/ngfx/core/ProcessUtil.h Namespaces Name ngfx Classes Name class ngfx::ProcessUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class ProcessUtil { public: static int getPID(); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/ProcessUtil.h"},{"location":"api/Files/ProcessUtil_8h/#srcngfxcoreprocessutilh","text":"","title":"src/ngfx/core/ProcessUtil.h"},{"location":"api/Files/ProcessUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ProcessUtil_8h/#classes","text":"Name class ngfx::ProcessUtil","title":"Classes"},{"location":"api/Files/ProcessUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class ProcessUtil { public: static int getPID(); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Queue_8h/","text":"src/ngfx/graphics/Queue.h Namespaces Name ngfx Classes Name class ngfx::Queue Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Fence.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Swapchain.h\" #include <vector> namespace ngfx { class Queue { public: virtual ~Queue() {} virtual void present() = 0; virtual void submit(CommandBuffer *commandBuffer) = 0; virtual void waitIdle() = 0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Queue.h"},{"location":"api/Files/Queue_8h/#srcngfxgraphicsqueueh","text":"","title":"src/ngfx/graphics/Queue.h"},{"location":"api/Files/Queue_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Queue_8h/#classes","text":"Name class ngfx::Queue","title":"Classes"},{"location":"api/Files/Queue_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/Fence.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include \"ngfx/graphics/Swapchain.h\" #include <vector> namespace ngfx { class Queue { public: virtual ~Queue() {} virtual void present() = 0; virtual void submit(CommandBuffer *commandBuffer) = 0; virtual void waitIdle() = 0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/RegexUtil_8cpp/","text":"src/ngfx/regex/RegexUtil.cpp Functions Name RegexUtil::Match toMatch (smatch & m) Functions Documentation function toMatch static RegexUtil::Match toMatch( smatch & m ) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"RegexUtil.h\" #include \"ngfx/core/DebugUtil.h\" using namespace std; using namespace ngfx; static RegexUtil::Match toMatch(smatch &m) { RegexUtil::Match match; match.s.resize(m.size()); for (uint32_t j = 0; j < m.size(); j++) match.s[j] = m.str(j); return match; } vector<RegexUtil::Match> RegexUtil::findAll(const regex &p, string contents) { vector<Match> matches; smatch m; while (regex_search(contents, m, p)) { matches.push_back(toMatch(m)); contents = m.suffix().str(); } return matches; } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/regex/RegexUtil.cpp"},{"location":"api/Files/RegexUtil_8cpp/#srcngfxregexregexutilcpp","text":"","title":"src/ngfx/regex/RegexUtil.cpp"},{"location":"api/Files/RegexUtil_8cpp/#functions","text":"Name RegexUtil::Match toMatch (smatch & m)","title":"Functions"},{"location":"api/Files/RegexUtil_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/RegexUtil_8cpp/#function-tomatch","text":"static RegexUtil::Match toMatch( smatch & m )","title":"function toMatch"},{"location":"api/Files/RegexUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"RegexUtil.h\" #include \"ngfx/core/DebugUtil.h\" using namespace std; using namespace ngfx; static RegexUtil::Match toMatch(smatch &m) { RegexUtil::Match match; match.s.resize(m.size()); for (uint32_t j = 0; j < m.size(); j++) match.s[j] = m.str(j); return match; } vector<RegexUtil::Match> RegexUtil::findAll(const regex &p, string contents) { vector<Match> matches; smatch m; while (regex_search(contents, m, p)) { matches.push_back(toMatch(m)); contents = m.suffix().str(); } return matches; } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/RegexUtil_8h/","text":"src/ngfx/regex/RegexUtil.h Namespaces Name ngfx Classes Name class ngfx::RegexUtil struct ngfx::RegexUtil::Match Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <regex> namespace ngfx { class RegexUtil { public: struct Match { std::vector<std::string> s; }; static std::vector<Match> findAll(const std::regex &p, std::string contents); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/regex/RegexUtil.h"},{"location":"api/Files/RegexUtil_8h/#srcngfxregexregexutilh","text":"","title":"src/ngfx/regex/RegexUtil.h"},{"location":"api/Files/RegexUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/RegexUtil_8h/#classes","text":"Name class ngfx::RegexUtil struct ngfx::RegexUtil::Match","title":"Classes"},{"location":"api/Files/RegexUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <regex> namespace ngfx { class RegexUtil { public: struct Match { std::vector<std::string> s; }; static std::vector<Match> findAll(const std::regex &p, std::string contents); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/RenderPass_8h/","text":"src/ngfx/graphics/RenderPass.h Namespaces Name ngfx Classes Name class ngfx::RenderPass Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Framebuffer; class RenderPass { public: virtual ~RenderPass() {} Framebuffer *currentFramebuffer = nullptr; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/RenderPass.h"},{"location":"api/Files/RenderPass_8h/#srcngfxgraphicsrenderpassh","text":"","title":"src/ngfx/graphics/RenderPass.h"},{"location":"api/Files/RenderPass_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/RenderPass_8h/#classes","text":"Name class ngfx::RenderPass","title":"Classes"},{"location":"api/Files/RenderPass_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { class Framebuffer; class RenderPass { public: virtual ~RenderPass() {} Framebuffer *currentFramebuffer = nullptr; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Semaphore_8h/","text":"src/ngfx/graphics/Semaphore.h Namespaces Name ngfx Classes Name class ngfx::Semaphore Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include <cstdint> namespace ngfx { class Semaphore { public: static Semaphore *create(Device *device); virtual ~Semaphore() {} virtual uint64_t wait() = 0; virtual void signal(uint64_t value = 1) = 0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Semaphore.h"},{"location":"api/Files/Semaphore_8h/#srcngfxgraphicssemaphoreh","text":"","title":"src/ngfx/graphics/Semaphore.h"},{"location":"api/Files/Semaphore_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Semaphore_8h/#classes","text":"Name class ngfx::Semaphore","title":"Classes"},{"location":"api/Files/Semaphore_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include <cstdint> namespace ngfx { class Semaphore { public: static Semaphore *create(Device *device); virtual ~Semaphore() {} virtual uint64_t wait() = 0; virtual void signal(uint64_t value = 1) = 0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ShaderModule_8cpp/","text":"src/ngfx/graphics/ShaderModule.cpp Classes Name struct VertexFormatInfo Functions Name void parseAttributes (ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs) void parseDescriptors (ifstream & in, vector< ShaderModule::DescriptorInfo > & descs) void parseBufferMemberInfos (ifstream & in, ShaderModule::BufferMemberInfos & memberInfos) void parseBufferInfos (ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages) Attributes Name const map< string, VertexFormatInfo > vertexFormatMap const map< string, VertexInputRate > vertexInputRateMap const map< string, DescriptorType > descriptorTypeMap Defines Name VF_ITEM (s, count, elementSize) ITEM (s) Functions Documentation function parseAttributes static void parseAttributes( ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs ) function parseDescriptors static void parseDescriptors( ifstream & in, vector< ShaderModule::DescriptorInfo > & descs ) function parseBufferMemberInfos static void parseBufferMemberInfos( ifstream & in, ShaderModule::BufferMemberInfos & memberInfos ) function parseBufferInfos static void parseBufferInfos( ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages ) Attributes Documentation variable vertexFormatMap static const map< string, VertexFormatInfo > vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}}; variable vertexInputRateMap static const map< string, VertexInputRate > vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), }; variable descriptorTypeMap static const map< string, DescriptorType > descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)}; Macro Documentation define VF_ITEM #define VF_ITEM( s, count, elementSize ) { \\ #s, { s, count, elementSize } \\ } define ITEM #define ITEM( s ) { #s, s } Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <map> using namespace ngfx; using namespace std; #define VF_ITEM(s, count, elementSize) \\ { \\ #s, { s, count, elementSize } \\ } struct VertexFormatInfo { VertexFormat format; uint32_t count, elementSize; }; static const map<string, VertexFormatInfo> vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}}; #define ITEM(s) \\ { #s, s } static const map<string, VertexInputRate> vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), }; static const map<string, DescriptorType> descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)}; static void parseAttributes(ifstream &in, vector<VertexShaderModule::AttributeDescription> &attrs) { string token; uint32_t numAttributes; in >> token >> numAttributes; attrs.resize(numAttributes); for (uint32_t j = 0; j < numAttributes; j++) { auto &attr = attrs[j]; string formatStr; in >> attr.name >> attr.semantic >> attr.location >> formatStr; auto formatInfo = vertexFormatMap.at(formatStr); attr.format = formatInfo.format; attr.count = formatInfo.count; attr.elementSize = formatInfo.elementSize; } } static void parseDescriptors(ifstream &in, vector<ShaderModule::DescriptorInfo> &descs) { string token; int numDescriptors; in >> token >> numDescriptors; descs.resize(numDescriptors); for (uint32_t j = 0; j < uint32_t(numDescriptors); j++) { auto &desc = descs[j]; string descriptorTypeStr; in >> desc.name >> descriptorTypeStr >> desc.set; desc.type = descriptorTypeMap.at(descriptorTypeStr); } } static void parseBufferMemberInfos(ifstream &in, ShaderModule::BufferMemberInfos &memberInfos) { uint32_t numMemberInfos; in >> numMemberInfos; for (uint32_t j = 0; j < numMemberInfos; j++) { ShaderModule::BufferMemberInfo memberInfo; string memberName; in >> memberName >> memberInfo.offset >> memberInfo.size >> memberInfo.arrayCount >> memberInfo.arrayStride; memberInfos[memberName] = memberInfo; } } static void parseBufferInfos(ifstream &in, string key, ShaderModule::BufferInfos &bufferInfos, ShaderStageFlags shaderStages) { string token; in >> token; if (token != key) return; uint32_t numUniformBufferInfos; in >> numUniformBufferInfos; for (uint32_t j = 0; j < numUniformBufferInfos; j++) { ShaderModule::BufferInfo bufferInfo; in >> bufferInfo.name >> bufferInfo.set; bufferInfo.shaderStages = shaderStages; parseBufferMemberInfos(in, bufferInfo.memberInfos); bufferInfos[bufferInfo.name] = std::move(bufferInfo); } } void ShaderModule::initBindings(std::ifstream &in, ShaderStageFlags shaderStages) { parseDescriptors(in, descriptors); parseBufferInfos(in, \"UNIFORM_BUFFER_INFOS\", uniformBufferInfos, shaderStages); parseBufferInfos(in, \"SHADER_STORAGE_BUFFER_INFOS\", shaderStorageBufferInfos, shaderStages); } void ShaderModule::initBindings(const std::string &filename, ShaderStageFlags shaderStages) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); initBindings(in, shaderStages); in.close(); } void VertexShaderModule::initBindings(const std::string &filename) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); parseAttributes(in, attributes); ShaderModule::initBindings(in, SHADER_STAGE_VERTEX_BIT); in.close(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/ShaderModule.cpp"},{"location":"api/Files/ShaderModule_8cpp/#srcngfxgraphicsshadermodulecpp","text":"","title":"src/ngfx/graphics/ShaderModule.cpp"},{"location":"api/Files/ShaderModule_8cpp/#classes","text":"Name struct VertexFormatInfo","title":"Classes"},{"location":"api/Files/ShaderModule_8cpp/#functions","text":"Name void parseAttributes (ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs) void parseDescriptors (ifstream & in, vector< ShaderModule::DescriptorInfo > & descs) void parseBufferMemberInfos (ifstream & in, ShaderModule::BufferMemberInfos & memberInfos) void parseBufferInfos (ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages)","title":"Functions"},{"location":"api/Files/ShaderModule_8cpp/#attributes","text":"Name const map< string, VertexFormatInfo > vertexFormatMap const map< string, VertexInputRate > vertexInputRateMap const map< string, DescriptorType > descriptorTypeMap","title":"Attributes"},{"location":"api/Files/ShaderModule_8cpp/#defines","text":"Name VF_ITEM (s, count, elementSize) ITEM (s)","title":"Defines"},{"location":"api/Files/ShaderModule_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/ShaderModule_8cpp/#function-parseattributes","text":"static void parseAttributes( ifstream & in, vector< VertexShaderModule::AttributeDescription > & attrs )","title":"function parseAttributes"},{"location":"api/Files/ShaderModule_8cpp/#function-parsedescriptors","text":"static void parseDescriptors( ifstream & in, vector< ShaderModule::DescriptorInfo > & descs )","title":"function parseDescriptors"},{"location":"api/Files/ShaderModule_8cpp/#function-parsebuffermemberinfos","text":"static void parseBufferMemberInfos( ifstream & in, ShaderModule::BufferMemberInfos & memberInfos )","title":"function parseBufferMemberInfos"},{"location":"api/Files/ShaderModule_8cpp/#function-parsebufferinfos","text":"static void parseBufferInfos( ifstream & in, string key, ShaderModule::BufferInfos & bufferInfos, ShaderStageFlags shaderStages )","title":"function parseBufferInfos"},{"location":"api/Files/ShaderModule_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/ShaderModule_8cpp/#variable-vertexformatmap","text":"static const map< string, VertexFormatInfo > vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}};","title":"variable vertexFormatMap"},{"location":"api/Files/ShaderModule_8cpp/#variable-vertexinputratemap","text":"static const map< string, VertexInputRate > vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), };","title":"variable vertexInputRateMap"},{"location":"api/Files/ShaderModule_8cpp/#variable-descriptortypemap","text":"static const map< string, DescriptorType > descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)};","title":"variable descriptorTypeMap"},{"location":"api/Files/ShaderModule_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/ShaderModule_8cpp/#define-vf_item","text":"#define VF_ITEM( s, count, elementSize ) { \\ #s, { s, count, elementSize } \\ }","title":"define VF_ITEM"},{"location":"api/Files/ShaderModule_8cpp/#define-item","text":"#define ITEM( s ) { #s, s }","title":"define ITEM"},{"location":"api/Files/ShaderModule_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/core/DebugUtil.h\" #include <fstream> #include <map> using namespace ngfx; using namespace std; #define VF_ITEM(s, count, elementSize) \\ { \\ #s, { s, count, elementSize } \\ } struct VertexFormatInfo { VertexFormat format; uint32_t count, elementSize; }; static const map<string, VertexFormatInfo> vertexFormatMap = { VF_ITEM(VERTEXFORMAT_FLOAT, 1, 4), VF_ITEM(VERTEXFORMAT_FLOAT2, 1, 8), VF_ITEM(VERTEXFORMAT_FLOAT3, 1, 12), VF_ITEM(VERTEXFORMAT_FLOAT4, 1, 16), {\"VERTEXFORMAT_MAT4\", {VERTEXFORMAT_FLOAT4, 4, 16}}}; #define ITEM(s) \\ { #s, s } static const map<string, VertexInputRate> vertexInputRateMap = { ITEM(VERTEX_INPUT_RATE_VERTEX), ITEM(VERTEX_INPUT_RATE_INSTANCE), }; static const map<string, DescriptorType> descriptorTypeMap = { ITEM(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), ITEM(DESCRIPTOR_TYPE_STORAGE_IMAGE), ITEM(DESCRIPTOR_TYPE_UNIFORM_BUFFER), ITEM(DESCRIPTOR_TYPE_STORAGE_BUFFER)}; static void parseAttributes(ifstream &in, vector<VertexShaderModule::AttributeDescription> &attrs) { string token; uint32_t numAttributes; in >> token >> numAttributes; attrs.resize(numAttributes); for (uint32_t j = 0; j < numAttributes; j++) { auto &attr = attrs[j]; string formatStr; in >> attr.name >> attr.semantic >> attr.location >> formatStr; auto formatInfo = vertexFormatMap.at(formatStr); attr.format = formatInfo.format; attr.count = formatInfo.count; attr.elementSize = formatInfo.elementSize; } } static void parseDescriptors(ifstream &in, vector<ShaderModule::DescriptorInfo> &descs) { string token; int numDescriptors; in >> token >> numDescriptors; descs.resize(numDescriptors); for (uint32_t j = 0; j < uint32_t(numDescriptors); j++) { auto &desc = descs[j]; string descriptorTypeStr; in >> desc.name >> descriptorTypeStr >> desc.set; desc.type = descriptorTypeMap.at(descriptorTypeStr); } } static void parseBufferMemberInfos(ifstream &in, ShaderModule::BufferMemberInfos &memberInfos) { uint32_t numMemberInfos; in >> numMemberInfos; for (uint32_t j = 0; j < numMemberInfos; j++) { ShaderModule::BufferMemberInfo memberInfo; string memberName; in >> memberName >> memberInfo.offset >> memberInfo.size >> memberInfo.arrayCount >> memberInfo.arrayStride; memberInfos[memberName] = memberInfo; } } static void parseBufferInfos(ifstream &in, string key, ShaderModule::BufferInfos &bufferInfos, ShaderStageFlags shaderStages) { string token; in >> token; if (token != key) return; uint32_t numUniformBufferInfos; in >> numUniformBufferInfos; for (uint32_t j = 0; j < numUniformBufferInfos; j++) { ShaderModule::BufferInfo bufferInfo; in >> bufferInfo.name >> bufferInfo.set; bufferInfo.shaderStages = shaderStages; parseBufferMemberInfos(in, bufferInfo.memberInfos); bufferInfos[bufferInfo.name] = std::move(bufferInfo); } } void ShaderModule::initBindings(std::ifstream &in, ShaderStageFlags shaderStages) { parseDescriptors(in, descriptors); parseBufferInfos(in, \"UNIFORM_BUFFER_INFOS\", uniformBufferInfos, shaderStages); parseBufferInfos(in, \"SHADER_STORAGE_BUFFER_INFOS\", shaderStorageBufferInfos, shaderStages); } void ShaderModule::initBindings(const std::string &filename, ShaderStageFlags shaderStages) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); initBindings(in, shaderStages); in.close(); } void VertexShaderModule::initBindings(const std::string &filename) { ifstream in(filename); if (!in.is_open()) NGFX_ERR(\"cannot open file: %s\", filename.c_str()); parseAttributes(in, attributes); ShaderModule::initBindings(in, SHADER_STAGE_VERTEX_BIT); in.close(); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ShaderModule_8h/","text":"src/ngfx/graphics/ShaderModule.h Namespaces Name ngfx Classes Name class ngfx::ShaderModule struct ngfx::ShaderModule::DescriptorInfo struct ngfx::ShaderModule::BufferMemberInfo struct ngfx::ShaderModule::BufferInfo class ngfx::VertexShaderModule struct ngfx::VertexShaderModule::AttributeDescription class ngfx::FragmentShaderModule class ngfx::ComputeShaderModule Defines Name ENABLE_NGL_INTEGRATION Macro Documentation define ENABLE_NGL_INTEGRATION #define ENABLE_NGL_INTEGRATION Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <map> #include <memory> #include <string> #include <vector> #define ENABLE_NGL_INTEGRATION namespace ngfx { class ShaderModule { public: virtual ~ShaderModule() {} struct DescriptorInfo { std::string name; uint32_t set; DescriptorType type; }; typedef std::vector<DescriptorInfo> DescriptorInfos; DescriptorInfos descriptors; inline DescriptorInfo *findDescriptorInfo(const std::string &name) { for (auto &desc : descriptors) { if (desc.name == name) return &desc; } return nullptr; } struct BufferMemberInfo { uint32_t offset, size, arrayCount, arrayStride; }; typedef std::map<std::string, BufferMemberInfo> BufferMemberInfos; struct BufferInfo { std::string name; uint32_t set; ShaderStageFlags shaderStages; BufferMemberInfos memberInfos; }; typedef std::map<std::string, BufferInfo> BufferInfos; inline BufferInfo *findUniformBufferInfo(const std::string &name) { auto it = uniformBufferInfos.find(name); if (it == uniformBufferInfos.end()) return nullptr; return &it->second; } inline BufferInfo *findStorageBufferInfo(const std::string &name) { auto it = shaderStorageBufferInfos.find(name); if (it == shaderStorageBufferInfos.end()) return nullptr; return &it->second; } BufferInfos uniformBufferInfos, shaderStorageBufferInfos; void initBindings(std::ifstream &in, ShaderStageFlags shaderStages); void initBindings(const std::string &filename, ShaderStageFlags shaderStages); }; class VertexShaderModule : public ShaderModule { public: static std::unique_ptr<VertexShaderModule> create(Device *device, const std::string &filename); virtual ~VertexShaderModule() {} struct AttributeDescription { std::string semantic; uint32_t location; VertexFormat format; std::string name; uint32_t count, elementSize; }; std::vector<AttributeDescription> attributes; inline AttributeDescription *findAttribute(const std::string &name) { for (auto &attr : attributes) { if (attr.name == name) return &attr; } return nullptr; } void initBindings(const std::string &filename); }; class FragmentShaderModule : public ShaderModule { public: static std::unique_ptr<FragmentShaderModule> create(Device *device, const std::string &filename); virtual ~FragmentShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_FRAGMENT_BIT); } }; class ComputeShaderModule : public ShaderModule { public: static std::unique_ptr<ComputeShaderModule> create(Device *device, const std::string &filename); virtual ~ComputeShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_COMPUTE_BIT); } }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/ShaderModule.h"},{"location":"api/Files/ShaderModule_8h/#srcngfxgraphicsshadermoduleh","text":"","title":"src/ngfx/graphics/ShaderModule.h"},{"location":"api/Files/ShaderModule_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ShaderModule_8h/#classes","text":"Name class ngfx::ShaderModule struct ngfx::ShaderModule::DescriptorInfo struct ngfx::ShaderModule::BufferMemberInfo struct ngfx::ShaderModule::BufferInfo class ngfx::VertexShaderModule struct ngfx::VertexShaderModule::AttributeDescription class ngfx::FragmentShaderModule class ngfx::ComputeShaderModule","title":"Classes"},{"location":"api/Files/ShaderModule_8h/#defines","text":"Name ENABLE_NGL_INTEGRATION","title":"Defines"},{"location":"api/Files/ShaderModule_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/ShaderModule_8h/#define-enable_ngl_integration","text":"#define ENABLE_NGL_INTEGRATION","title":"define ENABLE_NGL_INTEGRATION"},{"location":"api/Files/ShaderModule_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/graphics/GraphicsCore.h\" #include <cstdint> #include <map> #include <memory> #include <string> #include <vector> #define ENABLE_NGL_INTEGRATION namespace ngfx { class ShaderModule { public: virtual ~ShaderModule() {} struct DescriptorInfo { std::string name; uint32_t set; DescriptorType type; }; typedef std::vector<DescriptorInfo> DescriptorInfos; DescriptorInfos descriptors; inline DescriptorInfo *findDescriptorInfo(const std::string &name) { for (auto &desc : descriptors) { if (desc.name == name) return &desc; } return nullptr; } struct BufferMemberInfo { uint32_t offset, size, arrayCount, arrayStride; }; typedef std::map<std::string, BufferMemberInfo> BufferMemberInfos; struct BufferInfo { std::string name; uint32_t set; ShaderStageFlags shaderStages; BufferMemberInfos memberInfos; }; typedef std::map<std::string, BufferInfo> BufferInfos; inline BufferInfo *findUniformBufferInfo(const std::string &name) { auto it = uniformBufferInfos.find(name); if (it == uniformBufferInfos.end()) return nullptr; return &it->second; } inline BufferInfo *findStorageBufferInfo(const std::string &name) { auto it = shaderStorageBufferInfos.find(name); if (it == shaderStorageBufferInfos.end()) return nullptr; return &it->second; } BufferInfos uniformBufferInfos, shaderStorageBufferInfos; void initBindings(std::ifstream &in, ShaderStageFlags shaderStages); void initBindings(const std::string &filename, ShaderStageFlags shaderStages); }; class VertexShaderModule : public ShaderModule { public: static std::unique_ptr<VertexShaderModule> create(Device *device, const std::string &filename); virtual ~VertexShaderModule() {} struct AttributeDescription { std::string semantic; uint32_t location; VertexFormat format; std::string name; uint32_t count, elementSize; }; std::vector<AttributeDescription> attributes; inline AttributeDescription *findAttribute(const std::string &name) { for (auto &attr : attributes) { if (attr.name == name) return &attr; } return nullptr; } void initBindings(const std::string &filename); }; class FragmentShaderModule : public ShaderModule { public: static std::unique_ptr<FragmentShaderModule> create(Device *device, const std::string &filename); virtual ~FragmentShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_FRAGMENT_BIT); } }; class ComputeShaderModule : public ShaderModule { public: static std::unique_ptr<ComputeShaderModule> create(Device *device, const std::string &filename); virtual ~ComputeShaderModule() {} void initBindings(const std::string &filename) { ShaderModule::initBindings(filename, SHADER_STAGE_COMPUTE_BIT); } }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ShaderTools_8cpp/","text":"src/ngfx/graphics/ShaderTools.cpp Functions Name string getEnv (const string & name) json * getEntry (const json & data, const string & key) shaderc_shader_kind toShaderKind (const string & ext) Attributes Name auto readFile auto writeFile auto toLower Defines Name V (func) PATCH Functions Documentation function getEnv static string getEnv( const string & name ) function getEntry static json * getEntry( const json & data, const string & key ) function toShaderKind static shaderc_shader_kind toShaderKind( const string & ext ) Attributes Documentation variable readFile auto readFile = FileUtil::readFile; variable writeFile auto writeFile = FileUtil::writeFile; variable toLower auto toLower = StringUtil::toLower; Macro Documentation define V #define V( func ) { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ } define PATCH #define PATCH string(\"patch\") Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ShaderTools.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/FileUtil.h\" #include \"ngfx/core/StringUtil.h\" #include <cctype> #include <filesystem> #include <fstream> #include <regex> #include <set> #include <spirv_cross/spirv_glsl.hpp> #include <spirv_cross/spirv_hlsl.hpp> #include <spirv_cross/spirv_msl.hpp> #include <spirv_cross/spirv_reflect.hpp> #include <sstream> using namespace std; using namespace ngfx; auto readFile = FileUtil::readFile; auto writeFile = FileUtil::writeFile; auto toLower = StringUtil::toLower; namespace fs = std::filesystem; #define V(func) \\ { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ } #ifdef _WIN32 #define PATCH string(\"patch.exe\") #else #define PATCH string(\"patch\") #endif static string getEnv(const string &name) { char *value = getenv(name.c_str()); return (value ? value : \"\"); } static json *getEntry(const json &data, const string &key) { auto it = data.find(key); if (it == data.end()) return nullptr; return (json *)&it.value(); } ShaderTools::ShaderTools(bool verbose) : verbose(verbose) { defaultIncludePaths = {\"ngfx/data/shaders\", \"nodegl/data/shaders\"}; } int ShaderTools::cmd(string str) { if (verbose) { NGFX_LOG(\">> %s\", str.c_str()); } else str += \" >> /dev/null 2>&1\"; return system(str.c_str()); } bool ShaderTools::findIncludeFile(const string &includeFilename, const vector<string> &includePaths, string &includeFile) { for (const string &includePath : includePaths) { fs::path filename = includePath / fs::path(includeFilename); if (fs::exists(filename)) { includeFile = filename.string(); return true; } } return false; } int ShaderTools::preprocess(const string &src, const string &dataPath, string &dst) { dst = \"\"; vector<string> includePaths = defaultIncludePaths; includePaths.push_back(dataPath); istringstream sstream(src); string line; while (std::getline(sstream, line)) { smatch matchIncludeGroups; bool matchInclude = regex_search(line, matchIncludeGroups, regex(\"#include \\\"([^\\\"]*)\")); if (matchInclude) { string includeFilename = matchIncludeGroups[1]; string includeFilePath; findIncludeFile(includeFilename, includePaths, includeFilePath); dst += readFile(includeFilePath); } else { dst += line + \"\\n\"; } } return 0; } int ShaderTools::compileShaderGLSL( const string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, string &spv, bool verbose, shaderc_optimization_level optimizationLevel) { shaderc::Compiler compiler; shaderc::CompileOptions compileOptions; for (const MacroDefinition &define : defines) { compileOptions.AddMacroDefinition(define.name, define.value); } compileOptions.SetOptimizationLevel(optimizationLevel); compileOptions.SetGenerateDebugInfo(); auto result = compiler.CompileGlslToSpv(src, shaderKind, \"\", compileOptions); if (result.GetCompilationStatus() != shaderc_compilation_status_success) { NGFX_ERR(\"cannot compile file: %s\", result.GetErrorMessage().c_str()); return 1; } spv = string((const char *)result.cbegin(), sizeof(uint32_t) * (result.cend() - result.cbegin())); return 0; } int ShaderTools::removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst) { int ret = 0; string spv; V(compileShaderGLSL(src, shaderKind, defines, spv, false)); auto compilerGLSL = make_unique<spirv_cross::CompilerGLSL>( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto activeVariables = compilerGLSL->get_active_interface_variables(); compilerGLSL->get_shader_resources(activeVariables); compilerGLSL->set_enabled_interface_variables(move(activeVariables)); spirv_cross::CompilerGLSL::Options opts; opts.vulkan_semantics = true; compilerGLSL->set_common_options(opts); dst = compilerGLSL->compile(); return 0; } int ShaderTools::patchShaderLayoutsGLSL(const string &src, string &dst) { dst = \"\"; istringstream sstream(src); string line; while (std::getline(sstream, line)) { // Patch GLSL shader layouts smatch g; bool matchLayout = regex_search(line, g, regex(\"^(.*)\" \"layout\\\\s*\\\\(\" \"([^)]*)\" \"binding[\\\\s]*=[\\\\s]*\" \"([\\\\d]+)\" \"([^)]*)\" \"\\\\)\" \"(.*)\\r*$\")); if (matchLayout) { dst += g[1].str() + \"layout(\" + g[2].str() + \"set = \" + g[3].str() + \", binding = 0\" + g[4].str() + \")\" + g[5].str() + \"\\n\"; } else { dst += line + \"\\n\"; } } return 0; } static shaderc_shader_kind toShaderKind(const string &ext) { static const map<string, shaderc_shader_kind> shaderKindMap = { {\".vert\", shaderc_vertex_shader}, {\".frag\", shaderc_fragment_shader}, {\".comp\", shaderc_compute_shader}}; return shaderKindMap.at(ext); } int ShaderTools::compileShaderGLSL(string filename, const MacroDefinitions &defines, const string &outDir, vector<string> &outFiles, int flags) { string parentPath = fs::path(filename).parent_path().string(); filename = fs::path(filename).filename().string(); string inFileName = fs::path(parentPath + \"/\" + filename).make_preferred().string(); string outFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string src, dst; int ret = 0; src = FileUtil::readFile(inFileName); string ext = FileUtil::splitExt(inFileName)[1]; shaderc_shader_kind shaderKind = toShaderKind(ext); if (flags & REMOVE_UNUSED_VARIABLES) { V(removeUnusedVariablesGLSL(src, shaderKind, defines, dst)); src = move(dst); } if (flags & PATCH_SHADER_LAYOUTS_GLSL) { V(patchShaderLayoutsGLSL(src, dst)); src = move(dst); } V(compileShaderGLSL(src, shaderKind, defines, dst)); writeFile(outFileName, dst); outFiles.push_back(outFileName); return 0; } int ShaderTools::compileShaderMSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".metal\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".metallib\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string debugFlags = \"-gline-tables-only -MO\"; int result = cmd(\"xcrun -sdk macosx metal \" + debugFlags + \" -c \" + inFileName + \" -o \" + outDir + \"/\" + strippedFilename + \".air && \" \"xcrun -sdk macosx metallib \" + outDir + \"/\" + strippedFilename + \".air -o \" + outFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::compileShaderHLSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".hlsl\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".dxc\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string shaderModel = \"\"; if (strstr(inFileName.c_str(), \".vert\")) shaderModel = \"vs_5_0\"; else if (strstr(inFileName.c_str(), \".frag\")) shaderModel = \"ps_5_0\"; else if (strstr(inFileName.c_str(), \".comp\")) shaderModel = \"cs_5_0\"; int result = cmd(\"dxc.exe /T \" + shaderModel + \" /Fo \" + outFileName + \" \" + inFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::convertSPVToMSL(const string &spv, shaderc_shader_kind shaderKind, string &msl) { auto compilerMSL = make_unique<spirv_cross::CompilerMSL>( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); msl = compilerMSL->compile(); return 0; } int ShaderTools::convertSPVToHLSL(const string &spv, shaderc_shader_kind shaderKind, string &hlsl, uint32_t shaderModel) { auto compilerHLSL = make_unique<spirv_cross::CompilerHLSL>( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto options = compilerHLSL->get_hlsl_options(); options.shader_model = shaderModel; compilerHLSL->set_hlsl_options(options); hlsl = compilerHLSL->compile(); return 0; } int ShaderTools::convertShader(const string &file, const string &extraArgs, string outDir, Format fmt, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string strippedFilename = splitFilename[0]; string ext = FileUtil::splitExt(strippedFilename)[1]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".spv\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + (fmt == FORMAT_MSL ? \".metal\" : \".hlsl\")) .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string spv = FileUtil::readFile(inFileName), dst; int result; if (fmt == FORMAT_MSL) { result = convertSPVToMSL(spv, toShaderKind(ext), dst); } else { result = convertSPVToHLSL(spv, toShaderKind(ext), dst); } FileUtil::writeFile(outFileName, dst); string args = (fmt == FORMAT_MSL ? \"--msl\" : \"--hlsl --shader-model 60\") + extraArgs; if (result == 0) NGFX_LOG(\"converted file: %s to %s\", inFileName.c_str(), outFileName.c_str()); else NGFX_ERR(\"cannot convert file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } bool ShaderTools::findMetalReflectData( const vector<RegexUtil::Match> &metalReflectData, const string &name, RegexUtil::Match &match) { for (const RegexUtil::Match &data : metalReflectData) { if (data.s[2] == name) { match = data; return true; } else if (strstr(data.s[1].c_str(), name.c_str())) { match = data; return true; } } return false; } int ShaderTools::patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect) { auto glslReflectJson = json::parse(glslReflect); MetalReflectData metalReflectData; if (ext == \".vert\") { metalReflectData.attributes = RegexUtil::findAll(regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[\" \"attribute\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); } metalReflectData.buffers = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[buffer\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); metalReflectData.textures = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[texture\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); uint32_t numDescriptors = (textures ? textures->size() : 0) + (images ? images->size() : 0) + (ubos ? ubos->size() : 0) + (ssbos ? ssbos->size() : 0); // update input bindings if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { RegexUtil::Match metalInputReflectData; bool foundMatch = findMetalReflectData( metalReflectData.attributes, input[\"name\"], metalInputReflectData); if (!foundMatch) { return 1; } input[\"location\"] = stoi(metalInputReflectData.s[3]) + numDescriptors; } } // update descriptor bindings if (textures) for (json &descriptor : *textures) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } if (ubos) for (json &descriptor : *ubos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (ssbos) for (json &descriptor : *ssbos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (images) for (json &descriptor : *images) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } mslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect) { auto glslReflectJson = json::parse(glslReflect); HLSLReflectData hlslReflectData; // parse semantics if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { regex p(input[\"name\"].get<string>() + \"\\\\s*:\\\\s*([^;]*);\"); vector<RegexUtil::Match> hlslReflectData = RegexUtil::findAll(p, hlsl); input[\"semantic\"] = hlslReflectData[0].s[1]; } } // get descriptors json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); map<int, json *> descriptors; if (textures) for (auto &desc : *textures) descriptors[desc[\"set\"].get<int>()] = &desc; if (ubos) for (auto &desc : *ubos) descriptors[desc[\"set\"].get<int>()] = &desc; if (ssbos) for (auto &desc : *ssbos) descriptors[desc[\"set\"].get<int>()] = &desc; if (images) for (auto &desc : *images) descriptors[desc[\"set\"].get<int>()] = &desc; // patch descriptor bindings set<int> sets; set<string> samplerTypes = {\"sampler2D\", \"sampler3D\", \"samplerCube\"}; for (const auto &kv : descriptors) { uint32_t set = kv.first; json &desc = *kv.second; while (sets.find(set) != sets.end()) set += 1; desc[\"set\"] = set; sets.insert(set); if (samplerTypes.find(desc[\"type\"]) != samplerTypes.end()) sets.insert(set + 1); } hlslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::genShaderReflectionGLSL(const string &, const string &ext, const string &spv, string &glslMap) { spirv_cross::CompilerReflection compilerReflection( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto reflectOutput = compilerReflection.compile(); glslMap = json::parse(reflectOutput).dump(4); return 0; } int ShaderTools::genShaderReflectionMSL(const string &msl, const string &ext, const string &spv, string &mslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataMSL(glslReflect, ext, msl, mslMap); } int ShaderTools::genShaderReflectionHLSL(const string &hlsl, const string &ext, const string &spv, string &hlslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataHLSL(glslReflect, ext, hlsl, hlslMap); } string ShaderTools::parseReflectionData(const json &reflectData, string ext) { string contents = \"\"; if (ext == \".vert\") { json *inputs = getEntry(reflectData, \"inputs\"); contents += \"INPUT_ATTRIBUTES \" + to_string(inputs->size()) + \"\\n\"; for (const json &input : *inputs) { string inputName = input[\"name\"]; string inputSemantic = \"\"; string inputNameLower = toLower(inputName); inputSemantic = \"UNDEFINED\"; if (input.find(\"semantic\") != input.end()) inputSemantic = input[\"semantic\"]; map<string, string> inputTypeMap = { {\"float\", \"VERTEXFORMAT_FLOAT\"}, {\"vec2\", \"VERTEXFORMAT_FLOAT2\"}, {\"vec3\", \"VERTEXFORMAT_FLOAT3\"}, {\"vec4\", \"VERTEXFORMAT_FLOAT4\"}, {\"ivec2\", \"VERTEXFORMAT_INT2\"}, {\"ivec3\", \"VERTEXFORMAT_INT3\"}, {\"ivec4\", \"VERTEXFORMAT_INT4\"}, {\"mat2\", \"VERTEXFORMAT_MAT2\"}, {\"mat3\", \"VERTEXFORMAT_MAT3\"}, {\"mat4\", \"VERTEXFORMAT_MAT4\"}}; string inputType = inputTypeMap[input[\"type\"]]; contents += \"\\t\" + inputName + \" \" + inputSemantic + \" \" + to_string(input[\"location\"].get<int>()) + \" \" + inputType + \"\\n\"; } } json *textures = getEntry(reflectData, \"textures\"), *ubos = getEntry(reflectData, \"ubos\"), *ssbos = getEntry(reflectData, \"ssbos\"), *images = getEntry(reflectData, \"images\"), *types = getEntry(reflectData, \"types\"); json uniformBufferInfos; json shaderStorageBufferInfos; std::function<void(const json &, json &, uint32_t, string)> parseMembers = [&](const json &membersData, json &members, uint32_t baseOffset = 0, string baseName = \"\") { for (const json &memberData : membersData) { const map<string, int> typeSizeMap = { {\"int\", 4}, {\"uint\", 4}, {\"float\", 4}, {\"vec2\", 8}, {\"vec3\", 12}, {\"vec4\", 16}, {\"ivec2\", 8}, {\"ivec3\", 12}, {\"ivec4\", 16}, {\"uvec2\", 8}, {\"uvec3\", 12}, {\"uvec4\", 16}, {\"mat2\", 16}, {\"mat3\", 36}, {\"mat4\", 64}}; string memberType = memberData[\"type\"]; if (typeSizeMap.find(memberType) != typeSizeMap.end()) { json member = memberData; member[\"name\"] = baseName + member[\"name\"].get<string>(); member[\"size\"] = typeSizeMap.at(memberType); member[\"offset\"] = member[\"offset\"].get<int>() + baseOffset; member[\"array_count\"] = (member.find(\"array\") != member.end()) ? member[\"array\"][0].get<int>() : 0; member[\"array_stride\"] = (member.find(\"array_stride\") != member.end()) ? member[\"array_stride\"].get<int>() : 0; members.push_back(member); } else if (types->find(memberType) != types->end()) { const json &type = (*types)[memberType]; parseMembers(type[\"members\"], members, baseOffset + memberData[\"offset\"].get<int>(), baseName + memberData[\"name\"].get<string>() + \".\"); } else NGFX_ERR(\"unrecognized type: {memberType}\"); } }; auto parseBuffers = [&](const json &buffers, json &bufferInfos) { for (const json &buffer : buffers) { const json &bufferType = (*types)[buffer[\"type\"].get<string>()]; json bufferMembers = {}; parseMembers(bufferType[\"members\"], bufferMembers, 0, \"\"); json bufferInfo = {{\"name\", buffer[\"name\"].get<string>()}, {\"set\", buffer[\"set\"].get<int>()}, {\"binding\", buffer[\"binding\"].get<int>()}, {\"members\", bufferMembers}}; bufferInfos.push_back(bufferInfo); } }; if (ubos) parseBuffers(*ubos, uniformBufferInfos); if (ssbos) parseBuffers(*ssbos, shaderStorageBufferInfos); json textureDescriptors = {}; json bufferDescriptors = {}; if (textures) for (const json &texture : *textures) { textureDescriptors[to_string(texture[\"set\"].get<int>())] = { {\"type\", texture[\"type\"]}, {\"name\", texture[\"name\"]}, {\"set\", texture[\"set\"]}, {\"binding\", texture[\"binding\"]}}; } if (images) for (const json &image : *images) { textureDescriptors[to_string(image[\"set\"].get<int>())] = { {\"type\", image[\"type\"]}, {\"name\", image[\"name\"]}, {\"set\", image[\"set\"]}, {\"binding\", image[\"binding\"]}}; } if (ubos) for (const json &ubo : *ubos) { bufferDescriptors[to_string(ubo[\"set\"].get<int>())] = { {\"type\", \"uniformBuffer\"}, {\"name\", ubo[\"name\"]}, {\"set\", ubo[\"set\"]}, {\"binding\", ubo[\"binding\"]}}; } if (ssbos) for (const json &ssbo : *ssbos) { bufferDescriptors[to_string(ssbo[\"set\"].get<int>())] = { {\"type\", \"shaderStorageBuffer\"}, {\"name\", ssbo[\"name\"]}, {\"set\", ssbo[\"set\"]}, {\"binding\", ssbo[\"binding\"]}}; } contents += \"DESCRIPTORS \" + to_string(textureDescriptors.size() + bufferDescriptors.size()) + \"\\n\"; map<string, string> descriptorTypeMap = { {\"sampler2D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"sampler3D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"samplerCube\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"image2D\", \"DESCRIPTOR_TYPE_STORAGE_IMAGE\"}, {\"uniformBuffer\", \"DESCRIPTOR_TYPE_UNIFORM_BUFFER\"}, {\"shaderStorageBuffer\", \"DESCRIPTOR_TYPE_STORAGE_BUFFER\"}}; for (auto &[key, val] : textureDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } for (auto &[key, val] : bufferDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } auto processBufferInfos = [&](const json &bufferInfo) -> string { string contents = \"\"; const json &memberInfos = bufferInfo[\"members\"]; contents += bufferInfo[\"name\"].get<string>() + \" \" + to_string(bufferInfo[\"set\"].get<int>()) + \" \" + to_string(memberInfos.size()) + \"\\n\"; for (const json &m : memberInfos) { contents += m[\"name\"].get<string>() + \" \" + to_string(m[\"offset\"].get<int>()) + \" \" + to_string(m[\"size\"].get<int>()) + \" \" + to_string(m[\"array_count\"].get<int>()) + \" \" + to_string(m[\"array_stride\"].get<int>()) + \"\\n\"; } return contents; }; contents += \"UNIFORM_BUFFER_INFOS \" + to_string(uniformBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : uniformBufferInfos) { contents += processBufferInfos(bufferInfo); } contents += \"SHADER_STORAGE_BUFFER_INFOS \" + to_string(shaderStorageBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : shaderStorageBufferInfos) { contents += processBufferInfos(bufferInfo); } return contents; } int ShaderTools::generateShaderMapGLSL(const string &file, string outDir, vector<string> &outFiles) { string filename = fs::path(file).filename().string(); string ext = FileUtil::splitExt(filename)[1]; string glslFileName = fs::path(outDir + \"/\" + filename).make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); string glslMapFileName = fs::path(outDir + \"/\" + filename + \".map\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(glslFileName, glslMapFileName)) { outFiles.push_back(glslMapFileName); return 0; } string glsl = \"\", spv = readFile(spvFileName), glslReflect; genShaderReflectionGLSL(glsl, ext, spv, glslReflect); auto glslReflectJson = json::parse(glslReflect); string glslMap = parseReflectionData(glslReflectJson, ext); writeFile(glslMapFileName, glslMap); outFiles.push_back(glslMapFileName); return 0; } int ShaderTools::generateShaderMapMSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string mslFileName = fs::path(outDir + \"/\" + glslFilename + \".metal\") .make_preferred() .string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string mslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".metal.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(mslFileName, mslMapFileName)) { outFiles.push_back(mslMapFileName); return 0; } string msl = readFile(mslFileName), spv = readFile(spvFileName), mslReflect; genShaderReflectionMSL(msl, ext, spv, mslReflect); auto mslReflectJson = json::parse(mslReflect); string mslMap = parseReflectionData(mslReflectJson, ext); writeFile(mslMapFileName, mslMap); outFiles.push_back(mslMapFileName); return 0; } int ShaderTools::generateShaderMapHLSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string hlslFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl\").make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string hlslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(hlslFileName, hlslMapFileName)) { outFiles.push_back(hlslMapFileName); return 0; } string hlsl = readFile(hlslFileName), spv = readFile(spvFileName), hlslReflect; genShaderReflectionHLSL(hlsl, ext, spv, hlslReflect); auto hlslReflectJson = json::parse(hlslReflect); string hlslMap = parseReflectionData(hlslReflectJson, ext); writeFile(hlslMapFileName, hlslMap); outFiles.push_back(hlslMapFileName); return 0; } vector<string> ShaderTools::convertShaders(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) convertShader(file, \"\", outDir, fmt, outFiles); return outFiles; } vector<string> ShaderTools::compileShaders(const vector<string> &files, string outDir, Format fmt, const MacroDefinitions &defines, int flags) { #ifdef GRAPHICS_BACKEND_VULKAN defines += \" -DGRAPHICS_BACKEND_VULKAN=1\"; #endif vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) compileShaderGLSL(file, defines, outDir, outFiles, flags); else if (fmt == FORMAT_MSL) compileShaderMSL(file, defines, outDir, outFiles); else if (fmt == FORMAT_HLSL) compileShaderHLSL(file, defines, outDir, outFiles); } return outFiles; } void ShaderTools::applyPatches(const vector<string> &patchFiles, string outDir) { for (const string &patchFile : patchFiles) { string filename = FileUtil::splitExt(fs::path(patchFile).string())[0]; NGFX_LOG(\"filename: %s\", filename.c_str()); string outFile = fs::path(outDir + \"/\" + filename).make_preferred().string(); if (fs::exists(outFile)) { NGFX_LOG(\"applying patch: {patchFile}\"); string cmdStr = PATCH + \" -N -u \" + outFile + \" -i \" + patchFile; cmd(cmdStr); } } } vector<string> ShaderTools::generateShaderMaps(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) generateShaderMapGLSL(file, outDir, outFiles); else if (fmt == FORMAT_MSL) generateShaderMapMSL(file, outDir, outFiles); else if (fmt == FORMAT_HLSL) generateShaderMapHLSL(file, outDir, outFiles); } return outFiles; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/ShaderTools.cpp"},{"location":"api/Files/ShaderTools_8cpp/#srcngfxgraphicsshadertoolscpp","text":"","title":"src/ngfx/graphics/ShaderTools.cpp"},{"location":"api/Files/ShaderTools_8cpp/#functions","text":"Name string getEnv (const string & name) json * getEntry (const json & data, const string & key) shaderc_shader_kind toShaderKind (const string & ext)","title":"Functions"},{"location":"api/Files/ShaderTools_8cpp/#attributes","text":"Name auto readFile auto writeFile auto toLower","title":"Attributes"},{"location":"api/Files/ShaderTools_8cpp/#defines","text":"Name V (func) PATCH","title":"Defines"},{"location":"api/Files/ShaderTools_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/ShaderTools_8cpp/#function-getenv","text":"static string getEnv( const string & name )","title":"function getEnv"},{"location":"api/Files/ShaderTools_8cpp/#function-getentry","text":"static json * getEntry( const json & data, const string & key )","title":"function getEntry"},{"location":"api/Files/ShaderTools_8cpp/#function-toshaderkind","text":"static shaderc_shader_kind toShaderKind( const string & ext )","title":"function toShaderKind"},{"location":"api/Files/ShaderTools_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/ShaderTools_8cpp/#variable-readfile","text":"auto readFile = FileUtil::readFile;","title":"variable readFile"},{"location":"api/Files/ShaderTools_8cpp/#variable-writefile","text":"auto writeFile = FileUtil::writeFile;","title":"variable writeFile"},{"location":"api/Files/ShaderTools_8cpp/#variable-tolower","text":"auto toLower = StringUtil::toLower;","title":"variable toLower"},{"location":"api/Files/ShaderTools_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/ShaderTools_8cpp/#define-v","text":"#define V( func ) { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ }","title":"define V"},{"location":"api/Files/ShaderTools_8cpp/#define-patch","text":"#define PATCH string(\"patch\")","title":"define PATCH"},{"location":"api/Files/ShaderTools_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ShaderTools.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/FileUtil.h\" #include \"ngfx/core/StringUtil.h\" #include <cctype> #include <filesystem> #include <fstream> #include <regex> #include <set> #include <spirv_cross/spirv_glsl.hpp> #include <spirv_cross/spirv_hlsl.hpp> #include <spirv_cross/spirv_msl.hpp> #include <spirv_cross/spirv_reflect.hpp> #include <sstream> using namespace std; using namespace ngfx; auto readFile = FileUtil::readFile; auto writeFile = FileUtil::writeFile; auto toLower = StringUtil::toLower; namespace fs = std::filesystem; #define V(func) \\ { \\ ret = func; \\ if (ret != 0) \\ return ret; \\ } #ifdef _WIN32 #define PATCH string(\"patch.exe\") #else #define PATCH string(\"patch\") #endif static string getEnv(const string &name) { char *value = getenv(name.c_str()); return (value ? value : \"\"); } static json *getEntry(const json &data, const string &key) { auto it = data.find(key); if (it == data.end()) return nullptr; return (json *)&it.value(); } ShaderTools::ShaderTools(bool verbose) : verbose(verbose) { defaultIncludePaths = {\"ngfx/data/shaders\", \"nodegl/data/shaders\"}; } int ShaderTools::cmd(string str) { if (verbose) { NGFX_LOG(\">> %s\", str.c_str()); } else str += \" >> /dev/null 2>&1\"; return system(str.c_str()); } bool ShaderTools::findIncludeFile(const string &includeFilename, const vector<string> &includePaths, string &includeFile) { for (const string &includePath : includePaths) { fs::path filename = includePath / fs::path(includeFilename); if (fs::exists(filename)) { includeFile = filename.string(); return true; } } return false; } int ShaderTools::preprocess(const string &src, const string &dataPath, string &dst) { dst = \"\"; vector<string> includePaths = defaultIncludePaths; includePaths.push_back(dataPath); istringstream sstream(src); string line; while (std::getline(sstream, line)) { smatch matchIncludeGroups; bool matchInclude = regex_search(line, matchIncludeGroups, regex(\"#include \\\"([^\\\"]*)\")); if (matchInclude) { string includeFilename = matchIncludeGroups[1]; string includeFilePath; findIncludeFile(includeFilename, includePaths, includeFilePath); dst += readFile(includeFilePath); } else { dst += line + \"\\n\"; } } return 0; } int ShaderTools::compileShaderGLSL( const string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, string &spv, bool verbose, shaderc_optimization_level optimizationLevel) { shaderc::Compiler compiler; shaderc::CompileOptions compileOptions; for (const MacroDefinition &define : defines) { compileOptions.AddMacroDefinition(define.name, define.value); } compileOptions.SetOptimizationLevel(optimizationLevel); compileOptions.SetGenerateDebugInfo(); auto result = compiler.CompileGlslToSpv(src, shaderKind, \"\", compileOptions); if (result.GetCompilationStatus() != shaderc_compilation_status_success) { NGFX_ERR(\"cannot compile file: %s\", result.GetErrorMessage().c_str()); return 1; } spv = string((const char *)result.cbegin(), sizeof(uint32_t) * (result.cend() - result.cbegin())); return 0; } int ShaderTools::removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst) { int ret = 0; string spv; V(compileShaderGLSL(src, shaderKind, defines, spv, false)); auto compilerGLSL = make_unique<spirv_cross::CompilerGLSL>( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto activeVariables = compilerGLSL->get_active_interface_variables(); compilerGLSL->get_shader_resources(activeVariables); compilerGLSL->set_enabled_interface_variables(move(activeVariables)); spirv_cross::CompilerGLSL::Options opts; opts.vulkan_semantics = true; compilerGLSL->set_common_options(opts); dst = compilerGLSL->compile(); return 0; } int ShaderTools::patchShaderLayoutsGLSL(const string &src, string &dst) { dst = \"\"; istringstream sstream(src); string line; while (std::getline(sstream, line)) { // Patch GLSL shader layouts smatch g; bool matchLayout = regex_search(line, g, regex(\"^(.*)\" \"layout\\\\s*\\\\(\" \"([^)]*)\" \"binding[\\\\s]*=[\\\\s]*\" \"([\\\\d]+)\" \"([^)]*)\" \"\\\\)\" \"(.*)\\r*$\")); if (matchLayout) { dst += g[1].str() + \"layout(\" + g[2].str() + \"set = \" + g[3].str() + \", binding = 0\" + g[4].str() + \")\" + g[5].str() + \"\\n\"; } else { dst += line + \"\\n\"; } } return 0; } static shaderc_shader_kind toShaderKind(const string &ext) { static const map<string, shaderc_shader_kind> shaderKindMap = { {\".vert\", shaderc_vertex_shader}, {\".frag\", shaderc_fragment_shader}, {\".comp\", shaderc_compute_shader}}; return shaderKindMap.at(ext); } int ShaderTools::compileShaderGLSL(string filename, const MacroDefinitions &defines, const string &outDir, vector<string> &outFiles, int flags) { string parentPath = fs::path(filename).parent_path().string(); filename = fs::path(filename).filename().string(); string inFileName = fs::path(parentPath + \"/\" + filename).make_preferred().string(); string outFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string src, dst; int ret = 0; src = FileUtil::readFile(inFileName); string ext = FileUtil::splitExt(inFileName)[1]; shaderc_shader_kind shaderKind = toShaderKind(ext); if (flags & REMOVE_UNUSED_VARIABLES) { V(removeUnusedVariablesGLSL(src, shaderKind, defines, dst)); src = move(dst); } if (flags & PATCH_SHADER_LAYOUTS_GLSL) { V(patchShaderLayoutsGLSL(src, dst)); src = move(dst); } V(compileShaderGLSL(src, shaderKind, defines, dst)); writeFile(outFileName, dst); outFiles.push_back(outFileName); return 0; } int ShaderTools::compileShaderMSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".metal\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".metallib\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string debugFlags = \"-gline-tables-only -MO\"; int result = cmd(\"xcrun -sdk macosx metal \" + debugFlags + \" -c \" + inFileName + \" -o \" + outDir + \"/\" + strippedFilename + \".air && \" \"xcrun -sdk macosx metallib \" + outDir + \"/\" + strippedFilename + \".air -o \" + outFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::compileShaderHLSL(const string &file, const MacroDefinitions &defines, string outDir, vector<string> &outFiles) { string strippedFilename = FileUtil::splitExt(fs::path(file).filename().string())[0]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".hlsl\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + \".dxc\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string shaderModel = \"\"; if (strstr(inFileName.c_str(), \".vert\")) shaderModel = \"vs_5_0\"; else if (strstr(inFileName.c_str(), \".frag\")) shaderModel = \"ps_5_0\"; else if (strstr(inFileName.c_str(), \".comp\")) shaderModel = \"cs_5_0\"; int result = cmd(\"dxc.exe /T \" + shaderModel + \" /Fo \" + outFileName + \" \" + inFileName); if (result == 0) NGFX_LOG(\"compiled file: %s\", file.c_str()); else NGFX_ERR(\"cannot compile file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } int ShaderTools::convertSPVToMSL(const string &spv, shaderc_shader_kind shaderKind, string &msl) { auto compilerMSL = make_unique<spirv_cross::CompilerMSL>( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); msl = compilerMSL->compile(); return 0; } int ShaderTools::convertSPVToHLSL(const string &spv, shaderc_shader_kind shaderKind, string &hlsl, uint32_t shaderModel) { auto compilerHLSL = make_unique<spirv_cross::CompilerHLSL>( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto options = compilerHLSL->get_hlsl_options(); options.shader_model = shaderModel; compilerHLSL->set_hlsl_options(options); hlsl = compilerHLSL->compile(); return 0; } int ShaderTools::convertShader(const string &file, const string &extraArgs, string outDir, Format fmt, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string strippedFilename = splitFilename[0]; string ext = FileUtil::splitExt(strippedFilename)[1]; string inFileName = fs::path(outDir + \"/\" + strippedFilename + \".spv\") .make_preferred() .string(); string outFileName = fs::path(outDir + \"/\" + strippedFilename + (fmt == FORMAT_MSL ? \".metal\" : \".hlsl\")) .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) { outFiles.push_back(outFileName); return 0; } string spv = FileUtil::readFile(inFileName), dst; int result; if (fmt == FORMAT_MSL) { result = convertSPVToMSL(spv, toShaderKind(ext), dst); } else { result = convertSPVToHLSL(spv, toShaderKind(ext), dst); } FileUtil::writeFile(outFileName, dst); string args = (fmt == FORMAT_MSL ? \"--msl\" : \"--hlsl --shader-model 60\") + extraArgs; if (result == 0) NGFX_LOG(\"converted file: %s to %s\", inFileName.c_str(), outFileName.c_str()); else NGFX_ERR(\"cannot convert file: %s\", file.c_str()); outFiles.push_back(outFileName); return result; } bool ShaderTools::findMetalReflectData( const vector<RegexUtil::Match> &metalReflectData, const string &name, RegexUtil::Match &match) { for (const RegexUtil::Match &data : metalReflectData) { if (data.s[2] == name) { match = data; return true; } else if (strstr(data.s[1].c_str(), name.c_str())) { match = data; return true; } } return false; } int ShaderTools::patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect) { auto glslReflectJson = json::parse(glslReflect); MetalReflectData metalReflectData; if (ext == \".vert\") { metalReflectData.attributes = RegexUtil::findAll(regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[\" \"attribute\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); } metalReflectData.buffers = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[buffer\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); metalReflectData.textures = RegexUtil::findAll( regex(\"([^\\\\s]*)[\\\\s]*([^\\\\s]*)[\\\\s]*\\\\[\\\\[texture\\\\(([0-9]+)\\\\)\\\\]\\\\]\"), msl); json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); uint32_t numDescriptors = (textures ? textures->size() : 0) + (images ? images->size() : 0) + (ubos ? ubos->size() : 0) + (ssbos ? ssbos->size() : 0); // update input bindings if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { RegexUtil::Match metalInputReflectData; bool foundMatch = findMetalReflectData( metalReflectData.attributes, input[\"name\"], metalInputReflectData); if (!foundMatch) { return 1; } input[\"location\"] = stoi(metalInputReflectData.s[3]) + numDescriptors; } } // update descriptor bindings if (textures) for (json &descriptor : *textures) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } if (ubos) for (json &descriptor : *ubos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (ssbos) for (json &descriptor : *ssbos) { RegexUtil::Match metalBufferReflectData; bool foundMatch = findMetalReflectData( metalReflectData.buffers, descriptor[\"name\"], metalBufferReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalBufferReflectData.s[3]); } if (images) for (json &descriptor : *images) { RegexUtil::Match metalTextureReflectData; bool foundMatch = findMetalReflectData(metalReflectData.textures, descriptor[\"name\"], metalTextureReflectData); assert(foundMatch); descriptor[\"set\"] = stoi(metalTextureReflectData.s[3]); } mslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect) { auto glslReflectJson = json::parse(glslReflect); HLSLReflectData hlslReflectData; // parse semantics if (ext == \".vert\") { json *inputs = getEntry(glslReflectJson, \"inputs\"); for (json &input : *inputs) { regex p(input[\"name\"].get<string>() + \"\\\\s*:\\\\s*([^;]*);\"); vector<RegexUtil::Match> hlslReflectData = RegexUtil::findAll(p, hlsl); input[\"semantic\"] = hlslReflectData[0].s[1]; } } // get descriptors json *textures = getEntry(glslReflectJson, \"textures\"), *ubos = getEntry(glslReflectJson, \"ubos\"), *ssbos = getEntry(glslReflectJson, \"ssbos\"), *images = getEntry(glslReflectJson, \"images\"); map<int, json *> descriptors; if (textures) for (auto &desc : *textures) descriptors[desc[\"set\"].get<int>()] = &desc; if (ubos) for (auto &desc : *ubos) descriptors[desc[\"set\"].get<int>()] = &desc; if (ssbos) for (auto &desc : *ssbos) descriptors[desc[\"set\"].get<int>()] = &desc; if (images) for (auto &desc : *images) descriptors[desc[\"set\"].get<int>()] = &desc; // patch descriptor bindings set<int> sets; set<string> samplerTypes = {\"sampler2D\", \"sampler3D\", \"samplerCube\"}; for (const auto &kv : descriptors) { uint32_t set = kv.first; json &desc = *kv.second; while (sets.find(set) != sets.end()) set += 1; desc[\"set\"] = set; sets.insert(set); if (samplerTypes.find(desc[\"type\"]) != samplerTypes.end()) sets.insert(set + 1); } hlslReflect = glslReflectJson.dump(4); return 0; } int ShaderTools::genShaderReflectionGLSL(const string &, const string &ext, const string &spv, string &glslMap) { spirv_cross::CompilerReflection compilerReflection( (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t)); auto reflectOutput = compilerReflection.compile(); glslMap = json::parse(reflectOutput).dump(4); return 0; } int ShaderTools::genShaderReflectionMSL(const string &msl, const string &ext, const string &spv, string &mslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataMSL(glslReflect, ext, msl, mslMap); } int ShaderTools::genShaderReflectionHLSL(const string &hlsl, const string &ext, const string &spv, string &hlslMap) { string glslReflect; genShaderReflectionGLSL(\"\", ext, spv, glslReflect); return patchShaderReflectionDataHLSL(glslReflect, ext, hlsl, hlslMap); } string ShaderTools::parseReflectionData(const json &reflectData, string ext) { string contents = \"\"; if (ext == \".vert\") { json *inputs = getEntry(reflectData, \"inputs\"); contents += \"INPUT_ATTRIBUTES \" + to_string(inputs->size()) + \"\\n\"; for (const json &input : *inputs) { string inputName = input[\"name\"]; string inputSemantic = \"\"; string inputNameLower = toLower(inputName); inputSemantic = \"UNDEFINED\"; if (input.find(\"semantic\") != input.end()) inputSemantic = input[\"semantic\"]; map<string, string> inputTypeMap = { {\"float\", \"VERTEXFORMAT_FLOAT\"}, {\"vec2\", \"VERTEXFORMAT_FLOAT2\"}, {\"vec3\", \"VERTEXFORMAT_FLOAT3\"}, {\"vec4\", \"VERTEXFORMAT_FLOAT4\"}, {\"ivec2\", \"VERTEXFORMAT_INT2\"}, {\"ivec3\", \"VERTEXFORMAT_INT3\"}, {\"ivec4\", \"VERTEXFORMAT_INT4\"}, {\"mat2\", \"VERTEXFORMAT_MAT2\"}, {\"mat3\", \"VERTEXFORMAT_MAT3\"}, {\"mat4\", \"VERTEXFORMAT_MAT4\"}}; string inputType = inputTypeMap[input[\"type\"]]; contents += \"\\t\" + inputName + \" \" + inputSemantic + \" \" + to_string(input[\"location\"].get<int>()) + \" \" + inputType + \"\\n\"; } } json *textures = getEntry(reflectData, \"textures\"), *ubos = getEntry(reflectData, \"ubos\"), *ssbos = getEntry(reflectData, \"ssbos\"), *images = getEntry(reflectData, \"images\"), *types = getEntry(reflectData, \"types\"); json uniformBufferInfos; json shaderStorageBufferInfos; std::function<void(const json &, json &, uint32_t, string)> parseMembers = [&](const json &membersData, json &members, uint32_t baseOffset = 0, string baseName = \"\") { for (const json &memberData : membersData) { const map<string, int> typeSizeMap = { {\"int\", 4}, {\"uint\", 4}, {\"float\", 4}, {\"vec2\", 8}, {\"vec3\", 12}, {\"vec4\", 16}, {\"ivec2\", 8}, {\"ivec3\", 12}, {\"ivec4\", 16}, {\"uvec2\", 8}, {\"uvec3\", 12}, {\"uvec4\", 16}, {\"mat2\", 16}, {\"mat3\", 36}, {\"mat4\", 64}}; string memberType = memberData[\"type\"]; if (typeSizeMap.find(memberType) != typeSizeMap.end()) { json member = memberData; member[\"name\"] = baseName + member[\"name\"].get<string>(); member[\"size\"] = typeSizeMap.at(memberType); member[\"offset\"] = member[\"offset\"].get<int>() + baseOffset; member[\"array_count\"] = (member.find(\"array\") != member.end()) ? member[\"array\"][0].get<int>() : 0; member[\"array_stride\"] = (member.find(\"array_stride\") != member.end()) ? member[\"array_stride\"].get<int>() : 0; members.push_back(member); } else if (types->find(memberType) != types->end()) { const json &type = (*types)[memberType]; parseMembers(type[\"members\"], members, baseOffset + memberData[\"offset\"].get<int>(), baseName + memberData[\"name\"].get<string>() + \".\"); } else NGFX_ERR(\"unrecognized type: {memberType}\"); } }; auto parseBuffers = [&](const json &buffers, json &bufferInfos) { for (const json &buffer : buffers) { const json &bufferType = (*types)[buffer[\"type\"].get<string>()]; json bufferMembers = {}; parseMembers(bufferType[\"members\"], bufferMembers, 0, \"\"); json bufferInfo = {{\"name\", buffer[\"name\"].get<string>()}, {\"set\", buffer[\"set\"].get<int>()}, {\"binding\", buffer[\"binding\"].get<int>()}, {\"members\", bufferMembers}}; bufferInfos.push_back(bufferInfo); } }; if (ubos) parseBuffers(*ubos, uniformBufferInfos); if (ssbos) parseBuffers(*ssbos, shaderStorageBufferInfos); json textureDescriptors = {}; json bufferDescriptors = {}; if (textures) for (const json &texture : *textures) { textureDescriptors[to_string(texture[\"set\"].get<int>())] = { {\"type\", texture[\"type\"]}, {\"name\", texture[\"name\"]}, {\"set\", texture[\"set\"]}, {\"binding\", texture[\"binding\"]}}; } if (images) for (const json &image : *images) { textureDescriptors[to_string(image[\"set\"].get<int>())] = { {\"type\", image[\"type\"]}, {\"name\", image[\"name\"]}, {\"set\", image[\"set\"]}, {\"binding\", image[\"binding\"]}}; } if (ubos) for (const json &ubo : *ubos) { bufferDescriptors[to_string(ubo[\"set\"].get<int>())] = { {\"type\", \"uniformBuffer\"}, {\"name\", ubo[\"name\"]}, {\"set\", ubo[\"set\"]}, {\"binding\", ubo[\"binding\"]}}; } if (ssbos) for (const json &ssbo : *ssbos) { bufferDescriptors[to_string(ssbo[\"set\"].get<int>())] = { {\"type\", \"shaderStorageBuffer\"}, {\"name\", ssbo[\"name\"]}, {\"set\", ssbo[\"set\"]}, {\"binding\", ssbo[\"binding\"]}}; } contents += \"DESCRIPTORS \" + to_string(textureDescriptors.size() + bufferDescriptors.size()) + \"\\n\"; map<string, string> descriptorTypeMap = { {\"sampler2D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"sampler3D\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"samplerCube\", \"DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\"}, {\"image2D\", \"DESCRIPTOR_TYPE_STORAGE_IMAGE\"}, {\"uniformBuffer\", \"DESCRIPTOR_TYPE_UNIFORM_BUFFER\"}, {\"shaderStorageBuffer\", \"DESCRIPTOR_TYPE_STORAGE_BUFFER\"}}; for (auto &[key, val] : textureDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } for (auto &[key, val] : bufferDescriptors.items()) { string descriptorType = descriptorTypeMap[val[\"type\"]]; contents += \"\\t\" + val[\"name\"].get<string>() + \" \" + descriptorType + \" \" + to_string(val[\"set\"].get<int>()) + \"\\n\"; } auto processBufferInfos = [&](const json &bufferInfo) -> string { string contents = \"\"; const json &memberInfos = bufferInfo[\"members\"]; contents += bufferInfo[\"name\"].get<string>() + \" \" + to_string(bufferInfo[\"set\"].get<int>()) + \" \" + to_string(memberInfos.size()) + \"\\n\"; for (const json &m : memberInfos) { contents += m[\"name\"].get<string>() + \" \" + to_string(m[\"offset\"].get<int>()) + \" \" + to_string(m[\"size\"].get<int>()) + \" \" + to_string(m[\"array_count\"].get<int>()) + \" \" + to_string(m[\"array_stride\"].get<int>()) + \"\\n\"; } return contents; }; contents += \"UNIFORM_BUFFER_INFOS \" + to_string(uniformBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : uniformBufferInfos) { contents += processBufferInfos(bufferInfo); } contents += \"SHADER_STORAGE_BUFFER_INFOS \" + to_string(shaderStorageBufferInfos.size()) + \"\\n\"; for (const json &bufferInfo : shaderStorageBufferInfos) { contents += processBufferInfos(bufferInfo); } return contents; } int ShaderTools::generateShaderMapGLSL(const string &file, string outDir, vector<string> &outFiles) { string filename = fs::path(file).filename().string(); string ext = FileUtil::splitExt(filename)[1]; string glslFileName = fs::path(outDir + \"/\" + filename).make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + filename + \".spv\").make_preferred().string(); string glslMapFileName = fs::path(outDir + \"/\" + filename + \".map\").make_preferred().string(); if (!FileUtil::srcFileNewerThanOutFile(glslFileName, glslMapFileName)) { outFiles.push_back(glslMapFileName); return 0; } string glsl = \"\", spv = readFile(spvFileName), glslReflect; genShaderReflectionGLSL(glsl, ext, spv, glslReflect); auto glslReflectJson = json::parse(glslReflect); string glslMap = parseReflectionData(glslReflectJson, ext); writeFile(glslMapFileName, glslMap); outFiles.push_back(glslMapFileName); return 0; } int ShaderTools::generateShaderMapMSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string mslFileName = fs::path(outDir + \"/\" + glslFilename + \".metal\") .make_preferred() .string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string mslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".metal.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(mslFileName, mslMapFileName)) { outFiles.push_back(mslMapFileName); return 0; } string msl = readFile(mslFileName), spv = readFile(spvFileName), mslReflect; genShaderReflectionMSL(msl, ext, spv, mslReflect); auto mslReflectJson = json::parse(mslReflect); string mslMap = parseReflectionData(mslReflectJson, ext); writeFile(mslMapFileName, mslMap); outFiles.push_back(mslMapFileName); return 0; } int ShaderTools::generateShaderMapHLSL(const string &file, string outDir, vector<string> &outFiles) { auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string()); string glslFilename = splitFilename[0]; string ext = FileUtil::splitExt(splitFilename[0])[1]; string hlslFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl\").make_preferred().string(); string spvFileName = fs::path(outDir + \"/\" + glslFilename + \".spv\").make_preferred().string(); string hlslMapFileName = fs::path(outDir + \"/\" + glslFilename + \".hlsl.map\") .make_preferred() .string(); if (!FileUtil::srcFileNewerThanOutFile(hlslFileName, hlslMapFileName)) { outFiles.push_back(hlslMapFileName); return 0; } string hlsl = readFile(hlslFileName), spv = readFile(spvFileName), hlslReflect; genShaderReflectionHLSL(hlsl, ext, spv, hlslReflect); auto hlslReflectJson = json::parse(hlslReflect); string hlslMap = parseReflectionData(hlslReflectJson, ext); writeFile(hlslMapFileName, hlslMap); outFiles.push_back(hlslMapFileName); return 0; } vector<string> ShaderTools::convertShaders(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) convertShader(file, \"\", outDir, fmt, outFiles); return outFiles; } vector<string> ShaderTools::compileShaders(const vector<string> &files, string outDir, Format fmt, const MacroDefinitions &defines, int flags) { #ifdef GRAPHICS_BACKEND_VULKAN defines += \" -DGRAPHICS_BACKEND_VULKAN=1\"; #endif vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) compileShaderGLSL(file, defines, outDir, outFiles, flags); else if (fmt == FORMAT_MSL) compileShaderMSL(file, defines, outDir, outFiles); else if (fmt == FORMAT_HLSL) compileShaderHLSL(file, defines, outDir, outFiles); } return outFiles; } void ShaderTools::applyPatches(const vector<string> &patchFiles, string outDir) { for (const string &patchFile : patchFiles) { string filename = FileUtil::splitExt(fs::path(patchFile).string())[0]; NGFX_LOG(\"filename: %s\", filename.c_str()); string outFile = fs::path(outDir + \"/\" + filename).make_preferred().string(); if (fs::exists(outFile)) { NGFX_LOG(\"applying patch: {patchFile}\"); string cmdStr = PATCH + \" -N -u \" + outFile + \" -i \" + patchFile; cmd(cmdStr); } } } vector<string> ShaderTools::generateShaderMaps(const vector<string> &files, string outDir, Format fmt) { vector<string> outFiles; for (const string &file : files) { if (fmt == FORMAT_GLSL) generateShaderMapGLSL(file, outDir, outFiles); else if (fmt == FORMAT_MSL) generateShaderMapMSL(file, outDir, outFiles); else if (fmt == FORMAT_HLSL) generateShaderMapHLSL(file, outDir, outFiles); } return outFiles; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ShaderTools_8h/","text":"src/ngfx/graphics/ShaderTools.h Namespaces Name ngfx Classes Name class ngfx::ShaderTools struct ngfx::ShaderTools::MacroDefinition Types Name using nlohmann::json json Types Documentation using json using json = nlohmann::json; Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/regex/RegexUtil.h\" #include <ctime> #include <json.hpp> #include <map> #include <regex> #include <shaderc/shaderc.hpp> #include <string> #include <vector> using json = nlohmann::json; namespace ngfx { class ShaderTools { public: ShaderTools(bool verbose = false); enum { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2 }; enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL }; struct MacroDefinition { std::string name, value; }; typedef std::vector<MacroDefinition> MacroDefinitions; std::vector<std::string> compileShaders(const std::vector<std::string> &files, std::string outDir, Format fmt = FORMAT_GLSL, const MacroDefinitions &defines = {}, int flags = 0); std::vector<std::string> convertShaders(const std::vector<std::string> &files, std::string outDir, Format fmt); std::vector<std::string> generateShaderMaps(const std::vector<std::string> &files, std::string outDir, Format fmt); private: void applyPatches(const std::vector<std::string> &patchFiles, std::string outDir); int cmd(std::string str); int compileShaderGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &spv, bool verbose = true, shaderc_optimization_level optimizationLevel = shaderc_optimization_level_performance); int compileShaderGLSL(std::string filename, const MacroDefinitions &defines, const std::string &outDir, std::vector<std::string> &outFiles, int flags = 0); int compileShaderHLSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int compileShaderMSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int convertSPVToHLSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &hlsl, uint32_t shaderModel = 60); int convertSPVToMSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &msl); int convertShader(const std::string &file, const std::string &extraArgs, std::string outDir, Format fmt, std::vector<std::string> &outFiles); bool findIncludeFile(const std::string &includeFilename, const std::vector<std::string> &includePaths, std::string &includeFile); struct MetalReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; struct HLSLReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; bool findMetalReflectData(const std::vector<RegexUtil::Match> &metalReflectData, const std::string &name, RegexUtil::Match &match); int genShaderReflectionGLSL(const std::string &glsl, const std::string &ext, const std::string &spv, std::string &glslMap); int genShaderReflectionHLSL(const std::string &hlsl, const std::string &ext, const std::string &spv, std::string &hlslMap); int genShaderReflectionMSL(const std::string &msl, const std::string &ext, const std::string &spv, std::string &mslMap); int generateShaderMapGLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapHLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapMSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); std::string parseReflectionData(const json &reflectData, std::string ext); int patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect); int patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect); int patchShaderLayoutsGLSL(const std::string &src, std::string &dst); int preprocess(const std::string &src, const std::string &dataPath, std::string &dst); int removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst); bool verbose = false; std::vector<std::string> defaultIncludePaths; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/ShaderTools.h"},{"location":"api/Files/ShaderTools_8h/#srcngfxgraphicsshadertoolsh","text":"","title":"src/ngfx/graphics/ShaderTools.h"},{"location":"api/Files/ShaderTools_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/ShaderTools_8h/#classes","text":"Name class ngfx::ShaderTools struct ngfx::ShaderTools::MacroDefinition","title":"Classes"},{"location":"api/Files/ShaderTools_8h/#types","text":"Name using nlohmann::json json","title":"Types"},{"location":"api/Files/ShaderTools_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Files/ShaderTools_8h/#using-json","text":"using json = nlohmann::json;","title":"using json"},{"location":"api/Files/ShaderTools_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/regex/RegexUtil.h\" #include <ctime> #include <json.hpp> #include <map> #include <regex> #include <shaderc/shaderc.hpp> #include <string> #include <vector> using json = nlohmann::json; namespace ngfx { class ShaderTools { public: ShaderTools(bool verbose = false); enum { PATCH_SHADER_LAYOUTS_GLSL = 1, REMOVE_UNUSED_VARIABLES = 2 }; enum Format { FORMAT_GLSL, FORMAT_HLSL, FORMAT_MSL }; struct MacroDefinition { std::string name, value; }; typedef std::vector<MacroDefinition> MacroDefinitions; std::vector<std::string> compileShaders(const std::vector<std::string> &files, std::string outDir, Format fmt = FORMAT_GLSL, const MacroDefinitions &defines = {}, int flags = 0); std::vector<std::string> convertShaders(const std::vector<std::string> &files, std::string outDir, Format fmt); std::vector<std::string> generateShaderMaps(const std::vector<std::string> &files, std::string outDir, Format fmt); private: void applyPatches(const std::vector<std::string> &patchFiles, std::string outDir); int cmd(std::string str); int compileShaderGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &spv, bool verbose = true, shaderc_optimization_level optimizationLevel = shaderc_optimization_level_performance); int compileShaderGLSL(std::string filename, const MacroDefinitions &defines, const std::string &outDir, std::vector<std::string> &outFiles, int flags = 0); int compileShaderHLSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int compileShaderMSL(const std::string &file, const MacroDefinitions &defines, std::string outDir, std::vector<std::string> &outFiles); int convertSPVToHLSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &hlsl, uint32_t shaderModel = 60); int convertSPVToMSL(const std::string &spv, shaderc_shader_kind shaderKind, std::string &msl); int convertShader(const std::string &file, const std::string &extraArgs, std::string outDir, Format fmt, std::vector<std::string> &outFiles); bool findIncludeFile(const std::string &includeFilename, const std::vector<std::string> &includePaths, std::string &includeFile); struct MetalReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; struct HLSLReflectData { std::vector<RegexUtil::Match> attributes, buffers, textures; }; bool findMetalReflectData(const std::vector<RegexUtil::Match> &metalReflectData, const std::string &name, RegexUtil::Match &match); int genShaderReflectionGLSL(const std::string &glsl, const std::string &ext, const std::string &spv, std::string &glslMap); int genShaderReflectionHLSL(const std::string &hlsl, const std::string &ext, const std::string &spv, std::string &hlslMap); int genShaderReflectionMSL(const std::string &msl, const std::string &ext, const std::string &spv, std::string &mslMap); int generateShaderMapGLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapHLSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); int generateShaderMapMSL(const std::string &file, std::string outDir, std::vector<std::string> &outFiles); std::string parseReflectionData(const json &reflectData, std::string ext); int patchShaderReflectionDataMSL(const std::string &glslReflect, const std::string &ext, const std::string &msl, std::string &mslReflect); int patchShaderReflectionDataHLSL(const std::string &glslReflect, const std::string &ext, const std::string &hlsl, std::string &hlslReflect); int patchShaderLayoutsGLSL(const std::string &src, std::string &dst); int preprocess(const std::string &src, const std::string &dataPath, std::string &dst); int removeUnusedVariablesGLSL(const std::string &src, shaderc_shader_kind shaderKind, const MacroDefinitions &defines, std::string &dst); bool verbose = false; std::vector<std::string> defaultIncludePaths; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/StringUtil_8cpp/","text":"src/ngfx/core/StringUtil.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/StringUtil.h\" #include <codecvt> #include <locale> #include <string> using namespace std; using namespace ngfx; string StringUtil::toLower(const string &str) { string r = str; for (uint32_t j = 0; j < r.size(); j++) r[j] = tolower(r[j]); return r; } std::wstring StringUtil::toWString(const std::string &str) { std::wstring target; std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter; return converter.from_bytes(str); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/StringUtil.cpp"},{"location":"api/Files/StringUtil_8cpp/#srcngfxcorestringutilcpp","text":"","title":"src/ngfx/core/StringUtil.cpp"},{"location":"api/Files/StringUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/StringUtil.h\" #include <codecvt> #include <locale> #include <string> using namespace std; using namespace ngfx; string StringUtil::toLower(const string &str) { string r = str; for (uint32_t j = 0; j < r.size(); j++) r[j] = tolower(r[j]); return r; } std::wstring StringUtil::toWString(const std::string &str) { std::wstring target; std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter; return converter.from_bytes(str); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/StringUtil_8h/","text":"src/ngfx/core/StringUtil.h Namespaces Name ngfx Classes Name class ngfx::StringUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> namespace ngfx { class StringUtil { public: static std::string toLower(const std::string &str); static std::wstring toWString(const std::string &str); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/StringUtil.h"},{"location":"api/Files/StringUtil_8h/#srcngfxcorestringutilh","text":"","title":"src/ngfx/core/StringUtil.h"},{"location":"api/Files/StringUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/StringUtil_8h/#classes","text":"Name class ngfx::StringUtil","title":"Classes"},{"location":"api/Files/StringUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> namespace ngfx { class StringUtil { public: static std::string toLower(const std::string &str); static std::wstring toWString(const std::string &str); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Surface_8h/","text":"src/ngfx/graphics/Surface.h Namespaces Name ngfx Classes Name class ngfx::Surface Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> namespace ngfx { class Surface { public: Surface() {} Surface(uint32_t w, uint32_t h, bool offscreen = false) : w(w), h(h), offscreen(offscreen) {} virtual ~Surface() {} uint32_t w = 0, h = 0; bool offscreen = false; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Surface.h"},{"location":"api/Files/Surface_8h/#srcngfxgraphicssurfaceh","text":"","title":"src/ngfx/graphics/Surface.h"},{"location":"api/Files/Surface_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Surface_8h/#classes","text":"Name class ngfx::Surface","title":"Classes"},{"location":"api/Files/Surface_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstdint> namespace ngfx { class Surface { public: Surface() {} Surface(uint32_t w, uint32_t h, bool offscreen = false) : w(w), h(h), offscreen(offscreen) {} virtual ~Surface() {} uint32_t w = 0, h = 0; bool offscreen = false; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Swapchain_8h/","text":"src/ngfx/graphics/Swapchain.h Namespaces Name ngfx Classes Name class ngfx::Swapchain Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Semaphore.h\" #include <cstdint> namespace ngfx { class Swapchain { public: virtual ~Swapchain() {} virtual void acquireNextImage() = 0; uint32_t numImages; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Swapchain.h"},{"location":"api/Files/Swapchain_8h/#srcngfxgraphicsswapchainh","text":"","title":"src/ngfx/graphics/Swapchain.h"},{"location":"api/Files/Swapchain_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Swapchain_8h/#classes","text":"Name class ngfx::Swapchain","title":"Classes"},{"location":"api/Files/Swapchain_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Semaphore.h\" #include <cstdint> namespace ngfx { class Swapchain { public: virtual ~Swapchain() {} virtual void acquireNextImage() = 0; uint32_t numImages; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Texture_8cpp/","text":"src/ngfx/graphics/Texture.cpp Defines Name STB_IMAGE_IMPLEMENTATION Macro Documentation define STB_IMAGE_IMPLEMENTATION #define STB_IMAGE_IMPLEMENTATION Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Texture.h\" #define STB_IMAGE_IMPLEMENTATION #include <memory> #include <stb_image.h> using namespace ngfx; Texture *Texture::create(GraphicsContext *ctx, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { int w, h, channels; std::unique_ptr<stbi_uc> data(stbi_load(filename, &w, &h, &channels, 4)); assert(data); Texture *texture = create(ctx, graphics, data.get(), PIXELFORMAT_RGBA8_UNORM, w * h * 4, w, h, 1, 1, imageUsageFlags, textureType, genMipmaps, minFilter, magFilter, mipFilter, numSamples); return texture; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Texture.cpp"},{"location":"api/Files/Texture_8cpp/#srcngfxgraphicstexturecpp","text":"","title":"src/ngfx/graphics/Texture.cpp"},{"location":"api/Files/Texture_8cpp/#defines","text":"Name STB_IMAGE_IMPLEMENTATION","title":"Defines"},{"location":"api/Files/Texture_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/Texture_8cpp/#define-stb_image_implementation","text":"#define STB_IMAGE_IMPLEMENTATION","title":"define STB_IMAGE_IMPLEMENTATION"},{"location":"api/Files/Texture_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/graphics/Texture.h\" #define STB_IMAGE_IMPLEMENTATION #include <memory> #include <stb_image.h> using namespace ngfx; Texture *Texture::create(GraphicsContext *ctx, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { int w, h, channels; std::unique_ptr<stbi_uc> data(stbi_load(filename, &w, &h, &channels, 4)); assert(data); Texture *texture = create(ctx, graphics, data.get(), PIXELFORMAT_RGBA8_UNORM, w * h * 4, w, h, 1, 1, imageUsageFlags, textureType, genMipmaps, minFilter, magFilter, mipFilter, numSamples); return texture; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Texture_8h/","text":"src/ngfx/graphics/Texture.h Namespaces Name ngfx Classes Name class ngfx::Texture Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" namespace ngfx { class Graphics; class GraphicsContext; class Texture { public: static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, void *data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); virtual ~Texture() {} virtual void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) = 0; virtual void generateMipmaps(CommandBuffer *commandBuffer) = 0; PixelFormat format; uint32_t w = 0, h = 0, d = 1, arrayLayers = 1, mipLevels = 1, numSamples = 1; ImageUsageFlags imageUsageFlags; TextureType textureType; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Texture.h"},{"location":"api/Files/Texture_8h/#srcngfxgraphicstextureh","text":"","title":"src/ngfx/graphics/Texture.h"},{"location":"api/Files/Texture_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Texture_8h/#classes","text":"Name class ngfx::Texture","title":"Classes"},{"location":"api/Files/Texture_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsPipeline.h\" namespace ngfx { class Graphics; class GraphicsContext; class Texture { public: static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, const char *filename, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); static Texture * create(GraphicsContext *graphicsContext, Graphics *graphics, void *data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags = ImageUsageFlags( IMAGE_USAGE_SAMPLED_BIT | IMAGE_USAGE_TRANSFER_SRC_BIT | IMAGE_USAGE_TRANSFER_DST_BIT), TextureType textureType = TEXTURE_TYPE_2D, bool genMipmaps = false, FilterMode minFilter = FILTER_NEAREST, FilterMode magFilter = FILTER_NEAREST, FilterMode mipFilter = FILTER_NEAREST, uint32_t numSamples = 1); virtual ~Texture() {} virtual void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) = 0; virtual void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) = 0; virtual void generateMipmaps(CommandBuffer *commandBuffer) = 0; PixelFormat format; uint32_t w = 0, h = 0, d = 1, arrayLayers = 1, mipLevels = 1, numSamples = 1; ImageUsageFlags imageUsageFlags; TextureType textureType; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Timer_8cpp/","text":"src/ngfx/core/Timer.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/Timer.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; using namespace std::chrono; Timer::Timer() { t0 = system_clock::now(); } void Timer::update() { auto t1 = system_clock::now(); elapsed = duration_cast<nanoseconds>(t1 - t0).count() / float(1e9); t0 = t1; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/Timer.cpp"},{"location":"api/Files/Timer_8cpp/#srcngfxcoretimercpp","text":"","title":"src/ngfx/core/Timer.cpp"},{"location":"api/Files/Timer_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/core/Timer.h\" #include \"ngfx/core/DebugUtil.h\" using namespace ngfx; using namespace std::chrono; Timer::Timer() { t0 = system_clock::now(); } void Timer::update() { auto t1 = system_clock::now(); elapsed = duration_cast<nanoseconds>(t1 - t0).count() / float(1e9); t0 = t1; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Timer_8h/","text":"src/ngfx/core/Timer.h Namespaces Name ngfx Classes Name class ngfx::Timer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <chrono> namespace ngfx { class Timer { public: Timer(); void update(); float elapsed; std::chrono::system_clock::time_point t0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/Timer.h"},{"location":"api/Files/Timer_8h/#srcngfxcoretimerh","text":"","title":"src/ngfx/core/Timer.h"},{"location":"api/Files/Timer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Timer_8h/#classes","text":"Name class ngfx::Timer","title":"Classes"},{"location":"api/Files/Timer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <chrono> namespace ngfx { class Timer { public: Timer(); void update(); float elapsed; std::chrono::system_clock::time_point t0; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Util_8cpp/","text":"src/ngfx/core/Util.cpp Source code #include \"ngfx/core/Util.h\" using namespace ngfx; uint64_t Util::hash(const std::string &s) { uint64_t result = 2166136261U; for (const char &c : s) { result = 127 * result + uint8_t(c); } return result; }; Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/Util.cpp"},{"location":"api/Files/Util_8cpp/#srcngfxcoreutilcpp","text":"","title":"src/ngfx/core/Util.cpp"},{"location":"api/Files/Util_8cpp/#source-code","text":"#include \"ngfx/core/Util.h\" using namespace ngfx; uint64_t Util::hash(const std::string &s) { uint64_t result = 2166136261U; for (const char &c : s) { result = 127 * result + uint8_t(c); } return result; }; Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/Util_8h/","text":"src/ngfx/core/Util.h Namespaces Name ngfx Classes Name class ngfx::Util Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <algorithm> #include <string> #include <vector> namespace ngfx { class Util { public: template <typename T> static bool contains(std::vector<T> &v, T item) { return (std::find(v.begin(), v.end(), item) != v.end()); } static uint64_t hash(const std::string &s); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core/Util.h"},{"location":"api/Files/Util_8h/#srcngfxcoreutilh","text":"","title":"src/ngfx/core/Util.h"},{"location":"api/Files/Util_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Util_8h/#classes","text":"Name class ngfx::Util","title":"Classes"},{"location":"api/Files/Util_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <algorithm> #include <string> #include <vector> namespace ngfx { class Util { public: template <typename T> static bool contains(std::vector<T> &v, T item) { return (std::find(v.begin(), v.end(), item) != v.end()); } static uint64_t hash(const std::string &s); }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKBlit_8cpp/","text":"src/ngfx/porting/vulkan/VKBlit.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKBlit.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKBlit::blitImage(VkCommandBuffer cmdBuffer, VkImage srcImage, uint32_t srcLevel, VkImage dstImage, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer, uint32_t srcLayerCount, uint32_t dstBaseLayer, uint32_t dstLayerCount, VkImageLayout srcImageLayout, VkImageLayout dstImageLayout, VkFilter filter) { VkImageBlit b0 = { {VK_IMAGE_ASPECT_COLOR_BIT, srcLevel, srcBaseLayer, srcLayerCount}, {srcRegion.p0, srcRegion.p1}, {VK_IMAGE_ASPECT_COLOR_BIT, dstLevel, dstBaseLayer, dstLayerCount}, {dstRegion.p0, dstRegion.p1}}; VK_TRACE(vkCmdBlitImage(cmdBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, 1, &b0, filter)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKBlit.cpp"},{"location":"api/Files/VKBlit_8cpp/#srcngfxportingvulkanvkblitcpp","text":"","title":"src/ngfx/porting/vulkan/VKBlit.cpp"},{"location":"api/Files/VKBlit_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKBlit.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKBlit::blitImage(VkCommandBuffer cmdBuffer, VkImage srcImage, uint32_t srcLevel, VkImage dstImage, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer, uint32_t srcLayerCount, uint32_t dstBaseLayer, uint32_t dstLayerCount, VkImageLayout srcImageLayout, VkImageLayout dstImageLayout, VkFilter filter) { VkImageBlit b0 = { {VK_IMAGE_ASPECT_COLOR_BIT, srcLevel, srcBaseLayer, srcLayerCount}, {srcRegion.p0, srcRegion.p1}, {VK_IMAGE_ASPECT_COLOR_BIT, dstLevel, dstBaseLayer, dstLayerCount}, {dstRegion.p0, dstRegion.p1}}; VK_TRACE(vkCmdBlitImage(cmdBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, 1, &b0, filter)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKBlit_8h/","text":"src/ngfx/porting/vulkan/VKBlit.h Namespaces Name ngfx Classes Name struct ngfx::VKBlit struct ngfx::VKBlit::Region Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <vulkan/vulkan.h> namespace ngfx { struct VKBlit { struct Region { VkOffset3D p0, p1; }; static void blitImage(VkCommandBuffer cmdBuffer, VkImage srcImage, uint32_t srcLevel, VkImage dstImage, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer = 0, uint32_t srcLayerCount = 1, uint32_t dstBaseLayer = 0, uint32_t dstLayerCount = 1, VkImageLayout srcImageLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VkImageLayout dstImageLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VkFilter filter = VK_FILTER_LINEAR); }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKBlit.h"},{"location":"api/Files/VKBlit_8h/#srcngfxportingvulkanvkblith","text":"","title":"src/ngfx/porting/vulkan/VKBlit.h"},{"location":"api/Files/VKBlit_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKBlit_8h/#classes","text":"Name struct ngfx::VKBlit struct ngfx::VKBlit::Region","title":"Classes"},{"location":"api/Files/VKBlit_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <vulkan/vulkan.h> namespace ngfx { struct VKBlit { struct Region { VkOffset3D p0, p1; }; static void blitImage(VkCommandBuffer cmdBuffer, VkImage srcImage, uint32_t srcLevel, VkImage dstImage, uint32_t dstLevel, Region srcRegion, Region dstRegion, uint32_t srcBaseLayer = 0, uint32_t srcLayerCount = 1, uint32_t dstBaseLayer = 0, uint32_t dstLayerCount = 1, VkImageLayout srcImageLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VkImageLayout dstImageLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VkFilter filter = VK_FILTER_LINEAR); }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKBuffer_8cpp/","text":"src/ngfx/porting/vulkan/VKBuffer.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKBuffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include <cstring> using namespace ngfx; void VKBuffer::create(VKGraphicsContext *ctx, const void *data, uint32_t size, VkBufferUsageFlags bufferUsageFlags, VkMemoryPropertyFlags memoryPropertyFlags) { this->ctx = ctx; this->size = size; createBuffer(data, size, bufferUsageFlags); createMemory(memoryPropertyFlags); if (data) upload(data, size, 0); } const VkDescriptorSet & VKBuffer::getUboDescriptorSet(ShaderStageFlags shaderStageFlags) { if (!uboDescriptorSet) { VkDescriptorPool &descriptorPool = ctx->vkDescriptorPool; auto &bufferUsageFlags = createInfo.usage; if (!(bufferUsageFlags & VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT)) NGFX_ERR(\"incorrect buffer usage flags\"); auto descriptorSetLayout = ctx->vkDescriptorSetLayoutCache.get( VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, shaderStageFlags); initDescriptorSet(descriptorPool, descriptorSetLayout, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, uboDescriptorSet); } return uboDescriptorSet; } const VkDescriptorSet & VKBuffer::getSsboDescriptorSet(ShaderStageFlags shaderStageFlags) { if (!ssboDescriptorSet) { VkDescriptorPool &descriptorPool = ctx->vkDescriptorPool; auto &bufferUsageFlags = createInfo.usage; if (!(bufferUsageFlags & VK_BUFFER_USAGE_STORAGE_BUFFER_BIT)) NGFX_ERR(\"incorrect buffer usage flags\"); auto descriptorSetLayout = ctx->vkDescriptorSetLayoutCache.get( VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, shaderStageFlags); initDescriptorSet(descriptorPool, descriptorSetLayout, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ssboDescriptorSet); } return ssboDescriptorSet; } void VKBuffer::initDescriptorSet(VkDescriptorPool descriptorPool, VkDescriptorSetLayout descriptorSetLayout, VkDescriptorType descriptorType, VkDescriptorSet &descriptorSet) { VkResult vkResult; auto device = ctx->vkDevice.v; VkDescriptorSetAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, nullptr, descriptorPool, 1, &descriptorSetLayout}; V(vkAllocateDescriptorSets(device, &allocInfo, &descriptorSet)); VkDescriptorBufferInfo descriptorBufferInfo = {v, 0, size}; VkWriteDescriptorSet writeDescriptorSet = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, nullptr, descriptorSet, 0, 0, 1, descriptorType, nullptr, &descriptorBufferInfo, nullptr}; VK_TRACE(vkUpdateDescriptorSets(device, 1, &writeDescriptorSet, 0, nullptr)); } void VKBuffer::upload(const void *data, uint32_t size, uint32_t offset) { uint8_t *dst = (uint8_t *)map(); memcpy(dst + offset, data, size); unmap(); } void VKBuffer::download(void *dst, uint32_t size, uint32_t offset) { uint8_t *src = (uint8_t *)map(); memcpy(dst, src + offset, size); unmap(); } VKBuffer::~VKBuffer() { auto device = ctx->vkDevice.v; if (v) VK_TRACE(vkDestroyBuffer(device, v, nullptr)); if (memory) VK_TRACE(vkFreeMemory(device, memory, nullptr)); } void VKBuffer::createBuffer(const void *data, uint32_t size, VkBufferUsageFlags bufferUsageFlags) { VkResult vkResult; auto device = ctx->vkDevice.v; createInfo = {VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, nullptr, 0, VkDeviceSize(size), bufferUsageFlags, VK_SHARING_MODE_EXCLUSIVE, 0, 0}; V(vkCreateBuffer(device, &createInfo, nullptr, &v)); } void VKBuffer::createMemory(VkMemoryPropertyFlags memoryPropertyFlags) { VkResult vkResult; auto device = ctx->vkDevice.v; VK_TRACE(vkGetBufferMemoryRequirements(device, v, &memReqs)); auto physicalDevice = &ctx->vkPhysicalDevice; uint32_t memoryTypeIndex = physicalDevice->getMemoryType( memReqs.memoryTypeBits, memoryPropertyFlags); allocInfo = {VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, nullptr, memReqs.size, memoryTypeIndex}; V(vkAllocateMemory(device, &allocInfo, nullptr, &memory)); V(vkBindBufferMemory(device, v, memory, 0)); } void *VKBuffer::map() { VkResult vkResult; void *data; auto device = ctx->vkDevice.v; V(vkMapMemory(device, memory, 0, size, 0, &data)); return data; } void VKBuffer::unmap() { auto device = ctx->vkDevice.v; VK_TRACE(vkUnmapMemory(device, memory)); } Buffer *Buffer::create(GraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags usageFlags) { VKBuffer *vkBuffer = new VKBuffer(); vkBuffer->create(vk(ctx), data, size, usageFlags); return vkBuffer; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKBuffer.cpp"},{"location":"api/Files/VKBuffer_8cpp/#srcngfxportingvulkanvkbuffercpp","text":"","title":"src/ngfx/porting/vulkan/VKBuffer.cpp"},{"location":"api/Files/VKBuffer_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKBuffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include <cstring> using namespace ngfx; void VKBuffer::create(VKGraphicsContext *ctx, const void *data, uint32_t size, VkBufferUsageFlags bufferUsageFlags, VkMemoryPropertyFlags memoryPropertyFlags) { this->ctx = ctx; this->size = size; createBuffer(data, size, bufferUsageFlags); createMemory(memoryPropertyFlags); if (data) upload(data, size, 0); } const VkDescriptorSet & VKBuffer::getUboDescriptorSet(ShaderStageFlags shaderStageFlags) { if (!uboDescriptorSet) { VkDescriptorPool &descriptorPool = ctx->vkDescriptorPool; auto &bufferUsageFlags = createInfo.usage; if (!(bufferUsageFlags & VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT)) NGFX_ERR(\"incorrect buffer usage flags\"); auto descriptorSetLayout = ctx->vkDescriptorSetLayoutCache.get( VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, shaderStageFlags); initDescriptorSet(descriptorPool, descriptorSetLayout, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, uboDescriptorSet); } return uboDescriptorSet; } const VkDescriptorSet & VKBuffer::getSsboDescriptorSet(ShaderStageFlags shaderStageFlags) { if (!ssboDescriptorSet) { VkDescriptorPool &descriptorPool = ctx->vkDescriptorPool; auto &bufferUsageFlags = createInfo.usage; if (!(bufferUsageFlags & VK_BUFFER_USAGE_STORAGE_BUFFER_BIT)) NGFX_ERR(\"incorrect buffer usage flags\"); auto descriptorSetLayout = ctx->vkDescriptorSetLayoutCache.get( VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, shaderStageFlags); initDescriptorSet(descriptorPool, descriptorSetLayout, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, ssboDescriptorSet); } return ssboDescriptorSet; } void VKBuffer::initDescriptorSet(VkDescriptorPool descriptorPool, VkDescriptorSetLayout descriptorSetLayout, VkDescriptorType descriptorType, VkDescriptorSet &descriptorSet) { VkResult vkResult; auto device = ctx->vkDevice.v; VkDescriptorSetAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, nullptr, descriptorPool, 1, &descriptorSetLayout}; V(vkAllocateDescriptorSets(device, &allocInfo, &descriptorSet)); VkDescriptorBufferInfo descriptorBufferInfo = {v, 0, size}; VkWriteDescriptorSet writeDescriptorSet = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, nullptr, descriptorSet, 0, 0, 1, descriptorType, nullptr, &descriptorBufferInfo, nullptr}; VK_TRACE(vkUpdateDescriptorSets(device, 1, &writeDescriptorSet, 0, nullptr)); } void VKBuffer::upload(const void *data, uint32_t size, uint32_t offset) { uint8_t *dst = (uint8_t *)map(); memcpy(dst + offset, data, size); unmap(); } void VKBuffer::download(void *dst, uint32_t size, uint32_t offset) { uint8_t *src = (uint8_t *)map(); memcpy(dst, src + offset, size); unmap(); } VKBuffer::~VKBuffer() { auto device = ctx->vkDevice.v; if (v) VK_TRACE(vkDestroyBuffer(device, v, nullptr)); if (memory) VK_TRACE(vkFreeMemory(device, memory, nullptr)); } void VKBuffer::createBuffer(const void *data, uint32_t size, VkBufferUsageFlags bufferUsageFlags) { VkResult vkResult; auto device = ctx->vkDevice.v; createInfo = {VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, nullptr, 0, VkDeviceSize(size), bufferUsageFlags, VK_SHARING_MODE_EXCLUSIVE, 0, 0}; V(vkCreateBuffer(device, &createInfo, nullptr, &v)); } void VKBuffer::createMemory(VkMemoryPropertyFlags memoryPropertyFlags) { VkResult vkResult; auto device = ctx->vkDevice.v; VK_TRACE(vkGetBufferMemoryRequirements(device, v, &memReqs)); auto physicalDevice = &ctx->vkPhysicalDevice; uint32_t memoryTypeIndex = physicalDevice->getMemoryType( memReqs.memoryTypeBits, memoryPropertyFlags); allocInfo = {VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, nullptr, memReqs.size, memoryTypeIndex}; V(vkAllocateMemory(device, &allocInfo, nullptr, &memory)); V(vkBindBufferMemory(device, v, memory, 0)); } void *VKBuffer::map() { VkResult vkResult; void *data; auto device = ctx->vkDevice.v; V(vkMapMemory(device, memory, 0, size, 0, &data)); return data; } void VKBuffer::unmap() { auto device = ctx->vkDevice.v; VK_TRACE(vkUnmapMemory(device, memory)); } Buffer *Buffer::create(GraphicsContext *ctx, const void *data, uint32_t size, BufferUsageFlags usageFlags) { VKBuffer *vkBuffer = new VKBuffer(); vkBuffer->create(vk(ctx), data, size, usageFlags); return vkBuffer; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKBuffer_8h/","text":"src/ngfx/porting/vulkan/VKBuffer.h Namespaces Name ngfx Classes Name class ngfx::VKBuffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" namespace ngfx { class VKGraphicsContext; class VKBuffer : public Buffer { public: void create(VKGraphicsContext *ctx, const void *data, uint32_t size, VkBufferUsageFlags bufferUsageFlags, VkMemoryPropertyFlags memoryPropertyFlags = VkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)); virtual ~VKBuffer(); void *map() override; void unmap() override; void upload(const void *data, uint32_t size, uint32_t offset = 0) override; void download(void *data, uint32_t size, uint32_t offset = 0) override; VkDeviceMemory memory = VK_NULL_HANDLE; VkBuffer v = VK_NULL_HANDLE; uint32_t size; VkBufferCreateInfo createInfo; VkMemoryAllocateInfo allocInfo; const VkDescriptorSet &getUboDescriptorSet(ShaderStageFlags shaderStageFlags); const VkDescriptorSet & getSsboDescriptorSet(ShaderStageFlags shaderStageFlags); VkDescriptorSet uboDescriptorSet = 0, ssboDescriptorSet = 0; protected: void createBuffer(const void *data, uint32_t size, VkBufferUsageFlags bufferUsageFlags); void createMemory(VkMemoryPropertyFlags memoryPropertyFlags); void initDescriptorSet(VkDescriptorPool descriptorPool, VkDescriptorSetLayout descriptorSetLayout, VkDescriptorType descriptorType, VkDescriptorSet &descriptorSet); VKGraphicsContext *ctx; VkMemoryRequirements memReqs; }; VK_CAST(Buffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKBuffer.h"},{"location":"api/Files/VKBuffer_8h/#srcngfxportingvulkanvkbufferh","text":"","title":"src/ngfx/porting/vulkan/VKBuffer.h"},{"location":"api/Files/VKBuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKBuffer_8h/#classes","text":"Name class ngfx::VKBuffer","title":"Classes"},{"location":"api/Files/VKBuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Buffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" namespace ngfx { class VKGraphicsContext; class VKBuffer : public Buffer { public: void create(VKGraphicsContext *ctx, const void *data, uint32_t size, VkBufferUsageFlags bufferUsageFlags, VkMemoryPropertyFlags memoryPropertyFlags = VkMemoryPropertyFlags(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)); virtual ~VKBuffer(); void *map() override; void unmap() override; void upload(const void *data, uint32_t size, uint32_t offset = 0) override; void download(void *data, uint32_t size, uint32_t offset = 0) override; VkDeviceMemory memory = VK_NULL_HANDLE; VkBuffer v = VK_NULL_HANDLE; uint32_t size; VkBufferCreateInfo createInfo; VkMemoryAllocateInfo allocInfo; const VkDescriptorSet &getUboDescriptorSet(ShaderStageFlags shaderStageFlags); const VkDescriptorSet & getSsboDescriptorSet(ShaderStageFlags shaderStageFlags); VkDescriptorSet uboDescriptorSet = 0, ssboDescriptorSet = 0; protected: void createBuffer(const void *data, uint32_t size, VkBufferUsageFlags bufferUsageFlags); void createMemory(VkMemoryPropertyFlags memoryPropertyFlags); void initDescriptorSet(VkDescriptorPool descriptorPool, VkDescriptorSetLayout descriptorSetLayout, VkDescriptorType descriptorType, VkDescriptorSet &descriptorSet); VKGraphicsContext *ctx; VkMemoryRequirements memReqs; }; VK_CAST(Buffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKCommandBuffer_8cpp/","text":"src/ngfx/porting/vulkan/VKCommandBuffer.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKCommandBuffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKCommandBuffer::create(VkDevice device, VkCommandPool cmdPool, VkCommandBufferLevel level) { this->device = device; this->cmdPool = cmdPool; VkResult vkResult; allocateInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, nullptr, cmdPool, level, 1}; V(vkAllocateCommandBuffers(device, &allocateInfo, &v)); } VKCommandBuffer::~VKCommandBuffer() { if (v) VK_TRACE(vkFreeCommandBuffers(device, cmdPool, 1, &v)); } void VKCommandBuffer::begin() { VkResult vkResult; VkCommandBufferBeginInfo cmdBufferBeginInfo = { VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, nullptr, 0, nullptr}; V(vkBeginCommandBuffer(v, &cmdBufferBeginInfo)); } void VKCommandBuffer::end() { VkResult vkResult; V(vkEndCommandBuffer(v)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKCommandBuffer.cpp"},{"location":"api/Files/VKCommandBuffer_8cpp/#srcngfxportingvulkanvkcommandbuffercpp","text":"","title":"src/ngfx/porting/vulkan/VKCommandBuffer.cpp"},{"location":"api/Files/VKCommandBuffer_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKCommandBuffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKCommandBuffer::create(VkDevice device, VkCommandPool cmdPool, VkCommandBufferLevel level) { this->device = device; this->cmdPool = cmdPool; VkResult vkResult; allocateInfo = {VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, nullptr, cmdPool, level, 1}; V(vkAllocateCommandBuffers(device, &allocateInfo, &v)); } VKCommandBuffer::~VKCommandBuffer() { if (v) VK_TRACE(vkFreeCommandBuffers(device, cmdPool, 1, &v)); } void VKCommandBuffer::begin() { VkResult vkResult; VkCommandBufferBeginInfo cmdBufferBeginInfo = { VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, nullptr, 0, nullptr}; V(vkBeginCommandBuffer(v, &cmdBufferBeginInfo)); } void VKCommandBuffer::end() { VkResult vkResult; V(vkEndCommandBuffer(v)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKCommandBuffer_8h/","text":"src/ngfx/porting/vulkan/VKCommandBuffer.h Namespaces Name ngfx Classes Name class ngfx::VKCommandBuffer Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKCommandBuffer : public CommandBuffer { public: void create(VkDevice device, VkCommandPool cmdPool, VkCommandBufferLevel level = VK_COMMAND_BUFFER_LEVEL_PRIMARY); virtual ~VKCommandBuffer(); virtual void begin(); virtual void end(); VkCommandBuffer v = VK_NULL_HANDLE; VkCommandPool cmdPool; VkCommandBufferAllocateInfo allocateInfo; private: VkDevice device; }; VK_CAST(CommandBuffer); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKCommandBuffer.h"},{"location":"api/Files/VKCommandBuffer_8h/#srcngfxportingvulkanvkcommandbufferh","text":"","title":"src/ngfx/porting/vulkan/VKCommandBuffer.h"},{"location":"api/Files/VKCommandBuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKCommandBuffer_8h/#classes","text":"Name class ngfx::VKCommandBuffer","title":"Classes"},{"location":"api/Files/VKCommandBuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKCommandBuffer : public CommandBuffer { public: void create(VkDevice device, VkCommandPool cmdPool, VkCommandBufferLevel level = VK_COMMAND_BUFFER_LEVEL_PRIMARY); virtual ~VKCommandBuffer(); virtual void begin(); virtual void end(); VkCommandBuffer v = VK_NULL_HANDLE; VkCommandPool cmdPool; VkCommandBufferAllocateInfo allocateInfo; private: VkDevice device; }; VK_CAST(CommandBuffer); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKCommandPool_8cpp/","text":"src/ngfx/porting/vulkan/VKCommandPool.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKCommandPool.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKCommandPool::create(VkDevice device, uint32_t queueFamilyIndex, VkCommandPoolCreateFlags createFlags) { this->device = device; VkResult vkResult; createInfo = {}; createInfo.queueFamilyIndex = queueFamilyIndex; createInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; createInfo.flags = createFlags; V(vkCreateCommandPool(device, &createInfo, nullptr, &v)); } VKCommandPool::~VKCommandPool() { if (v) VK_TRACE(vkDestroyCommandPool(device, v, nullptr)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKCommandPool.cpp"},{"location":"api/Files/VKCommandPool_8cpp/#srcngfxportingvulkanvkcommandpoolcpp","text":"","title":"src/ngfx/porting/vulkan/VKCommandPool.cpp"},{"location":"api/Files/VKCommandPool_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKCommandPool.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKCommandPool::create(VkDevice device, uint32_t queueFamilyIndex, VkCommandPoolCreateFlags createFlags) { this->device = device; VkResult vkResult; createInfo = {}; createInfo.queueFamilyIndex = queueFamilyIndex; createInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; createInfo.flags = createFlags; V(vkCreateCommandPool(device, &createInfo, nullptr, &v)); } VKCommandPool::~VKCommandPool() { if (v) VK_TRACE(vkDestroyCommandPool(device, v, nullptr)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKCommandPool_8h/","text":"src/ngfx/porting/vulkan/VKCommandPool.h Namespaces Name ngfx Classes Name class ngfx::VKCommandPool Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <vulkan/vulkan.h> namespace ngfx { class VKCommandPool { public: void create(VkDevice device, uint32_t queueFamilyIndex, VkCommandPoolCreateFlags createFlags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT); virtual ~VKCommandPool(); VkCommandPool v = VK_NULL_HANDLE; VkCommandPoolCreateInfo createInfo; private: VkDevice device; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKCommandPool.h"},{"location":"api/Files/VKCommandPool_8h/#srcngfxportingvulkanvkcommandpoolh","text":"","title":"src/ngfx/porting/vulkan/VKCommandPool.h"},{"location":"api/Files/VKCommandPool_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKCommandPool_8h/#classes","text":"Name class ngfx::VKCommandPool","title":"Classes"},{"location":"api/Files/VKCommandPool_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <vulkan/vulkan.h> namespace ngfx { class VKCommandPool { public: void create(VkDevice device, uint32_t queueFamilyIndex, VkCommandPoolCreateFlags createFlags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT); virtual ~VKCommandPool(); VkCommandPool v = VK_NULL_HANDLE; VkCommandPoolCreateInfo createInfo; private: VkDevice device; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKComputePipeline_8cpp/","text":"src/ngfx/porting/vulkan/VKComputePipeline.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKComputePipeline.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKComputePipeline::create( VKGraphicsContext *ctx, const std::vector<VKPipeline::Descriptor> &descriptors, VkShaderModule shaderModule) { VkResult vkResult; this->device = ctx->vkDevice.v; std::vector<VkDescriptorSetLayout> descriptorSetLayouts(descriptors.size()); for (int j = 0; j < descriptors.size(); j++) { auto &descriptor = descriptors[j]; descriptorSetLayouts[j] = ctx->vkDescriptorSetLayoutCache.get( descriptor.type, descriptor.stageFlags); } pipelineLayoutCreateInfo = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, nullptr, 0, uint32_t(descriptorSetLayouts.size()), descriptorSetLayouts.data(), 0, nullptr}; V(vkCreatePipelineLayout(device, &pipelineLayoutCreateInfo, nullptr, &pipelineLayout)); shaderStageCreateInfo = {VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, nullptr, 0, VK_SHADER_STAGE_COMPUTE_BIT, shaderModule, \"main\", nullptr}; createInfo = {VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, nullptr, 0, shaderStageCreateInfo, pipelineLayout, 0, 0}; V(vkCreateComputePipelines(device, ctx->vkPipelineCache.v, 1, &createInfo, nullptr, &v)); } ComputePipeline *ComputePipeline::create(GraphicsContext *graphicsContext, ComputeShaderModule *cs) { VKComputePipeline *vkComputePipeline = new VKComputePipeline(); uint32_t numDescriptors = cs->descriptors.empty() ? 0 : cs->descriptors.back().set + 1; auto &descriptorBindings = vkComputePipeline->descriptorBindings; descriptorBindings.resize(numDescriptors); std::vector<VKPipeline::Descriptor> vkDescriptors(numDescriptors); VKPipelineUtil::parseDescriptors(cs->descriptors, VK_SHADER_STAGE_COMPUTE_BIT, vkDescriptors, descriptorBindings); vkComputePipeline->create(vk(graphicsContext), vkDescriptors, vk(cs)->v); return vkComputePipeline; } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKComputePipeline.cpp"},{"location":"api/Files/VKComputePipeline_8cpp/#srcngfxportingvulkanvkcomputepipelinecpp","text":"","title":"src/ngfx/porting/vulkan/VKComputePipeline.cpp"},{"location":"api/Files/VKComputePipeline_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKComputePipeline.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKComputePipeline::create( VKGraphicsContext *ctx, const std::vector<VKPipeline::Descriptor> &descriptors, VkShaderModule shaderModule) { VkResult vkResult; this->device = ctx->vkDevice.v; std::vector<VkDescriptorSetLayout> descriptorSetLayouts(descriptors.size()); for (int j = 0; j < descriptors.size(); j++) { auto &descriptor = descriptors[j]; descriptorSetLayouts[j] = ctx->vkDescriptorSetLayoutCache.get( descriptor.type, descriptor.stageFlags); } pipelineLayoutCreateInfo = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, nullptr, 0, uint32_t(descriptorSetLayouts.size()), descriptorSetLayouts.data(), 0, nullptr}; V(vkCreatePipelineLayout(device, &pipelineLayoutCreateInfo, nullptr, &pipelineLayout)); shaderStageCreateInfo = {VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, nullptr, 0, VK_SHADER_STAGE_COMPUTE_BIT, shaderModule, \"main\", nullptr}; createInfo = {VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, nullptr, 0, shaderStageCreateInfo, pipelineLayout, 0, 0}; V(vkCreateComputePipelines(device, ctx->vkPipelineCache.v, 1, &createInfo, nullptr, &v)); } ComputePipeline *ComputePipeline::create(GraphicsContext *graphicsContext, ComputeShaderModule *cs) { VKComputePipeline *vkComputePipeline = new VKComputePipeline(); uint32_t numDescriptors = cs->descriptors.empty() ? 0 : cs->descriptors.back().set + 1; auto &descriptorBindings = vkComputePipeline->descriptorBindings; descriptorBindings.resize(numDescriptors); std::vector<VKPipeline::Descriptor> vkDescriptors(numDescriptors); VKPipelineUtil::parseDescriptors(cs->descriptors, VK_SHADER_STAGE_COMPUTE_BIT, vkDescriptors, descriptorBindings); vkComputePipeline->create(vk(graphicsContext), vkDescriptors, vk(cs)->v); return vkComputePipeline; } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKComputePipeline_8h/","text":"src/ngfx/porting/vulkan/VKComputePipeline.h Namespaces Name ngfx Classes Name class ngfx::VKComputePipeline Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKPipeline.h\" namespace ngfx { class VKComputePipeline : public ComputePipeline, public VKPipeline { public: void create(VKGraphicsContext *ctx, const std::vector<VKPipeline::Descriptor> &descriptors, VkShaderModule shaderModule); VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo; VkPipelineShaderStageCreateInfo shaderStageCreateInfo; VkComputePipelineCreateInfo createInfo; }; VK_CAST(ComputePipeline); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKComputePipeline.h"},{"location":"api/Files/VKComputePipeline_8h/#srcngfxportingvulkanvkcomputepipelineh","text":"","title":"src/ngfx/porting/vulkan/VKComputePipeline.h"},{"location":"api/Files/VKComputePipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKComputePipeline_8h/#classes","text":"Name class ngfx::VKComputePipeline","title":"Classes"},{"location":"api/Files/VKComputePipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/compute/ComputePipeline.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKPipeline.h\" namespace ngfx { class VKComputePipeline : public ComputePipeline, public VKPipeline { public: void create(VKGraphicsContext *ctx, const std::vector<VKPipeline::Descriptor> &descriptors, VkShaderModule shaderModule); VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo; VkPipelineShaderStageCreateInfo shaderStageCreateInfo; VkComputePipelineCreateInfo createInfo; }; VK_CAST(ComputePipeline); }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKConfig_8h/","text":"src/ngfx/porting/vulkan/VKConfig.h Defines Name PREFERRED_DEVICE_TYPE ORIGIN_BOTTOM_LEFT Macro Documentation define PREFERRED_DEVICE_TYPE #define PREFERRED_DEVICE_TYPE VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU define ORIGIN_BOTTOM_LEFT #define ORIGIN_BOTTOM_LEFT Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <vulkan/vulkan.h> //#define VK_FLIP_Y #if defined(VK_USE_PLATFORM_WIN32_KHR) #define VK_SURFACE_EXTENSION_NAMES VK_KHR_WIN32_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_ANDROID_KHR) #define VK_SURFACE_EXTENSION_NAMES VK_KHR_ANDROID_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_WAYLAND_KHR) #define VK_SURFACE_EXTENSION_NAMES VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_XCB_KHR) && defined(VK_USE_PLATFORM_XLIB_KHR) #define VK_SURFACE_EXTENSION_NAMES \\ VK_KHR_XCB_SURFACE_EXTENSION_NAME, VK_KHR_XLIB_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_XCB_KHR) #define VK_SURFACE_EXTENSION_NAMES VK_KHR_XCB_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_XLIB_KHR) #define VK_SURFACE_EXTENSION_NAMES VK_KHR_XLIB_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_IOS_MVK) #define VK_SURFACE_EXTENSION_NAMES VK_MVK_IOS_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_MACOS_MVK) #define VK_SURFACE_EXTENSION_NAMES VK_MVK_MACOS_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_METAL_EXT) #define VK_SURFACE_EXTENSION_NAMES VK_EXT_METAL_SURFACE_EXTENSION_NAME #endif #define PREFERRED_DEVICE_TYPE \\ VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU // VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU #define ORIGIN_BOTTOM_LEFT Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKConfig.h"},{"location":"api/Files/VKConfig_8h/#srcngfxportingvulkanvkconfigh","text":"","title":"src/ngfx/porting/vulkan/VKConfig.h"},{"location":"api/Files/VKConfig_8h/#defines","text":"Name PREFERRED_DEVICE_TYPE ORIGIN_BOTTOM_LEFT","title":"Defines"},{"location":"api/Files/VKConfig_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/VKConfig_8h/#define-preferred_device_type","text":"#define PREFERRED_DEVICE_TYPE VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU","title":"define PREFERRED_DEVICE_TYPE"},{"location":"api/Files/VKConfig_8h/#define-origin_bottom_left","text":"#define ORIGIN_BOTTOM_LEFT","title":"define ORIGIN_BOTTOM_LEFT"},{"location":"api/Files/VKConfig_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <vulkan/vulkan.h> //#define VK_FLIP_Y #if defined(VK_USE_PLATFORM_WIN32_KHR) #define VK_SURFACE_EXTENSION_NAMES VK_KHR_WIN32_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_ANDROID_KHR) #define VK_SURFACE_EXTENSION_NAMES VK_KHR_ANDROID_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_WAYLAND_KHR) #define VK_SURFACE_EXTENSION_NAMES VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_XCB_KHR) && defined(VK_USE_PLATFORM_XLIB_KHR) #define VK_SURFACE_EXTENSION_NAMES \\ VK_KHR_XCB_SURFACE_EXTENSION_NAME, VK_KHR_XLIB_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_XCB_KHR) #define VK_SURFACE_EXTENSION_NAMES VK_KHR_XCB_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_XLIB_KHR) #define VK_SURFACE_EXTENSION_NAMES VK_KHR_XLIB_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_IOS_MVK) #define VK_SURFACE_EXTENSION_NAMES VK_MVK_IOS_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_MACOS_MVK) #define VK_SURFACE_EXTENSION_NAMES VK_MVK_MACOS_SURFACE_EXTENSION_NAME #elif defined(VK_USE_PLATFORM_METAL_EXT) #define VK_SURFACE_EXTENSION_NAMES VK_EXT_METAL_SURFACE_EXTENSION_NAME #endif #define PREFERRED_DEVICE_TYPE \\ VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU // VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU #define ORIGIN_BOTTOM_LEFT Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKDebugUtil_8cpp/","text":"src/ngfx/porting/vulkan/VKDebugUtil.cpp Functions Name VKAPI_ATTR VkBool32 VKAPI_CALL debugUtilsMessengerCallback (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT * pCallbackData, void * pUserData) Defines Name STR (r) Functions Documentation function debugUtilsMessengerCallback static VKAPI_ATTR VkBool32 VKAPI_CALL debugUtilsMessengerCallback( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT * pCallbackData, void * pUserData ) Macro Documentation define STR #define STR( r ) case VK_##r: \\ return #r Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include <sstream> #include <string> using namespace ngfx; VKDebugMessenger VKDebugMessenger::inst; const char *VKDebugMessenger::VkResultToString(VkResult errorCode) { switch (errorCode) { #define STR(r) \\ case VK_##r: \\ return #r STR(NOT_READY); STR(TIMEOUT); STR(EVENT_SET); STR(EVENT_RESET); STR(INCOMPLETE); STR(ERROR_OUT_OF_HOST_MEMORY); STR(ERROR_OUT_OF_DEVICE_MEMORY); STR(ERROR_INITIALIZATION_FAILED); STR(ERROR_DEVICE_LOST); STR(ERROR_MEMORY_MAP_FAILED); STR(ERROR_LAYER_NOT_PRESENT); STR(ERROR_EXTENSION_NOT_PRESENT); STR(ERROR_FEATURE_NOT_PRESENT); STR(ERROR_INCOMPATIBLE_DRIVER); STR(ERROR_TOO_MANY_OBJECTS); STR(ERROR_FORMAT_NOT_SUPPORTED); STR(ERROR_SURFACE_LOST_KHR); STR(ERROR_NATIVE_WINDOW_IN_USE_KHR); STR(SUBOPTIMAL_KHR); STR(ERROR_OUT_OF_DATE_KHR); STR(ERROR_INCOMPATIBLE_DISPLAY_KHR); STR(ERROR_VALIDATION_FAILED_EXT); STR(ERROR_INVALID_SHADER_NV); #undef STR default: return \"UNKNOWN_ERROR\"; } } static VKAPI_ATTR VkBool32 VKAPI_CALL debugUtilsMessengerCallback( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData) { std::stringstream debugMessage; debugMessage << \"[\" << pCallbackData->messageIdNumber << \"][\" << pCallbackData->pMessageIdName << \"] : \" << pCallbackData->pMessage; if (messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) { NGFX_ERR(\"%s\", debugMessage.str().c_str()); } else NGFX_LOG(\"%s\", debugMessage.str().c_str()); return VK_FALSE; } void VKDebugMessenger::create(VkInstance instance, VkDebugReportFlagsEXT flags) { this->instance = instance; VkResult vkResult; PFN_vkCreateDebugUtilsMessengerEXT vkCreateDebugUtilsMessengerEXT = reinterpret_cast<PFN_vkCreateDebugUtilsMessengerEXT>( vkGetInstanceProcAddr(instance, \"vkCreateDebugUtilsMessengerEXT\")); VkDebugUtilsMessengerCreateInfoEXT debugUtilsMessengerCI{}; debugUtilsMessengerCI.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; debugUtilsMessengerCI.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT; debugUtilsMessengerCI.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT; debugUtilsMessengerCI.pfnUserCallback = debugUtilsMessengerCallback; V(vkCreateDebugUtilsMessengerEXT(instance, &debugUtilsMessengerCI, nullptr, &v)); } void VKDebugMessenger::destroy() { PFN_vkDestroyDebugUtilsMessengerEXT vkDestroyDebugUtilsMessengerEXT = reinterpret_cast<PFN_vkDestroyDebugUtilsMessengerEXT>( vkGetInstanceProcAddr(instance, \"vkDestroyDebugUtilsMessengerEXT\")); VK_TRACE(vkDestroyDebugUtilsMessengerEXT(instance, v, nullptr)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKDebugUtil.cpp"},{"location":"api/Files/VKDebugUtil_8cpp/#srcngfxportingvulkanvkdebugutilcpp","text":"","title":"src/ngfx/porting/vulkan/VKDebugUtil.cpp"},{"location":"api/Files/VKDebugUtil_8cpp/#functions","text":"Name VKAPI_ATTR VkBool32 VKAPI_CALL debugUtilsMessengerCallback (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT * pCallbackData, void * pUserData)","title":"Functions"},{"location":"api/Files/VKDebugUtil_8cpp/#defines","text":"Name STR (r)","title":"Defines"},{"location":"api/Files/VKDebugUtil_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/VKDebugUtil_8cpp/#function-debugutilsmessengercallback","text":"static VKAPI_ATTR VkBool32 VKAPI_CALL debugUtilsMessengerCallback( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT * pCallbackData, void * pUserData )","title":"function debugUtilsMessengerCallback"},{"location":"api/Files/VKDebugUtil_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/VKDebugUtil_8cpp/#define-str","text":"#define STR( r ) case VK_##r: \\ return #r","title":"define STR"},{"location":"api/Files/VKDebugUtil_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/core/DebugUtil.h\" #include <sstream> #include <string> using namespace ngfx; VKDebugMessenger VKDebugMessenger::inst; const char *VKDebugMessenger::VkResultToString(VkResult errorCode) { switch (errorCode) { #define STR(r) \\ case VK_##r: \\ return #r STR(NOT_READY); STR(TIMEOUT); STR(EVENT_SET); STR(EVENT_RESET); STR(INCOMPLETE); STR(ERROR_OUT_OF_HOST_MEMORY); STR(ERROR_OUT_OF_DEVICE_MEMORY); STR(ERROR_INITIALIZATION_FAILED); STR(ERROR_DEVICE_LOST); STR(ERROR_MEMORY_MAP_FAILED); STR(ERROR_LAYER_NOT_PRESENT); STR(ERROR_EXTENSION_NOT_PRESENT); STR(ERROR_FEATURE_NOT_PRESENT); STR(ERROR_INCOMPATIBLE_DRIVER); STR(ERROR_TOO_MANY_OBJECTS); STR(ERROR_FORMAT_NOT_SUPPORTED); STR(ERROR_SURFACE_LOST_KHR); STR(ERROR_NATIVE_WINDOW_IN_USE_KHR); STR(SUBOPTIMAL_KHR); STR(ERROR_OUT_OF_DATE_KHR); STR(ERROR_INCOMPATIBLE_DISPLAY_KHR); STR(ERROR_VALIDATION_FAILED_EXT); STR(ERROR_INVALID_SHADER_NV); #undef STR default: return \"UNKNOWN_ERROR\"; } } static VKAPI_ATTR VkBool32 VKAPI_CALL debugUtilsMessengerCallback( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData) { std::stringstream debugMessage; debugMessage << \"[\" << pCallbackData->messageIdNumber << \"][\" << pCallbackData->pMessageIdName << \"] : \" << pCallbackData->pMessage; if (messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) { NGFX_ERR(\"%s\", debugMessage.str().c_str()); } else NGFX_LOG(\"%s\", debugMessage.str().c_str()); return VK_FALSE; } void VKDebugMessenger::create(VkInstance instance, VkDebugReportFlagsEXT flags) { this->instance = instance; VkResult vkResult; PFN_vkCreateDebugUtilsMessengerEXT vkCreateDebugUtilsMessengerEXT = reinterpret_cast<PFN_vkCreateDebugUtilsMessengerEXT>( vkGetInstanceProcAddr(instance, \"vkCreateDebugUtilsMessengerEXT\")); VkDebugUtilsMessengerCreateInfoEXT debugUtilsMessengerCI{}; debugUtilsMessengerCI.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; debugUtilsMessengerCI.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT; debugUtilsMessengerCI.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT; debugUtilsMessengerCI.pfnUserCallback = debugUtilsMessengerCallback; V(vkCreateDebugUtilsMessengerEXT(instance, &debugUtilsMessengerCI, nullptr, &v)); } void VKDebugMessenger::destroy() { PFN_vkDestroyDebugUtilsMessengerEXT vkDestroyDebugUtilsMessengerEXT = reinterpret_cast<PFN_vkDestroyDebugUtilsMessengerEXT>( vkGetInstanceProcAddr(instance, \"vkDestroyDebugUtilsMessengerEXT\")); VK_TRACE(vkDestroyDebugUtilsMessengerEXT(instance, v, nullptr)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKDebugUtil_8h/","text":"src/ngfx/porting/vulkan/VKDebugUtil.h Namespaces Name ngfx Classes Name class ngfx::VKDebugMessenger Attributes Name const int VK_ENABLE_TRACE Defines Name VK_TRACE (func) V (func) Attributes Documentation variable VK_ENABLE_TRACE const int VK_ENABLE_TRACE = 0; VK_TRACE all Vulkan calls to log output Macro Documentation define VK_TRACE #define VK_TRACE( func ) { \\ if (VK_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ func; \\ } define V #define V( func ) { \\ if (VK_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ vkResult = func; \\ if (vkResult != VK_SUCCESS) { \\ NGFX_ERR(\"%s failed: %s\", #func, \\ VKDebugMessenger::inst.VkResultToString(vkResult)); \\ } \\ } Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include <cassert> #include <cstdarg> #include <vulkan/vulkan.h> const int VK_ENABLE_TRACE = 0; namespace ngfx { class VKDebugMessenger { public: void create(VkInstance instance, VkDebugReportFlagsEXT flags = VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT); void destroy(); const char *VkResultToString(VkResult errorCode); static VKDebugMessenger inst; private: VkInstance instance; VkDebugUtilsMessengerEXT v; }; }; // namespace ngfx #define VK_TRACE(func) \\ { \\ if (VK_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ func; \\ } #define V(func) \\ { \\ if (VK_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ vkResult = func; \\ if (vkResult != VK_SUCCESS) { \\ NGFX_ERR(\"%s failed: %s\", #func, \\ VKDebugMessenger::inst.VkResultToString(vkResult)); \\ } \\ } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKDebugUtil.h"},{"location":"api/Files/VKDebugUtil_8h/#srcngfxportingvulkanvkdebugutilh","text":"","title":"src/ngfx/porting/vulkan/VKDebugUtil.h"},{"location":"api/Files/VKDebugUtil_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKDebugUtil_8h/#classes","text":"Name class ngfx::VKDebugMessenger","title":"Classes"},{"location":"api/Files/VKDebugUtil_8h/#attributes","text":"Name const int VK_ENABLE_TRACE","title":"Attributes"},{"location":"api/Files/VKDebugUtil_8h/#defines","text":"Name VK_TRACE (func) V (func)","title":"Defines"},{"location":"api/Files/VKDebugUtil_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/VKDebugUtil_8h/#variable-vk_enable_trace","text":"const int VK_ENABLE_TRACE = 0; VK_TRACE all Vulkan calls to log output","title":"variable VK_ENABLE_TRACE"},{"location":"api/Files/VKDebugUtil_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/VKDebugUtil_8h/#define-vk_trace","text":"#define VK_TRACE( func ) { \\ if (VK_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ func; \\ }","title":"define VK_TRACE"},{"location":"api/Files/VKDebugUtil_8h/#define-v","text":"#define V( func ) { \\ if (VK_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ vkResult = func; \\ if (vkResult != VK_SUCCESS) { \\ NGFX_ERR(\"%s failed: %s\", #func, \\ VKDebugMessenger::inst.VkResultToString(vkResult)); \\ } \\ }","title":"define V"},{"location":"api/Files/VKDebugUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/core/DebugUtil.h\" #include <cassert> #include <cstdarg> #include <vulkan/vulkan.h> const int VK_ENABLE_TRACE = 0; namespace ngfx { class VKDebugMessenger { public: void create(VkInstance instance, VkDebugReportFlagsEXT flags = VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT); void destroy(); const char *VkResultToString(VkResult errorCode); static VKDebugMessenger inst; private: VkInstance instance; VkDebugUtilsMessengerEXT v; }; }; // namespace ngfx #define VK_TRACE(func) \\ { \\ if (VK_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ func; \\ } #define V(func) \\ { \\ if (VK_ENABLE_TRACE) \\ NGFX_LOG(\"%s\", #func); \\ vkResult = func; \\ if (vkResult != VK_SUCCESS) { \\ NGFX_ERR(\"%s failed: %s\", #func, \\ VKDebugMessenger::inst.VkResultToString(vkResult)); \\ } \\ } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKDescriptorSetLayoutCache_8cpp/","text":"src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKDescriptorSetLayoutCache::create(VkDevice device) { this->device = device; initDescriptorSetLayout(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER); initDescriptorSetLayout(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER); initDescriptorSetLayout(VK_DESCRIPTOR_TYPE_STORAGE_IMAGE); initDescriptorSetLayout(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER); } VKDescriptorSetLayoutCache::~VKDescriptorSetLayoutCache() { for (const auto &it : cache) { VK_TRACE(vkDestroyDescriptorSetLayout(device, it.second.layout, nullptr)); } } VkDescriptorSetLayout VKDescriptorSetLayoutCache::get(VkDescriptorType type, VkShaderStageFlags stageFlags) { return cache.at(type).layout; } void VKDescriptorSetLayoutCache::initDescriptorSetLayout( VkDescriptorType descriptorType) { VkResult vkResult; VKDescriptorSetLayoutData data; data.layoutBinding = {0, descriptorType, 1, VK_SHADER_STAGE_ALL, nullptr}; data.createInfo = {VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, nullptr, 0, 1, &data.layoutBinding}; V(vkCreateDescriptorSetLayout(device, &data.createInfo, nullptr, &data.layout)); cache[descriptorType] = std::move(data); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.cpp"},{"location":"api/Files/VKDescriptorSetLayoutCache_8cpp/#srcngfxportingvulkanvkdescriptorsetlayoutcachecpp","text":"","title":"src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.cpp"},{"location":"api/Files/VKDescriptorSetLayoutCache_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKDescriptorSetLayoutCache::create(VkDevice device) { this->device = device; initDescriptorSetLayout(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER); initDescriptorSetLayout(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER); initDescriptorSetLayout(VK_DESCRIPTOR_TYPE_STORAGE_IMAGE); initDescriptorSetLayout(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER); } VKDescriptorSetLayoutCache::~VKDescriptorSetLayoutCache() { for (const auto &it : cache) { VK_TRACE(vkDestroyDescriptorSetLayout(device, it.second.layout, nullptr)); } } VkDescriptorSetLayout VKDescriptorSetLayoutCache::get(VkDescriptorType type, VkShaderStageFlags stageFlags) { return cache.at(type).layout; } void VKDescriptorSetLayoutCache::initDescriptorSetLayout( VkDescriptorType descriptorType) { VkResult vkResult; VKDescriptorSetLayoutData data; data.layoutBinding = {0, descriptorType, 1, VK_SHADER_STAGE_ALL, nullptr}; data.createInfo = {VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, nullptr, 0, 1, &data.layoutBinding}; V(vkCreateDescriptorSetLayout(device, &data.createInfo, nullptr, &data.layout)); cache[descriptorType] = std::move(data); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKDescriptorSetLayoutCache_8h/","text":"src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h Namespaces Name ngfx Classes Name class ngfx::VKDescriptorSetLayoutCache Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <map> #include <vulkan/vulkan.h> namespace ngfx { class VKDescriptorSetLayoutCache { public: void create(VkDevice device); VkDescriptorSetLayout get(VkDescriptorType type, VkShaderStageFlags stageFlags = VK_SHADER_STAGE_ALL); ~VKDescriptorSetLayoutCache(); private: void initDescriptorSetLayout(VkDescriptorType descriptorType); struct VKDescriptorSetLayoutData { VkDescriptorSetLayoutCreateInfo createInfo; VkDescriptorSetLayout layout; VkDescriptorSetLayoutBinding layoutBinding; }; std::map<VkDescriptorType, VKDescriptorSetLayoutData> cache; VkDevice device; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h"},{"location":"api/Files/VKDescriptorSetLayoutCache_8h/#srcngfxportingvulkanvkdescriptorsetlayoutcacheh","text":"","title":"src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h"},{"location":"api/Files/VKDescriptorSetLayoutCache_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKDescriptorSetLayoutCache_8h/#classes","text":"Name class ngfx::VKDescriptorSetLayoutCache","title":"Classes"},{"location":"api/Files/VKDescriptorSetLayoutCache_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <map> #include <vulkan/vulkan.h> namespace ngfx { class VKDescriptorSetLayoutCache { public: void create(VkDevice device); VkDescriptorSetLayout get(VkDescriptorType type, VkShaderStageFlags stageFlags = VK_SHADER_STAGE_ALL); ~VKDescriptorSetLayoutCache(); private: void initDescriptorSetLayout(VkDescriptorType descriptorType); struct VKDescriptorSetLayoutData { VkDescriptorSetLayoutCreateInfo createInfo; VkDescriptorSetLayout layout; VkDescriptorSetLayoutBinding layoutBinding; }; std::map<VkDescriptorType, VKDescriptorSetLayoutData> cache; VkDevice device; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKDevice_8cpp/","text":"src/ngfx/porting/vulkan/VKDevice.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; uint32_t VKDevice::getQueueFamilyIndex(VkQueueFlags queueFlags) { auto queueFamilyProperties = vkPhysicalDevice->queueFamilyProperties; if (queueFlags & VK_QUEUE_COMPUTE_BIT) { // Try to find dedicated queue for compute for (uint32_t i = 0; i < queueFamilyProperties.size(); i++) { auto &props = queueFamilyProperties[i]; if ((props.queueFlags & queueFlags) && (!(props.queueFlags & VK_QUEUE_GRAPHICS_BIT))) { return i; break; } } } if (queueFlags & VK_QUEUE_TRANSFER_BIT) { // Try to find dedicated queue for transfer for (uint32_t i = 0; i < queueFamilyProperties.size(); i++) { auto &props = queueFamilyProperties[i]; if ((props.queueFlags & queueFlags) && (!(props.queueFlags & VK_QUEUE_GRAPHICS_BIT)) && (!(props.queueFlags & VK_QUEUE_COMPUTE_BIT))) { return i; break; } } } // Return the first queue to support the requested flags for (uint32_t i = 0; i < queueFamilyProperties.size(); i++) { if (queueFamilyProperties[i].queueFlags & queueFlags) { return i; break; } } NGFX_ERR(\"Could not find a matching queue family index\"); return 0; } void VKDevice::getQueueCreateInfos(VkQueueFlags requestedQueueTypes) { // Get queue family indices for the requested queue family types // Note that the indices may overlap depending on the implementation static const float defaultQueuePriority = 0.0f; // Graphics queue if (requestedQueueTypes & VK_QUEUE_GRAPHICS_BIT) { queueFamilyIndices.graphics = getQueueFamilyIndex(VK_QUEUE_GRAPHICS_BIT); VkDeviceQueueCreateInfo queueInfo{}; queueInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueInfo.queueFamilyIndex = queueFamilyIndices.graphics; queueInfo.queueCount = 1; queueInfo.pQueuePriorities = &defaultQueuePriority; queueCreateInfos.push_back(queueInfo); } else { queueFamilyIndices.graphics = VK_NULL_HANDLE; } // Compute queue if (requestedQueueTypes & VK_QUEUE_COMPUTE_BIT) { queueFamilyIndices.compute = getQueueFamilyIndex(VK_QUEUE_COMPUTE_BIT); if (queueFamilyIndices.compute != queueFamilyIndices.graphics) { // Found dedicated compute queue VkDeviceQueueCreateInfo queueInfo{}; queueInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueInfo.queueFamilyIndex = queueFamilyIndices.compute; queueInfo.queueCount = 1; queueInfo.pQueuePriorities = &defaultQueuePriority; queueCreateInfos.push_back(queueInfo); } } else { // Use the same queue queueFamilyIndices.compute = queueFamilyIndices.graphics; } // Transfer queue if (requestedQueueTypes & VK_QUEUE_TRANSFER_BIT) { queueFamilyIndices.transfer = getQueueFamilyIndex(VK_QUEUE_TRANSFER_BIT); if ((queueFamilyIndices.transfer != queueFamilyIndices.graphics) && (queueFamilyIndices.transfer != queueFamilyIndices.compute)) { // Found dedicated transfer queue VkDeviceQueueCreateInfo queueInfo{}; queueInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueInfo.queueFamilyIndex = queueFamilyIndices.transfer; queueInfo.queueCount = 1; queueInfo.pQueuePriorities = &defaultQueuePriority; queueCreateInfos.push_back(queueInfo); } } else { // Use the same queue queueFamilyIndices.transfer = queueFamilyIndices.graphics; } } void VKDevice::getDeviceExtensions() { deviceExtensions.push_back(VK_KHR_SWAPCHAIN_EXTENSION_NAME); deviceExtensions.push_back(VK_KHR_MAINTENANCE1_EXTENSION_NAME); // Enable the debug marker extension if it is present if (vkPhysicalDevice->extensionSupported( VK_EXT_DEBUG_MARKER_EXTENSION_NAME) && vkPhysicalDevice->extensionSupported( VK_EXT_DEBUG_REPORT_EXTENSION_NAME)) { deviceExtensions.push_back(VK_EXT_DEBUG_MARKER_EXTENSION_NAME); deviceExtensions.push_back(VK_EXT_DEBUG_REPORT_EXTENSION_NAME); enableDebugMarkers = true; } } void VKDevice::create(VKPhysicalDevice *vkPhysicalDevice) { VkResult vkResult; this->vkPhysicalDevice = vkPhysicalDevice; getQueueCreateInfos(); getDeviceExtensions(); createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()); ; createInfo.pQueueCreateInfos = queueCreateInfos.data(); createInfo.pEnabledFeatures = nullptr; createInfo.enabledExtensionCount = (uint32_t)deviceExtensions.size(); enabledDeviceExtensions.resize(deviceExtensions.size()); for (uint32_t j = 0; j < deviceExtensions.size(); j++) enabledDeviceExtensions[j] = deviceExtensions[j].c_str(); createInfo.ppEnabledExtensionNames = enabledDeviceExtensions.data(); V(vkCreateDevice(vkPhysicalDevice->v, &createInfo, nullptr, &v)); } void VKDevice::waitIdle() { VkResult vkResult; V(vkDeviceWaitIdle(v)); } VKDevice::~VKDevice() { if (v) VK_TRACE(vkDestroyDevice(v, nullptr)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKDevice.cpp"},{"location":"api/Files/VKDevice_8cpp/#srcngfxportingvulkanvkdevicecpp","text":"","title":"src/ngfx/porting/vulkan/VKDevice.cpp"},{"location":"api/Files/VKDevice_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; uint32_t VKDevice::getQueueFamilyIndex(VkQueueFlags queueFlags) { auto queueFamilyProperties = vkPhysicalDevice->queueFamilyProperties; if (queueFlags & VK_QUEUE_COMPUTE_BIT) { // Try to find dedicated queue for compute for (uint32_t i = 0; i < queueFamilyProperties.size(); i++) { auto &props = queueFamilyProperties[i]; if ((props.queueFlags & queueFlags) && (!(props.queueFlags & VK_QUEUE_GRAPHICS_BIT))) { return i; break; } } } if (queueFlags & VK_QUEUE_TRANSFER_BIT) { // Try to find dedicated queue for transfer for (uint32_t i = 0; i < queueFamilyProperties.size(); i++) { auto &props = queueFamilyProperties[i]; if ((props.queueFlags & queueFlags) && (!(props.queueFlags & VK_QUEUE_GRAPHICS_BIT)) && (!(props.queueFlags & VK_QUEUE_COMPUTE_BIT))) { return i; break; } } } // Return the first queue to support the requested flags for (uint32_t i = 0; i < queueFamilyProperties.size(); i++) { if (queueFamilyProperties[i].queueFlags & queueFlags) { return i; break; } } NGFX_ERR(\"Could not find a matching queue family index\"); return 0; } void VKDevice::getQueueCreateInfos(VkQueueFlags requestedQueueTypes) { // Get queue family indices for the requested queue family types // Note that the indices may overlap depending on the implementation static const float defaultQueuePriority = 0.0f; // Graphics queue if (requestedQueueTypes & VK_QUEUE_GRAPHICS_BIT) { queueFamilyIndices.graphics = getQueueFamilyIndex(VK_QUEUE_GRAPHICS_BIT); VkDeviceQueueCreateInfo queueInfo{}; queueInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueInfo.queueFamilyIndex = queueFamilyIndices.graphics; queueInfo.queueCount = 1; queueInfo.pQueuePriorities = &defaultQueuePriority; queueCreateInfos.push_back(queueInfo); } else { queueFamilyIndices.graphics = VK_NULL_HANDLE; } // Compute queue if (requestedQueueTypes & VK_QUEUE_COMPUTE_BIT) { queueFamilyIndices.compute = getQueueFamilyIndex(VK_QUEUE_COMPUTE_BIT); if (queueFamilyIndices.compute != queueFamilyIndices.graphics) { // Found dedicated compute queue VkDeviceQueueCreateInfo queueInfo{}; queueInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueInfo.queueFamilyIndex = queueFamilyIndices.compute; queueInfo.queueCount = 1; queueInfo.pQueuePriorities = &defaultQueuePriority; queueCreateInfos.push_back(queueInfo); } } else { // Use the same queue queueFamilyIndices.compute = queueFamilyIndices.graphics; } // Transfer queue if (requestedQueueTypes & VK_QUEUE_TRANSFER_BIT) { queueFamilyIndices.transfer = getQueueFamilyIndex(VK_QUEUE_TRANSFER_BIT); if ((queueFamilyIndices.transfer != queueFamilyIndices.graphics) && (queueFamilyIndices.transfer != queueFamilyIndices.compute)) { // Found dedicated transfer queue VkDeviceQueueCreateInfo queueInfo{}; queueInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueInfo.queueFamilyIndex = queueFamilyIndices.transfer; queueInfo.queueCount = 1; queueInfo.pQueuePriorities = &defaultQueuePriority; queueCreateInfos.push_back(queueInfo); } } else { // Use the same queue queueFamilyIndices.transfer = queueFamilyIndices.graphics; } } void VKDevice::getDeviceExtensions() { deviceExtensions.push_back(VK_KHR_SWAPCHAIN_EXTENSION_NAME); deviceExtensions.push_back(VK_KHR_MAINTENANCE1_EXTENSION_NAME); // Enable the debug marker extension if it is present if (vkPhysicalDevice->extensionSupported( VK_EXT_DEBUG_MARKER_EXTENSION_NAME) && vkPhysicalDevice->extensionSupported( VK_EXT_DEBUG_REPORT_EXTENSION_NAME)) { deviceExtensions.push_back(VK_EXT_DEBUG_MARKER_EXTENSION_NAME); deviceExtensions.push_back(VK_EXT_DEBUG_REPORT_EXTENSION_NAME); enableDebugMarkers = true; } } void VKDevice::create(VKPhysicalDevice *vkPhysicalDevice) { VkResult vkResult; this->vkPhysicalDevice = vkPhysicalDevice; getQueueCreateInfos(); getDeviceExtensions(); createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()); ; createInfo.pQueueCreateInfos = queueCreateInfos.data(); createInfo.pEnabledFeatures = nullptr; createInfo.enabledExtensionCount = (uint32_t)deviceExtensions.size(); enabledDeviceExtensions.resize(deviceExtensions.size()); for (uint32_t j = 0; j < deviceExtensions.size(); j++) enabledDeviceExtensions[j] = deviceExtensions[j].c_str(); createInfo.ppEnabledExtensionNames = enabledDeviceExtensions.data(); V(vkCreateDevice(vkPhysicalDevice->v, &createInfo, nullptr, &v)); } void VKDevice::waitIdle() { VkResult vkResult; V(vkDeviceWaitIdle(v)); } VKDevice::~VKDevice() { if (v) VK_TRACE(vkDestroyDevice(v, nullptr)); } Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKDevice_8h/","text":"src/ngfx/porting/vulkan/VKDevice.h Namespaces Name ngfx Classes Name class ngfx::VKDevice Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/porting/vulkan/VKPhysicalDevice.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <string> #include <vector> #include <vulkan/vulkan.h> namespace ngfx { class VKDevice : public Device { public: void create(VKPhysicalDevice *vkPhysicalDevice); virtual ~VKDevice(); void waitIdle(); std::vector<VkDeviceQueueCreateInfo> queueCreateInfos; struct { uint32_t graphics; uint32_t compute; uint32_t transfer; } queueFamilyIndices; VkDevice v = VK_NULL_HANDLE; bool enableDebugMarkers = false; std::vector<std::string> deviceExtensions; VKPhysicalDevice *vkPhysicalDevice; VkDeviceCreateInfo createInfo; std::vector<const char *> enabledDeviceExtensions; private: uint32_t getQueueFamilyIndex(VkQueueFlags queueFlags); void getQueueCreateInfos(VkQueueFlags requestedQueueTypes = VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT); void getDeviceExtensions(); }; VK_CAST(Device); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan/VKDevice.h"},{"location":"api/Files/VKDevice_8h/#srcngfxportingvulkanvkdeviceh","text":"","title":"src/ngfx/porting/vulkan/VKDevice.h"},{"location":"api/Files/VKDevice_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKDevice_8h/#classes","text":"Name class ngfx::VKDevice","title":"Classes"},{"location":"api/Files/VKDevice_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Device.h\" #include \"ngfx/porting/vulkan/VKPhysicalDevice.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <string> #include <vector> #include <vulkan/vulkan.h> namespace ngfx { class VKDevice : public Device { public: void create(VKPhysicalDevice *vkPhysicalDevice); virtual ~VKDevice(); void waitIdle(); std::vector<VkDeviceQueueCreateInfo> queueCreateInfos; struct { uint32_t graphics; uint32_t compute; uint32_t transfer; } queueFamilyIndices; VkDevice v = VK_NULL_HANDLE; bool enableDebugMarkers = false; std::vector<std::string> deviceExtensions; VKPhysicalDevice *vkPhysicalDevice; VkDeviceCreateInfo createInfo; std::vector<const char *> enabledDeviceExtensions; private: uint32_t getQueueFamilyIndex(VkQueueFlags queueFlags); void getQueueCreateInfos(VkQueueFlags requestedQueueTypes = VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT); void getDeviceExtensions(); }; VK_CAST(Device); } // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/VKFence_8cpp/","text":"src/ngfx/porting/vulkan/VKFence.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKFence.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKFence::create(VkDevice device, VkFenceCreateFlags flags) { this->device = device; VkResult vkResult; createInfo = {VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, nullptr, flags}; V(vkCreateFence(device, &createInfo, nullptr, &v)); } VKFence::~VKFence() { if (v) VK_TRACE(vkDestroyFence(device, v, nullptr)); } void VKFence::wait() { VkResult vkResult; V(vkWaitForFences(device, 1, &v, VK_TRUE, UINT64_MAX)); } void VKFence::reset() { VkResult vkResult; V(vkResetFences(device, 1, &v)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKFence.cpp"},{"location":"api/Files/VKFence_8cpp/#srcngfxportingvulkanvkfencecpp","text":"","title":"src/ngfx/porting/vulkan/VKFence.cpp"},{"location":"api/Files/VKFence_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKFence.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKFence::create(VkDevice device, VkFenceCreateFlags flags) { this->device = device; VkResult vkResult; createInfo = {VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, nullptr, flags}; V(vkCreateFence(device, &createInfo, nullptr, &v)); } VKFence::~VKFence() { if (v) VK_TRACE(vkDestroyFence(device, v, nullptr)); } void VKFence::wait() { VkResult vkResult; V(vkWaitForFences(device, 1, &v, VK_TRUE, UINT64_MAX)); } void VKFence::reset() { VkResult vkResult; V(vkResetFences(device, 1, &v)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKFence_8h/","text":"src/ngfx/porting/vulkan/VKFence.h Namespaces Name ngfx Classes Name class ngfx::VKFence Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Fence.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKFence : public Fence { public: void create(VkDevice device, VkFenceCreateFlags flags = 0); virtual ~VKFence(); virtual void wait(); virtual void reset(); VkFence v = VK_NULL_HANDLE; VkFenceCreateInfo createInfo; private: VkDevice device; }; VK_CAST(Fence); }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKFence.h"},{"location":"api/Files/VKFence_8h/#srcngfxportingvulkanvkfenceh","text":"","title":"src/ngfx/porting/vulkan/VKFence.h"},{"location":"api/Files/VKFence_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKFence_8h/#classes","text":"Name class ngfx::VKFence","title":"Classes"},{"location":"api/Files/VKFence_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Fence.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKFence : public Fence { public: void create(VkDevice device, VkFenceCreateFlags flags = 0); virtual ~VKFence(); virtual void wait(); virtual void reset(); VkFence v = VK_NULL_HANDLE; VkFenceCreateInfo createInfo; private: VkDevice device; }; VK_CAST(Fence); }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKFramebuffer_8cpp/","text":"src/ngfx/porting/vulkan/VKFramebuffer.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKFramebuffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKRenderPass.h\" #include \"ngfx/porting/vulkan/VKTexture.h\" using namespace ngfx; void VKFramebuffer::create( VkDevice device, VkRenderPass renderPass, const std::vector<VKAttachmentDescriptor> &attachments, uint32_t w, uint32_t h, uint32_t layers) { this->device = device; VkResult vkResult; this->numAttachments = attachments.size(); this->w = w; this->h = h; this->layers = layers; vkAttachments.resize(attachments.size()); vkAttachmentInfos.resize(attachments.size()); for (uint32_t j = 0; j < attachments.size(); j++) { vkAttachments[j] = attachments[j].imageView->v; vkAttachmentInfos[j] = attachments[j].info; } createInfo = {VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, NULL, 0, renderPass, uint32_t(vkAttachments.size()), vkAttachments.data(), w, h, layers}; V(vkCreateFramebuffer(device, &createInfo, nullptr, &v)); } VKFramebuffer::~VKFramebuffer() { if (v) VK_TRACE(vkDestroyFramebuffer(device, v, nullptr)); } Framebuffer *Framebuffer::create(Device *device, RenderPass *renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers) { VKFramebuffer *vkFramebuffer = new VKFramebuffer(); vkFramebuffer->attachments = attachments; std::vector<VKFramebuffer::VKAttachmentDescriptor> vkAttachments( attachments.size()); for (int j = 0; j < vkAttachments.size(); j++) { auto &attachment = attachments[j]; auto vkTexture = vk(attachment.texture); auto &vkAttachment = vkAttachments[j]; vkAttachment.info = {VkImageUsageFlags(vkTexture->imageUsageFlags)}; vkAttachment.imageView = vkTexture->getImageView( VK_IMAGE_VIEW_TYPE_2D, 1, 1, attachment.level, attachment.layer); } vkFramebuffer->create(vk(device)->v, vk(renderPass)->v, vkAttachments, w, h, layers); return vkFramebuffer; } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKFramebuffer.cpp"},{"location":"api/Files/VKFramebuffer_8cpp/#srcngfxportingvulkanvkframebuffercpp","text":"","title":"src/ngfx/porting/vulkan/VKFramebuffer.cpp"},{"location":"api/Files/VKFramebuffer_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKFramebuffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKRenderPass.h\" #include \"ngfx/porting/vulkan/VKTexture.h\" using namespace ngfx; void VKFramebuffer::create( VkDevice device, VkRenderPass renderPass, const std::vector<VKAttachmentDescriptor> &attachments, uint32_t w, uint32_t h, uint32_t layers) { this->device = device; VkResult vkResult; this->numAttachments = attachments.size(); this->w = w; this->h = h; this->layers = layers; vkAttachments.resize(attachments.size()); vkAttachmentInfos.resize(attachments.size()); for (uint32_t j = 0; j < attachments.size(); j++) { vkAttachments[j] = attachments[j].imageView->v; vkAttachmentInfos[j] = attachments[j].info; } createInfo = {VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, NULL, 0, renderPass, uint32_t(vkAttachments.size()), vkAttachments.data(), w, h, layers}; V(vkCreateFramebuffer(device, &createInfo, nullptr, &v)); } VKFramebuffer::~VKFramebuffer() { if (v) VK_TRACE(vkDestroyFramebuffer(device, v, nullptr)); } Framebuffer *Framebuffer::create(Device *device, RenderPass *renderPass, const std::vector<Attachment> &attachments, uint32_t w, uint32_t h, uint32_t layers) { VKFramebuffer *vkFramebuffer = new VKFramebuffer(); vkFramebuffer->attachments = attachments; std::vector<VKFramebuffer::VKAttachmentDescriptor> vkAttachments( attachments.size()); for (int j = 0; j < vkAttachments.size(); j++) { auto &attachment = attachments[j]; auto vkTexture = vk(attachment.texture); auto &vkAttachment = vkAttachments[j]; vkAttachment.info = {VkImageUsageFlags(vkTexture->imageUsageFlags)}; vkAttachment.imageView = vkTexture->getImageView( VK_IMAGE_VIEW_TYPE_2D, 1, 1, attachment.level, attachment.layer); } vkFramebuffer->create(vk(device)->v, vk(renderPass)->v, vkAttachments, w, h, layers); return vkFramebuffer; } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKFramebuffer_8h/","text":"src/ngfx/porting/vulkan/VKFramebuffer.h Namespaces Name ngfx Classes Name class ngfx::VKFramebuffer struct ngfx::VKFramebuffer::VKAttachmentInfo struct ngfx::VKFramebuffer::VKAttachmentDescriptor Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/porting/vulkan/VKImageView.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vector> namespace ngfx { class VKFramebuffer : public Framebuffer { public: struct VKAttachmentInfo { VkImageUsageFlags imageUsageFlags; }; struct VKAttachmentDescriptor { VKImageView *imageView = nullptr; VKAttachmentInfo info; }; void create(VkDevice, VkRenderPass renderPass, const std::vector<VKAttachmentDescriptor> &attachments, uint32_t w, uint32_t h, uint32_t layers = 1); virtual ~VKFramebuffer(); VkFramebuffer v = VK_NULL_HANDLE; std::vector<VkImageView> vkAttachments; std::vector<VKAttachmentInfo> vkAttachmentInfos; VkFramebufferCreateInfo createInfo; private: VkDevice device; }; VK_CAST(Framebuffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKFramebuffer.h"},{"location":"api/Files/VKFramebuffer_8h/#srcngfxportingvulkanvkframebufferh","text":"","title":"src/ngfx/porting/vulkan/VKFramebuffer.h"},{"location":"api/Files/VKFramebuffer_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKFramebuffer_8h/#classes","text":"Name class ngfx::VKFramebuffer struct ngfx::VKFramebuffer::VKAttachmentInfo struct ngfx::VKFramebuffer::VKAttachmentDescriptor","title":"Classes"},{"location":"api/Files/VKFramebuffer_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Framebuffer.h\" #include \"ngfx/porting/vulkan/VKImageView.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vector> namespace ngfx { class VKFramebuffer : public Framebuffer { public: struct VKAttachmentInfo { VkImageUsageFlags imageUsageFlags; }; struct VKAttachmentDescriptor { VKImageView *imageView = nullptr; VKAttachmentInfo info; }; void create(VkDevice, VkRenderPass renderPass, const std::vector<VKAttachmentDescriptor> &attachments, uint32_t w, uint32_t h, uint32_t layers = 1); virtual ~VKFramebuffer(); VkFramebuffer v = VK_NULL_HANDLE; std::vector<VkImageView> vkAttachments; std::vector<VKAttachmentInfo> vkAttachmentInfos; VkFramebufferCreateInfo createInfo; private: VkDevice device; }; VK_CAST(Framebuffer); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKGraphicsContext_8cpp/","text":"src/ngfx/porting/vulkan/VKGraphicsContext.cpp Defines Name MAX_DESCRIPTOR_SETS MAX_DESCRIPTORS Macro Documentation define MAX_DESCRIPTOR_SETS #define MAX_DESCRIPTOR_SETS MAX_DESCRIPTORS * 4 define MAX_DESCRIPTORS #define MAX_DESCRIPTORS 1024 Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" using namespace ngfx; using namespace std; #define MAX_DESCRIPTOR_SETS MAX_DESCRIPTORS * 4 #define MAX_DESCRIPTORS 1024 void VKGraphicsContext::create(const char *appName, bool enableDepthStencil, bool debug) { this->debug = debug; vkInstance.create(appName, \"Graphics Abstraction Engine\", 0, debug); auto instance = vkInstance.v; if (debug) VKDebugMessenger::inst.create(instance); vkPhysicalDevice.create(instance); vkDevice.create(&vkPhysicalDevice); vkCommandPool.create(vkDevice.v, vkDevice.queueFamilyIndices.graphics); vkQueue.create(this, vkDevice.queueFamilyIndices.graphics, 0); initDescriptorPool(); vkDescriptorSetLayoutCache.create(vkDevice.v); this->enableDepthStencil = enableDepthStencil; depthFormat = PixelFormat(vkPhysicalDevice.depthFormat); } VKGraphicsContext::~VKGraphicsContext() { VK_TRACE(vkDestroyDescriptorPool(vkDevice.v, vkDescriptorPool, nullptr)); if (debug) VKDebugMessenger::inst.destroy(); } void VKGraphicsContext::initDescriptorPool() { VkResult vkResult; descriptorPoolSizes = { {VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, MAX_DESCRIPTORS}, {VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, MAX_DESCRIPTORS}, {VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, MAX_DESCRIPTORS}, {VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, MAX_DESCRIPTORS}}; descriptorPoolCreateInfo = {VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, nullptr, 0, MAX_DESCRIPTOR_SETS, uint32_t(descriptorPoolSizes.size()), descriptorPoolSizes.data()}; V(vkCreateDescriptorPool(vkDevice.v, &descriptorPoolCreateInfo, nullptr, &vkDescriptorPool)); }; RenderPass *VKGraphicsContext::getRenderPass(RenderPassConfig config) { for (auto &r : vkRenderPassCache) { if (r->config == config) return &r->vkRenderPass; } auto renderPassData = make_unique<VKRenderPassData>(); initRenderPass(config, renderPassData->vkRenderPass); auto result = &renderPassData->vkRenderPass; vkRenderPassCache.emplace_back(std::move(renderPassData)); return result; } void VKGraphicsContext::initRenderPass(const RenderPassConfig &config, VKRenderPass &renderPass) { std::vector<VkAttachmentDescription> attachments; uint32_t depthAttachmentBaseIndex = 0; for (uint32_t j = 0; j < config.numColorAttachments(); j++) { auto &colorAttachmentDesc = config.colorAttachmentDescriptions[j]; VkFormat colorFormat = VkFormat(colorAttachmentDesc.format); VkImageLayout initialLayout = (colorAttachmentDesc.initialLayout) ? VkImageLayout(*colorAttachmentDesc.initialLayout) : VK_IMAGE_LAYOUT_UNDEFINED; VkImageLayout finalLayout = (colorAttachmentDesc.finalLayout) ? VkImageLayout(*colorAttachmentDesc.finalLayout) : VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; attachments.push_back( {0, colorFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, initialLayout, finalLayout}); } auto &depthStencilAttachmentDesc = config.depthStencilAttachmentDescription; if (depthStencilAttachmentDesc) { depthAttachmentBaseIndex = attachments.size(); VkFormat depthFormat = VkFormat(depthStencilAttachmentDesc->format); VkImageLayout initialLayout = (depthStencilAttachmentDesc->initialLayout) ? VkImageLayout(*depthStencilAttachmentDesc->initialLayout) : VK_IMAGE_LAYOUT_UNDEFINED; VkImageLayout finalLayout = (depthStencilAttachmentDesc->finalLayout) ? VkImageLayout(*depthStencilAttachmentDesc->finalLayout) : VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL; attachments.push_back( {0, depthFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, initialLayout, finalLayout}); } std::vector<VkAttachmentReference> colorReferences( config.numColorAttachments()); for (uint32_t j = 0; j < colorReferences.size(); j++) { colorReferences[j] = {j, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL}; } VkAttachmentReference depthReference = { depthAttachmentBaseIndex, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL}; std::vector<VkSubpassDescription> subpasses = { {0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0, nullptr, uint32_t(colorReferences.size()), colorReferences.data(), nullptr, config.depthStencilAttachmentDescription ? &depthReference : nullptr, 0, nullptr}}; // Subpass dependencies for layout transitions std::vector<VkSubpassDependency> dependencies = { {VK_SUBPASS_EXTERNAL, 0, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_MEMORY_READ_BIT, VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_DEPENDENCY_BY_REGION_BIT}, {0, VK_SUBPASS_EXTERNAL, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_ACCESS_MEMORY_READ_BIT, VK_DEPENDENCY_BY_REGION_BIT}}; renderPass.create(vkDevice.v, attachments, subpasses, dependencies); } #if 0 void VKGraphicsContext::initRenderPassMSAA(const RenderPassConfig &config, VKRenderPass& renderPass) { std::vector<VkAttachmentDescription> attachments; uint32_t depthAttachmentBaseIndex = 0; for (uint32_t j = 0; j<config.numColorAttachments(); j++) { auto &colorAttachmentDesc = config.colorAttachmentDescriptions[j]; VkFormat colorFormat = VkFormat(colorAttachmentDesc.format); attachments.push_back({ 0, colorFormat, VkSampleCountFlagBits(config.numSamples), VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }); attachments.push_back({ 0, colorFormat, VkSampleCountFlagBits(1), VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR }); } if (config.depthStencilAttachmentDescription) { depthAttachmentBaseIndex = attachments.size(); VkFormat depthFormat = VkFormat(config.depthStencilAttachmentDescription->format); attachments.push_back({ 0, depthFormat, VkSampleCountFlagBits(config.numSamples), VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }); if (config.enableDepthStencilResolve) { attachments.push_back({ 0, depthFormat, VkSampleCountFlagBits(1), VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }); } } std::vector<VkAttachmentReference> colorReferences(config.numColorAttachments()); for (uint32_t j = 0; j<colorReferences.size(); j++) { colorReferences[j] = { 2 * j, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; } std::vector<VkAttachmentReference> resolveReferences(config.numColorAttachments()); for (uint32_t j = 0; j<resolveReferences.size(); j++) { resolveReferences[j] = { 2 * j + 1, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; } VkAttachmentReference depthReference = { depthAttachmentBaseIndex, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }; std::vector<VkSubpassDescription> subpasses = { { 0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0, nullptr, uint32_t(colorReferences.size()), colorReferences.data(), resolveReferences.data(), config.depthStencilAttachmentDescription ? &depthReference : nullptr, 0, nullptr } }; // Subpass dependencies for layout transitions std::vector<VkSubpassDependency> dependencies = { { VK_SUBPASS_EXTERNAL, 0, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_MEMORY_READ_BIT, VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_DEPENDENCY_BY_REGION_BIT }, { 0, VK_SUBPASS_EXTERNAL, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_ACCESS_MEMORY_READ_BIT, VK_DEPENDENCY_BY_REGION_BIT } }; renderPass.create(vkDevice.v, attachments, subpasses, dependencies); } void VKGraphicsContext::initOffscreenRenderPass(const RenderPassConfig &config, VKRenderPass& renderPass) { VkFormat colorFormat = VkFormat(defaultOffscreenSurfaceFormat), depthFormat = vkPhysicalDevice.depthFormat; std::vector<VkAttachmentDescription> attachments; uint32_t depthAttachmentBaseIndex = 0; for (uint32_t j = 0; j<config.numColorAttachments(); j++) { attachments.push_back({ 0, colorFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }); } if (config.depthStencilAttachmentDescription) { depthAttachmentBaseIndex = attachments.size(); attachments.push_back({ 0, depthFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }); } std::vector<VkAttachmentReference> colorReferences(config.numColorAttachments()); for (uint32_t j = 0; j<colorReferences.size(); j++) { colorReferences[j] = { j, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; } VkAttachmentReference depthReference = { depthAttachmentBaseIndex, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }; std::vector<VkSubpassDescription> subpasses = { { 0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0, nullptr, uint32_t(colorReferences.size()), colorReferences.data(), nullptr, config.depthStencilAttachmentDescription ? &depthReference : nullptr, 0, nullptr } }; // Subpass dependencies for layout transitions std::vector<VkSubpassDependency> dependencies = { { VK_SUBPASS_EXTERNAL, 0, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_SHADER_READ_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_DEPENDENCY_BY_REGION_BIT }, { 0, VK_SUBPASS_EXTERNAL, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_ACCESS_SHADER_READ_BIT, VK_DEPENDENCY_BY_REGION_BIT } }; renderPass.create(vkDevice.v, attachments, subpasses, dependencies); } void VKGraphicsContext::initOffscreenRenderPassMSAA(const RenderPassConfig &config, VKRenderPass& renderPass) { VkFormat colorFormat = VkFormat(defaultOffscreenSurfaceFormat), depthFormat = vkPhysicalDevice.depthFormat; std::vector<VkAttachmentDescription> attachments; uint32_t depthAttachmentBaseIndex = 0; for (uint32_t j = 0; j<config.numColorAttachments(); j++) { attachments.push_back({ 0, colorFormat, VkSampleCountFlagBits(config.numSamples), VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }); attachments.push_back({ 0, colorFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }); } if (config.depthStencilAttachmentDescription) { depthAttachmentBaseIndex = attachments.size(); attachments.push_back({ 0, depthFormat, VkSampleCountFlagBits(config.numSamples), VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }); if (config.enableDepthStencilResolve) { attachments.push_back({ 0, depthFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }); } } std::vector<VkAttachmentReference> colorReferences(config.numColorAttachments()); for (uint32_t j = 0; j<colorReferences.size(); j++) { colorReferences[j] = { 2 * j, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; } std::vector<VkAttachmentReference> resolveReferences(config.numColorAttachments()); for (uint32_t j = 0; j<resolveReferences.size(); j++) { resolveReferences[j] = { 2 * j + 1, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; } VkAttachmentReference depthReference = { depthAttachmentBaseIndex, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }; std::vector<VkSubpassDescription> subpasses = { { 0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0, nullptr, uint32_t(colorReferences.size()), colorReferences.data(), resolveReferences.data(), config.depthStencilAttachmentDescription ? &depthReference : nullptr, 0, nullptr } }; // Subpass dependencies for layout transitions std::vector<VkSubpassDependency> dependencies = { { VK_SUBPASS_EXTERNAL, 0, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_SHADER_READ_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_DEPENDENCY_BY_REGION_BIT }, { 0, VK_SUBPASS_EXTERNAL, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_ACCESS_SHADER_READ_BIT, VK_DEPENDENCY_BY_REGION_BIT } }; renderPass.create(vkDevice.v, attachments, subpasses, dependencies); } #endif void VKGraphicsContext::createSwapchainFramebuffers(int w, int h) { // Create frame buffers for every swap chain image vkSwapchainFramebuffers.resize(vkSwapchain->numImages); for (uint32_t i = 0; i < vkSwapchainFramebuffers.size(); i++) { std::vector<VKFramebuffer::VKAttachmentDescriptor> attachments; if (numSamples != 1) attachments.push_back({&vkMultisampleColorImageView, {vkMultisampleColorImage.createInfo.usage}}); attachments.push_back( {&vkSwapchain->imageViews[i], {VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT}}); if (enableDepthStencil) { if (numSamples != 1) attachments.push_back({&vkMultisampleDepthImageView, {vkMultisampleDepthImage.createInfo.usage}}); attachments.push_back( {&vkDepthStencilImageView, {vkDepthStencilImage.createInfo.usage}}); } vkSwapchainFramebuffers[i].create(vkDevice.v, vkDefaultRenderPass->v, attachments, w, h); } } void VKGraphicsContext::initSemaphores(VkDevice device) { vkPresentCompleteSemaphore.create(device); vkRenderCompleteSemaphore.create(device); } void VKGraphicsContext::initFences(VkDevice device) { vkWaitFences.resize(numDrawCommandBuffers); for (auto &fence : vkWaitFences) fence.create(device, VK_FENCE_CREATE_SIGNALED_BIT); vkComputeFence.create(device); } void VKGraphicsContext::setSurface(Surface *surface) { if (surface && !surface->offscreen) { offscreen = false; vkSwapchain = make_unique<VKSwapchain>(this, vk(surface)); surfaceFormat = PixelFormat(vkSwapchain->surfaceFormat.format); numDrawCommandBuffers = vkSwapchain->numImages; } else { offscreen = true; numDrawCommandBuffers = 1; } vkDrawCommandBuffers.resize(numDrawCommandBuffers); for (auto &cmdBuffer : vkDrawCommandBuffers) { cmdBuffer.create(vkDevice.v, vkCommandPool.v); } vkCopyCommandBuffer.create(vkDevice.v, vkCommandPool.v); vkComputeCommandBuffer.create(vkDevice.v, vkCommandPool.v); if (surface && numSamples != 1) { msColorImageCreateInfo = {}; msColorImageCreateInfo.format = VkFormat(surfaceFormat); msColorImageCreateInfo.extent = {surface->w, surface->h, 1}; msColorImageCreateInfo.samples = VkSampleCountFlagBits(numSamples); msColorImageCreateInfo.usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT; vkMultisampleColorImage.create(&vkDevice, msColorImageCreateInfo); // TODO: use // VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT // on mobile GPU vkMultisampleColorImageView.create(vkDevice.v, vkMultisampleColorImage.v, VK_IMAGE_VIEW_TYPE_2D, VkFormat(surfaceFormat)); } if (surface && enableDepthStencil) { vkDepthStencilImage.create(&vkDevice, {surface->w, surface->h, 1}, vkPhysicalDevice.depthFormat, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT); vkDepthStencilImageView.create( vkDevice.v, vkDepthStencilImage.v, VK_IMAGE_VIEW_TYPE_2D, vkPhysicalDevice.depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT); if (numSamples != 1) { msDepthImageCreateInfo = {}; msDepthImageCreateInfo.format = vkPhysicalDevice.depthFormat; msDepthImageCreateInfo.extent = {surface->w, surface->h, 1}; msDepthImageCreateInfo.samples = VkSampleCountFlagBits(numSamples); msDepthImageCreateInfo.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT; vkMultisampleDepthImage.create(&vkDevice, msDepthImageCreateInfo); // TODO: use // VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT // on mobile GPU vkMultisampleDepthImageView.create( vkDevice.v, vkMultisampleDepthImage.v, VK_IMAGE_VIEW_TYPE_2D, vkPhysicalDevice.depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT); } } std::optional<AttachmentDescription> depthAttachmentDescription; if (enableDepthStencil) depthAttachmentDescription = {depthFormat}; else depthAttachmentDescription = nullopt; if (surface && !surface->offscreen) { RenderPassConfig onscreenRenderPassConfig = { {{surfaceFormat, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_PRESENT_SRC}}, depthAttachmentDescription, false, numSamples}; vkDefaultRenderPass = (VKRenderPass *)getRenderPass(onscreenRenderPassConfig); } defaultOffscreenSurfaceFormat = PixelFormat(VK_FORMAT_R8G8B8A8_UNORM); RenderPassConfig offscreenRenderPassConfig = { {{defaultOffscreenSurfaceFormat}}, depthAttachmentDescription, false, numSamples}; vkDefaultOffscreenRenderPass = (VKRenderPass *)getRenderPass(offscreenRenderPassConfig); vkPipelineCache.create(vkDevice.v); if (surface && !surface->offscreen) createSwapchainFramebuffers(surface->w, surface->h); initSemaphores(vkDevice.v); initFences(vkDevice.v); createBindings(); pipelineCache = &vkPipelineCache; } CommandBuffer *VKGraphicsContext::drawCommandBuffer(int32_t index) { if (index == -1) index = currentImageIndex; return &vkDrawCommandBuffers[index]; } CommandBuffer *VKGraphicsContext::copyCommandBuffer() { return &vkCopyCommandBuffer; } CommandBuffer *VKGraphicsContext::computeCommandBuffer() { return &vkComputeCommandBuffer; } void VKGraphicsContext::createBindings() { device = &vkDevice; queue = &vkQueue; defaultRenderPass = offscreen ? vkDefaultOffscreenRenderPass : vkDefaultRenderPass; defaultOffscreenRenderPass = vkDefaultOffscreenRenderPass; swapchain = vkSwapchain.get(); frameFences.resize(vkWaitFences.size()); for (size_t j = 0; j < vkWaitFences.size(); j++) frameFences[j] = &vkWaitFences[j]; computeFence = &vkComputeFence; swapchainFramebuffers.resize(vkSwapchainFramebuffers.size()); for (size_t j = 0; j < vkSwapchainFramebuffers.size(); j++) swapchainFramebuffers[j] = &vkSwapchainFramebuffers[j]; presentCompleteSemaphore = &vkPresentCompleteSemaphore; renderCompleteSemaphore = &vkRenderCompleteSemaphore; } GraphicsContext *GraphicsContext::create(const char *appName, bool enableDepthStencil, bool debug) { NGFX_LOG(\"debug: %s\", (debug) ? \"true\" : \"false\"); auto vkGraphicsContext = new VKGraphicsContext(); vkGraphicsContext->create(appName, enableDepthStencil, debug); return vkGraphicsContext; } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKGraphicsContext.cpp"},{"location":"api/Files/VKGraphicsContext_8cpp/#srcngfxportingvulkanvkgraphicscontextcpp","text":"","title":"src/ngfx/porting/vulkan/VKGraphicsContext.cpp"},{"location":"api/Files/VKGraphicsContext_8cpp/#defines","text":"Name MAX_DESCRIPTOR_SETS MAX_DESCRIPTORS","title":"Defines"},{"location":"api/Files/VKGraphicsContext_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/VKGraphicsContext_8cpp/#define-max_descriptor_sets","text":"#define MAX_DESCRIPTOR_SETS MAX_DESCRIPTORS * 4","title":"define MAX_DESCRIPTOR_SETS"},{"location":"api/Files/VKGraphicsContext_8cpp/#define-max_descriptors","text":"#define MAX_DESCRIPTORS 1024","title":"define MAX_DESCRIPTORS"},{"location":"api/Files/VKGraphicsContext_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" using namespace ngfx; using namespace std; #define MAX_DESCRIPTOR_SETS MAX_DESCRIPTORS * 4 #define MAX_DESCRIPTORS 1024 void VKGraphicsContext::create(const char *appName, bool enableDepthStencil, bool debug) { this->debug = debug; vkInstance.create(appName, \"Graphics Abstraction Engine\", 0, debug); auto instance = vkInstance.v; if (debug) VKDebugMessenger::inst.create(instance); vkPhysicalDevice.create(instance); vkDevice.create(&vkPhysicalDevice); vkCommandPool.create(vkDevice.v, vkDevice.queueFamilyIndices.graphics); vkQueue.create(this, vkDevice.queueFamilyIndices.graphics, 0); initDescriptorPool(); vkDescriptorSetLayoutCache.create(vkDevice.v); this->enableDepthStencil = enableDepthStencil; depthFormat = PixelFormat(vkPhysicalDevice.depthFormat); } VKGraphicsContext::~VKGraphicsContext() { VK_TRACE(vkDestroyDescriptorPool(vkDevice.v, vkDescriptorPool, nullptr)); if (debug) VKDebugMessenger::inst.destroy(); } void VKGraphicsContext::initDescriptorPool() { VkResult vkResult; descriptorPoolSizes = { {VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, MAX_DESCRIPTORS}, {VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, MAX_DESCRIPTORS}, {VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, MAX_DESCRIPTORS}, {VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, MAX_DESCRIPTORS}}; descriptorPoolCreateInfo = {VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, nullptr, 0, MAX_DESCRIPTOR_SETS, uint32_t(descriptorPoolSizes.size()), descriptorPoolSizes.data()}; V(vkCreateDescriptorPool(vkDevice.v, &descriptorPoolCreateInfo, nullptr, &vkDescriptorPool)); }; RenderPass *VKGraphicsContext::getRenderPass(RenderPassConfig config) { for (auto &r : vkRenderPassCache) { if (r->config == config) return &r->vkRenderPass; } auto renderPassData = make_unique<VKRenderPassData>(); initRenderPass(config, renderPassData->vkRenderPass); auto result = &renderPassData->vkRenderPass; vkRenderPassCache.emplace_back(std::move(renderPassData)); return result; } void VKGraphicsContext::initRenderPass(const RenderPassConfig &config, VKRenderPass &renderPass) { std::vector<VkAttachmentDescription> attachments; uint32_t depthAttachmentBaseIndex = 0; for (uint32_t j = 0; j < config.numColorAttachments(); j++) { auto &colorAttachmentDesc = config.colorAttachmentDescriptions[j]; VkFormat colorFormat = VkFormat(colorAttachmentDesc.format); VkImageLayout initialLayout = (colorAttachmentDesc.initialLayout) ? VkImageLayout(*colorAttachmentDesc.initialLayout) : VK_IMAGE_LAYOUT_UNDEFINED; VkImageLayout finalLayout = (colorAttachmentDesc.finalLayout) ? VkImageLayout(*colorAttachmentDesc.finalLayout) : VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; attachments.push_back( {0, colorFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, initialLayout, finalLayout}); } auto &depthStencilAttachmentDesc = config.depthStencilAttachmentDescription; if (depthStencilAttachmentDesc) { depthAttachmentBaseIndex = attachments.size(); VkFormat depthFormat = VkFormat(depthStencilAttachmentDesc->format); VkImageLayout initialLayout = (depthStencilAttachmentDesc->initialLayout) ? VkImageLayout(*depthStencilAttachmentDesc->initialLayout) : VK_IMAGE_LAYOUT_UNDEFINED; VkImageLayout finalLayout = (depthStencilAttachmentDesc->finalLayout) ? VkImageLayout(*depthStencilAttachmentDesc->finalLayout) : VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL; attachments.push_back( {0, depthFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, initialLayout, finalLayout}); } std::vector<VkAttachmentReference> colorReferences( config.numColorAttachments()); for (uint32_t j = 0; j < colorReferences.size(); j++) { colorReferences[j] = {j, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL}; } VkAttachmentReference depthReference = { depthAttachmentBaseIndex, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL}; std::vector<VkSubpassDescription> subpasses = { {0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0, nullptr, uint32_t(colorReferences.size()), colorReferences.data(), nullptr, config.depthStencilAttachmentDescription ? &depthReference : nullptr, 0, nullptr}}; // Subpass dependencies for layout transitions std::vector<VkSubpassDependency> dependencies = { {VK_SUBPASS_EXTERNAL, 0, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_MEMORY_READ_BIT, VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_DEPENDENCY_BY_REGION_BIT}, {0, VK_SUBPASS_EXTERNAL, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_ACCESS_MEMORY_READ_BIT, VK_DEPENDENCY_BY_REGION_BIT}}; renderPass.create(vkDevice.v, attachments, subpasses, dependencies); } #if 0 void VKGraphicsContext::initRenderPassMSAA(const RenderPassConfig &config, VKRenderPass& renderPass) { std::vector<VkAttachmentDescription> attachments; uint32_t depthAttachmentBaseIndex = 0; for (uint32_t j = 0; j<config.numColorAttachments(); j++) { auto &colorAttachmentDesc = config.colorAttachmentDescriptions[j]; VkFormat colorFormat = VkFormat(colorAttachmentDesc.format); attachments.push_back({ 0, colorFormat, VkSampleCountFlagBits(config.numSamples), VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }); attachments.push_back({ 0, colorFormat, VkSampleCountFlagBits(1), VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_PRESENT_SRC_KHR }); } if (config.depthStencilAttachmentDescription) { depthAttachmentBaseIndex = attachments.size(); VkFormat depthFormat = VkFormat(config.depthStencilAttachmentDescription->format); attachments.push_back({ 0, depthFormat, VkSampleCountFlagBits(config.numSamples), VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }); if (config.enableDepthStencilResolve) { attachments.push_back({ 0, depthFormat, VkSampleCountFlagBits(1), VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }); } } std::vector<VkAttachmentReference> colorReferences(config.numColorAttachments()); for (uint32_t j = 0; j<colorReferences.size(); j++) { colorReferences[j] = { 2 * j, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; } std::vector<VkAttachmentReference> resolveReferences(config.numColorAttachments()); for (uint32_t j = 0; j<resolveReferences.size(); j++) { resolveReferences[j] = { 2 * j + 1, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; } VkAttachmentReference depthReference = { depthAttachmentBaseIndex, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }; std::vector<VkSubpassDescription> subpasses = { { 0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0, nullptr, uint32_t(colorReferences.size()), colorReferences.data(), resolveReferences.data(), config.depthStencilAttachmentDescription ? &depthReference : nullptr, 0, nullptr } }; // Subpass dependencies for layout transitions std::vector<VkSubpassDependency> dependencies = { { VK_SUBPASS_EXTERNAL, 0, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_MEMORY_READ_BIT, VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_DEPENDENCY_BY_REGION_BIT }, { 0, VK_SUBPASS_EXTERNAL, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_ACCESS_MEMORY_READ_BIT, VK_DEPENDENCY_BY_REGION_BIT } }; renderPass.create(vkDevice.v, attachments, subpasses, dependencies); } void VKGraphicsContext::initOffscreenRenderPass(const RenderPassConfig &config, VKRenderPass& renderPass) { VkFormat colorFormat = VkFormat(defaultOffscreenSurfaceFormat), depthFormat = vkPhysicalDevice.depthFormat; std::vector<VkAttachmentDescription> attachments; uint32_t depthAttachmentBaseIndex = 0; for (uint32_t j = 0; j<config.numColorAttachments(); j++) { attachments.push_back({ 0, colorFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }); } if (config.depthStencilAttachmentDescription) { depthAttachmentBaseIndex = attachments.size(); attachments.push_back({ 0, depthFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }); } std::vector<VkAttachmentReference> colorReferences(config.numColorAttachments()); for (uint32_t j = 0; j<colorReferences.size(); j++) { colorReferences[j] = { j, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; } VkAttachmentReference depthReference = { depthAttachmentBaseIndex, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }; std::vector<VkSubpassDescription> subpasses = { { 0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0, nullptr, uint32_t(colorReferences.size()), colorReferences.data(), nullptr, config.depthStencilAttachmentDescription ? &depthReference : nullptr, 0, nullptr } }; // Subpass dependencies for layout transitions std::vector<VkSubpassDependency> dependencies = { { VK_SUBPASS_EXTERNAL, 0, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_SHADER_READ_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_DEPENDENCY_BY_REGION_BIT }, { 0, VK_SUBPASS_EXTERNAL, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_ACCESS_SHADER_READ_BIT, VK_DEPENDENCY_BY_REGION_BIT } }; renderPass.create(vkDevice.v, attachments, subpasses, dependencies); } void VKGraphicsContext::initOffscreenRenderPassMSAA(const RenderPassConfig &config, VKRenderPass& renderPass) { VkFormat colorFormat = VkFormat(defaultOffscreenSurfaceFormat), depthFormat = vkPhysicalDevice.depthFormat; std::vector<VkAttachmentDescription> attachments; uint32_t depthAttachmentBaseIndex = 0; for (uint32_t j = 0; j<config.numColorAttachments(); j++) { attachments.push_back({ 0, colorFormat, VkSampleCountFlagBits(config.numSamples), VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }); attachments.push_back({ 0, colorFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }); } if (config.depthStencilAttachmentDescription) { depthAttachmentBaseIndex = attachments.size(); attachments.push_back({ 0, depthFormat, VkSampleCountFlagBits(config.numSamples), VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }); if (config.enableDepthStencilResolve) { attachments.push_back({ 0, depthFormat, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }); } } std::vector<VkAttachmentReference> colorReferences(config.numColorAttachments()); for (uint32_t j = 0; j<colorReferences.size(); j++) { colorReferences[j] = { 2 * j, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; } std::vector<VkAttachmentReference> resolveReferences(config.numColorAttachments()); for (uint32_t j = 0; j<resolveReferences.size(); j++) { resolveReferences[j] = { 2 * j + 1, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; } VkAttachmentReference depthReference = { depthAttachmentBaseIndex, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }; std::vector<VkSubpassDescription> subpasses = { { 0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0, nullptr, uint32_t(colorReferences.size()), colorReferences.data(), resolveReferences.data(), config.depthStencilAttachmentDescription ? &depthReference : nullptr, 0, nullptr } }; // Subpass dependencies for layout transitions std::vector<VkSubpassDependency> dependencies = { { VK_SUBPASS_EXTERNAL, 0, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_ACCESS_SHADER_READ_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_DEPENDENCY_BY_REGION_BIT }, { 0, VK_SUBPASS_EXTERNAL, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_ACCESS_SHADER_READ_BIT, VK_DEPENDENCY_BY_REGION_BIT } }; renderPass.create(vkDevice.v, attachments, subpasses, dependencies); } #endif void VKGraphicsContext::createSwapchainFramebuffers(int w, int h) { // Create frame buffers for every swap chain image vkSwapchainFramebuffers.resize(vkSwapchain->numImages); for (uint32_t i = 0; i < vkSwapchainFramebuffers.size(); i++) { std::vector<VKFramebuffer::VKAttachmentDescriptor> attachments; if (numSamples != 1) attachments.push_back({&vkMultisampleColorImageView, {vkMultisampleColorImage.createInfo.usage}}); attachments.push_back( {&vkSwapchain->imageViews[i], {VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT}}); if (enableDepthStencil) { if (numSamples != 1) attachments.push_back({&vkMultisampleDepthImageView, {vkMultisampleDepthImage.createInfo.usage}}); attachments.push_back( {&vkDepthStencilImageView, {vkDepthStencilImage.createInfo.usage}}); } vkSwapchainFramebuffers[i].create(vkDevice.v, vkDefaultRenderPass->v, attachments, w, h); } } void VKGraphicsContext::initSemaphores(VkDevice device) { vkPresentCompleteSemaphore.create(device); vkRenderCompleteSemaphore.create(device); } void VKGraphicsContext::initFences(VkDevice device) { vkWaitFences.resize(numDrawCommandBuffers); for (auto &fence : vkWaitFences) fence.create(device, VK_FENCE_CREATE_SIGNALED_BIT); vkComputeFence.create(device); } void VKGraphicsContext::setSurface(Surface *surface) { if (surface && !surface->offscreen) { offscreen = false; vkSwapchain = make_unique<VKSwapchain>(this, vk(surface)); surfaceFormat = PixelFormat(vkSwapchain->surfaceFormat.format); numDrawCommandBuffers = vkSwapchain->numImages; } else { offscreen = true; numDrawCommandBuffers = 1; } vkDrawCommandBuffers.resize(numDrawCommandBuffers); for (auto &cmdBuffer : vkDrawCommandBuffers) { cmdBuffer.create(vkDevice.v, vkCommandPool.v); } vkCopyCommandBuffer.create(vkDevice.v, vkCommandPool.v); vkComputeCommandBuffer.create(vkDevice.v, vkCommandPool.v); if (surface && numSamples != 1) { msColorImageCreateInfo = {}; msColorImageCreateInfo.format = VkFormat(surfaceFormat); msColorImageCreateInfo.extent = {surface->w, surface->h, 1}; msColorImageCreateInfo.samples = VkSampleCountFlagBits(numSamples); msColorImageCreateInfo.usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT; vkMultisampleColorImage.create(&vkDevice, msColorImageCreateInfo); // TODO: use // VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT // on mobile GPU vkMultisampleColorImageView.create(vkDevice.v, vkMultisampleColorImage.v, VK_IMAGE_VIEW_TYPE_2D, VkFormat(surfaceFormat)); } if (surface && enableDepthStencil) { vkDepthStencilImage.create(&vkDevice, {surface->w, surface->h, 1}, vkPhysicalDevice.depthFormat, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT); vkDepthStencilImageView.create( vkDevice.v, vkDepthStencilImage.v, VK_IMAGE_VIEW_TYPE_2D, vkPhysicalDevice.depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT); if (numSamples != 1) { msDepthImageCreateInfo = {}; msDepthImageCreateInfo.format = vkPhysicalDevice.depthFormat; msDepthImageCreateInfo.extent = {surface->w, surface->h, 1}; msDepthImageCreateInfo.samples = VkSampleCountFlagBits(numSamples); msDepthImageCreateInfo.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT; vkMultisampleDepthImage.create(&vkDevice, msDepthImageCreateInfo); // TODO: use // VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT // on mobile GPU vkMultisampleDepthImageView.create( vkDevice.v, vkMultisampleDepthImage.v, VK_IMAGE_VIEW_TYPE_2D, vkPhysicalDevice.depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT); } } std::optional<AttachmentDescription> depthAttachmentDescription; if (enableDepthStencil) depthAttachmentDescription = {depthFormat}; else depthAttachmentDescription = nullopt; if (surface && !surface->offscreen) { RenderPassConfig onscreenRenderPassConfig = { {{surfaceFormat, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_PRESENT_SRC}}, depthAttachmentDescription, false, numSamples}; vkDefaultRenderPass = (VKRenderPass *)getRenderPass(onscreenRenderPassConfig); } defaultOffscreenSurfaceFormat = PixelFormat(VK_FORMAT_R8G8B8A8_UNORM); RenderPassConfig offscreenRenderPassConfig = { {{defaultOffscreenSurfaceFormat}}, depthAttachmentDescription, false, numSamples}; vkDefaultOffscreenRenderPass = (VKRenderPass *)getRenderPass(offscreenRenderPassConfig); vkPipelineCache.create(vkDevice.v); if (surface && !surface->offscreen) createSwapchainFramebuffers(surface->w, surface->h); initSemaphores(vkDevice.v); initFences(vkDevice.v); createBindings(); pipelineCache = &vkPipelineCache; } CommandBuffer *VKGraphicsContext::drawCommandBuffer(int32_t index) { if (index == -1) index = currentImageIndex; return &vkDrawCommandBuffers[index]; } CommandBuffer *VKGraphicsContext::copyCommandBuffer() { return &vkCopyCommandBuffer; } CommandBuffer *VKGraphicsContext::computeCommandBuffer() { return &vkComputeCommandBuffer; } void VKGraphicsContext::createBindings() { device = &vkDevice; queue = &vkQueue; defaultRenderPass = offscreen ? vkDefaultOffscreenRenderPass : vkDefaultRenderPass; defaultOffscreenRenderPass = vkDefaultOffscreenRenderPass; swapchain = vkSwapchain.get(); frameFences.resize(vkWaitFences.size()); for (size_t j = 0; j < vkWaitFences.size(); j++) frameFences[j] = &vkWaitFences[j]; computeFence = &vkComputeFence; swapchainFramebuffers.resize(vkSwapchainFramebuffers.size()); for (size_t j = 0; j < vkSwapchainFramebuffers.size(); j++) swapchainFramebuffers[j] = &vkSwapchainFramebuffers[j]; presentCompleteSemaphore = &vkPresentCompleteSemaphore; renderCompleteSemaphore = &vkRenderCompleteSemaphore; } GraphicsContext *GraphicsContext::create(const char *appName, bool enableDepthStencil, bool debug) { NGFX_LOG(\"debug: %s\", (debug) ? \"true\" : \"false\"); auto vkGraphicsContext = new VKGraphicsContext(); vkGraphicsContext->create(appName, enableDepthStencil, debug); return vkGraphicsContext; } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKGraphicsContext_8h/","text":"src/ngfx/porting/vulkan/VKGraphicsContext.h Namespaces Name ngfx Classes Name class ngfx::VKGraphicsContext struct ngfx::VKGraphicsContext::VKRenderPassData Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/graphics/Window.h\" #include \"ngfx/porting/vulkan/VKCommandBuffer.h\" #include \"ngfx/porting/vulkan/VKCommandPool.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKFence.h\" #include \"ngfx/porting/vulkan/VKFramebuffer.h\" #include \"ngfx/porting/vulkan/VKImage.h\" #include \"ngfx/porting/vulkan/VKInstance.h\" #include \"ngfx/porting/vulkan/VKPhysicalDevice.h\" #include \"ngfx/porting/vulkan/VKPipelineCache.h\" #include \"ngfx/porting/vulkan/VKQueue.h\" #include \"ngfx/porting/vulkan/VKRenderPass.h\" #include \"ngfx/porting/vulkan/VKSemaphore.h\" #include \"ngfx/porting/vulkan/VKSwapchain.h\" //#define ENABLE_DEPTH_STENCIL namespace ngfx { class VKGraphicsContext : public GraphicsContext { public: void create(const char *appName, bool enableDepthStencil, bool debug); virtual ~VKGraphicsContext(); void setSurface(Surface *surface) override; CommandBuffer *drawCommandBuffer(int32_t index = -1) override; CommandBuffer *copyCommandBuffer() override; CommandBuffer *computeCommandBuffer() override; void createBindings(); VKInstance vkInstance; VKPhysicalDevice vkPhysicalDevice; VKDevice vkDevice; VKCommandPool vkCommandPool; VKQueue vkQueue; std::unique_ptr<VKSwapchain> vkSwapchain; std::vector<VKCommandBuffer> vkDrawCommandBuffers; VKCommandBuffer vkCopyCommandBuffer, vkComputeCommandBuffer; VKImage vkDepthStencilImage, vkMultisampleColorImage, vkMultisampleDepthImage; VKImageView vkDepthStencilImageView, vkMultisampleColorImageView, vkMultisampleDepthImageView; struct VKRenderPassData { RenderPassConfig config; VKRenderPass vkRenderPass; }; RenderPass *getRenderPass(RenderPassConfig config) override; std::vector<std::unique_ptr<VKRenderPassData>> vkRenderPassCache; VKRenderPass *vkDefaultRenderPass = nullptr, *vkDefaultOffscreenRenderPass = nullptr; VKPipelineCache vkPipelineCache; std::vector<VKFramebuffer> vkSwapchainFramebuffers; std::vector<VKFence> vkWaitFences; VKFence vkComputeFence; VKSemaphore vkPresentCompleteSemaphore, vkRenderCompleteSemaphore; VkDescriptorPool vkDescriptorPool; VKDescriptorSetLayoutCache vkDescriptorSetLayoutCache; bool offscreen = true; uint32_t numSamples = 1; std::vector<VkDescriptorPoolSize> descriptorPoolSizes; VkDescriptorPoolCreateInfo descriptorPoolCreateInfo; VKImageCreateInfo msColorImageCreateInfo; VKImageCreateInfo msDepthImageCreateInfo; private: void initDescriptorPool(); void initRenderPass(const RenderPassConfig &config, VKRenderPass &renderPass); void initRenderPassMSAA(const RenderPassConfig &config, VKRenderPass &renderPass); void initOffscreenRenderPass(const RenderPassConfig &config, VKRenderPass &renderPass); void initOffscreenRenderPassMSAA(const RenderPassConfig &config, VKRenderPass &renderPass); void createSwapchainFramebuffers(int w, int h); void initSemaphores(VkDevice device); void initFences(VkDevice device); }; inline VKGraphicsContext *vk(GraphicsContext *g) { return (VKGraphicsContext *)g; } } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKGraphicsContext.h"},{"location":"api/Files/VKGraphicsContext_8h/#srcngfxportingvulkanvkgraphicscontexth","text":"","title":"src/ngfx/porting/vulkan/VKGraphicsContext.h"},{"location":"api/Files/VKGraphicsContext_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKGraphicsContext_8h/#classes","text":"Name class ngfx::VKGraphicsContext struct ngfx::VKGraphicsContext::VKRenderPassData","title":"Classes"},{"location":"api/Files/VKGraphicsContext_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/graphics/Window.h\" #include \"ngfx/porting/vulkan/VKCommandBuffer.h\" #include \"ngfx/porting/vulkan/VKCommandPool.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKFence.h\" #include \"ngfx/porting/vulkan/VKFramebuffer.h\" #include \"ngfx/porting/vulkan/VKImage.h\" #include \"ngfx/porting/vulkan/VKInstance.h\" #include \"ngfx/porting/vulkan/VKPhysicalDevice.h\" #include \"ngfx/porting/vulkan/VKPipelineCache.h\" #include \"ngfx/porting/vulkan/VKQueue.h\" #include \"ngfx/porting/vulkan/VKRenderPass.h\" #include \"ngfx/porting/vulkan/VKSemaphore.h\" #include \"ngfx/porting/vulkan/VKSwapchain.h\" //#define ENABLE_DEPTH_STENCIL namespace ngfx { class VKGraphicsContext : public GraphicsContext { public: void create(const char *appName, bool enableDepthStencil, bool debug); virtual ~VKGraphicsContext(); void setSurface(Surface *surface) override; CommandBuffer *drawCommandBuffer(int32_t index = -1) override; CommandBuffer *copyCommandBuffer() override; CommandBuffer *computeCommandBuffer() override; void createBindings(); VKInstance vkInstance; VKPhysicalDevice vkPhysicalDevice; VKDevice vkDevice; VKCommandPool vkCommandPool; VKQueue vkQueue; std::unique_ptr<VKSwapchain> vkSwapchain; std::vector<VKCommandBuffer> vkDrawCommandBuffers; VKCommandBuffer vkCopyCommandBuffer, vkComputeCommandBuffer; VKImage vkDepthStencilImage, vkMultisampleColorImage, vkMultisampleDepthImage; VKImageView vkDepthStencilImageView, vkMultisampleColorImageView, vkMultisampleDepthImageView; struct VKRenderPassData { RenderPassConfig config; VKRenderPass vkRenderPass; }; RenderPass *getRenderPass(RenderPassConfig config) override; std::vector<std::unique_ptr<VKRenderPassData>> vkRenderPassCache; VKRenderPass *vkDefaultRenderPass = nullptr, *vkDefaultOffscreenRenderPass = nullptr; VKPipelineCache vkPipelineCache; std::vector<VKFramebuffer> vkSwapchainFramebuffers; std::vector<VKFence> vkWaitFences; VKFence vkComputeFence; VKSemaphore vkPresentCompleteSemaphore, vkRenderCompleteSemaphore; VkDescriptorPool vkDescriptorPool; VKDescriptorSetLayoutCache vkDescriptorSetLayoutCache; bool offscreen = true; uint32_t numSamples = 1; std::vector<VkDescriptorPoolSize> descriptorPoolSizes; VkDescriptorPoolCreateInfo descriptorPoolCreateInfo; VKImageCreateInfo msColorImageCreateInfo; VKImageCreateInfo msDepthImageCreateInfo; private: void initDescriptorPool(); void initRenderPass(const RenderPassConfig &config, VKRenderPass &renderPass); void initRenderPassMSAA(const RenderPassConfig &config, VKRenderPass &renderPass); void initOffscreenRenderPass(const RenderPassConfig &config, VKRenderPass &renderPass); void initOffscreenRenderPassMSAA(const RenderPassConfig &config, VKRenderPass &renderPass); void createSwapchainFramebuffers(int w, int h); void initSemaphores(VkDevice device); void initFences(VkDevice device); }; inline VKGraphicsContext *vk(GraphicsContext *g) { return (VKGraphicsContext *)g; } } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKGraphicsCore_8h/","text":"src/ngfx/porting/vulkan/VKGraphicsCore.h Namespaces Name ngfx Defines Name VK (s) DEFINE_PIXELFORMATS (s, t0, t1) DEFINE_VERTEXFORMATS (s, t0, t1) Macro Documentation define VK #define VK( s ) s = VK_##s define DEFINE_PIXELFORMATS #define DEFINE_PIXELFORMATS( s, t0, t1 ) PIXELFORMAT_R##s##_##t0 = VK_FORMAT_R##s##_##t1, \\ PIXELFORMAT_RG##s##_##t0 = VK_FORMAT_R##s##G##s##_##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = VK_FORMAT_R##s##G##s##B##s##A##s##_##t1 define DEFINE_VERTEXFORMATS #define DEFINE_VERTEXFORMATS( s, t0, t1 ) VERTEXFORMAT_##t0 = VK_FORMAT_R##s##_##t1, \\ VERTEXFORMAT_##t0##2 = VK_FORMAT_R##s##G##s##_##t1, \\ VERTEXFORMAT_##t0##3 = VK_FORMAT_R##s##G##s##B##s##_##t1, \\ VERTEXFORMAT_##t0##4 = VK_FORMAT_R##s##G##s##B##s##A##s##_##t1 Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <vulkan/vulkan.h> namespace ngfx { #define VK(s) s = VK_##s enum PrimitiveTopology { VK(PRIMITIVE_TOPOLOGY_POINT_LIST), VK(PRIMITIVE_TOPOLOGY_LINE_LIST), VK(PRIMITIVE_TOPOLOGY_LINE_STRIP), VK(PRIMITIVE_TOPOLOGY_TRIANGLE_LIST), VK(PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP) }; enum PolygonMode { VK(POLYGON_MODE_FILL), VK(POLYGON_MODE_LINE), VK(POLYGON_MODE_POINT) }; enum BlendFactor { VK(BLEND_FACTOR_ZERO), VK(BLEND_FACTOR_ONE), VK(BLEND_FACTOR_SRC_COLOR), VK(BLEND_FACTOR_ONE_MINUS_SRC_COLOR), VK(BLEND_FACTOR_DST_COLOR), VK(BLEND_FACTOR_ONE_MINUS_DST_COLOR), VK(BLEND_FACTOR_SRC_ALPHA), VK(BLEND_FACTOR_ONE_MINUS_SRC_ALPHA), VK(BLEND_FACTOR_DST_ALPHA), VK(BLEND_FACTOR_ONE_MINUS_DST_ALPHA), VK(BLEND_FACTOR_CONSTANT_COLOR), VK(BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR), VK(BLEND_FACTOR_CONSTANT_ALPHA), VK(BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA), VK(BLEND_FACTOR_SRC_ALPHA_SATURATE), }; enum BlendOp { VK(BLEND_OP_ADD), VK(BLEND_OP_SUBTRACT), VK(BLEND_OP_REVERSE_SUBTRACT), VK(BLEND_OP_MIN), VK(BLEND_OP_MAX) }; enum BufferUsageFlagBits { VK(BUFFER_USAGE_TRANSFER_SRC_BIT), VK(BUFFER_USAGE_TRANSFER_DST_BIT), VK(BUFFER_USAGE_UNIFORM_BUFFER_BIT), VK(BUFFER_USAGE_STORAGE_BUFFER_BIT), VK(BUFFER_USAGE_VERTEX_BUFFER_BIT), VK(BUFFER_USAGE_INDEX_BUFFER_BIT) }; enum ColorComponentFlagBits { VK(COLOR_COMPONENT_R_BIT), VK(COLOR_COMPONENT_G_BIT), VK(COLOR_COMPONENT_B_BIT), VK(COLOR_COMPONENT_A_BIT) }; enum CommandBufferLevel { VK(COMMAND_BUFFER_LEVEL_PRIMARY), VK(COMMAND_BUFFER_LEVEL_SECONDARY) }; enum CullModeFlags { VK(CULL_MODE_NONE), VK(CULL_MODE_FRONT_BIT), VK(CULL_MODE_BACK_BIT), VK(CULL_MODE_FRONT_AND_BACK) }; enum FenceCreateFlagBits { VK(FENCE_CREATE_SIGNALED_BIT), }; enum FrontFace { VK(FRONT_FACE_COUNTER_CLOCKWISE), VK(FRONT_FACE_CLOCKWISE) }; enum TextureType { TEXTURE_TYPE_2D = VK_IMAGE_VIEW_TYPE_2D, TEXTURE_TYPE_3D = VK_IMAGE_TYPE_3D, TEXTURE_TYPE_CUBE = VK_IMAGE_VIEW_TYPE_CUBE, TEXTURE_TYPE_2D_ARRAY = VK_IMAGE_VIEW_TYPE_2D_ARRAY }; enum ImageUsageFlagBits { VK(IMAGE_USAGE_TRANSFER_SRC_BIT), VK(IMAGE_USAGE_TRANSFER_DST_BIT), VK(IMAGE_USAGE_SAMPLED_BIT), VK(IMAGE_USAGE_STORAGE_BIT), VK(IMAGE_USAGE_COLOR_ATTACHMENT_BIT), VK(IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT), VK(IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT), VK(IMAGE_USAGE_INPUT_ATTACHMENT_BIT), }; enum PipelineStageFlagBits { VK(PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT) }; enum ShaderStageFlagBits { VK(SHADER_STAGE_VERTEX_BIT), VK(SHADER_STAGE_TESSELLATION_CONTROL_BIT), VK(SHADER_STAGE_TESSELLATION_EVALUATION_BIT), VK(SHADER_STAGE_GEOMETRY_BIT), VK(SHADER_STAGE_FRAGMENT_BIT), VK(SHADER_STAGE_COMPUTE_BIT), VK(SHADER_STAGE_ALL_GRAPHICS), VK(SHADER_STAGE_ALL) }; #define DEFINE_PIXELFORMATS(s, t0, t1) \\ PIXELFORMAT_R##s##_##t0 = VK_FORMAT_R##s##_##t1, \\ PIXELFORMAT_RG##s##_##t0 = VK_FORMAT_R##s##G##s##_##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = VK_FORMAT_R##s##G##s##B##s##A##s##_##t1 enum PixelFormat { PIXELFORMAT_UNDEFINED = VK_FORMAT_UNDEFINED, DEFINE_PIXELFORMATS(8, UNORM, UNORM), DEFINE_PIXELFORMATS(16, UINT, UINT), DEFINE_PIXELFORMATS(16, SFLOAT, SFLOAT), DEFINE_PIXELFORMATS(32, UINT, UINT), DEFINE_PIXELFORMATS(32, SFLOAT, SFLOAT), PIXELFORMAT_BGRA8_UNORM = VK_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = VK_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = VK_FORMAT_X8_D24_UNORM_PACK32, PIXELFORMAT_D24_UNORM_S8 = VK_FORMAT_D24_UNORM_S8_UINT }; enum IndexFormat { INDEXFORMAT_UINT16 = VK_INDEX_TYPE_UINT16, INDEXFORMAT_UINT32 = VK_INDEX_TYPE_UINT32 }; #define DEFINE_VERTEXFORMATS(s, t0, t1) \\ VERTEXFORMAT_##t0 = VK_FORMAT_R##s##_##t1, \\ VERTEXFORMAT_##t0##2 = VK_FORMAT_R##s##G##s##_##t1, \\ VERTEXFORMAT_##t0##3 = VK_FORMAT_R##s##G##s##B##s##_##t1, \\ VERTEXFORMAT_##t0##4 = VK_FORMAT_R##s##G##s##B##s##A##s##_##t1 enum VertexFormat { DEFINE_VERTEXFORMATS(32, FLOAT, SFLOAT) }; enum DescriptorType { VK(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), VK(DESCRIPTOR_TYPE_STORAGE_IMAGE), VK(DESCRIPTOR_TYPE_UNIFORM_BUFFER), VK(DESCRIPTOR_TYPE_STORAGE_BUFFER) }; enum VertexInputRate { VK(VERTEX_INPUT_RATE_VERTEX), VK(VERTEX_INPUT_RATE_INSTANCE) }; enum FilterMode { VK(FILTER_NEAREST), VK(FILTER_LINEAR) }; enum ImageLayout { VK(IMAGE_LAYOUT_UNDEFINED), VK(IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL), VK(IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL), VK(IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL), VK(IMAGE_LAYOUT_GENERAL), IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKGraphicsCore.h"},{"location":"api/Files/VKGraphicsCore_8h/#srcngfxportingvulkanvkgraphicscoreh","text":"","title":"src/ngfx/porting/vulkan/VKGraphicsCore.h"},{"location":"api/Files/VKGraphicsCore_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKGraphicsCore_8h/#defines","text":"Name VK (s) DEFINE_PIXELFORMATS (s, t0, t1) DEFINE_VERTEXFORMATS (s, t0, t1)","title":"Defines"},{"location":"api/Files/VKGraphicsCore_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/VKGraphicsCore_8h/#define-vk","text":"#define VK( s ) s = VK_##s","title":"define VK"},{"location":"api/Files/VKGraphicsCore_8h/#define-define_pixelformats","text":"#define DEFINE_PIXELFORMATS( s, t0, t1 ) PIXELFORMAT_R##s##_##t0 = VK_FORMAT_R##s##_##t1, \\ PIXELFORMAT_RG##s##_##t0 = VK_FORMAT_R##s##G##s##_##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = VK_FORMAT_R##s##G##s##B##s##A##s##_##t1","title":"define DEFINE_PIXELFORMATS"},{"location":"api/Files/VKGraphicsCore_8h/#define-define_vertexformats","text":"#define DEFINE_VERTEXFORMATS( s, t0, t1 ) VERTEXFORMAT_##t0 = VK_FORMAT_R##s##_##t1, \\ VERTEXFORMAT_##t0##2 = VK_FORMAT_R##s##G##s##_##t1, \\ VERTEXFORMAT_##t0##3 = VK_FORMAT_R##s##G##s##B##s##_##t1, \\ VERTEXFORMAT_##t0##4 = VK_FORMAT_R##s##G##s##B##s##A##s##_##t1","title":"define DEFINE_VERTEXFORMATS"},{"location":"api/Files/VKGraphicsCore_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <vulkan/vulkan.h> namespace ngfx { #define VK(s) s = VK_##s enum PrimitiveTopology { VK(PRIMITIVE_TOPOLOGY_POINT_LIST), VK(PRIMITIVE_TOPOLOGY_LINE_LIST), VK(PRIMITIVE_TOPOLOGY_LINE_STRIP), VK(PRIMITIVE_TOPOLOGY_TRIANGLE_LIST), VK(PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP) }; enum PolygonMode { VK(POLYGON_MODE_FILL), VK(POLYGON_MODE_LINE), VK(POLYGON_MODE_POINT) }; enum BlendFactor { VK(BLEND_FACTOR_ZERO), VK(BLEND_FACTOR_ONE), VK(BLEND_FACTOR_SRC_COLOR), VK(BLEND_FACTOR_ONE_MINUS_SRC_COLOR), VK(BLEND_FACTOR_DST_COLOR), VK(BLEND_FACTOR_ONE_MINUS_DST_COLOR), VK(BLEND_FACTOR_SRC_ALPHA), VK(BLEND_FACTOR_ONE_MINUS_SRC_ALPHA), VK(BLEND_FACTOR_DST_ALPHA), VK(BLEND_FACTOR_ONE_MINUS_DST_ALPHA), VK(BLEND_FACTOR_CONSTANT_COLOR), VK(BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR), VK(BLEND_FACTOR_CONSTANT_ALPHA), VK(BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA), VK(BLEND_FACTOR_SRC_ALPHA_SATURATE), }; enum BlendOp { VK(BLEND_OP_ADD), VK(BLEND_OP_SUBTRACT), VK(BLEND_OP_REVERSE_SUBTRACT), VK(BLEND_OP_MIN), VK(BLEND_OP_MAX) }; enum BufferUsageFlagBits { VK(BUFFER_USAGE_TRANSFER_SRC_BIT), VK(BUFFER_USAGE_TRANSFER_DST_BIT), VK(BUFFER_USAGE_UNIFORM_BUFFER_BIT), VK(BUFFER_USAGE_STORAGE_BUFFER_BIT), VK(BUFFER_USAGE_VERTEX_BUFFER_BIT), VK(BUFFER_USAGE_INDEX_BUFFER_BIT) }; enum ColorComponentFlagBits { VK(COLOR_COMPONENT_R_BIT), VK(COLOR_COMPONENT_G_BIT), VK(COLOR_COMPONENT_B_BIT), VK(COLOR_COMPONENT_A_BIT) }; enum CommandBufferLevel { VK(COMMAND_BUFFER_LEVEL_PRIMARY), VK(COMMAND_BUFFER_LEVEL_SECONDARY) }; enum CullModeFlags { VK(CULL_MODE_NONE), VK(CULL_MODE_FRONT_BIT), VK(CULL_MODE_BACK_BIT), VK(CULL_MODE_FRONT_AND_BACK) }; enum FenceCreateFlagBits { VK(FENCE_CREATE_SIGNALED_BIT), }; enum FrontFace { VK(FRONT_FACE_COUNTER_CLOCKWISE), VK(FRONT_FACE_CLOCKWISE) }; enum TextureType { TEXTURE_TYPE_2D = VK_IMAGE_VIEW_TYPE_2D, TEXTURE_TYPE_3D = VK_IMAGE_TYPE_3D, TEXTURE_TYPE_CUBE = VK_IMAGE_VIEW_TYPE_CUBE, TEXTURE_TYPE_2D_ARRAY = VK_IMAGE_VIEW_TYPE_2D_ARRAY }; enum ImageUsageFlagBits { VK(IMAGE_USAGE_TRANSFER_SRC_BIT), VK(IMAGE_USAGE_TRANSFER_DST_BIT), VK(IMAGE_USAGE_SAMPLED_BIT), VK(IMAGE_USAGE_STORAGE_BIT), VK(IMAGE_USAGE_COLOR_ATTACHMENT_BIT), VK(IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT), VK(IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT), VK(IMAGE_USAGE_INPUT_ATTACHMENT_BIT), }; enum PipelineStageFlagBits { VK(PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT) }; enum ShaderStageFlagBits { VK(SHADER_STAGE_VERTEX_BIT), VK(SHADER_STAGE_TESSELLATION_CONTROL_BIT), VK(SHADER_STAGE_TESSELLATION_EVALUATION_BIT), VK(SHADER_STAGE_GEOMETRY_BIT), VK(SHADER_STAGE_FRAGMENT_BIT), VK(SHADER_STAGE_COMPUTE_BIT), VK(SHADER_STAGE_ALL_GRAPHICS), VK(SHADER_STAGE_ALL) }; #define DEFINE_PIXELFORMATS(s, t0, t1) \\ PIXELFORMAT_R##s##_##t0 = VK_FORMAT_R##s##_##t1, \\ PIXELFORMAT_RG##s##_##t0 = VK_FORMAT_R##s##G##s##_##t1, \\ PIXELFORMAT_RGBA##s##_##t0 = VK_FORMAT_R##s##G##s##B##s##A##s##_##t1 enum PixelFormat { PIXELFORMAT_UNDEFINED = VK_FORMAT_UNDEFINED, DEFINE_PIXELFORMATS(8, UNORM, UNORM), DEFINE_PIXELFORMATS(16, UINT, UINT), DEFINE_PIXELFORMATS(16, SFLOAT, SFLOAT), DEFINE_PIXELFORMATS(32, UINT, UINT), DEFINE_PIXELFORMATS(32, SFLOAT, SFLOAT), PIXELFORMAT_BGRA8_UNORM = VK_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = VK_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = VK_FORMAT_X8_D24_UNORM_PACK32, PIXELFORMAT_D24_UNORM_S8 = VK_FORMAT_D24_UNORM_S8_UINT }; enum IndexFormat { INDEXFORMAT_UINT16 = VK_INDEX_TYPE_UINT16, INDEXFORMAT_UINT32 = VK_INDEX_TYPE_UINT32 }; #define DEFINE_VERTEXFORMATS(s, t0, t1) \\ VERTEXFORMAT_##t0 = VK_FORMAT_R##s##_##t1, \\ VERTEXFORMAT_##t0##2 = VK_FORMAT_R##s##G##s##_##t1, \\ VERTEXFORMAT_##t0##3 = VK_FORMAT_R##s##G##s##B##s##_##t1, \\ VERTEXFORMAT_##t0##4 = VK_FORMAT_R##s##G##s##B##s##A##s##_##t1 enum VertexFormat { DEFINE_VERTEXFORMATS(32, FLOAT, SFLOAT) }; enum DescriptorType { VK(DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER), VK(DESCRIPTOR_TYPE_STORAGE_IMAGE), VK(DESCRIPTOR_TYPE_UNIFORM_BUFFER), VK(DESCRIPTOR_TYPE_STORAGE_BUFFER) }; enum VertexInputRate { VK(VERTEX_INPUT_RATE_VERTEX), VK(VERTEX_INPUT_RATE_INSTANCE) }; enum FilterMode { VK(FILTER_NEAREST), VK(FILTER_LINEAR) }; enum ImageLayout { VK(IMAGE_LAYOUT_UNDEFINED), VK(IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL), VK(IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL), VK(IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL), VK(IMAGE_LAYOUT_GENERAL), IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKGraphicsPipeline_8cpp/","text":"src/ngfx/porting/vulkan/VKGraphicsPipeline.cpp Attributes Name std::map< VertexFormat, uint32_t > strideMap Attributes Documentation variable strideMap static std::map< VertexFormat, uint32_t > strideMap = {{VERTEXFORMAT_FLOAT, 4}, {VERTEXFORMAT_FLOAT2, 8}, {VERTEXFORMAT_FLOAT3, 12}, {VERTEXFORMAT_FLOAT4, 16}}; Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKGraphicsPipeline.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKShaderModule.h\" #include <vector> using namespace ngfx; void VKGraphicsPipeline::create( VKGraphicsContext *ctx, const State &state, const std::vector<VKPipeline::Descriptor> &descriptors, const std::vector<VkVertexInputBindingDescription> &vertexInputBindings, const std::vector<VkVertexInputAttributeDescription> &vertexInputAttributes, const std::vector<VKPipeline::ShaderStage> &shaderStages, VkFormat colorFormat) { this->device = vk(ctx->device)->v; VkResult vkResult; inputAssemblyState = { VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, nullptr, 0, state.primitiveTopology, VK_FALSE}; rasterizationState = { VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, nullptr, 0, VK_FALSE, VK_FALSE, state.polygonMode, state.cullModeFlags, state.frontFace, VK_FALSE, 0.0f, 0.0f, 0.0f, state.lineWidth}; blendAttachmentState.resize(state.numColorAttachments); for (auto &pState : blendAttachmentState) pState = {state.blendEnable, state.srcColorBlendFactor, state.dstColorBlendFactor, state.colorBlendOp, state.srcColorBlendFactor, state.dstColorBlendFactor, state.alphaBlendOp, state.colorWriteMask}; colorBlendState = {VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, nullptr, 0, VK_FALSE, VK_LOGIC_OP_CLEAR, uint32_t(blendAttachmentState.size()), blendAttachmentState.data(), {0.0f, 0.0f, 0.0f, 0.0f}}; viewportState = {VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, nullptr, 0, 1, nullptr, 1, nullptr}; dynamicStateEnables = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR}; dynamicState = {VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, nullptr, 0, uint32_t(dynamicStateEnables.size()), dynamicStateEnables.data()}; depthStencilState = { VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO, nullptr, 0, state.depthTestEnable, state.depthWriteEnable, VK_COMPARE_OP_LESS, VK_FALSE, VK_FALSE, {VK_STENCIL_OP_KEEP, VK_STENCIL_OP_KEEP, VK_STENCIL_OP_KEEP, VK_COMPARE_OP_NEVER, 0, 0, 0}, {VK_STENCIL_OP_KEEP, VK_STENCIL_OP_KEEP, VK_STENCIL_OP_KEEP, VK_COMPARE_OP_NEVER, 0, 0, 0}, 0.0f, 0.0f}; multisampleState = {VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, nullptr, 0, VkSampleCountFlagBits(state.numSamples), VK_FALSE, 0.0f, nullptr, VK_FALSE, VK_FALSE}; vertexInputState = {VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, nullptr, 0, uint32_t(vertexInputBindings.size()), vertexInputBindings.data(), uint32_t(vertexInputAttributes.size()), vertexInputAttributes.data()}; vkShaderStages.resize(shaderStages.size()); for (int j = 0; j < shaderStages.size(); j++) { auto &shaderStage = shaderStages[j]; vkShaderStages[j] = {VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, nullptr, 0, shaderStage.stage, shaderStage.module->v, \"main\", nullptr}; } descriptorSetLayouts.resize(descriptors.size()); for (int j = 0; j < descriptors.size(); j++) { auto &descriptor = descriptors[j]; descriptorSetLayouts[j] = ctx->vkDescriptorSetLayoutCache.get( descriptor.type, descriptor.stageFlags); } pipelineLayoutCreateInfo = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, nullptr, 0, uint32_t(descriptorSetLayouts.size()), descriptorSetLayouts.data(), 0, nullptr}; V(vkCreatePipelineLayout(device, &pipelineLayoutCreateInfo, nullptr, &pipelineLayout)); createInfo = {VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, nullptr, 0, static_cast<uint32_t>(vkShaderStages.size()), vkShaderStages.data(), &vertexInputState, &inputAssemblyState, nullptr, &viewportState, &rasterizationState, &multisampleState, &depthStencilState, &colorBlendState, &dynamicState, pipelineLayout, state.renderPass, 0, 0, 0}; V(vkCreateGraphicsPipelines(device, ctx->vkPipelineCache.v, 1, &createInfo, nullptr, &v)); } static std::map<VertexFormat, uint32_t> strideMap = {{VERTEXFORMAT_FLOAT, 4}, {VERTEXFORMAT_FLOAT2, 8}, {VERTEXFORMAT_FLOAT3, 12}, {VERTEXFORMAT_FLOAT4, 16}}; GraphicsPipeline * GraphicsPipeline::create(GraphicsContext *graphicsContext, const State &state, VertexShaderModule *vs, FragmentShaderModule *fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes) { VKGraphicsPipeline *vkGraphicsPipeline = new VKGraphicsPipeline(); VKGraphicsPipeline::State vkState = { VkPrimitiveTopology(state.primitiveTopology), VkPolygonMode(state.polygonMode), state.blendEnable, VkBlendFactor(state.srcColorBlendFactor), VkBlendFactor(state.dstColorBlendFactor), VkBlendFactor(state.srcAlphaBlendFactor), VkBlendFactor(state.dstAlphaBlendFactor), VkBlendOp(state.colorBlendOp), VkBlendOp(state.alphaBlendOp), VkColorComponentFlags(state.colorWriteMask), VkCullModeFlags(state.cullModeFlags), VkFrontFace(state.frontFace), state.lineWidth, state.depthTestEnable, state.depthWriteEnable, vk(state.renderPass)->v, state.numSamples, state.numColorAttachments}; auto &descriptorBindings = vkGraphicsPipeline->descriptorBindings; uint32_t numDescriptors = glm::max(vs->descriptors.empty() ? 0 : vs->descriptors.back().set + 1, fs->descriptors.empty() ? 0 : fs->descriptors.back().set + 1); descriptorBindings.resize(numDescriptors); std::vector<VKPipeline::Descriptor> vkDescriptors(numDescriptors); VKPipelineUtil::parseDescriptors(vs->descriptors, VK_SHADER_STAGE_VERTEX_BIT, vkDescriptors, descriptorBindings); VKPipelineUtil::parseDescriptors(fs->descriptors, VK_SHADER_STAGE_FRAGMENT_BIT, vkDescriptors, descriptorBindings); std::vector<VkVertexInputAttributeDescription> vkVertexInputAttributes; auto &vertexAttributeBindings = vkGraphicsPipeline->vertexAttributeBindings; vertexAttributeBindings.resize(vs->attributes.size()); // TODO: support interleaved vertex bindings for (uint32_t j = 0; j < vs->attributes.size(); j++) { auto &va = vs->attributes[j]; uint32_t binding = va.location, offset = 0; for (uint32_t k = 0; k < va.count; k++) { vkVertexInputAttributes.push_back( {va.location + k, binding, VkFormat(va.format), offset}); offset += va.elementSize; } vertexAttributeBindings[j] = j; } std::vector<VKPipeline::ShaderStage> vkShaderStages = { {VK_SHADER_STAGE_VERTEX_BIT, (VKVertexShaderModule *)vs}, {VK_SHADER_STAGE_FRAGMENT_BIT, (VKFragmentShaderModule *)fs}}; std::vector<VkVertexInputBindingDescription> vkVertexInputBindings( vs->attributes.size()); for (uint32_t j = 0; j < vs->attributes.size(); j++) { auto &attr = vs->attributes[j]; uint32_t binding = attr.location; VkVertexInputRate inputRate = VK_VERTEX_INPUT_RATE_VERTEX; if (instanceAttributes.find(attr.name) != instanceAttributes.end()) inputRate = VK_VERTEX_INPUT_RATE_INSTANCE; vkVertexInputBindings[j] = {binding, attr.elementSize * attr.count, inputRate}; } vkGraphicsPipeline->create(vk(graphicsContext), vkState, vkDescriptors, vkVertexInputBindings, vkVertexInputAttributes, vkShaderStages, VkFormat(colorFormat)); return vkGraphicsPipeline; } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKGraphicsPipeline.cpp"},{"location":"api/Files/VKGraphicsPipeline_8cpp/#srcngfxportingvulkanvkgraphicspipelinecpp","text":"","title":"src/ngfx/porting/vulkan/VKGraphicsPipeline.cpp"},{"location":"api/Files/VKGraphicsPipeline_8cpp/#attributes","text":"Name std::map< VertexFormat, uint32_t > strideMap","title":"Attributes"},{"location":"api/Files/VKGraphicsPipeline_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/VKGraphicsPipeline_8cpp/#variable-stridemap","text":"static std::map< VertexFormat, uint32_t > strideMap = {{VERTEXFORMAT_FLOAT, 4}, {VERTEXFORMAT_FLOAT2, 8}, {VERTEXFORMAT_FLOAT3, 12}, {VERTEXFORMAT_FLOAT4, 16}};","title":"variable strideMap"},{"location":"api/Files/VKGraphicsPipeline_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKGraphicsPipeline.h\" #include \"ngfx/graphics/CommandBuffer.h\" #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKShaderModule.h\" #include <vector> using namespace ngfx; void VKGraphicsPipeline::create( VKGraphicsContext *ctx, const State &state, const std::vector<VKPipeline::Descriptor> &descriptors, const std::vector<VkVertexInputBindingDescription> &vertexInputBindings, const std::vector<VkVertexInputAttributeDescription> &vertexInputAttributes, const std::vector<VKPipeline::ShaderStage> &shaderStages, VkFormat colorFormat) { this->device = vk(ctx->device)->v; VkResult vkResult; inputAssemblyState = { VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, nullptr, 0, state.primitiveTopology, VK_FALSE}; rasterizationState = { VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, nullptr, 0, VK_FALSE, VK_FALSE, state.polygonMode, state.cullModeFlags, state.frontFace, VK_FALSE, 0.0f, 0.0f, 0.0f, state.lineWidth}; blendAttachmentState.resize(state.numColorAttachments); for (auto &pState : blendAttachmentState) pState = {state.blendEnable, state.srcColorBlendFactor, state.dstColorBlendFactor, state.colorBlendOp, state.srcColorBlendFactor, state.dstColorBlendFactor, state.alphaBlendOp, state.colorWriteMask}; colorBlendState = {VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, nullptr, 0, VK_FALSE, VK_LOGIC_OP_CLEAR, uint32_t(blendAttachmentState.size()), blendAttachmentState.data(), {0.0f, 0.0f, 0.0f, 0.0f}}; viewportState = {VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, nullptr, 0, 1, nullptr, 1, nullptr}; dynamicStateEnables = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR}; dynamicState = {VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, nullptr, 0, uint32_t(dynamicStateEnables.size()), dynamicStateEnables.data()}; depthStencilState = { VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO, nullptr, 0, state.depthTestEnable, state.depthWriteEnable, VK_COMPARE_OP_LESS, VK_FALSE, VK_FALSE, {VK_STENCIL_OP_KEEP, VK_STENCIL_OP_KEEP, VK_STENCIL_OP_KEEP, VK_COMPARE_OP_NEVER, 0, 0, 0}, {VK_STENCIL_OP_KEEP, VK_STENCIL_OP_KEEP, VK_STENCIL_OP_KEEP, VK_COMPARE_OP_NEVER, 0, 0, 0}, 0.0f, 0.0f}; multisampleState = {VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, nullptr, 0, VkSampleCountFlagBits(state.numSamples), VK_FALSE, 0.0f, nullptr, VK_FALSE, VK_FALSE}; vertexInputState = {VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, nullptr, 0, uint32_t(vertexInputBindings.size()), vertexInputBindings.data(), uint32_t(vertexInputAttributes.size()), vertexInputAttributes.data()}; vkShaderStages.resize(shaderStages.size()); for (int j = 0; j < shaderStages.size(); j++) { auto &shaderStage = shaderStages[j]; vkShaderStages[j] = {VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, nullptr, 0, shaderStage.stage, shaderStage.module->v, \"main\", nullptr}; } descriptorSetLayouts.resize(descriptors.size()); for (int j = 0; j < descriptors.size(); j++) { auto &descriptor = descriptors[j]; descriptorSetLayouts[j] = ctx->vkDescriptorSetLayoutCache.get( descriptor.type, descriptor.stageFlags); } pipelineLayoutCreateInfo = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, nullptr, 0, uint32_t(descriptorSetLayouts.size()), descriptorSetLayouts.data(), 0, nullptr}; V(vkCreatePipelineLayout(device, &pipelineLayoutCreateInfo, nullptr, &pipelineLayout)); createInfo = {VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, nullptr, 0, static_cast<uint32_t>(vkShaderStages.size()), vkShaderStages.data(), &vertexInputState, &inputAssemblyState, nullptr, &viewportState, &rasterizationState, &multisampleState, &depthStencilState, &colorBlendState, &dynamicState, pipelineLayout, state.renderPass, 0, 0, 0}; V(vkCreateGraphicsPipelines(device, ctx->vkPipelineCache.v, 1, &createInfo, nullptr, &v)); } static std::map<VertexFormat, uint32_t> strideMap = {{VERTEXFORMAT_FLOAT, 4}, {VERTEXFORMAT_FLOAT2, 8}, {VERTEXFORMAT_FLOAT3, 12}, {VERTEXFORMAT_FLOAT4, 16}}; GraphicsPipeline * GraphicsPipeline::create(GraphicsContext *graphicsContext, const State &state, VertexShaderModule *vs, FragmentShaderModule *fs, PixelFormat colorFormat, PixelFormat depthFormat, std::set<std::string> instanceAttributes) { VKGraphicsPipeline *vkGraphicsPipeline = new VKGraphicsPipeline(); VKGraphicsPipeline::State vkState = { VkPrimitiveTopology(state.primitiveTopology), VkPolygonMode(state.polygonMode), state.blendEnable, VkBlendFactor(state.srcColorBlendFactor), VkBlendFactor(state.dstColorBlendFactor), VkBlendFactor(state.srcAlphaBlendFactor), VkBlendFactor(state.dstAlphaBlendFactor), VkBlendOp(state.colorBlendOp), VkBlendOp(state.alphaBlendOp), VkColorComponentFlags(state.colorWriteMask), VkCullModeFlags(state.cullModeFlags), VkFrontFace(state.frontFace), state.lineWidth, state.depthTestEnable, state.depthWriteEnable, vk(state.renderPass)->v, state.numSamples, state.numColorAttachments}; auto &descriptorBindings = vkGraphicsPipeline->descriptorBindings; uint32_t numDescriptors = glm::max(vs->descriptors.empty() ? 0 : vs->descriptors.back().set + 1, fs->descriptors.empty() ? 0 : fs->descriptors.back().set + 1); descriptorBindings.resize(numDescriptors); std::vector<VKPipeline::Descriptor> vkDescriptors(numDescriptors); VKPipelineUtil::parseDescriptors(vs->descriptors, VK_SHADER_STAGE_VERTEX_BIT, vkDescriptors, descriptorBindings); VKPipelineUtil::parseDescriptors(fs->descriptors, VK_SHADER_STAGE_FRAGMENT_BIT, vkDescriptors, descriptorBindings); std::vector<VkVertexInputAttributeDescription> vkVertexInputAttributes; auto &vertexAttributeBindings = vkGraphicsPipeline->vertexAttributeBindings; vertexAttributeBindings.resize(vs->attributes.size()); // TODO: support interleaved vertex bindings for (uint32_t j = 0; j < vs->attributes.size(); j++) { auto &va = vs->attributes[j]; uint32_t binding = va.location, offset = 0; for (uint32_t k = 0; k < va.count; k++) { vkVertexInputAttributes.push_back( {va.location + k, binding, VkFormat(va.format), offset}); offset += va.elementSize; } vertexAttributeBindings[j] = j; } std::vector<VKPipeline::ShaderStage> vkShaderStages = { {VK_SHADER_STAGE_VERTEX_BIT, (VKVertexShaderModule *)vs}, {VK_SHADER_STAGE_FRAGMENT_BIT, (VKFragmentShaderModule *)fs}}; std::vector<VkVertexInputBindingDescription> vkVertexInputBindings( vs->attributes.size()); for (uint32_t j = 0; j < vs->attributes.size(); j++) { auto &attr = vs->attributes[j]; uint32_t binding = attr.location; VkVertexInputRate inputRate = VK_VERTEX_INPUT_RATE_VERTEX; if (instanceAttributes.find(attr.name) != instanceAttributes.end()) inputRate = VK_VERTEX_INPUT_RATE_INSTANCE; vkVertexInputBindings[j] = {binding, attr.elementSize * attr.count, inputRate}; } vkGraphicsPipeline->create(vk(graphicsContext), vkState, vkDescriptors, vkVertexInputBindings, vkVertexInputAttributes, vkShaderStages, VkFormat(colorFormat)); return vkGraphicsPipeline; } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKGraphicsPipeline_8h/","text":"src/ngfx/porting/vulkan/VKGraphicsPipeline.h Namespaces Name ngfx Classes Name class ngfx::VKGraphicsPipeline struct ngfx::VKGraphicsPipeline::State Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKPipeline.h\" #include \"ngfx/porting/vulkan/VKShaderModule.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vector> #include <vulkan/vulkan.h> namespace ngfx { class VKGraphicsPipeline : public GraphicsPipeline, public VKPipeline { public: struct State { VkPrimitiveTopology primitiveTopology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; VkPolygonMode polygonMode = VK_POLYGON_MODE_FILL; VkBool32 blendEnable = VK_FALSE; VkBlendFactor srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; VkBlendFactor dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; VkBlendFactor srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; VkBlendFactor dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; VkBlendOp colorBlendOp = VK_BLEND_OP_ADD, alphaBlendOp = VK_BLEND_OP_ADD; VkColorComponentFlags colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; VkCullModeFlags cullModeFlags = VK_CULL_MODE_BACK_BIT; VkFrontFace frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE; float lineWidth = 1.0f; VkBool32 depthTestEnable = VK_FALSE, depthWriteEnable = VK_FALSE; VkRenderPass renderPass; uint32_t numSamples = 1, numColorAttachments = 1; }; void create( VKGraphicsContext *ctx, const State &state, const std::vector<VKPipeline::Descriptor> &descriptors, const std::vector<VkVertexInputBindingDescription> &vertexInputBindings, const std::vector<VkVertexInputAttributeDescription> &vertexInputAttributes, const std::vector<VKPipeline::ShaderStage> &shaderStages, VkFormat colorFormat); virtual ~VKGraphicsPipeline() {} VkPipelineInputAssemblyStateCreateInfo inputAssemblyState; VkPipelineRasterizationStateCreateInfo rasterizationState; std::vector<VkPipelineColorBlendAttachmentState> blendAttachmentState; VkPipelineColorBlendStateCreateInfo colorBlendState; VkPipelineViewportStateCreateInfo viewportState; std::vector<VkDynamicState> dynamicStateEnables; VkPipelineDynamicStateCreateInfo dynamicState; VkPipelineDepthStencilStateCreateInfo depthStencilState; VkPipelineMultisampleStateCreateInfo multisampleState; VkPipelineVertexInputStateCreateInfo vertexInputState; std::vector<VkPipelineShaderStageCreateInfo> vkShaderStages; std::vector<VkDescriptorSetLayout> descriptorSetLayouts; VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo; VkGraphicsPipelineCreateInfo createInfo; }; VK_CAST(GraphicsPipeline); }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKGraphicsPipeline.h"},{"location":"api/Files/VKGraphicsPipeline_8h/#srcngfxportingvulkanvkgraphicspipelineh","text":"","title":"src/ngfx/porting/vulkan/VKGraphicsPipeline.h"},{"location":"api/Files/VKGraphicsPipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKGraphicsPipeline_8h/#classes","text":"Name class ngfx::VKGraphicsPipeline struct ngfx::VKGraphicsPipeline::State","title":"Classes"},{"location":"api/Files/VKGraphicsPipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsPipeline.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKPipeline.h\" #include \"ngfx/porting/vulkan/VKShaderModule.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vector> #include <vulkan/vulkan.h> namespace ngfx { class VKGraphicsPipeline : public GraphicsPipeline, public VKPipeline { public: struct State { VkPrimitiveTopology primitiveTopology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; VkPolygonMode polygonMode = VK_POLYGON_MODE_FILL; VkBool32 blendEnable = VK_FALSE; VkBlendFactor srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; VkBlendFactor dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; VkBlendFactor srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA; VkBlendFactor dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA; VkBlendOp colorBlendOp = VK_BLEND_OP_ADD, alphaBlendOp = VK_BLEND_OP_ADD; VkColorComponentFlags colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT; VkCullModeFlags cullModeFlags = VK_CULL_MODE_BACK_BIT; VkFrontFace frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE; float lineWidth = 1.0f; VkBool32 depthTestEnable = VK_FALSE, depthWriteEnable = VK_FALSE; VkRenderPass renderPass; uint32_t numSamples = 1, numColorAttachments = 1; }; void create( VKGraphicsContext *ctx, const State &state, const std::vector<VKPipeline::Descriptor> &descriptors, const std::vector<VkVertexInputBindingDescription> &vertexInputBindings, const std::vector<VkVertexInputAttributeDescription> &vertexInputAttributes, const std::vector<VKPipeline::ShaderStage> &shaderStages, VkFormat colorFormat); virtual ~VKGraphicsPipeline() {} VkPipelineInputAssemblyStateCreateInfo inputAssemblyState; VkPipelineRasterizationStateCreateInfo rasterizationState; std::vector<VkPipelineColorBlendAttachmentState> blendAttachmentState; VkPipelineColorBlendStateCreateInfo colorBlendState; VkPipelineViewportStateCreateInfo viewportState; std::vector<VkDynamicState> dynamicStateEnables; VkPipelineDynamicStateCreateInfo dynamicState; VkPipelineDepthStencilStateCreateInfo depthStencilState; VkPipelineMultisampleStateCreateInfo multisampleState; VkPipelineVertexInputStateCreateInfo vertexInputState; std::vector<VkPipelineShaderStageCreateInfo> vkShaderStages; std::vector<VkDescriptorSetLayout> descriptorSetLayouts; VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo; VkGraphicsPipelineCreateInfo createInfo; }; VK_CAST(GraphicsPipeline); }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKGraphics_8cpp/","text":"src/ngfx/porting/vulkan/VKGraphics.cpp Functions Name void bindBufferFN0 ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t set, Pipeline * currentPipeline, const VkDescriptorSet * descriptorSet) Functions Documentation function bindBufferFN0 static void bindBufferFN0( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t set, Pipeline * currentPipeline, const VkDescriptorSet * descriptorSet ) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKGraphics.h\" #include \"ngfx/porting/vulkan/VKBuffer.h\" #include \"ngfx/porting/vulkan/VKComputePipeline.h\" #include \"ngfx/porting/vulkan/VKConfig.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKGraphicsPipeline.h\" #include \"ngfx/porting/vulkan/VKRenderPass.h\" #include \"ngfx/porting/vulkan/VKTexture.h\" using namespace ngfx; void VKGraphics::beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil) { currentRenderPass = renderPass; currentFramebuffer = framebuffer; auto &vkCommandBuffer = vk(commandBuffer)->v; auto vkFramebuffer = vk(framebuffer); auto &vkAttachmentInfos = vkFramebuffer->vkAttachmentInfos; std::vector<VkClearValue> clearValues(vkAttachmentInfos.size()); for (uint32_t j = 0; j < vkAttachmentInfos.size(); j++) { auto &info = vkAttachmentInfos[j]; bool depthStencilAttachment = info.imageUsageFlags & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT; if (depthStencilAttachment) clearValues[j].depthStencil = {clearDepth, clearStencil}; else clearValues[j].color = { {clearColor[0], clearColor[1], clearColor[2], clearColor[3]}}; } VkRenderPassBeginInfo renderPassBeginInfo = { VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, nullptr, vk(renderPass)->v, vk(framebuffer)->v, {{0, 0}, {vk(framebuffer)->w, vk(framebuffer)->h}}, uint32_t(clearValues.size()), clearValues.data()}; VK_TRACE(vkCmdBeginRenderPass(vkCommandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE)); auto vkRenderPass = vk(renderPass); for (uint32_t j = 0; j < framebuffer->attachments.size(); j++) { auto &attachment = framebuffer->attachments[j]; auto vkTexture = (VKTexture *)attachment.texture; uint32_t baseIndex = attachment.layer * vkTexture->vkImage.createInfo.mipLevels + attachment.level; vkTexture->vkImage.imageLayout[baseIndex] = vkRenderPass->createInfo.pAttachments[j].initialLayout; } } void VKGraphics::endRenderPass(CommandBuffer *commandBuffer) { VK_TRACE(vkCmdEndRenderPass(vk(commandBuffer)->v)); auto vkRenderPass = vk(currentRenderPass); auto framebuffer = currentFramebuffer; for (uint32_t j = 0; j < framebuffer->attachments.size(); j++) { auto &attachment = framebuffer->attachments[j]; auto vkTexture = (VKTexture *)attachment.texture; uint32_t baseIndex = attachment.layer * vkTexture->vkImage.createInfo.mipLevels + attachment.level; vkTexture->vkImage.imageLayout[baseIndex] = vkRenderPass->createInfo.pAttachments[j].finalLayout; } currentRenderPass = nullptr; } void VKGraphics::bindComputePipeline(CommandBuffer *commandBuffer, ComputePipeline *computePipeline) { VK_TRACE(vkCmdBindPipeline(vk(commandBuffer)->v, VK_PIPELINE_BIND_POINT_COMPUTE, vk(computePipeline)->v)); currentPipeline = computePipeline; } void VKGraphics::bindGraphicsPipeline(CommandBuffer *commandBuffer, GraphicsPipeline *graphicsPipeline) { VK_TRACE(vkCmdBindPipeline(vk(commandBuffer)->v, VK_PIPELINE_BIND_POINT_GRAPHICS, vk(graphicsPipeline)->v)); currentPipeline = graphicsPipeline; } void VKGraphics::bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) { auto vkTexture = vk(texture); VkPipelineLayout pipelineLayout; VkPipelineBindPoint pipelineBindPoint; VkDescriptorSet *descriptorSet = nullptr; if (VKGraphicsPipeline *graphicsPipeline = dynamic_cast<VKGraphicsPipeline *>(currentPipeline)) { if (!(vkTexture->imageUsageFlags & VK_IMAGE_USAGE_SAMPLED_BIT)) { NGFX_ERR(\"incorrect image usage flags: missing IMAGE_USAGE_SAMPLED_BIT\"); } pipelineLayout = graphicsPipeline->pipelineLayout; pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; descriptorSet = &vkTexture->samplerDescriptorSet; } else if (VKComputePipeline *computePipeline = dynamic_cast<VKComputePipeline *>(currentPipeline)) { if (!(vkTexture->imageUsageFlags & VK_IMAGE_USAGE_STORAGE_BIT)) { NGFX_ERR(\"incorrect image usage flags: missing IMAGE_USAGE_STORAGE_BIT\"); } pipelineLayout = computePipeline->pipelineLayout; pipelineBindPoint = VK_PIPELINE_BIND_POINT_COMPUTE; descriptorSet = &vkTexture->storageImageDescriptorSet; } else NGFX_ERR(); VK_TRACE(vkCmdBindDescriptorSets(vk(commandBuffer)->v, pipelineBindPoint, pipelineLayout, set, 1, descriptorSet, 0, nullptr)); } void VKGraphics::bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) { VkDeviceSize offsets[] = {0}; VK_TRACE(vkCmdBindVertexBuffers(vk(commandBuffer)->v, location, 1, &vk(buffer)->v, offsets)); } void VKGraphics::bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat) { VkDeviceSize offset = 0; VK_TRACE(vkCmdBindIndexBuffer(vk(commandBuffer)->v, vk(buffer)->v, offset, VkIndexType(indexFormat))); } static void bindBufferFN0(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t set, Pipeline *currentPipeline, const VkDescriptorSet *descriptorSet) { VkPipelineLayout pipelineLayout; VkPipelineBindPoint pipelineBindPoint; if (VKGraphicsPipeline *graphicsPipeline = dynamic_cast<VKGraphicsPipeline *>(currentPipeline)) { pipelineLayout = graphicsPipeline->pipelineLayout; pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; } else if (VKComputePipeline *computePipeline = dynamic_cast<VKComputePipeline *>(currentPipeline)) { pipelineLayout = computePipeline->pipelineLayout; pipelineBindPoint = VK_PIPELINE_BIND_POINT_COMPUTE; } else NGFX_ERR(); VK_TRACE(vkCmdBindDescriptorSets(vk(commandBuffer)->v, pipelineBindPoint, pipelineLayout, set, 1, descriptorSet, 0, nullptr)); } void VKGraphics::bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t set, ShaderStageFlags shaderStageFlags) { bindBufferFN0(commandBuffer, buffer, set, currentPipeline, &vk(buffer)->getUboDescriptorSet(shaderStageFlags)); } void VKGraphics::bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t set, ShaderStageFlags shaderStageFlags) { bindBufferFN0(commandBuffer, buffer, set, currentPipeline, &vk(buffer)->getSsboDescriptorSet(shaderStageFlags)); } void VKGraphics::dispatch(CommandBuffer *commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) { VK_TRACE(vkCmdDispatch(vk(commandBuffer)->v, groupCountX, groupCountY, groupCountZ)); } void VKGraphics::draw(CommandBuffer *commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) { VK_TRACE(vkCmdDraw(vk(commandBuffer)->v, vertexCount, instanceCount, firstVertex, firstInstance)); } void VKGraphics::drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) { VK_TRACE(vkCmdDrawIndexed(vk(cmdBuffer)->v, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)); } void VKGraphics::setViewport(CommandBuffer *commandBuffer, Rect2D r) { viewport = r; VkViewport vkViewport = {float(r.x), float(r.y), float(r.w), float(r.h), 0.0f, 1.0f}; VK_TRACE(vkCmdSetViewport(vk(commandBuffer)->v, 0, 1, &vkViewport)); } void VKGraphics::setScissor(CommandBuffer *commandBuffer, Rect2D r) { scissorRect = r; #ifdef ORIGIN_BOTTOM_LEFT auto &v = viewport; VkRect2D vkScissorRect = {{r.x, int32_t(v.h) - r.y - int32_t(r.h)}, {r.w, r.h}}; #else VkRect2D vkScissorRect = {{r.x, r.y}, {r.w, r.h}}; #endif VK_TRACE(vkCmdSetScissor(vk(commandBuffer)->v, 0, 1, &vkScissorRect)); } void VKGraphics::waitIdle(CommandBuffer *cmdBuffer) { vk(ctx)->vkDevice.waitIdle(); } Graphics *Graphics::create(GraphicsContext *ctx) { VKGraphics *vkGraphics = new VKGraphics(); vkGraphics->ctx = ctx; vkGraphics->create(); return vkGraphics; } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKGraphics.cpp"},{"location":"api/Files/VKGraphics_8cpp/#srcngfxportingvulkanvkgraphicscpp","text":"","title":"src/ngfx/porting/vulkan/VKGraphics.cpp"},{"location":"api/Files/VKGraphics_8cpp/#functions","text":"Name void bindBufferFN0 ( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t set, Pipeline * currentPipeline, const VkDescriptorSet * descriptorSet)","title":"Functions"},{"location":"api/Files/VKGraphics_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/VKGraphics_8cpp/#function-bindbufferfn0","text":"static void bindBufferFN0( CommandBuffer * commandBuffer, Buffer * buffer, uint32_t set, Pipeline * currentPipeline, const VkDescriptorSet * descriptorSet )","title":"function bindBufferFN0"},{"location":"api/Files/VKGraphics_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKGraphics.h\" #include \"ngfx/porting/vulkan/VKBuffer.h\" #include \"ngfx/porting/vulkan/VKComputePipeline.h\" #include \"ngfx/porting/vulkan/VKConfig.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKGraphicsPipeline.h\" #include \"ngfx/porting/vulkan/VKRenderPass.h\" #include \"ngfx/porting/vulkan/VKTexture.h\" using namespace ngfx; void VKGraphics::beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor, float clearDepth, uint32_t clearStencil) { currentRenderPass = renderPass; currentFramebuffer = framebuffer; auto &vkCommandBuffer = vk(commandBuffer)->v; auto vkFramebuffer = vk(framebuffer); auto &vkAttachmentInfos = vkFramebuffer->vkAttachmentInfos; std::vector<VkClearValue> clearValues(vkAttachmentInfos.size()); for (uint32_t j = 0; j < vkAttachmentInfos.size(); j++) { auto &info = vkAttachmentInfos[j]; bool depthStencilAttachment = info.imageUsageFlags & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT; if (depthStencilAttachment) clearValues[j].depthStencil = {clearDepth, clearStencil}; else clearValues[j].color = { {clearColor[0], clearColor[1], clearColor[2], clearColor[3]}}; } VkRenderPassBeginInfo renderPassBeginInfo = { VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, nullptr, vk(renderPass)->v, vk(framebuffer)->v, {{0, 0}, {vk(framebuffer)->w, vk(framebuffer)->h}}, uint32_t(clearValues.size()), clearValues.data()}; VK_TRACE(vkCmdBeginRenderPass(vkCommandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE)); auto vkRenderPass = vk(renderPass); for (uint32_t j = 0; j < framebuffer->attachments.size(); j++) { auto &attachment = framebuffer->attachments[j]; auto vkTexture = (VKTexture *)attachment.texture; uint32_t baseIndex = attachment.layer * vkTexture->vkImage.createInfo.mipLevels + attachment.level; vkTexture->vkImage.imageLayout[baseIndex] = vkRenderPass->createInfo.pAttachments[j].initialLayout; } } void VKGraphics::endRenderPass(CommandBuffer *commandBuffer) { VK_TRACE(vkCmdEndRenderPass(vk(commandBuffer)->v)); auto vkRenderPass = vk(currentRenderPass); auto framebuffer = currentFramebuffer; for (uint32_t j = 0; j < framebuffer->attachments.size(); j++) { auto &attachment = framebuffer->attachments[j]; auto vkTexture = (VKTexture *)attachment.texture; uint32_t baseIndex = attachment.layer * vkTexture->vkImage.createInfo.mipLevels + attachment.level; vkTexture->vkImage.imageLayout[baseIndex] = vkRenderPass->createInfo.pAttachments[j].finalLayout; } currentRenderPass = nullptr; } void VKGraphics::bindComputePipeline(CommandBuffer *commandBuffer, ComputePipeline *computePipeline) { VK_TRACE(vkCmdBindPipeline(vk(commandBuffer)->v, VK_PIPELINE_BIND_POINT_COMPUTE, vk(computePipeline)->v)); currentPipeline = computePipeline; } void VKGraphics::bindGraphicsPipeline(CommandBuffer *commandBuffer, GraphicsPipeline *graphicsPipeline) { VK_TRACE(vkCmdBindPipeline(vk(commandBuffer)->v, VK_PIPELINE_BIND_POINT_GRAPHICS, vk(graphicsPipeline)->v)); currentPipeline = graphicsPipeline; } void VKGraphics::bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) { auto vkTexture = vk(texture); VkPipelineLayout pipelineLayout; VkPipelineBindPoint pipelineBindPoint; VkDescriptorSet *descriptorSet = nullptr; if (VKGraphicsPipeline *graphicsPipeline = dynamic_cast<VKGraphicsPipeline *>(currentPipeline)) { if (!(vkTexture->imageUsageFlags & VK_IMAGE_USAGE_SAMPLED_BIT)) { NGFX_ERR(\"incorrect image usage flags: missing IMAGE_USAGE_SAMPLED_BIT\"); } pipelineLayout = graphicsPipeline->pipelineLayout; pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; descriptorSet = &vkTexture->samplerDescriptorSet; } else if (VKComputePipeline *computePipeline = dynamic_cast<VKComputePipeline *>(currentPipeline)) { if (!(vkTexture->imageUsageFlags & VK_IMAGE_USAGE_STORAGE_BIT)) { NGFX_ERR(\"incorrect image usage flags: missing IMAGE_USAGE_STORAGE_BIT\"); } pipelineLayout = computePipeline->pipelineLayout; pipelineBindPoint = VK_PIPELINE_BIND_POINT_COMPUTE; descriptorSet = &vkTexture->storageImageDescriptorSet; } else NGFX_ERR(); VK_TRACE(vkCmdBindDescriptorSets(vk(commandBuffer)->v, pipelineBindPoint, pipelineLayout, set, 1, descriptorSet, 0, nullptr)); } void VKGraphics::bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) { VkDeviceSize offsets[] = {0}; VK_TRACE(vkCmdBindVertexBuffers(vk(commandBuffer)->v, location, 1, &vk(buffer)->v, offsets)); } void VKGraphics::bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat) { VkDeviceSize offset = 0; VK_TRACE(vkCmdBindIndexBuffer(vk(commandBuffer)->v, vk(buffer)->v, offset, VkIndexType(indexFormat))); } static void bindBufferFN0(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t set, Pipeline *currentPipeline, const VkDescriptorSet *descriptorSet) { VkPipelineLayout pipelineLayout; VkPipelineBindPoint pipelineBindPoint; if (VKGraphicsPipeline *graphicsPipeline = dynamic_cast<VKGraphicsPipeline *>(currentPipeline)) { pipelineLayout = graphicsPipeline->pipelineLayout; pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; } else if (VKComputePipeline *computePipeline = dynamic_cast<VKComputePipeline *>(currentPipeline)) { pipelineLayout = computePipeline->pipelineLayout; pipelineBindPoint = VK_PIPELINE_BIND_POINT_COMPUTE; } else NGFX_ERR(); VK_TRACE(vkCmdBindDescriptorSets(vk(commandBuffer)->v, pipelineBindPoint, pipelineLayout, set, 1, descriptorSet, 0, nullptr)); } void VKGraphics::bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t set, ShaderStageFlags shaderStageFlags) { bindBufferFN0(commandBuffer, buffer, set, currentPipeline, &vk(buffer)->getUboDescriptorSet(shaderStageFlags)); } void VKGraphics::bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t set, ShaderStageFlags shaderStageFlags) { bindBufferFN0(commandBuffer, buffer, set, currentPipeline, &vk(buffer)->getSsboDescriptorSet(shaderStageFlags)); } void VKGraphics::dispatch(CommandBuffer *commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) { VK_TRACE(vkCmdDispatch(vk(commandBuffer)->v, groupCountX, groupCountY, groupCountZ)); } void VKGraphics::draw(CommandBuffer *commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) { VK_TRACE(vkCmdDraw(vk(commandBuffer)->v, vertexCount, instanceCount, firstVertex, firstInstance)); } void VKGraphics::drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) { VK_TRACE(vkCmdDrawIndexed(vk(cmdBuffer)->v, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)); } void VKGraphics::setViewport(CommandBuffer *commandBuffer, Rect2D r) { viewport = r; VkViewport vkViewport = {float(r.x), float(r.y), float(r.w), float(r.h), 0.0f, 1.0f}; VK_TRACE(vkCmdSetViewport(vk(commandBuffer)->v, 0, 1, &vkViewport)); } void VKGraphics::setScissor(CommandBuffer *commandBuffer, Rect2D r) { scissorRect = r; #ifdef ORIGIN_BOTTOM_LEFT auto &v = viewport; VkRect2D vkScissorRect = {{r.x, int32_t(v.h) - r.y - int32_t(r.h)}, {r.w, r.h}}; #else VkRect2D vkScissorRect = {{r.x, r.y}, {r.w, r.h}}; #endif VK_TRACE(vkCmdSetScissor(vk(commandBuffer)->v, 0, 1, &vkScissorRect)); } void VKGraphics::waitIdle(CommandBuffer *cmdBuffer) { vk(ctx)->vkDevice.waitIdle(); } Graphics *Graphics::create(GraphicsContext *ctx) { VKGraphics *vkGraphics = new VKGraphics(); vkGraphics->ctx = ctx; vkGraphics->create(); return vkGraphics; } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKGraphics_8h/","text":"src/ngfx/porting/vulkan/VKGraphics.h Namespaces Name ngfx Classes Name class ngfx::VKGraphics Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" namespace ngfx { class VKGraphics : public Graphics { public: void create() {} virtual ~VKGraphics() {} void beginComputePass(CommandBuffer *commandBuffer) override {} void endComputePass(CommandBuffer *commandBuffer) override {} void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) override; void endRenderPass(CommandBuffer *commandBuffer) override; void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) override; void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat) override; void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) override; void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) override; void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) override; void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override; void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) override; void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) override; void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) override; void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) override; void waitIdle(CommandBuffer *cmdBuffer) override; }; VK_CAST(Graphics); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKGraphics.h"},{"location":"api/Files/VKGraphics_8h/#srcngfxportingvulkanvkgraphicsh","text":"","title":"src/ngfx/porting/vulkan/VKGraphics.h"},{"location":"api/Files/VKGraphics_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKGraphics_8h/#classes","text":"Name class ngfx::VKGraphics","title":"Classes"},{"location":"api/Files/VKGraphics_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Graphics.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" namespace ngfx { class VKGraphics : public Graphics { public: void create() {} virtual ~VKGraphics() {} void beginComputePass(CommandBuffer *commandBuffer) override {} void endComputePass(CommandBuffer *commandBuffer) override {} void beginRenderPass(CommandBuffer *commandBuffer, RenderPass *renderPass, Framebuffer *framebuffer, glm::vec4 clearColor = glm::vec4(0.0f), float clearDepth = 1.0f, uint32_t clearStencil = 0) override; void endRenderPass(CommandBuffer *commandBuffer) override; void bindVertexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t location, uint32_t stride) override; void bindIndexBuffer(CommandBuffer *commandBuffer, Buffer *buffer, IndexFormat indexFormat) override; void bindUniformBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindStorageBuffer(CommandBuffer *commandBuffer, Buffer *buffer, uint32_t binding, ShaderStageFlags shaderStageFlags) override; void bindComputePipeline(CommandBuffer *cmdBuffer, ComputePipeline *computePipeline) override; void bindGraphicsPipeline(CommandBuffer *cmdBuffer, GraphicsPipeline *graphicsPipeline) override; void bindTexture(CommandBuffer *commandBuffer, Texture *texture, uint32_t set) override; void dispatch(CommandBuffer *cmdBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ, uint32_t threadsPerGroupX, uint32_t threadsPerGroupY, uint32_t threadsPerGroupZ) override; void draw(CommandBuffer *cmdBuffer, uint32_t vertexCount, uint32_t instanceCount = 1, uint32_t firstVertex = 0, uint32_t firstInstance = 0) override; void drawIndexed(CommandBuffer *cmdBuffer, uint32_t indexCount, uint32_t instanceCount = 1, uint32_t firstIndex = 0, int32_t vertexOffset = 0, uint32_t firstInstance = 0) override; void setViewport(CommandBuffer *cmdBuffer, Rect2D rect) override; void setScissor(CommandBuffer *cmdBuffer, Rect2D rect) override; void waitIdle(CommandBuffer *cmdBuffer) override; }; VK_CAST(Graphics); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKImageCreateInfo_8h/","text":"src/ngfx/porting/vulkan/VKImageCreateInfo.h Namespaces Name ngfx Classes Name struct ngfx::VKImageCreateInfo Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { struct VKImageCreateInfo : VkImageCreateInfo { VKImageCreateInfo() { sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; pNext = nullptr; flags = 0; imageType = VK_IMAGE_TYPE_2D; format = VK_FORMAT_R8G8B8A8_UNORM; extent = {1, 1, 1}; mipLevels = 1; arrayLayers = 1; samples = VK_SAMPLE_COUNT_1_BIT; tiling = VK_IMAGE_TILING_OPTIMAL; usage = VK_IMAGE_USAGE_SAMPLED_BIT; sharingMode = VK_SHARING_MODE_EXCLUSIVE; queueFamilyIndexCount = 0; pQueueFamilyIndices = nullptr; initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; } }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKImageCreateInfo.h"},{"location":"api/Files/VKImageCreateInfo_8h/#srcngfxportingvulkanvkimagecreateinfoh","text":"","title":"src/ngfx/porting/vulkan/VKImageCreateInfo.h"},{"location":"api/Files/VKImageCreateInfo_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKImageCreateInfo_8h/#classes","text":"Name struct ngfx::VKImageCreateInfo","title":"Classes"},{"location":"api/Files/VKImageCreateInfo_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once namespace ngfx { struct VKImageCreateInfo : VkImageCreateInfo { VKImageCreateInfo() { sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; pNext = nullptr; flags = 0; imageType = VK_IMAGE_TYPE_2D; format = VK_FORMAT_R8G8B8A8_UNORM; extent = {1, 1, 1}; mipLevels = 1; arrayLayers = 1; samples = VK_SAMPLE_COUNT_1_BIT; tiling = VK_IMAGE_TILING_OPTIMAL; usage = VK_IMAGE_USAGE_SAMPLED_BIT; sharingMode = VK_SHARING_MODE_EXCLUSIVE; queueFamilyIndexCount = 0; pQueueFamilyIndices = nullptr; initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; } }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKImageViewCreateInfo_8h/","text":"src/ngfx/porting/vulkan/VKImageViewCreateInfo.h Namespaces Name ngfx Classes Name struct ngfx::VKImageViewCreateInfo Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstring> #include <vulkan/vulkan.h> namespace ngfx { struct VKImageViewCreateInfo : VkImageViewCreateInfo { VKImageViewCreateInfo() { sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; pNext = NULL; flags = 0; image = 0; viewType = VK_IMAGE_VIEW_TYPE_2D; format = VK_FORMAT_R8G8B8A8_UNORM; components = {VK_COMPONENT_SWIZZLE_R, VK_COMPONENT_SWIZZLE_G, VK_COMPONENT_SWIZZLE_B, VK_COMPONENT_SWIZZLE_A}; subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1}; }; VKImageViewCreateInfo( VkImage image, VkImageViewType imageViewType = VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat = VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels = 1, uint32_t arrayLayers = 1, uint32_t baseMipLevel = 0, uint32_t baseArrayLayer = 0) { sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; pNext = NULL; flags = 0; this->image = image; viewType = imageViewType; format = colorFormat; components = {VK_COMPONENT_SWIZZLE_R, VK_COMPONENT_SWIZZLE_G, VK_COMPONENT_SWIZZLE_B, VK_COMPONENT_SWIZZLE_A}; subresourceRange = {aspectMask, baseMipLevel, mipLevels, baseArrayLayer, arrayLayers}; }; }; static bool operator==(const VKImageViewCreateInfo &lhs, const VKImageViewCreateInfo &rhs) { return lhs.sType == rhs.sType && lhs.pNext == rhs.pNext && lhs.flags == rhs.flags && lhs.image == rhs.image && lhs.viewType == rhs.viewType && lhs.format == rhs.format && lhs.components.a == rhs.components.a && lhs.components.b == rhs.components.b && lhs.components.g == rhs.components.g && lhs.components.r == rhs.components.r && lhs.subresourceRange.aspectMask == rhs.subresourceRange.aspectMask && lhs.subresourceRange.baseArrayLayer == rhs.subresourceRange.baseArrayLayer && lhs.subresourceRange.baseMipLevel == rhs.subresourceRange.baseMipLevel && lhs.subresourceRange.layerCount == rhs.subresourceRange.layerCount && lhs.subresourceRange.levelCount == rhs.subresourceRange.levelCount; } } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKImageViewCreateInfo.h"},{"location":"api/Files/VKImageViewCreateInfo_8h/#srcngfxportingvulkanvkimageviewcreateinfoh","text":"","title":"src/ngfx/porting/vulkan/VKImageViewCreateInfo.h"},{"location":"api/Files/VKImageViewCreateInfo_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKImageViewCreateInfo_8h/#classes","text":"Name struct ngfx::VKImageViewCreateInfo","title":"Classes"},{"location":"api/Files/VKImageViewCreateInfo_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <cstring> #include <vulkan/vulkan.h> namespace ngfx { struct VKImageViewCreateInfo : VkImageViewCreateInfo { VKImageViewCreateInfo() { sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; pNext = NULL; flags = 0; image = 0; viewType = VK_IMAGE_VIEW_TYPE_2D; format = VK_FORMAT_R8G8B8A8_UNORM; components = {VK_COMPONENT_SWIZZLE_R, VK_COMPONENT_SWIZZLE_G, VK_COMPONENT_SWIZZLE_B, VK_COMPONENT_SWIZZLE_A}; subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1}; }; VKImageViewCreateInfo( VkImage image, VkImageViewType imageViewType = VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat = VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels = 1, uint32_t arrayLayers = 1, uint32_t baseMipLevel = 0, uint32_t baseArrayLayer = 0) { sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; pNext = NULL; flags = 0; this->image = image; viewType = imageViewType; format = colorFormat; components = {VK_COMPONENT_SWIZZLE_R, VK_COMPONENT_SWIZZLE_G, VK_COMPONENT_SWIZZLE_B, VK_COMPONENT_SWIZZLE_A}; subresourceRange = {aspectMask, baseMipLevel, mipLevels, baseArrayLayer, arrayLayers}; }; }; static bool operator==(const VKImageViewCreateInfo &lhs, const VKImageViewCreateInfo &rhs) { return lhs.sType == rhs.sType && lhs.pNext == rhs.pNext && lhs.flags == rhs.flags && lhs.image == rhs.image && lhs.viewType == rhs.viewType && lhs.format == rhs.format && lhs.components.a == rhs.components.a && lhs.components.b == rhs.components.b && lhs.components.g == rhs.components.g && lhs.components.r == rhs.components.r && lhs.subresourceRange.aspectMask == rhs.subresourceRange.aspectMask && lhs.subresourceRange.baseArrayLayer == rhs.subresourceRange.baseArrayLayer && lhs.subresourceRange.baseMipLevel == rhs.subresourceRange.baseMipLevel && lhs.subresourceRange.layerCount == rhs.subresourceRange.layerCount && lhs.subresourceRange.levelCount == rhs.subresourceRange.levelCount; } } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKImageView_8cpp/","text":"src/ngfx/porting/vulkan/VKImageView.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKImageView.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKImageView::create(VkDevice device, VkImage image, VkImageViewType imageViewType, VkFormat colorFormat, VkImageAspectFlags aspectMask, uint32_t mipLevels, uint32_t arrayLayers, uint32_t baseMipLevel, uint32_t baseArrayLayer) { VKImageViewCreateInfo p(image, imageViewType, colorFormat, aspectMask, mipLevels, arrayLayers, baseMipLevel, baseArrayLayer); create(device, p); } void VKImageView::create(VkDevice device, VKImageViewCreateInfo &createInfo) { VkResult vkResult; this->device = device; this->createInfo = createInfo; V(vkCreateImageView(device, &createInfo, nullptr, &v)); } VKImageView::~VKImageView() { if (v) VK_TRACE(vkDestroyImageView(device, v, nullptr)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKImageView.cpp"},{"location":"api/Files/VKImageView_8cpp/#srcngfxportingvulkanvkimageviewcpp","text":"","title":"src/ngfx/porting/vulkan/VKImageView.cpp"},{"location":"api/Files/VKImageView_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKImageView.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKImageView::create(VkDevice device, VkImage image, VkImageViewType imageViewType, VkFormat colorFormat, VkImageAspectFlags aspectMask, uint32_t mipLevels, uint32_t arrayLayers, uint32_t baseMipLevel, uint32_t baseArrayLayer) { VKImageViewCreateInfo p(image, imageViewType, colorFormat, aspectMask, mipLevels, arrayLayers, baseMipLevel, baseArrayLayer); create(device, p); } void VKImageView::create(VkDevice device, VKImageViewCreateInfo &createInfo) { VkResult vkResult; this->device = device; this->createInfo = createInfo; V(vkCreateImageView(device, &createInfo, nullptr, &v)); } VKImageView::~VKImageView() { if (v) VK_TRACE(vkDestroyImageView(device, v, nullptr)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKImageView_8h/","text":"src/ngfx/porting/vulkan/VKImageView.h Namespaces Name ngfx Classes Name class ngfx::VKImageView Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKImageViewCreateInfo.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKImageView { public: void create(VkDevice device, VkImage image, VkImageViewType imageViewType = VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat = VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels = 1, uint32_t arrayLayers = 1, uint32_t baseMipLevel = 0, uint32_t baseArrayLayer = 0); void create(VkDevice device, VKImageViewCreateInfo &createInfo); virtual ~VKImageView(); VkImageView v = VK_NULL_HANDLE; VKImageViewCreateInfo createInfo; private: VkDevice device; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKImageView.h"},{"location":"api/Files/VKImageView_8h/#srcngfxportingvulkanvkimageviewh","text":"","title":"src/ngfx/porting/vulkan/VKImageView.h"},{"location":"api/Files/VKImageView_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKImageView_8h/#classes","text":"Name class ngfx::VKImageView","title":"Classes"},{"location":"api/Files/VKImageView_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKImageViewCreateInfo.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKImageView { public: void create(VkDevice device, VkImage image, VkImageViewType imageViewType = VK_IMAGE_VIEW_TYPE_2D, VkFormat colorFormat = VK_FORMAT_R8G8B8A8_UNORM, VkImageAspectFlags aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, uint32_t mipLevels = 1, uint32_t arrayLayers = 1, uint32_t baseMipLevel = 0, uint32_t baseArrayLayer = 0); void create(VkDevice device, VKImageViewCreateInfo &createInfo); virtual ~VKImageView(); VkImageView v = VK_NULL_HANDLE; VKImageViewCreateInfo createInfo; private: VkDevice device; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKImage_8cpp/","text":"src/ngfx/porting/vulkan/VKImage.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKImage.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKImage::create(VKDevice *vkDevice, VkExtent3D extent, VkFormat format, VkImageUsageFlags usage, VkImageType imageType, uint32_t mipLevels, uint32_t arrayLayers, uint32_t numSamples, VkImageCreateFlags imageCreateFlags, VkMemoryPropertyFlags memoryPropertyFlags) { VKImageCreateInfo p; p.format = format; p.extent = extent; p.usage = usage; p.imageType = imageType; p.mipLevels = mipLevels; p.arrayLayers = arrayLayers; p.flags = imageCreateFlags; p.samples = VkSampleCountFlagBits(numSamples); create(vkDevice, p, memoryPropertyFlags); } void VKImage::create(VKDevice *vkDevice, const VKImageCreateInfo &createInfo, VkMemoryPropertyFlags memoryPropertyFlags) { this->device = vkDevice->v; this->createInfo = createInfo; VkResult vkResult; V(vkCreateImage(device, &createInfo, nullptr, &v)); uint32_t mipLevels = createInfo.mipLevels, arrayLayers = createInfo.arrayLayers; imageLayout.resize(mipLevels * arrayLayers); accessMask.resize(mipLevels * arrayLayers); stageMask.resize(mipLevels * arrayLayers); for (uint32_t j = 0; j < (mipLevels * arrayLayers); j++) { imageLayout[j] = createInfo.initialLayout; accessMask[j] = 0; stageMask[j] = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT; } VkMemoryRequirements memReqs = {}; vkGetImageMemoryRequirements(device, v, &memReqs); VkMemoryAllocateInfo memAllloc = {}; memAllloc.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; memAllloc.allocationSize = memReqs.size; memAllloc.memoryTypeIndex = vkDevice->vkPhysicalDevice->getMemoryType( memReqs.memoryTypeBits, memoryPropertyFlags); V(vkAllocateMemory(device, &memAllloc, nullptr, &memory)); V(vkBindImageMemory(device, v, memory, 0)); } void VKImage::changeLayout(VkCommandBuffer commandBuffer, VkImageLayout newLayout, VkAccessFlags dstAccessMask, VkPipelineStageFlags dstStageMask, VkImageAspectFlags aspectMask, uint32_t baseMipLevel, uint32_t levelCount, uint32_t baseArrayLayer, uint32_t layerCount) { uint32_t baseIndex = baseArrayLayer * createInfo.mipLevels + baseMipLevel; VkImageLayout srcImageLayout = imageLayout[baseIndex]; if (srcImageLayout == newLayout) { return; } VkAccessFlags srcAccessMask = accessMask[baseIndex]; VkPipelineStageFlags srcStageMask = stageMask[baseIndex]; VkImageSubresourceRange subresourceRange = { aspectMask, baseMipLevel, levelCount, baseArrayLayer, layerCount}; VkImageMemoryBarrier imageMemoryBarrier = { VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, nullptr, srcAccessMask, dstAccessMask, srcImageLayout, newLayout, VK_QUEUE_FAMILY_IGNORED, VK_QUEUE_FAMILY_IGNORED, v, subresourceRange}; VK_TRACE(vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, 0, 0, nullptr, 0, nullptr, 1, &imageMemoryBarrier)); for (uint32_t layer = baseArrayLayer; layer < (baseArrayLayer + layerCount); layer++) { for (uint32_t level = baseMipLevel; level < (baseMipLevel + levelCount); level++) { uint32_t index = layer * createInfo.mipLevels + level; imageLayout[index] = newLayout; accessMask[index] = dstAccessMask; stageMask[index] = dstStageMask; } } } VKImage::~VKImage() { if (v) VK_TRACE(vkDestroyImage(device, v, nullptr)); if (memory) VK_TRACE(vkFreeMemory(device, memory, nullptr)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKImage.cpp"},{"location":"api/Files/VKImage_8cpp/#srcngfxportingvulkanvkimagecpp","text":"","title":"src/ngfx/porting/vulkan/VKImage.cpp"},{"location":"api/Files/VKImage_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKImage.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKImage::create(VKDevice *vkDevice, VkExtent3D extent, VkFormat format, VkImageUsageFlags usage, VkImageType imageType, uint32_t mipLevels, uint32_t arrayLayers, uint32_t numSamples, VkImageCreateFlags imageCreateFlags, VkMemoryPropertyFlags memoryPropertyFlags) { VKImageCreateInfo p; p.format = format; p.extent = extent; p.usage = usage; p.imageType = imageType; p.mipLevels = mipLevels; p.arrayLayers = arrayLayers; p.flags = imageCreateFlags; p.samples = VkSampleCountFlagBits(numSamples); create(vkDevice, p, memoryPropertyFlags); } void VKImage::create(VKDevice *vkDevice, const VKImageCreateInfo &createInfo, VkMemoryPropertyFlags memoryPropertyFlags) { this->device = vkDevice->v; this->createInfo = createInfo; VkResult vkResult; V(vkCreateImage(device, &createInfo, nullptr, &v)); uint32_t mipLevels = createInfo.mipLevels, arrayLayers = createInfo.arrayLayers; imageLayout.resize(mipLevels * arrayLayers); accessMask.resize(mipLevels * arrayLayers); stageMask.resize(mipLevels * arrayLayers); for (uint32_t j = 0; j < (mipLevels * arrayLayers); j++) { imageLayout[j] = createInfo.initialLayout; accessMask[j] = 0; stageMask[j] = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT; } VkMemoryRequirements memReqs = {}; vkGetImageMemoryRequirements(device, v, &memReqs); VkMemoryAllocateInfo memAllloc = {}; memAllloc.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; memAllloc.allocationSize = memReqs.size; memAllloc.memoryTypeIndex = vkDevice->vkPhysicalDevice->getMemoryType( memReqs.memoryTypeBits, memoryPropertyFlags); V(vkAllocateMemory(device, &memAllloc, nullptr, &memory)); V(vkBindImageMemory(device, v, memory, 0)); } void VKImage::changeLayout(VkCommandBuffer commandBuffer, VkImageLayout newLayout, VkAccessFlags dstAccessMask, VkPipelineStageFlags dstStageMask, VkImageAspectFlags aspectMask, uint32_t baseMipLevel, uint32_t levelCount, uint32_t baseArrayLayer, uint32_t layerCount) { uint32_t baseIndex = baseArrayLayer * createInfo.mipLevels + baseMipLevel; VkImageLayout srcImageLayout = imageLayout[baseIndex]; if (srcImageLayout == newLayout) { return; } VkAccessFlags srcAccessMask = accessMask[baseIndex]; VkPipelineStageFlags srcStageMask = stageMask[baseIndex]; VkImageSubresourceRange subresourceRange = { aspectMask, baseMipLevel, levelCount, baseArrayLayer, layerCount}; VkImageMemoryBarrier imageMemoryBarrier = { VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, nullptr, srcAccessMask, dstAccessMask, srcImageLayout, newLayout, VK_QUEUE_FAMILY_IGNORED, VK_QUEUE_FAMILY_IGNORED, v, subresourceRange}; VK_TRACE(vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, 0, 0, nullptr, 0, nullptr, 1, &imageMemoryBarrier)); for (uint32_t layer = baseArrayLayer; layer < (baseArrayLayer + layerCount); layer++) { for (uint32_t level = baseMipLevel; level < (baseMipLevel + levelCount); level++) { uint32_t index = layer * createInfo.mipLevels + level; imageLayout[index] = newLayout; accessMask[index] = dstAccessMask; stageMask[index] = dstStageMask; } } } VKImage::~VKImage() { if (v) VK_TRACE(vkDestroyImage(device, v, nullptr)); if (memory) VK_TRACE(vkFreeMemory(device, memory, nullptr)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKImage_8h/","text":"src/ngfx/porting/vulkan/VKImage.h Namespaces Name ngfx Classes Name class ngfx::VKImage Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKImageCreateInfo.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKImage { public: void create(VKDevice *vkDevice, VkExtent3D extent, VkFormat format = VK_FORMAT_R8G8B8A8_UNORM, VkImageUsageFlags usage = VK_IMAGE_USAGE_SAMPLED_BIT, VkImageType imageType = VK_IMAGE_TYPE_2D, uint32_t mipLevels = 1, uint32_t arrayLayers = 1, uint32_t numSamples = 1, VkImageCreateFlags imageCreateFlags = 0, VkMemoryPropertyFlags memoryPropertyFlags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT); void create(VKDevice *vkDevice, const VKImageCreateInfo &createInfo, VkMemoryPropertyFlags memoryPropertyFlags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT); void changeLayout(VkCommandBuffer commandBuffer, VkImageLayout newLayout, VkImageAspectFlags dstAccessMask, VkPipelineStageFlags dstStageMask, VkImageAspectFlags aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, uint32_t baseMipLevel = 0, uint32_t levelCount = 1, uint32_t baseArrayLayer = 0, uint32_t layerCount = 1); virtual ~VKImage(); VkImage v = VK_NULL_HANDLE; VkDeviceMemory memory = VK_NULL_HANDLE; std::vector<VkImageLayout> imageLayout; std::vector<VkAccessFlags> accessMask; std::vector<VkPipelineStageFlags> stageMask; VKImageCreateInfo createInfo; private: VkDevice device; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKImage.h"},{"location":"api/Files/VKImage_8h/#srcngfxportingvulkanvkimageh","text":"","title":"src/ngfx/porting/vulkan/VKImage.h"},{"location":"api/Files/VKImage_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKImage_8h/#classes","text":"Name class ngfx::VKImage","title":"Classes"},{"location":"api/Files/VKImage_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKImageCreateInfo.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKImage { public: void create(VKDevice *vkDevice, VkExtent3D extent, VkFormat format = VK_FORMAT_R8G8B8A8_UNORM, VkImageUsageFlags usage = VK_IMAGE_USAGE_SAMPLED_BIT, VkImageType imageType = VK_IMAGE_TYPE_2D, uint32_t mipLevels = 1, uint32_t arrayLayers = 1, uint32_t numSamples = 1, VkImageCreateFlags imageCreateFlags = 0, VkMemoryPropertyFlags memoryPropertyFlags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT); void create(VKDevice *vkDevice, const VKImageCreateInfo &createInfo, VkMemoryPropertyFlags memoryPropertyFlags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT); void changeLayout(VkCommandBuffer commandBuffer, VkImageLayout newLayout, VkImageAspectFlags dstAccessMask, VkPipelineStageFlags dstStageMask, VkImageAspectFlags aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, uint32_t baseMipLevel = 0, uint32_t levelCount = 1, uint32_t baseArrayLayer = 0, uint32_t layerCount = 1); virtual ~VKImage(); VkImage v = VK_NULL_HANDLE; VkDeviceMemory memory = VK_NULL_HANDLE; std::vector<VkImageLayout> imageLayout; std::vector<VkAccessFlags> accessMask; std::vector<VkPipelineStageFlags> stageMask; VKImageCreateInfo createInfo; private: VkDevice device; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKInstance_8cpp/","text":"src/ngfx/porting/vulkan/VKInstance.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKInstance.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/porting/vulkan/VKConfig.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include <cstring> using namespace ngfx; void VKInstance::create(const char *appName, const char *engineName, uint32_t apiVersion, bool enableValidation) { VkResult vkResult; this->settings.enableValidation = enableValidation; appInfo = {}; appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO; appInfo.pApplicationName = appName; appInfo.pEngineName = engineName; appInfo.apiVersion = apiVersion; // Get instance layer properties uint32_t instanceLayerCount; vkEnumerateInstanceLayerProperties(&instanceLayerCount, nullptr); instanceLayerProperties.resize(instanceLayerCount); vkEnumerateInstanceLayerProperties(&instanceLayerCount, instanceLayerProperties.data()); // Set instance layers if (settings.enableValidation) { const char *validationLayerName = \"VK_LAYER_KHRONOS_validation\"; // Check if this layer is available bool validationLayerPresent = hasInstanceLayer(validationLayerName); if (validationLayerPresent) { instanceLayers.push_back(validationLayerName); } else { NGFX_ERR(\"Validation layer VK_LAYER_KHRONOS_validation not found\"); } } // Set instance extensions instanceExtensions = {VK_KHR_SURFACE_EXTENSION_NAME}; std::vector<const char *> surfaceExtensions = {VK_SURFACE_EXTENSION_NAMES}; for (auto &ext : surfaceExtensions) instanceExtensions.push_back(ext); if (instanceExtensions.size() > 0) { if (settings.enableValidation) { instanceExtensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); } } createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pNext = NULL; createInfo.pApplicationInfo = &appInfo; createInfo.ppEnabledExtensionNames = instanceExtensions.data(); createInfo.enabledExtensionCount = (uint32_t)instanceExtensions.size(); createInfo.ppEnabledLayerNames = instanceLayers.data(); createInfo.enabledLayerCount = (uint32_t)instanceLayers.size(); V(vkCreateInstance(&createInfo, nullptr, &v)); } bool VKInstance::hasInstanceLayer(const char *name) { for (VkLayerProperties &props : instanceLayerProperties) { if (strcmp(props.layerName, name) == 0) { return true; } } return false; } VKInstance::~VKInstance() { if (v) VK_TRACE(vkDestroyInstance(v, nullptr)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKInstance.cpp"},{"location":"api/Files/VKInstance_8cpp/#srcngfxportingvulkanvkinstancecpp","text":"","title":"src/ngfx/porting/vulkan/VKInstance.cpp"},{"location":"api/Files/VKInstance_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKInstance.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/porting/vulkan/VKConfig.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include <cstring> using namespace ngfx; void VKInstance::create(const char *appName, const char *engineName, uint32_t apiVersion, bool enableValidation) { VkResult vkResult; this->settings.enableValidation = enableValidation; appInfo = {}; appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO; appInfo.pApplicationName = appName; appInfo.pEngineName = engineName; appInfo.apiVersion = apiVersion; // Get instance layer properties uint32_t instanceLayerCount; vkEnumerateInstanceLayerProperties(&instanceLayerCount, nullptr); instanceLayerProperties.resize(instanceLayerCount); vkEnumerateInstanceLayerProperties(&instanceLayerCount, instanceLayerProperties.data()); // Set instance layers if (settings.enableValidation) { const char *validationLayerName = \"VK_LAYER_KHRONOS_validation\"; // Check if this layer is available bool validationLayerPresent = hasInstanceLayer(validationLayerName); if (validationLayerPresent) { instanceLayers.push_back(validationLayerName); } else { NGFX_ERR(\"Validation layer VK_LAYER_KHRONOS_validation not found\"); } } // Set instance extensions instanceExtensions = {VK_KHR_SURFACE_EXTENSION_NAME}; std::vector<const char *> surfaceExtensions = {VK_SURFACE_EXTENSION_NAMES}; for (auto &ext : surfaceExtensions) instanceExtensions.push_back(ext); if (instanceExtensions.size() > 0) { if (settings.enableValidation) { instanceExtensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); } } createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pNext = NULL; createInfo.pApplicationInfo = &appInfo; createInfo.ppEnabledExtensionNames = instanceExtensions.data(); createInfo.enabledExtensionCount = (uint32_t)instanceExtensions.size(); createInfo.ppEnabledLayerNames = instanceLayers.data(); createInfo.enabledLayerCount = (uint32_t)instanceLayers.size(); V(vkCreateInstance(&createInfo, nullptr, &v)); } bool VKInstance::hasInstanceLayer(const char *name) { for (VkLayerProperties &props : instanceLayerProperties) { if (strcmp(props.layerName, name) == 0) { return true; } } return false; } VKInstance::~VKInstance() { if (v) VK_TRACE(vkDestroyInstance(v, nullptr)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKInstance_8h/","text":"src/ngfx/porting/vulkan/VKInstance.h Namespaces Name ngfx Classes Name class ngfx::VKInstance Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> #include <vector> #include <vulkan/vulkan.h> namespace ngfx { class VKInstance { public: void create(const char *appName, const char *engineName, uint32_t apiVersion, bool enableValidation); virtual ~VKInstance(); bool hasInstanceLayer(const char *name); struct { bool enableValidation = false; } settings; std::vector<const char *> instanceExtensions; std::vector<const char *> instanceLayers; std::vector<VkLayerProperties> instanceLayerProperties; VkInstance v = VK_NULL_HANDLE; VkInstanceCreateInfo createInfo; VkApplicationInfo appInfo; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKInstance.h"},{"location":"api/Files/VKInstance_8h/#srcngfxportingvulkanvkinstanceh","text":"","title":"src/ngfx/porting/vulkan/VKInstance.h"},{"location":"api/Files/VKInstance_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKInstance_8h/#classes","text":"Name class ngfx::VKInstance","title":"Classes"},{"location":"api/Files/VKInstance_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> #include <vector> #include <vulkan/vulkan.h> namespace ngfx { class VKInstance { public: void create(const char *appName, const char *engineName, uint32_t apiVersion, bool enableValidation); virtual ~VKInstance(); bool hasInstanceLayer(const char *name); struct { bool enableValidation = false; } settings; std::vector<const char *> instanceExtensions; std::vector<const char *> instanceLayers; std::vector<VkLayerProperties> instanceLayerProperties; VkInstance v = VK_NULL_HANDLE; VkInstanceCreateInfo createInfo; VkApplicationInfo appInfo; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKPhysicalDevice_8cpp/","text":"src/ngfx/porting/vulkan/VKPhysicalDevice.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKPhysicalDevice.h\" #include \"ngfx/porting/vulkan/VKConfig.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include <algorithm> using namespace ngfx; void VKPhysicalDevice::getProperties() { vkGetPhysicalDeviceProperties(v, &deviceProperties); vkGetPhysicalDeviceFeatures(v, &deviceFeatures); vkGetPhysicalDeviceMemoryProperties(v, &deviceMemoryProperties); uint32_t queueFamilyCount; vkGetPhysicalDeviceQueueFamilyProperties(v, &queueFamilyCount, nullptr); assert(queueFamilyCount > 0); queueFamilyProperties.resize(queueFamilyCount); vkGetPhysicalDeviceQueueFamilyProperties(v, &queueFamilyCount, queueFamilyProperties.data()); // Get list of supported extensions uint32_t extCount = 0; vkEnumerateDeviceExtensionProperties(v, nullptr, &extCount, nullptr); if (extCount > 0) { std::vector<VkExtensionProperties> extensions(extCount); if (vkEnumerateDeviceExtensionProperties( v, nullptr, &extCount, &extensions.front()) == VK_SUCCESS) { for (auto ext : extensions) { supportedExtensions.push_back(ext.extensionName); } } } } void VKPhysicalDevice::selectDevice(VkInstance instance) { VkResult vkResult; uint32_t gpuCount = 0; // Get number of available physical devices V(vkEnumeratePhysicalDevices(instance, &gpuCount, nullptr)); assert(gpuCount > 0); // Enumerate devices std::vector<VkPhysicalDevice> physicalDevices(gpuCount); V(vkEnumeratePhysicalDevices(instance, &gpuCount, physicalDevices.data())); // Select GPU device v = physicalDevices[0]; std::vector<VkPhysicalDeviceProperties> devicesProperties; devicesProperties.resize(physicalDevices.size()); for (int j = 0; j < physicalDevices.size(); j++) { auto &device = physicalDevices[j]; vkGetPhysicalDeviceProperties(device, &devicesProperties[j]); } auto containsDevice = [&](VkPhysicalDeviceType type, VkPhysicalDevice &deviceResult) -> bool { for (int j = 0; j < devicesProperties.size(); j++) { auto &deviceProps = devicesProperties[j]; if (deviceProps.deviceType == type) { deviceResult = physicalDevices[j]; return true; } } return false; }; VkPhysicalDevice physicalDeviceResult; if (containsDevice(PREFERRED_DEVICE_TYPE, physicalDeviceResult)) v = physicalDeviceResult; else v = physicalDevices[0]; vkGetPhysicalDeviceProperties(v, &deviceProperties); NGFX_LOG(\"selected device: %s\", deviceProperties.deviceName); } void VKPhysicalDevice::chooseDepthFormat() { std::vector<VkFormat> depthFormats = {VK_FORMAT_D16_UNORM}; for (auto &format : depthFormats) { VkFormatProperties formatProps; vkGetPhysicalDeviceFormatProperties(v, format, &formatProps); // Format must support depth stencil attachment for optimal tiling if (formatProps.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) { depthFormat = format; break; } } } uint32_t VKPhysicalDevice::getMemoryType(uint32_t type, VkMemoryPropertyFlags memoryPropertyFlags) { for (uint32_t i = 0; i < deviceMemoryProperties.memoryTypeCount; i++) { if ((type & 1) == 1) { auto &memoryType = deviceMemoryProperties.memoryTypes[i]; if ((memoryType.propertyFlags & memoryPropertyFlags) == memoryPropertyFlags) { return i; } } type >>= 1; } NGFX_ERR(\"Could not find a matching memory type\"); return 0; } void VKPhysicalDevice::create(VkInstance instance) { selectDevice(instance); getProperties(); chooseDepthFormat(); } VKPhysicalDevice::~VKPhysicalDevice() {} bool VKPhysicalDevice::extensionSupported(std::string extension) { return (std::find(supportedExtensions.begin(), supportedExtensions.end(), extension) != supportedExtensions.end()); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKPhysicalDevice.cpp"},{"location":"api/Files/VKPhysicalDevice_8cpp/#srcngfxportingvulkanvkphysicaldevicecpp","text":"","title":"src/ngfx/porting/vulkan/VKPhysicalDevice.cpp"},{"location":"api/Files/VKPhysicalDevice_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKPhysicalDevice.h\" #include \"ngfx/porting/vulkan/VKConfig.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include <algorithm> using namespace ngfx; void VKPhysicalDevice::getProperties() { vkGetPhysicalDeviceProperties(v, &deviceProperties); vkGetPhysicalDeviceFeatures(v, &deviceFeatures); vkGetPhysicalDeviceMemoryProperties(v, &deviceMemoryProperties); uint32_t queueFamilyCount; vkGetPhysicalDeviceQueueFamilyProperties(v, &queueFamilyCount, nullptr); assert(queueFamilyCount > 0); queueFamilyProperties.resize(queueFamilyCount); vkGetPhysicalDeviceQueueFamilyProperties(v, &queueFamilyCount, queueFamilyProperties.data()); // Get list of supported extensions uint32_t extCount = 0; vkEnumerateDeviceExtensionProperties(v, nullptr, &extCount, nullptr); if (extCount > 0) { std::vector<VkExtensionProperties> extensions(extCount); if (vkEnumerateDeviceExtensionProperties( v, nullptr, &extCount, &extensions.front()) == VK_SUCCESS) { for (auto ext : extensions) { supportedExtensions.push_back(ext.extensionName); } } } } void VKPhysicalDevice::selectDevice(VkInstance instance) { VkResult vkResult; uint32_t gpuCount = 0; // Get number of available physical devices V(vkEnumeratePhysicalDevices(instance, &gpuCount, nullptr)); assert(gpuCount > 0); // Enumerate devices std::vector<VkPhysicalDevice> physicalDevices(gpuCount); V(vkEnumeratePhysicalDevices(instance, &gpuCount, physicalDevices.data())); // Select GPU device v = physicalDevices[0]; std::vector<VkPhysicalDeviceProperties> devicesProperties; devicesProperties.resize(physicalDevices.size()); for (int j = 0; j < physicalDevices.size(); j++) { auto &device = physicalDevices[j]; vkGetPhysicalDeviceProperties(device, &devicesProperties[j]); } auto containsDevice = [&](VkPhysicalDeviceType type, VkPhysicalDevice &deviceResult) -> bool { for (int j = 0; j < devicesProperties.size(); j++) { auto &deviceProps = devicesProperties[j]; if (deviceProps.deviceType == type) { deviceResult = physicalDevices[j]; return true; } } return false; }; VkPhysicalDevice physicalDeviceResult; if (containsDevice(PREFERRED_DEVICE_TYPE, physicalDeviceResult)) v = physicalDeviceResult; else v = physicalDevices[0]; vkGetPhysicalDeviceProperties(v, &deviceProperties); NGFX_LOG(\"selected device: %s\", deviceProperties.deviceName); } void VKPhysicalDevice::chooseDepthFormat() { std::vector<VkFormat> depthFormats = {VK_FORMAT_D16_UNORM}; for (auto &format : depthFormats) { VkFormatProperties formatProps; vkGetPhysicalDeviceFormatProperties(v, format, &formatProps); // Format must support depth stencil attachment for optimal tiling if (formatProps.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) { depthFormat = format; break; } } } uint32_t VKPhysicalDevice::getMemoryType(uint32_t type, VkMemoryPropertyFlags memoryPropertyFlags) { for (uint32_t i = 0; i < deviceMemoryProperties.memoryTypeCount; i++) { if ((type & 1) == 1) { auto &memoryType = deviceMemoryProperties.memoryTypes[i]; if ((memoryType.propertyFlags & memoryPropertyFlags) == memoryPropertyFlags) { return i; } } type >>= 1; } NGFX_ERR(\"Could not find a matching memory type\"); return 0; } void VKPhysicalDevice::create(VkInstance instance) { selectDevice(instance); getProperties(); chooseDepthFormat(); } VKPhysicalDevice::~VKPhysicalDevice() {} bool VKPhysicalDevice::extensionSupported(std::string extension) { return (std::find(supportedExtensions.begin(), supportedExtensions.end(), extension) != supportedExtensions.end()); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKPhysicalDevice_8h/","text":"src/ngfx/porting/vulkan/VKPhysicalDevice.h Namespaces Name ngfx Classes Name class ngfx::VKPhysicalDevice Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> #include <vector> #include <vulkan/vulkan.h> namespace ngfx { class VKPhysicalDevice { public: void create(VkInstance instance); virtual ~VKPhysicalDevice(); bool extensionSupported(std::string extension); uint32_t getMemoryType(uint32_t typeBits, VkMemoryPropertyFlags memoryPropertyFlags); VkPhysicalDevice v = VK_NULL_HANDLE; VkPhysicalDeviceProperties deviceProperties; VkPhysicalDeviceFeatures deviceFeatures; VkPhysicalDeviceMemoryProperties deviceMemoryProperties; std::vector<VkQueueFamilyProperties> queueFamilyProperties; std::vector<std::string> supportedExtensions; VkFormat depthFormat; private: void chooseDepthFormat(); void selectDevice(VkInstance instance); void getProperties(); }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKPhysicalDevice.h"},{"location":"api/Files/VKPhysicalDevice_8h/#srcngfxportingvulkanvkphysicaldeviceh","text":"","title":"src/ngfx/porting/vulkan/VKPhysicalDevice.h"},{"location":"api/Files/VKPhysicalDevice_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKPhysicalDevice_8h/#classes","text":"Name class ngfx::VKPhysicalDevice","title":"Classes"},{"location":"api/Files/VKPhysicalDevice_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <string> #include <vector> #include <vulkan/vulkan.h> namespace ngfx { class VKPhysicalDevice { public: void create(VkInstance instance); virtual ~VKPhysicalDevice(); bool extensionSupported(std::string extension); uint32_t getMemoryType(uint32_t typeBits, VkMemoryPropertyFlags memoryPropertyFlags); VkPhysicalDevice v = VK_NULL_HANDLE; VkPhysicalDeviceProperties deviceProperties; VkPhysicalDeviceFeatures deviceFeatures; VkPhysicalDeviceMemoryProperties deviceMemoryProperties; std::vector<VkQueueFamilyProperties> queueFamilyProperties; std::vector<std::string> supportedExtensions; VkFormat depthFormat; private: void chooseDepthFormat(); void selectDevice(VkInstance instance); void getProperties(); }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKPipelineCache_8cpp/","text":"src/ngfx/porting/vulkan/VKPipelineCache.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKPipelineCache.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKPipelineCache::create(VkDevice device) { this->device = device; VkResult vkResult; VkPipelineCacheCreateInfo pipelineCacheCreateInfo = {}; pipelineCacheCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO; V(vkCreatePipelineCache(device, &pipelineCacheCreateInfo, nullptr, &v)); } VKPipelineCache::~VKPipelineCache() { VK_TRACE(vkDestroyPipelineCache(device, v, nullptr)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKPipelineCache.cpp"},{"location":"api/Files/VKPipelineCache_8cpp/#srcngfxportingvulkanvkpipelinecachecpp","text":"","title":"src/ngfx/porting/vulkan/VKPipelineCache.cpp"},{"location":"api/Files/VKPipelineCache_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKPipelineCache.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKPipelineCache::create(VkDevice device) { this->device = device; VkResult vkResult; VkPipelineCacheCreateInfo pipelineCacheCreateInfo = {}; pipelineCacheCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO; V(vkCreatePipelineCache(device, &pipelineCacheCreateInfo, nullptr, &v)); } VKPipelineCache::~VKPipelineCache() { VK_TRACE(vkDestroyPipelineCache(device, v, nullptr)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKPipelineCache_8h/","text":"src/ngfx/porting/vulkan/VKPipelineCache.h Namespaces Name ngfx Classes Name class ngfx::VKPipelineCache Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/PipelineCache.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKPipelineCache : public PipelineCache { public: void create(VkDevice device); virtual ~VKPipelineCache(); VkPipelineCache v; private: VkDevice device; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKPipelineCache.h"},{"location":"api/Files/VKPipelineCache_8h/#srcngfxportingvulkanvkpipelinecacheh","text":"","title":"src/ngfx/porting/vulkan/VKPipelineCache.h"},{"location":"api/Files/VKPipelineCache_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKPipelineCache_8h/#classes","text":"Name class ngfx::VKPipelineCache","title":"Classes"},{"location":"api/Files/VKPipelineCache_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/PipelineCache.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKPipelineCache : public PipelineCache { public: void create(VkDevice device); virtual ~VKPipelineCache(); VkPipelineCache v; private: VkDevice device; }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKPipeline_8cpp/","text":"src/ngfx/porting/vulkan/VKPipeline.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKPipeline.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; VKPipeline::~VKPipeline() { if (pipelineLayout) VK_TRACE(vkDestroyPipelineLayout(device, pipelineLayout, nullptr)); if (v) VK_TRACE(vkDestroyPipeline(device, v, nullptr)); } void VKPipelineUtil::parseDescriptors( std::vector<ShaderModule::DescriptorInfo> &descriptors, VkShaderStageFlagBits shaderStage, std::vector<VKPipeline::Descriptor> &vkDescriptors, std::vector<uint32_t> &descriptorBindings) { for (uint32_t j = 0; j < descriptors.size(); j++) { auto &descriptor = descriptors[j]; auto &vkDesc = vkDescriptors[descriptor.set]; vkDesc.type = VkDescriptorType(descriptor.type); vkDesc.stageFlags |= shaderStage; descriptorBindings[descriptor.set] = descriptor.set; } }; Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKPipeline.cpp"},{"location":"api/Files/VKPipeline_8cpp/#srcngfxportingvulkanvkpipelinecpp","text":"","title":"src/ngfx/porting/vulkan/VKPipeline.cpp"},{"location":"api/Files/VKPipeline_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKPipeline.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; VKPipeline::~VKPipeline() { if (pipelineLayout) VK_TRACE(vkDestroyPipelineLayout(device, pipelineLayout, nullptr)); if (v) VK_TRACE(vkDestroyPipeline(device, v, nullptr)); } void VKPipelineUtil::parseDescriptors( std::vector<ShaderModule::DescriptorInfo> &descriptors, VkShaderStageFlagBits shaderStage, std::vector<VKPipeline::Descriptor> &vkDescriptors, std::vector<uint32_t> &descriptorBindings) { for (uint32_t j = 0; j < descriptors.size(); j++) { auto &descriptor = descriptors[j]; auto &vkDesc = vkDescriptors[descriptor.set]; vkDesc.type = VkDescriptorType(descriptor.type); vkDesc.stageFlags |= shaderStage; descriptorBindings[descriptor.set] = descriptor.set; } }; Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKPipeline_8h/","text":"src/ngfx/porting/vulkan/VKPipeline.h Namespaces Name ngfx Classes Name class ngfx::VKPipeline struct ngfx::VKPipeline::Descriptor struct ngfx::VKPipeline::ShaderStage struct ngfx::VKPipelineUtil Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/vulkan/VKShaderModule.h\" namespace ngfx { class VKPipeline { public: virtual ~VKPipeline(); struct Descriptor { VkDescriptorType type; VkShaderStageFlags stageFlags = 0; }; struct ShaderStage { VkShaderStageFlagBits stage; VKShaderModule *module; }; VkPipeline v = VK_NULL_HANDLE; VkPipelineLayout pipelineLayout = VK_NULL_HANDLE; protected: VkDevice device; }; struct VKPipelineUtil { static void parseDescriptors(std::vector<ShaderModule::DescriptorInfo> &descriptors, VkShaderStageFlagBits shaderStage, std::vector<VKPipeline::Descriptor> &vkDescriptors, std::vector<uint32_t> &descriptorBindings); }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKPipeline.h"},{"location":"api/Files/VKPipeline_8h/#srcngfxportingvulkanvkpipelineh","text":"","title":"src/ngfx/porting/vulkan/VKPipeline.h"},{"location":"api/Files/VKPipeline_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKPipeline_8h/#classes","text":"Name class ngfx::VKPipeline struct ngfx::VKPipeline::Descriptor struct ngfx::VKPipeline::ShaderStage struct ngfx::VKPipelineUtil","title":"Classes"},{"location":"api/Files/VKPipeline_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/porting/vulkan/VKShaderModule.h\" namespace ngfx { class VKPipeline { public: virtual ~VKPipeline(); struct Descriptor { VkDescriptorType type; VkShaderStageFlags stageFlags = 0; }; struct ShaderStage { VkShaderStageFlagBits stage; VKShaderModule *module; }; VkPipeline v = VK_NULL_HANDLE; VkPipelineLayout pipelineLayout = VK_NULL_HANDLE; protected: VkDevice device; }; struct VKPipelineUtil { static void parseDescriptors(std::vector<ShaderModule::DescriptorInfo> &descriptors, VkShaderStageFlagBits shaderStage, std::vector<VKPipeline::Descriptor> &vkDescriptors, std::vector<uint32_t> &descriptorBindings); }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKQueue_8cpp/","text":"src/ngfx/porting/vulkan/VKQueue.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKQueue.h\" #include \"ngfx/porting/vulkan/VKCommandBuffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKFence.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKSemaphore.h\" #include \"ngfx/porting/vulkan/VKSwapchain.h\" using namespace ngfx; void VKQueue::create(VKGraphicsContext *ctx, int queueFamilyIndex, int queueIndex) { this->ctx = ctx; VK_TRACE(vkGetDeviceQueue(ctx->vkDevice.v, queueFamilyIndex, queueIndex, &v)); } VKQueue::~VKQueue() {} void VKQueue::present() { VkResult vkResult; Swapchain *swapChain = ctx->swapchain; uint32_t currentImageIndex = ctx->currentImageIndex; const std::vector<VkSemaphore> vkWaitSemaphores = { ctx->vkRenderCompleteSemaphore.v}; VkPresentInfoKHR presentInfo = {VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, nullptr, uint32_t(vkWaitSemaphores.size()), vkWaitSemaphores.data(), 1, &vk(swapChain)->v, &currentImageIndex, nullptr}; V(vkQueuePresentKHR(v, &presentInfo)); } void VKQueue::submit(CommandBuffer *commandBuffer) { if (commandBuffer == &ctx->vkComputeCommandBuffer) { submit(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, {}, {}, ctx->computeFence); } else if (commandBuffer == &ctx->vkCopyCommandBuffer) { submit(commandBuffer, 0, {}, {}, nullptr); } else if (ctx->offscreen && commandBuffer == &ctx->vkDrawCommandBuffers[0]) { submit(commandBuffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, {}, {}, nullptr); } else { submit(commandBuffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, {ctx->presentCompleteSemaphore}, {ctx->renderCompleteSemaphore}, ctx->frameFences[ctx->currentImageIndex]); } } void VKQueue::submit(CommandBuffer *commandBuffer, VkPipelineStageFlags waitStageMask, const std::vector<Semaphore *> &waitSemaphores, const std::vector<Semaphore *> &signalSemaphores, Fence *waitFence) { VkResult vkResult; std::vector<VkSemaphore> vkWaitSemaphores(waitSemaphores.size()); for (size_t j = 0; j < waitSemaphores.size(); j++) vkWaitSemaphores[j] = vk(waitSemaphores[j])->v; std::vector<VkSemaphore> vkSignalSemaphores(signalSemaphores.size()); for (size_t j = 0; j < signalSemaphores.size(); j++) vkSignalSemaphores[j] = vk(signalSemaphores[j])->v; VkSubmitInfo submitInfo = {VK_STRUCTURE_TYPE_SUBMIT_INFO, nullptr, uint32_t(vkWaitSemaphores.size()), vkWaitSemaphores.data(), &waitStageMask, 1, &vk(commandBuffer)->v, uint32_t(vkSignalSemaphores.size()), vkSignalSemaphores.data()}; V(vkQueueSubmit(v, 1, &submitInfo, waitFence ? vk(waitFence)->v : VK_NULL_HANDLE)); } void VKQueue::waitIdle() { VkResult vkResult; V(vkQueueWaitIdle(v)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKQueue.cpp"},{"location":"api/Files/VKQueue_8cpp/#srcngfxportingvulkanvkqueuecpp","text":"","title":"src/ngfx/porting/vulkan/VKQueue.cpp"},{"location":"api/Files/VKQueue_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKQueue.h\" #include \"ngfx/porting/vulkan/VKCommandBuffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKFence.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKSemaphore.h\" #include \"ngfx/porting/vulkan/VKSwapchain.h\" using namespace ngfx; void VKQueue::create(VKGraphicsContext *ctx, int queueFamilyIndex, int queueIndex) { this->ctx = ctx; VK_TRACE(vkGetDeviceQueue(ctx->vkDevice.v, queueFamilyIndex, queueIndex, &v)); } VKQueue::~VKQueue() {} void VKQueue::present() { VkResult vkResult; Swapchain *swapChain = ctx->swapchain; uint32_t currentImageIndex = ctx->currentImageIndex; const std::vector<VkSemaphore> vkWaitSemaphores = { ctx->vkRenderCompleteSemaphore.v}; VkPresentInfoKHR presentInfo = {VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, nullptr, uint32_t(vkWaitSemaphores.size()), vkWaitSemaphores.data(), 1, &vk(swapChain)->v, &currentImageIndex, nullptr}; V(vkQueuePresentKHR(v, &presentInfo)); } void VKQueue::submit(CommandBuffer *commandBuffer) { if (commandBuffer == &ctx->vkComputeCommandBuffer) { submit(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, {}, {}, ctx->computeFence); } else if (commandBuffer == &ctx->vkCopyCommandBuffer) { submit(commandBuffer, 0, {}, {}, nullptr); } else if (ctx->offscreen && commandBuffer == &ctx->vkDrawCommandBuffers[0]) { submit(commandBuffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, {}, {}, nullptr); } else { submit(commandBuffer, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, {ctx->presentCompleteSemaphore}, {ctx->renderCompleteSemaphore}, ctx->frameFences[ctx->currentImageIndex]); } } void VKQueue::submit(CommandBuffer *commandBuffer, VkPipelineStageFlags waitStageMask, const std::vector<Semaphore *> &waitSemaphores, const std::vector<Semaphore *> &signalSemaphores, Fence *waitFence) { VkResult vkResult; std::vector<VkSemaphore> vkWaitSemaphores(waitSemaphores.size()); for (size_t j = 0; j < waitSemaphores.size(); j++) vkWaitSemaphores[j] = vk(waitSemaphores[j])->v; std::vector<VkSemaphore> vkSignalSemaphores(signalSemaphores.size()); for (size_t j = 0; j < signalSemaphores.size(); j++) vkSignalSemaphores[j] = vk(signalSemaphores[j])->v; VkSubmitInfo submitInfo = {VK_STRUCTURE_TYPE_SUBMIT_INFO, nullptr, uint32_t(vkWaitSemaphores.size()), vkWaitSemaphores.data(), &waitStageMask, 1, &vk(commandBuffer)->v, uint32_t(vkSignalSemaphores.size()), vkSignalSemaphores.data()}; V(vkQueueSubmit(v, 1, &submitInfo, waitFence ? vk(waitFence)->v : VK_NULL_HANDLE)); } void VKQueue::waitIdle() { VkResult vkResult; V(vkQueueWaitIdle(v)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKQueue_8h/","text":"src/ngfx/porting/vulkan/VKQueue.h Namespaces Name ngfx Classes Name class ngfx::VKQueue Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Queue.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" namespace ngfx { class VKGraphicsContext; class VKQueue : public Queue { public: void create(VKGraphicsContext *ctx, int queueFamilyIndex, int queueIndex); virtual ~VKQueue(); virtual void present(); virtual void submit(CommandBuffer *commandBuffer); void submit(CommandBuffer *commandBuffer, VkPipelineStageFlags waitStageMask, const std::vector<Semaphore *> &waitSemaphores, const std::vector<Semaphore *> &signalSemaphores, Fence *waitFence); virtual void waitIdle(); VkQueue v = VK_NULL_HANDLE; private: VKGraphicsContext *ctx; }; VK_CAST(Queue); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKQueue.h"},{"location":"api/Files/VKQueue_8h/#srcngfxportingvulkanvkqueueh","text":"","title":"src/ngfx/porting/vulkan/VKQueue.h"},{"location":"api/Files/VKQueue_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKQueue_8h/#classes","text":"Name class ngfx::VKQueue","title":"Classes"},{"location":"api/Files/VKQueue_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Queue.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" namespace ngfx { class VKGraphicsContext; class VKQueue : public Queue { public: void create(VKGraphicsContext *ctx, int queueFamilyIndex, int queueIndex); virtual ~VKQueue(); virtual void present(); virtual void submit(CommandBuffer *commandBuffer); void submit(CommandBuffer *commandBuffer, VkPipelineStageFlags waitStageMask, const std::vector<Semaphore *> &waitSemaphores, const std::vector<Semaphore *> &signalSemaphores, Fence *waitFence); virtual void waitIdle(); VkQueue v = VK_NULL_HANDLE; private: VKGraphicsContext *ctx; }; VK_CAST(Queue); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKRenderPass_8cpp/","text":"src/ngfx/porting/vulkan/VKRenderPass.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKRenderPass.h\" #include \"ngfx/porting/vulkan/VKCommandBuffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKTexture.h\" #include <vector> using namespace ngfx; void VKRenderPass::create( VkDevice device, const std::vector<VkAttachmentDescription> &pAttachmentsDesc, const std::vector<VkSubpassDescription> &pSubpassesDesc, const std::vector<VkSubpassDependency> &pDependenciesDesc) { VkResult vkResult; this->device = device; this->attachmentsDesc = pAttachmentsDesc; this->subpassesDesc = pSubpassesDesc; this->dependencies = pDependenciesDesc; createInfo = {VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, nullptr, 0, uint32_t(attachmentsDesc.size()), attachmentsDesc.data(), uint32_t(subpassesDesc.size()), subpassesDesc.data(), uint32_t(dependencies.size()), dependencies.data()}; V(vkCreateRenderPass(device, &createInfo, nullptr, &v)); } VKRenderPass::~VKRenderPass() { if (v) VK_TRACE(vkDestroyRenderPass(device, v, nullptr)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKRenderPass.cpp"},{"location":"api/Files/VKRenderPass_8cpp/#srcngfxportingvulkanvkrenderpasscpp","text":"","title":"src/ngfx/porting/vulkan/VKRenderPass.cpp"},{"location":"api/Files/VKRenderPass_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKRenderPass.h\" #include \"ngfx/porting/vulkan/VKCommandBuffer.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKTexture.h\" #include <vector> using namespace ngfx; void VKRenderPass::create( VkDevice device, const std::vector<VkAttachmentDescription> &pAttachmentsDesc, const std::vector<VkSubpassDescription> &pSubpassesDesc, const std::vector<VkSubpassDependency> &pDependenciesDesc) { VkResult vkResult; this->device = device; this->attachmentsDesc = pAttachmentsDesc; this->subpassesDesc = pSubpassesDesc; this->dependencies = pDependenciesDesc; createInfo = {VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, nullptr, 0, uint32_t(attachmentsDesc.size()), attachmentsDesc.data(), uint32_t(subpassesDesc.size()), subpassesDesc.data(), uint32_t(dependencies.size()), dependencies.data()}; V(vkCreateRenderPass(device, &createInfo, nullptr, &v)); } VKRenderPass::~VKRenderPass() { if (v) VK_TRACE(vkDestroyRenderPass(device, v, nullptr)); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKRenderPass_8h/","text":"src/ngfx/porting/vulkan/VKRenderPass.h Namespaces Name ngfx Classes Name class ngfx::VKRenderPass Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKFramebuffer.h\" #include <glm/glm.hpp> #include <vector> #include <vulkan/vulkan.h> namespace ngfx { class VKRenderPass : public RenderPass { public: void create(VkDevice device, const std::vector<VkAttachmentDescription> &attachmentsDesc, const std::vector<VkSubpassDescription> &subpassesDesc, const std::vector<VkSubpassDependency> &dependencies); virtual ~VKRenderPass(); VkRenderPass v = VK_NULL_HANDLE; VkRenderPassCreateInfo createInfo; std::vector<VkAttachmentDescription> attachmentsDesc; std::vector<VkSubpassDescription> subpassesDesc; std::vector<VkSubpassDependency> dependencies; private: VkDevice device; }; VK_CAST(RenderPass); }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKRenderPass.h"},{"location":"api/Files/VKRenderPass_8h/#srcngfxportingvulkanvkrenderpassh","text":"","title":"src/ngfx/porting/vulkan/VKRenderPass.h"},{"location":"api/Files/VKRenderPass_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKRenderPass_8h/#classes","text":"Name class ngfx::VKRenderPass","title":"Classes"},{"location":"api/Files/VKRenderPass_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/RenderPass.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKFramebuffer.h\" #include <glm/glm.hpp> #include <vector> #include <vulkan/vulkan.h> namespace ngfx { class VKRenderPass : public RenderPass { public: void create(VkDevice device, const std::vector<VkAttachmentDescription> &attachmentsDesc, const std::vector<VkSubpassDescription> &subpassesDesc, const std::vector<VkSubpassDependency> &dependencies); virtual ~VKRenderPass(); VkRenderPass v = VK_NULL_HANDLE; VkRenderPassCreateInfo createInfo; std::vector<VkAttachmentDescription> attachmentsDesc; std::vector<VkSubpassDescription> subpassesDesc; std::vector<VkSubpassDependency> dependencies; private: VkDevice device; }; VK_CAST(RenderPass); }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKSamplerCreateInfo_8h/","text":"src/ngfx/porting/vulkan/VKSamplerCreateInfo.h Namespaces Name ngfx Classes Name struct ngfx::VKSamplerCreateInfo Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <vulkan/vulkan.h> namespace ngfx { struct VKSamplerCreateInfo : VkSamplerCreateInfo { VKSamplerCreateInfo() { sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO; pNext = VK_NULL_HANDLE; flags = 0; magFilter = VK_FILTER_NEAREST; minFilter = VK_FILTER_NEAREST; mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST; addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; mipLodBias = 0.0f; anisotropyEnable = VK_FALSE; maxAnisotropy = 0.0f; compareEnable = VK_FALSE; compareOp = VK_COMPARE_OP_NEVER; minLod = 0.0f; maxLod = 1.0f; borderColor = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK; unnormalizedCoordinates = VK_FALSE; } }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKSamplerCreateInfo.h"},{"location":"api/Files/VKSamplerCreateInfo_8h/#srcngfxportingvulkanvksamplercreateinfoh","text":"","title":"src/ngfx/porting/vulkan/VKSamplerCreateInfo.h"},{"location":"api/Files/VKSamplerCreateInfo_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKSamplerCreateInfo_8h/#classes","text":"Name struct ngfx::VKSamplerCreateInfo","title":"Classes"},{"location":"api/Files/VKSamplerCreateInfo_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <vulkan/vulkan.h> namespace ngfx { struct VKSamplerCreateInfo : VkSamplerCreateInfo { VKSamplerCreateInfo() { sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO; pNext = VK_NULL_HANDLE; flags = 0; magFilter = VK_FILTER_NEAREST; minFilter = VK_FILTER_NEAREST; mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST; addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE; mipLodBias = 0.0f; anisotropyEnable = VK_FALSE; maxAnisotropy = 0.0f; compareEnable = VK_FALSE; compareOp = VK_COMPARE_OP_NEVER; minLod = 0.0f; maxLod = 1.0f; borderColor = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK; unnormalizedCoordinates = VK_FALSE; } }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKSemaphore_8cpp/","text":"src/ngfx/porting/vulkan/VKSemaphore.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKSemaphore.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKSemaphore::create(VkDevice device) { this->device = device; VkResult vkResult; createInfo = {VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, nullptr, 0}; V(vkCreateSemaphore(device, &createInfo, nullptr, &v)); } VKSemaphore::~VKSemaphore() { if (v) VK_TRACE(vkDestroySemaphore(device, v, nullptr)); } uint64_t VKSemaphore::wait() { /*VkResult vkResult; uint64_t value; VkSemaphoreWaitInfo waitInfo = { VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO, nullptr, 0, 1, &v, &value }; V(vkWaitSemaphores(device, &waitInfo, UINT64_MAX)); return value;*/ return 0; } void VKSemaphore::signal(uint64_t value) { /*VkResult vkResult; VkSemaphoreSignalInfo signalInfo = { VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO, nullptr, v, value }; V(vkSignalSemaphore(device, &signalInfo));*/ } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKSemaphore.cpp"},{"location":"api/Files/VKSemaphore_8cpp/#srcngfxportingvulkanvksemaphorecpp","text":"","title":"src/ngfx/porting/vulkan/VKSemaphore.cpp"},{"location":"api/Files/VKSemaphore_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKSemaphore.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" using namespace ngfx; void VKSemaphore::create(VkDevice device) { this->device = device; VkResult vkResult; createInfo = {VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, nullptr, 0}; V(vkCreateSemaphore(device, &createInfo, nullptr, &v)); } VKSemaphore::~VKSemaphore() { if (v) VK_TRACE(vkDestroySemaphore(device, v, nullptr)); } uint64_t VKSemaphore::wait() { /*VkResult vkResult; uint64_t value; VkSemaphoreWaitInfo waitInfo = { VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO, nullptr, 0, 1, &v, &value }; V(vkWaitSemaphores(device, &waitInfo, UINT64_MAX)); return value;*/ return 0; } void VKSemaphore::signal(uint64_t value) { /*VkResult vkResult; VkSemaphoreSignalInfo signalInfo = { VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO, nullptr, v, value }; V(vkSignalSemaphore(device, &signalInfo));*/ } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKSemaphore_8h/","text":"src/ngfx/porting/vulkan/VKSemaphore.h Namespaces Name ngfx Classes Name class ngfx::VKSemaphore Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Semaphore.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKSemaphore : public Semaphore { public: void create(VkDevice device); virtual ~VKSemaphore(); virtual uint64_t wait(); virtual void signal(uint64_t value = 1); VkSemaphore v = VK_NULL_HANDLE; VkSemaphoreCreateInfo createInfo; private: VkDevice device; }; VK_CAST(Semaphore); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKSemaphore.h"},{"location":"api/Files/VKSemaphore_8h/#srcngfxportingvulkanvksemaphoreh","text":"","title":"src/ngfx/porting/vulkan/VKSemaphore.h"},{"location":"api/Files/VKSemaphore_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKSemaphore_8h/#classes","text":"Name class ngfx::VKSemaphore","title":"Classes"},{"location":"api/Files/VKSemaphore_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Semaphore.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKSemaphore : public Semaphore { public: void create(VkDevice device); virtual ~VKSemaphore(); virtual uint64_t wait(); virtual void signal(uint64_t value = 1); VkSemaphore v = VK_NULL_HANDLE; VkSemaphoreCreateInfo createInfo; private: VkDevice device; }; VK_CAST(Semaphore); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKShaderModule_8cpp/","text":"src/ngfx/porting/vulkan/VKShaderModule.cpp Functions Name template <typename T > std::unique_ptr< T > createShaderModule ( Device * device, const std::string & filename) Functions Documentation function createShaderModule template <typename T > static std::unique_ptr< T > createShaderModule( Device * device, const std::string & filename ) Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKShaderModule.h\" #include \"ngfx/core/File.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" using namespace ngfx; using namespace std; void VKShaderModule::initFromFile(VkDevice device, const std::string &filename) { File file; #ifdef USE_PRECOMPILED_SHADERS file.read(filename + \".spv\"); initFromByteCode(device, file.data.get(), file.size); #else NGFX_ERR(\"TODO: Support runtime shader compilation\"); #endif } void VKShaderModule::initFromByteCode(VkDevice device, void *data, uint32_t size) { this->device = device; VkResult vkResult; VkShaderModuleCreateInfo moduleCreateInfo = { VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, nullptr, 0, size, (const uint32_t *)data}; V(vkCreateShaderModule(this->device, &moduleCreateInfo, NULL, &v)); } VKShaderModule::~VKShaderModule() { if (v) VK_TRACE(vkDestroyShaderModule(device, v, nullptr)); } template <typename T> static std::unique_ptr<T> createShaderModule(Device *device, const std::string &filename) { auto vkShaderModule = make_unique<T>(); vkShaderModule->initFromFile(vk(device)->v, filename); vkShaderModule->initBindings(filename + \".map\"); return vkShaderModule; } unique_ptr<VertexShaderModule> VertexShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<VKVertexShaderModule>(device, filename); } unique_ptr<FragmentShaderModule> FragmentShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<VKFragmentShaderModule>(device, filename); } unique_ptr<ComputeShaderModule> ComputeShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<VKComputeShaderModule>(device, filename); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKShaderModule.cpp"},{"location":"api/Files/VKShaderModule_8cpp/#srcngfxportingvulkanvkshadermodulecpp","text":"","title":"src/ngfx/porting/vulkan/VKShaderModule.cpp"},{"location":"api/Files/VKShaderModule_8cpp/#functions","text":"Name template <typename T > std::unique_ptr< T > createShaderModule ( Device * device, const std::string & filename)","title":"Functions"},{"location":"api/Files/VKShaderModule_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/VKShaderModule_8cpp/#function-createshadermodule","text":"template <typename T > static std::unique_ptr< T > createShaderModule( Device * device, const std::string & filename )","title":"function createShaderModule"},{"location":"api/Files/VKShaderModule_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKShaderModule.h\" #include \"ngfx/core/File.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" using namespace ngfx; using namespace std; void VKShaderModule::initFromFile(VkDevice device, const std::string &filename) { File file; #ifdef USE_PRECOMPILED_SHADERS file.read(filename + \".spv\"); initFromByteCode(device, file.data.get(), file.size); #else NGFX_ERR(\"TODO: Support runtime shader compilation\"); #endif } void VKShaderModule::initFromByteCode(VkDevice device, void *data, uint32_t size) { this->device = device; VkResult vkResult; VkShaderModuleCreateInfo moduleCreateInfo = { VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, nullptr, 0, size, (const uint32_t *)data}; V(vkCreateShaderModule(this->device, &moduleCreateInfo, NULL, &v)); } VKShaderModule::~VKShaderModule() { if (v) VK_TRACE(vkDestroyShaderModule(device, v, nullptr)); } template <typename T> static std::unique_ptr<T> createShaderModule(Device *device, const std::string &filename) { auto vkShaderModule = make_unique<T>(); vkShaderModule->initFromFile(vk(device)->v, filename); vkShaderModule->initBindings(filename + \".map\"); return vkShaderModule; } unique_ptr<VertexShaderModule> VertexShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<VKVertexShaderModule>(device, filename); } unique_ptr<FragmentShaderModule> FragmentShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<VKFragmentShaderModule>(device, filename); } unique_ptr<ComputeShaderModule> ComputeShaderModule::create(Device *device, const std::string &filename) { return createShaderModule<VKComputeShaderModule>(device, filename); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKShaderModule_8h/","text":"src/ngfx/porting/vulkan/VKShaderModule.h Namespaces Name ngfx Classes Name class ngfx::VKShaderModule class ngfx::VKVertexShaderModule class ngfx::VKFragmentShaderModule class ngfx::VKComputeShaderModule Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKShaderModule { public: virtual void initFromFile(VkDevice device, const std::string &filename); virtual ~VKShaderModule(); VkShaderModule v = VK_NULL_HANDLE; protected: virtual void initFromByteCode(VkDevice device, void *data, uint32_t size); private: VkDevice device; }; VK_CAST(ShaderModule); class VKVertexShaderModule : public VertexShaderModule, public VKShaderModule { public: virtual ~VKVertexShaderModule() {} }; VK_CAST(VertexShaderModule); class VKFragmentShaderModule : public FragmentShaderModule, public VKShaderModule { public: virtual ~VKFragmentShaderModule() {} }; VK_CAST(FragmentShaderModule); class VKComputeShaderModule : public ComputeShaderModule, public VKShaderModule { public: virtual ~VKComputeShaderModule() {} }; VK_CAST(ComputeShaderModule); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKShaderModule.h"},{"location":"api/Files/VKShaderModule_8h/#srcngfxportingvulkanvkshadermoduleh","text":"","title":"src/ngfx/porting/vulkan/VKShaderModule.h"},{"location":"api/Files/VKShaderModule_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKShaderModule_8h/#classes","text":"Name class ngfx::VKShaderModule class ngfx::VKVertexShaderModule class ngfx::VKFragmentShaderModule class ngfx::VKComputeShaderModule","title":"Classes"},{"location":"api/Files/VKShaderModule_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/ShaderModule.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKShaderModule { public: virtual void initFromFile(VkDevice device, const std::string &filename); virtual ~VKShaderModule(); VkShaderModule v = VK_NULL_HANDLE; protected: virtual void initFromByteCode(VkDevice device, void *data, uint32_t size); private: VkDevice device; }; VK_CAST(ShaderModule); class VKVertexShaderModule : public VertexShaderModule, public VKShaderModule { public: virtual ~VKVertexShaderModule() {} }; VK_CAST(VertexShaderModule); class VKFragmentShaderModule : public FragmentShaderModule, public VKShaderModule { public: virtual ~VKFragmentShaderModule() {} }; VK_CAST(FragmentShaderModule); class VKComputeShaderModule : public ComputeShaderModule, public VKShaderModule { public: virtual ~VKComputeShaderModule() {} }; VK_CAST(ComputeShaderModule); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKSurface_8cpp/","text":"src/ngfx/porting/vulkan/VKSurface.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKSurface.h\" using namespace ngfx; void VKSurface::destroy() { vkDestroySurfaceKHR(instance, v, nullptr); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKSurface.cpp"},{"location":"api/Files/VKSurface_8cpp/#srcngfxportingvulkanvksurfacecpp","text":"","title":"src/ngfx/porting/vulkan/VKSurface.cpp"},{"location":"api/Files/VKSurface_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKSurface.h\" using namespace ngfx; void VKSurface::destroy() { vkDestroySurfaceKHR(instance, v, nullptr); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKSurface_8h/","text":"src/ngfx/porting/vulkan/VKSurface.h Namespaces Name ngfx Classes Name class ngfx::VKSurface Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKSurface : public Surface { public: virtual ~VKSurface() {} void destroy(); VkInstance instance = 0; VkSurfaceKHR v = 0; }; VK_CAST(Surface); }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKSurface.h"},{"location":"api/Files/VKSurface_8h/#srcngfxportingvulkanvksurfaceh","text":"","title":"src/ngfx/porting/vulkan/VKSurface.h"},{"location":"api/Files/VKSurface_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKSurface_8h/#classes","text":"Name class ngfx::VKSurface","title":"Classes"},{"location":"api/Files/VKSurface_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" #include <vulkan/vulkan.h> namespace ngfx { class VKSurface : public Surface { public: virtual ~VKSurface() {} void destroy(); VkInstance instance = 0; VkSurfaceKHR v = 0; }; VK_CAST(Surface); }; // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKSwapchain_8cpp/","text":"src/ngfx/porting/vulkan/VKSwapchain.cpp Attributes Name const VkPresentModeKHR PREFERRED_PRESENT_MODE Attributes Documentation variable PREFERRED_PRESENT_MODE static const VkPresentModeKHR PREFERRED_PRESENT_MODE = VK_PRESENT_MODE_MAILBOX_KHR; Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKSwapchain.h\" #include \"ngfx/core/Util.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKSemaphore.h\" using namespace ngfx; #ifdef ENABLE_VSYNC static const VkPresentModeKHR PREFERRED_PRESENT_MODE = VK_PRESENT_MODE_FIFO_KHR; #else static const VkPresentModeKHR PREFERRED_PRESENT_MODE = VK_PRESENT_MODE_MAILBOX_KHR; #endif void VKSwapchain::chooseNumSwapchainImages() { numImages = PREFERRED_NUM_SWAPCHAIN_IMAGES; if ((surfaceCaps.maxImageCount > 0) && (numImages > surfaceCaps.maxImageCount)) { numImages = surfaceCaps.maxImageCount; } } void VKSwapchain::chooseSurfaceFormat() { for (auto &fmt : surfaceFormats) { if (fmt.format == VK_FORMAT_B8G8R8A8_UNORM && fmt.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { surfaceFormat = fmt; return; } } surfaceFormat = surfaceFormats[0]; } void VKSwapchain::getSurfaceCapabilities(VkPhysicalDevice physicalDevice) { VkResult vkResult; V(vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface->v, &surfaceCaps)); } void VKSwapchain::getSurfaceFormats(VkPhysicalDevice physicalDevice) { VkResult vkResult; uint32_t surfaceFormatCount; V(vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface->v, &surfaceFormatCount, nullptr)); assert(surfaceFormatCount > 0); surfaceFormats.resize(surfaceFormatCount); V(vkGetPhysicalDeviceSurfaceFormatsKHR( physicalDevice, surface->v, &surfaceFormatCount, surfaceFormats.data())); } void VKSwapchain::choosePresentMode() { if (!Util::contains(presentModes, PREFERRED_PRESENT_MODE)) { NGFX_ERR(\"present mode: %d not supported\", PREFERRED_PRESENT_MODE); } else presentMode = PREFERRED_PRESENT_MODE; } void VKSwapchain::getPresentModes(VkPhysicalDevice physicalDevice) { VkResult vkResult; uint32_t presentModeCount; V(vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface->v, &presentModeCount, nullptr)); assert(presentModeCount > 0); presentModes.resize(presentModeCount); V(vkGetPhysicalDeviceSurfacePresentModesKHR( physicalDevice, surface->v, &presentModeCount, presentModes.data())); } void VKSwapchain::chooseCompositeAlphaMode() { // Choose the first composite alpha format available std::vector<VkCompositeAlphaFlagBitsKHR> compositeAlphaFlags = { VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR, VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR, VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR, VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR, }; for (auto &compositeAlphaFlag : compositeAlphaFlags) { if (surfaceCaps.supportedCompositeAlpha & compositeAlphaFlag) { compositeAlpha = compositeAlphaFlag; break; }; } } void VKSwapchain::choosePreTransform() { if (surfaceCaps.supportedTransforms & VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR) { preTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR; } else { preTransform = surfaceCaps.currentTransform; } } void VKSwapchain::createSwapchain(const VKDevice &vkDevice, uint32_t w, uint32_t h) { VkResult vkResult; createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; createInfo.pNext = NULL; createInfo.surface = surface->v; createInfo.minImageCount = numImages; createInfo.imageFormat = surfaceFormat.format; createInfo.imageColorSpace = surfaceFormat.colorSpace; createInfo.imageExtent = surfaceCaps.currentExtent; createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; createInfo.preTransform = (VkSurfaceTransformFlagBitsKHR)preTransform; createInfo.imageArrayLayers = 1; createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; createInfo.queueFamilyIndexCount = 0; createInfo.pQueueFamilyIndices = NULL; createInfo.presentMode = presentMode; createInfo.oldSwapchain = VK_NULL_HANDLE; // Setting clipped to VK_TRUE allows the implementation to discard rendering // outside of the surface area createInfo.clipped = VK_TRUE; createInfo.compositeAlpha = compositeAlpha; // Enable transfer source on swap chain images if supported if (surfaceCaps.supportedUsageFlags & VK_IMAGE_USAGE_TRANSFER_SRC_BIT) { createInfo.imageUsage |= VK_IMAGE_USAGE_TRANSFER_SRC_BIT; } // Enable transfer destination on swap chain images if supported if (surfaceCaps.supportedUsageFlags & VK_IMAGE_USAGE_TRANSFER_DST_BIT) { createInfo.imageUsage |= VK_IMAGE_USAGE_TRANSFER_DST_BIT; } V(vkCreateSwapchainKHR(vkDevice.v, &createInfo, nullptr, &v)) } void VKSwapchain::getSwapchainImages(VkDevice device) { VkResult vkResult; uint32_t imageCount; V(vkGetSwapchainImagesKHR(device, v, &imageCount, NULL)); images.resize(imageCount); V(vkGetSwapchainImagesKHR(device, v, &imageCount, images.data())); } void VKSwapchain::getQueueFamilyProperties( const VKPhysicalDevice &vkPhysicalDevice) { VkResult vkResult; uint32_t queueFamilyCount = uint32_t(vkPhysicalDevice.queueFamilyProperties.size()); queueFamilyProperties.resize(queueFamilyCount); auto physicalDevice = vkPhysicalDevice.v; for (uint32_t queueFamilyIndex = 0; queueFamilyIndex < queueFamilyCount; queueFamilyIndex++) { auto &queueFamilyProps = queueFamilyProperties[queueFamilyIndex]; V(vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface->v, &queueFamilyProps.supportsPresent)); } } void VKSwapchain::createSwapchainImageViews(const VKDevice &vkDevice) { uint32_t imageCount = uint32_t(images.size()); imageViews.resize(imageCount); for (uint32_t i = 0; i < imageCount; i++) { auto &imageView = imageViews[i]; imageView.create(vkDevice.v, images[i], VK_IMAGE_VIEW_TYPE_2D, surfaceFormat.format); } } VKSwapchain::VKSwapchain(VKGraphicsContext *ctx, VKSurface *surface) { this->ctx = ctx; auto &vkDevice = ctx->vkDevice; this->device = vkDevice.v; this->surface = surface; chooseNumSwapchainImages(); auto physicalDevice = vkDevice.vkPhysicalDevice->v; getSurfaceCapabilities(physicalDevice); getSurfaceFormats(physicalDevice); getPresentModes(physicalDevice); getQueueFamilyProperties(*vkDevice.vkPhysicalDevice); assert(queueFamilyProperties[vkDevice.queueFamilyIndices.graphics] .supportsPresent); chooseSurfaceFormat(); choosePresentMode(); chooseCompositeAlphaMode(); choosePreTransform(); createSwapchain(vkDevice, surface->w, surface->h); getSwapchainImages(vkDevice.v); createSwapchainImageViews(vkDevice); } VKSwapchain::~VKSwapchain() { if (v) VK_TRACE(vkDestroySwapchainKHR(device, v, nullptr)); surface->destroy(); }; void VKSwapchain::acquireNextImage() { VkResult vkResult; Semaphore *semaphore = ctx->presentCompleteSemaphore; uint32_t *imageIndex = &ctx->currentImageIndex; V(vkAcquireNextImageKHR(device, v, UINT64_MAX, vk(semaphore)->v, VK_NULL_HANDLE, imageIndex)); auto waitFence = ctx->frameFences[ctx->currentImageIndex]; waitFence->wait(); waitFence->reset(); } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKSwapchain.cpp"},{"location":"api/Files/VKSwapchain_8cpp/#srcngfxportingvulkanvkswapchaincpp","text":"","title":"src/ngfx/porting/vulkan/VKSwapchain.cpp"},{"location":"api/Files/VKSwapchain_8cpp/#attributes","text":"Name const VkPresentModeKHR PREFERRED_PRESENT_MODE","title":"Attributes"},{"location":"api/Files/VKSwapchain_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/VKSwapchain_8cpp/#variable-preferred_present_mode","text":"static const VkPresentModeKHR PREFERRED_PRESENT_MODE = VK_PRESENT_MODE_MAILBOX_KHR;","title":"variable PREFERRED_PRESENT_MODE"},{"location":"api/Files/VKSwapchain_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKSwapchain.h\" #include \"ngfx/core/Util.h\" #include \"ngfx/graphics/Config.h\" #include \"ngfx/porting/vulkan/VKDebugUtil.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKSemaphore.h\" using namespace ngfx; #ifdef ENABLE_VSYNC static const VkPresentModeKHR PREFERRED_PRESENT_MODE = VK_PRESENT_MODE_FIFO_KHR; #else static const VkPresentModeKHR PREFERRED_PRESENT_MODE = VK_PRESENT_MODE_MAILBOX_KHR; #endif void VKSwapchain::chooseNumSwapchainImages() { numImages = PREFERRED_NUM_SWAPCHAIN_IMAGES; if ((surfaceCaps.maxImageCount > 0) && (numImages > surfaceCaps.maxImageCount)) { numImages = surfaceCaps.maxImageCount; } } void VKSwapchain::chooseSurfaceFormat() { for (auto &fmt : surfaceFormats) { if (fmt.format == VK_FORMAT_B8G8R8A8_UNORM && fmt.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) { surfaceFormat = fmt; return; } } surfaceFormat = surfaceFormats[0]; } void VKSwapchain::getSurfaceCapabilities(VkPhysicalDevice physicalDevice) { VkResult vkResult; V(vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface->v, &surfaceCaps)); } void VKSwapchain::getSurfaceFormats(VkPhysicalDevice physicalDevice) { VkResult vkResult; uint32_t surfaceFormatCount; V(vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface->v, &surfaceFormatCount, nullptr)); assert(surfaceFormatCount > 0); surfaceFormats.resize(surfaceFormatCount); V(vkGetPhysicalDeviceSurfaceFormatsKHR( physicalDevice, surface->v, &surfaceFormatCount, surfaceFormats.data())); } void VKSwapchain::choosePresentMode() { if (!Util::contains(presentModes, PREFERRED_PRESENT_MODE)) { NGFX_ERR(\"present mode: %d not supported\", PREFERRED_PRESENT_MODE); } else presentMode = PREFERRED_PRESENT_MODE; } void VKSwapchain::getPresentModes(VkPhysicalDevice physicalDevice) { VkResult vkResult; uint32_t presentModeCount; V(vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface->v, &presentModeCount, nullptr)); assert(presentModeCount > 0); presentModes.resize(presentModeCount); V(vkGetPhysicalDeviceSurfacePresentModesKHR( physicalDevice, surface->v, &presentModeCount, presentModes.data())); } void VKSwapchain::chooseCompositeAlphaMode() { // Choose the first composite alpha format available std::vector<VkCompositeAlphaFlagBitsKHR> compositeAlphaFlags = { VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR, VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR, VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR, VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR, }; for (auto &compositeAlphaFlag : compositeAlphaFlags) { if (surfaceCaps.supportedCompositeAlpha & compositeAlphaFlag) { compositeAlpha = compositeAlphaFlag; break; }; } } void VKSwapchain::choosePreTransform() { if (surfaceCaps.supportedTransforms & VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR) { preTransform = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR; } else { preTransform = surfaceCaps.currentTransform; } } void VKSwapchain::createSwapchain(const VKDevice &vkDevice, uint32_t w, uint32_t h) { VkResult vkResult; createInfo = {}; createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; createInfo.pNext = NULL; createInfo.surface = surface->v; createInfo.minImageCount = numImages; createInfo.imageFormat = surfaceFormat.format; createInfo.imageColorSpace = surfaceFormat.colorSpace; createInfo.imageExtent = surfaceCaps.currentExtent; createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; createInfo.preTransform = (VkSurfaceTransformFlagBitsKHR)preTransform; createInfo.imageArrayLayers = 1; createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; createInfo.queueFamilyIndexCount = 0; createInfo.pQueueFamilyIndices = NULL; createInfo.presentMode = presentMode; createInfo.oldSwapchain = VK_NULL_HANDLE; // Setting clipped to VK_TRUE allows the implementation to discard rendering // outside of the surface area createInfo.clipped = VK_TRUE; createInfo.compositeAlpha = compositeAlpha; // Enable transfer source on swap chain images if supported if (surfaceCaps.supportedUsageFlags & VK_IMAGE_USAGE_TRANSFER_SRC_BIT) { createInfo.imageUsage |= VK_IMAGE_USAGE_TRANSFER_SRC_BIT; } // Enable transfer destination on swap chain images if supported if (surfaceCaps.supportedUsageFlags & VK_IMAGE_USAGE_TRANSFER_DST_BIT) { createInfo.imageUsage |= VK_IMAGE_USAGE_TRANSFER_DST_BIT; } V(vkCreateSwapchainKHR(vkDevice.v, &createInfo, nullptr, &v)) } void VKSwapchain::getSwapchainImages(VkDevice device) { VkResult vkResult; uint32_t imageCount; V(vkGetSwapchainImagesKHR(device, v, &imageCount, NULL)); images.resize(imageCount); V(vkGetSwapchainImagesKHR(device, v, &imageCount, images.data())); } void VKSwapchain::getQueueFamilyProperties( const VKPhysicalDevice &vkPhysicalDevice) { VkResult vkResult; uint32_t queueFamilyCount = uint32_t(vkPhysicalDevice.queueFamilyProperties.size()); queueFamilyProperties.resize(queueFamilyCount); auto physicalDevice = vkPhysicalDevice.v; for (uint32_t queueFamilyIndex = 0; queueFamilyIndex < queueFamilyCount; queueFamilyIndex++) { auto &queueFamilyProps = queueFamilyProperties[queueFamilyIndex]; V(vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface->v, &queueFamilyProps.supportsPresent)); } } void VKSwapchain::createSwapchainImageViews(const VKDevice &vkDevice) { uint32_t imageCount = uint32_t(images.size()); imageViews.resize(imageCount); for (uint32_t i = 0; i < imageCount; i++) { auto &imageView = imageViews[i]; imageView.create(vkDevice.v, images[i], VK_IMAGE_VIEW_TYPE_2D, surfaceFormat.format); } } VKSwapchain::VKSwapchain(VKGraphicsContext *ctx, VKSurface *surface) { this->ctx = ctx; auto &vkDevice = ctx->vkDevice; this->device = vkDevice.v; this->surface = surface; chooseNumSwapchainImages(); auto physicalDevice = vkDevice.vkPhysicalDevice->v; getSurfaceCapabilities(physicalDevice); getSurfaceFormats(physicalDevice); getPresentModes(physicalDevice); getQueueFamilyProperties(*vkDevice.vkPhysicalDevice); assert(queueFamilyProperties[vkDevice.queueFamilyIndices.graphics] .supportsPresent); chooseSurfaceFormat(); choosePresentMode(); chooseCompositeAlphaMode(); choosePreTransform(); createSwapchain(vkDevice, surface->w, surface->h); getSwapchainImages(vkDevice.v); createSwapchainImageViews(vkDevice); } VKSwapchain::~VKSwapchain() { if (v) VK_TRACE(vkDestroySwapchainKHR(device, v, nullptr)); surface->destroy(); }; void VKSwapchain::acquireNextImage() { VkResult vkResult; Semaphore *semaphore = ctx->presentCompleteSemaphore; uint32_t *imageIndex = &ctx->currentImageIndex; V(vkAcquireNextImageKHR(device, v, UINT64_MAX, vk(semaphore)->v, VK_NULL_HANDLE, imageIndex)); auto waitFence = ctx->frameFences[ctx->currentImageIndex]; waitFence->wait(); waitFence->reset(); } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKSwapchain_8h/","text":"src/ngfx/porting/vulkan/VKSwapchain.h Namespaces Name ngfx Classes Name class ngfx::VKSwapchain struct ngfx::VKSwapchain::queueFamilyProperties Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Swapchain.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKImageView.h\" #include \"ngfx/porting/vulkan/VKPhysicalDevice.h\" #include \"ngfx/porting/vulkan/VKSurface.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" namespace ngfx { class VKGraphicsContext; class VKSwapchain : public Swapchain { public: VKSwapchain(VKGraphicsContext *ctx, VKSurface *surface); virtual ~VKSwapchain(); virtual void acquireNextImage(); VkSurfaceCapabilitiesKHR surfaceCaps; VKSurface *surface; VkSwapchainKHR v = VK_NULL_HANDLE; VkSurfaceFormatKHR surfaceFormat; std::vector<VkSurfaceFormatKHR> surfaceFormats; std::vector<VkPresentModeKHR> presentModes; VkPresentModeKHR presentMode; VkCompositeAlphaFlagBitsKHR compositeAlpha; VkSurfaceTransformFlagsKHR preTransform; std::vector<VkImage> images; std::vector<VKImageView> imageViews; struct queueFamilyProperties { VkBool32 supportsPresent = VK_FALSE; }; std::vector<queueFamilyProperties> queueFamilyProperties; VkSwapchainCreateInfoKHR createInfo; private: void chooseCompositeAlphaMode(); void chooseSurfaceFormat(); void chooseNumSwapchainImages(); void choosePresentMode(); void choosePreTransform(); void createSwapchain(const VKDevice &vkDevice, uint32_t w, uint32_t h); void getPresentModes(VkPhysicalDevice physicalDevice); void getQueueFamilyProperties(const VKPhysicalDevice &vkPhysicalDevice); void getSurfaceCapabilities(VkPhysicalDevice physicalDevice); void getSwapchainImages(VkDevice device); void createSwapchainImageViews(const VKDevice &device); void getSurfaceFormats(VkPhysicalDevice physicalDevice); VKGraphicsContext *ctx; VkDevice device; }; VK_CAST(Swapchain); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKSwapchain.h"},{"location":"api/Files/VKSwapchain_8h/#srcngfxportingvulkanvkswapchainh","text":"","title":"src/ngfx/porting/vulkan/VKSwapchain.h"},{"location":"api/Files/VKSwapchain_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKSwapchain_8h/#classes","text":"Name class ngfx::VKSwapchain struct ngfx::VKSwapchain::queueFamilyProperties","title":"Classes"},{"location":"api/Files/VKSwapchain_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Swapchain.h\" #include \"ngfx/porting/vulkan/VKDevice.h\" #include \"ngfx/porting/vulkan/VKImageView.h\" #include \"ngfx/porting/vulkan/VKPhysicalDevice.h\" #include \"ngfx/porting/vulkan/VKSurface.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" namespace ngfx { class VKGraphicsContext; class VKSwapchain : public Swapchain { public: VKSwapchain(VKGraphicsContext *ctx, VKSurface *surface); virtual ~VKSwapchain(); virtual void acquireNextImage(); VkSurfaceCapabilitiesKHR surfaceCaps; VKSurface *surface; VkSwapchainKHR v = VK_NULL_HANDLE; VkSurfaceFormatKHR surfaceFormat; std::vector<VkSurfaceFormatKHR> surfaceFormats; std::vector<VkPresentModeKHR> presentModes; VkPresentModeKHR presentMode; VkCompositeAlphaFlagBitsKHR compositeAlpha; VkSurfaceTransformFlagsKHR preTransform; std::vector<VkImage> images; std::vector<VKImageView> imageViews; struct queueFamilyProperties { VkBool32 supportsPresent = VK_FALSE; }; std::vector<queueFamilyProperties> queueFamilyProperties; VkSwapchainCreateInfoKHR createInfo; private: void chooseCompositeAlphaMode(); void chooseSurfaceFormat(); void chooseNumSwapchainImages(); void choosePresentMode(); void choosePreTransform(); void createSwapchain(const VKDevice &vkDevice, uint32_t w, uint32_t h); void getPresentModes(VkPhysicalDevice physicalDevice); void getQueueFamilyProperties(const VKPhysicalDevice &vkPhysicalDevice); void getSurfaceCapabilities(VkPhysicalDevice physicalDevice); void getSwapchainImages(VkDevice device); void createSwapchainImageViews(const VKDevice &device); void getSurfaceFormats(VkPhysicalDevice physicalDevice); VKGraphicsContext *ctx; VkDevice device; }; VK_CAST(Swapchain); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKTexture_8cpp/","text":"src/ngfx/porting/vulkan/VKTexture.cpp Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKTexture.h\" #include \"ngfx/porting/vulkan/VKBlit.h\" #include \"ngfx/porting/vulkan/VKBuffer.h\" #include \"ngfx/porting/vulkan/VKCommandBuffer.h\" #include \"ngfx/porting/vulkan/VKComputePipeline.h\" #include \"ngfx/porting/vulkan/VKGraphicsPipeline.h\" #include \"ngfx/porting/vulkan/VKQueue.h\" #include <algorithm> using namespace ngfx; void VKTexture::create(VKGraphicsContext *ctx, void *data, uint32_t size, VkExtent3D extent, uint32_t arrayLayers, VkFormat format, VkImageUsageFlags imageUsageFlags, VkImageViewType imageViewType, bool genMipmaps, VKSamplerCreateInfo *pSamplerCreateInfo, uint32_t numSamples) { this->ctx = ctx; this->w = extent.width; this->h = extent.height; this->d = extent.depth; this->arrayLayers = arrayLayers; this->numSamples = numSamples; this->vkFormat = format; this->imageUsageFlags = imageUsageFlags; this->genMipmaps = genMipmaps; this->samplerCreateInfo.reset(pSamplerCreateInfo); const std::vector<VkFormat> depthFormats = { VK_FORMAT_D16_UNORM, VK_FORMAT_X8_D24_UNORM_PACK32, VK_FORMAT_D32_SFLOAT}; depthTexture = std::find(depthFormats.begin(), depthFormats.end(), format) != depthFormats.end(); this->aspectFlags = depthTexture ? VK_IMAGE_ASPECT_DEPTH_BIT : VK_IMAGE_ASPECT_COLOR_BIT; VkImageType imageType; if (imageViewType == VK_IMAGE_VIEW_TYPE_1D || imageViewType == VK_IMAGE_VIEW_TYPE_1D_ARRAY) imageType = VK_IMAGE_TYPE_1D; else if (imageViewType == VK_IMAGE_VIEW_TYPE_2D || imageViewType == VK_IMAGE_VIEW_TYPE_2D_ARRAY || imageViewType == VK_IMAGE_VIEW_TYPE_CUBE) imageType = VK_IMAGE_TYPE_2D; else imageType = VK_IMAGE_TYPE_3D; this->mipLevels = genMipmaps ? floor(log2(float(glm::min(extent.width, extent.height)))) + 1 : 1; vkImage.create(&ctx->vkDevice, extent, format, imageUsageFlags, imageType, mipLevels, arrayLayers, numSamples, (imageViewType == VK_IMAGE_VIEW_TYPE_CUBE) ? VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT : 0); vkDefaultImageView = getImageView(imageViewType, mipLevels, arrayLayers); auto &copyCommandBuffer = ctx->vkCopyCommandBuffer; std::unique_ptr<VKBuffer> stagingBuffer; if (data) { stagingBuffer.reset(new VKBuffer()); stagingBuffer->create(ctx, data, size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT); } copyCommandBuffer.begin(); uploadFn(copyCommandBuffer.v, data, size, stagingBuffer.get()); if (imageUsageFlags & IMAGE_USAGE_SAMPLED_BIT) { if (genMipmaps) samplerCreateInfo->maxLod = mipLevels; if (!sampler) initSampler(); if (!samplerDescriptorSet) initSamplerDescriptorSet(copyCommandBuffer.v); } if (imageUsageFlags & IMAGE_USAGE_STORAGE_BIT) { if (!storageImageDescriptorSet) initStorageImageDescriptorSet(copyCommandBuffer.v); } if (imageUsageFlags & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) { vkImage.changeLayout( copyCommandBuffer.v, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT, VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, aspectFlags); } else if (imageUsageFlags & VK_IMAGE_USAGE_STORAGE_BIT) { vkImage.changeLayout(copyCommandBuffer.v, VK_IMAGE_LAYOUT_GENERAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); } else if (imageUsageFlags & VK_IMAGE_USAGE_SAMPLED_BIT) { vkImage.changeLayout( copyCommandBuffer.v, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); } copyCommandBuffer.end(); vk(ctx->queue)->submit(&copyCommandBuffer, 0, {}, {}, nullptr); ctx->queue->waitIdle(); } void VKTexture::generateMipmaps(CommandBuffer *commandBuffer) { generateMipmapsFn(vk(commandBuffer)->v); } void VKTexture::generateMipmapsFn(VkCommandBuffer cmdBuffer) { vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_ACCESS_TRANSFER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, aspectFlags, 0, 1, 0, arrayLayers); for (uint32_t j = 1; j < mipLevels; j++) { vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, aspectFlags, j, 1, 0, arrayLayers); VKBlit::blitImage( cmdBuffer, vkImage.v, j - 1, vkImage.v, j, {{0, 0, 0}, {int32_t(glm::max(w >> (j - 1), 1u)), int32_t(glm::max(h >> (j - 1), 1u)), 1}}, {{0, 0, 0}, {int32_t(glm::max(w >> j, 1u)), int32_t(glm::max(h >> j, 1u)), 1}}, 0, arrayLayers, 0, arrayLayers); vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_ACCESS_TRANSFER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, aspectFlags, j, 1, 0, arrayLayers); } } void VKTexture::upload(void *data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { auto &copyCommandBuffer = ctx->vkCopyCommandBuffer; std::unique_ptr<VKBuffer> stagingBuffer; if (data) { stagingBuffer.reset(new VKBuffer()); stagingBuffer->create(ctx, data, size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT); } copyCommandBuffer.begin(); uploadFn(copyCommandBuffer.v, data, size, stagingBuffer.get(), x, y, z, w, h, d, arrayLayers); if (imageUsageFlags & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) { vkImage.changeLayout( copyCommandBuffer.v, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT, VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, aspectFlags); } else if (imageUsageFlags & VK_IMAGE_USAGE_STORAGE_BIT) { vkImage.changeLayout(copyCommandBuffer.v, VK_IMAGE_LAYOUT_GENERAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); } else if (imageUsageFlags & VK_IMAGE_USAGE_SAMPLED_BIT) { vkImage.changeLayout( copyCommandBuffer.v, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); } copyCommandBuffer.end(); vk(ctx->queue)->submit(&copyCommandBuffer, 0, {}, {}, nullptr); ctx->queue->waitIdle(); } void VKTexture::uploadFn(VkCommandBuffer cmdBuffer, void *data, uint32_t size, VKBuffer *stagingBuffer, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { if (data) { if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; if (arrayLayers == -1) arrayLayers = this->arrayLayers; vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, aspectFlags, 0, 1, 0, arrayLayers); std::vector<VkBufferImageCopy> bufferCopyRegions = { {0, 0, 0, {aspectFlags, 0, 0, uint32_t(arrayLayers)}, {int32_t(x), int32_t(y), int32_t(z)}, {uint32_t(w), uint32_t(h), uint32_t(d)}}}; VK_TRACE(vkCmdCopyBufferToImage( cmdBuffer, stagingBuffer->v, vkImage.v, vkImage.imageLayout[0], uint32_t(bufferCopyRegions.size()), bufferCopyRegions.data())); } if (data && mipLevels != 1) generateMipmapsFn(cmdBuffer); } void VKTexture::download(void *data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { auto &copyCommandBuffer = ctx->vkCopyCommandBuffer; std::unique_ptr<VKBuffer> stagingBuffer; stagingBuffer.reset(new VKBuffer()); stagingBuffer->create(ctx, nullptr, size, VK_BUFFER_USAGE_TRANSFER_DST_BIT); copyCommandBuffer.begin(); downloadFn(copyCommandBuffer.v, data, size, stagingBuffer.get(), x, y, z, w, h, d, arrayLayers); copyCommandBuffer.end(); vk(ctx->queue)->submit(&copyCommandBuffer, 0, {}, {}, nullptr); ctx->queue->waitIdle(); stagingBuffer->download(data, size); } void VKTexture::downloadFn(VkCommandBuffer cmdBuffer, void *data, uint32_t size, VKBuffer *stagingBuffer, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; if (arrayLayers == -1) arrayLayers = this->arrayLayers; vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_ACCESS_TRANSFER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT); std::vector<VkBufferImageCopy> bufferCopyRegions = { {0, 0, 0, {aspectFlags, 0, 0, 1}, {int32_t(x), int32_t(y), int32_t(z)}, {uint32_t(w), uint32_t(h), uint32_t(d)}}}; VK_TRACE(vkCmdCopyImageToBuffer( cmdBuffer, vkImage.v, vkImage.imageLayout[0], stagingBuffer->v, uint32_t(bufferCopyRegions.size()), bufferCopyRegions.data())); } VKTexture::~VKTexture() { if (sampler) VK_TRACE(vkDestroySampler(ctx->vkDevice.v, sampler, nullptr)); } void VKTexture::initSampler() { VkResult vkResult; V(vkCreateSampler(ctx->vkDevice.v, samplerCreateInfo.get(), nullptr, &sampler)); } void VKTexture::initSamplerDescriptorSet(VkCommandBuffer cmdBuffer) { VkResult vkResult; vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); VkDescriptorPool descriptorPool = ctx->vkDescriptorPool; VkDescriptorSetLayout descriptorSetLayout = ctx->vkDescriptorSetLayoutCache.get( VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER); VkDescriptorSetAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, nullptr, descriptorPool, 1, &descriptorSetLayout}; V(vkAllocateDescriptorSets(ctx->vkDevice.v, &allocInfo, &samplerDescriptorSet)); VkDescriptorImageInfo descriptorImageInfo = {sampler, vkDefaultImageView->v, vkImage.imageLayout[0]}; VkWriteDescriptorSet writeDescriptorSet = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, nullptr, samplerDescriptorSet, 0, 0, 1, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, &descriptorImageInfo, nullptr, nullptr}; VK_TRACE(vkUpdateDescriptorSets(ctx->vkDevice.v, 1, &writeDescriptorSet, 0, nullptr)); } void VKTexture::initStorageImageDescriptorSet(VkCommandBuffer cmdBuffer) { VkResult vkResult; vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_GENERAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); VkDescriptorPool descriptorPool = ctx->vkDescriptorPool; VkDescriptorSetLayout descriptorSetLayout = ctx->vkDescriptorSetLayoutCache.get(VK_DESCRIPTOR_TYPE_STORAGE_IMAGE); VkDescriptorSetAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, nullptr, descriptorPool, 1, &descriptorSetLayout}; V(vkAllocateDescriptorSets(ctx->vkDevice.v, &allocInfo, &storageImageDescriptorSet)); VkDescriptorImageInfo descriptorImageInfo = {sampler, vkDefaultImageView->v, vkImage.imageLayout[0]}; VkWriteDescriptorSet writeDescriptorSet = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, nullptr, storageImageDescriptorSet, 0, 0, 1, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, &descriptorImageInfo, nullptr, nullptr}; VK_TRACE(vkUpdateDescriptorSets(ctx->vkDevice.v, 1, &writeDescriptorSet, 0, nullptr)); } void VKTexture::changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) { if (imageLayout == IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL) { vkImage.changeLayout(vk(commandBuffer)->v, VkImageLayout(imageLayout), VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, aspectFlags, 0, mipLevels, 0, arrayLayers); } else if (imageLayout == IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) { vkImage.changeLayout(vk(commandBuffer)->v, VkImageLayout(imageLayout), VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, aspectFlags, 0, mipLevels, 0, arrayLayers); } else if (imageLayout == IMAGE_LAYOUT_GENERAL) { vkImage.changeLayout(vk(commandBuffer)->v, VkImageLayout(imageLayout), VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, aspectFlags, 0, mipLevels, 0, arrayLayers); } else if (imageLayout == IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) { vkImage.changeLayout(vk(commandBuffer)->v, VkImageLayout(imageLayout), VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT, aspectFlags, 0, mipLevels, 0, arrayLayers); } } VKImageView *VKTexture::getImageView(VkImageViewType imageViewType, uint32_t mipLevels, uint32_t arrayLayers, uint32_t baseMipLevel, uint32_t baseArrayLayer) { VKImageViewCreateInfo imageViewCreateInfo(vkImage.v, imageViewType, vkFormat, aspectFlags, mipLevels, arrayLayers, baseMipLevel, baseArrayLayer); for (auto &imageView : vkImageViewCache) { if (imageView->createInfo == imageViewCreateInfo) { return imageView.get(); } } auto vkImageView = std::make_unique<VKImageView>(); vkImageView->create(ctx->vkDevice.v, imageViewCreateInfo); auto result = vkImageView.get(); vkImageViewCache.push_back(std::move(vkImageView)); return result; } Texture *Texture::create(GraphicsContext *ctx, Graphics *graphics, void *data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { VKTexture *vkTexture = new VKTexture(); VKSamplerCreateInfo *samplerCreateInfo = nullptr; if (imageUsageFlags & IMAGE_USAGE_SAMPLED_BIT) { samplerCreateInfo = new VKSamplerCreateInfo; samplerCreateInfo->minFilter = VkFilter(minFilter); samplerCreateInfo->magFilter = VkFilter(magFilter); samplerCreateInfo->mipmapMode = (mipFilter == FILTER_LINEAR) ? VK_SAMPLER_MIPMAP_MODE_LINEAR : VK_SAMPLER_MIPMAP_MODE_NEAREST; } vkTexture->create(vk(ctx), data, size, {w, h, d}, arrayLayers, VkFormat(format), imageUsageFlags, VkImageViewType(textureType), genMipmaps, samplerCreateInfo, numSamples); vkTexture->format = format; return vkTexture; } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKTexture.cpp"},{"location":"api/Files/VKTexture_8cpp/#srcngfxportingvulkanvktexturecpp","text":"","title":"src/ngfx/porting/vulkan/VKTexture.cpp"},{"location":"api/Files/VKTexture_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/vulkan/VKTexture.h\" #include \"ngfx/porting/vulkan/VKBlit.h\" #include \"ngfx/porting/vulkan/VKBuffer.h\" #include \"ngfx/porting/vulkan/VKCommandBuffer.h\" #include \"ngfx/porting/vulkan/VKComputePipeline.h\" #include \"ngfx/porting/vulkan/VKGraphicsPipeline.h\" #include \"ngfx/porting/vulkan/VKQueue.h\" #include <algorithm> using namespace ngfx; void VKTexture::create(VKGraphicsContext *ctx, void *data, uint32_t size, VkExtent3D extent, uint32_t arrayLayers, VkFormat format, VkImageUsageFlags imageUsageFlags, VkImageViewType imageViewType, bool genMipmaps, VKSamplerCreateInfo *pSamplerCreateInfo, uint32_t numSamples) { this->ctx = ctx; this->w = extent.width; this->h = extent.height; this->d = extent.depth; this->arrayLayers = arrayLayers; this->numSamples = numSamples; this->vkFormat = format; this->imageUsageFlags = imageUsageFlags; this->genMipmaps = genMipmaps; this->samplerCreateInfo.reset(pSamplerCreateInfo); const std::vector<VkFormat> depthFormats = { VK_FORMAT_D16_UNORM, VK_FORMAT_X8_D24_UNORM_PACK32, VK_FORMAT_D32_SFLOAT}; depthTexture = std::find(depthFormats.begin(), depthFormats.end(), format) != depthFormats.end(); this->aspectFlags = depthTexture ? VK_IMAGE_ASPECT_DEPTH_BIT : VK_IMAGE_ASPECT_COLOR_BIT; VkImageType imageType; if (imageViewType == VK_IMAGE_VIEW_TYPE_1D || imageViewType == VK_IMAGE_VIEW_TYPE_1D_ARRAY) imageType = VK_IMAGE_TYPE_1D; else if (imageViewType == VK_IMAGE_VIEW_TYPE_2D || imageViewType == VK_IMAGE_VIEW_TYPE_2D_ARRAY || imageViewType == VK_IMAGE_VIEW_TYPE_CUBE) imageType = VK_IMAGE_TYPE_2D; else imageType = VK_IMAGE_TYPE_3D; this->mipLevels = genMipmaps ? floor(log2(float(glm::min(extent.width, extent.height)))) + 1 : 1; vkImage.create(&ctx->vkDevice, extent, format, imageUsageFlags, imageType, mipLevels, arrayLayers, numSamples, (imageViewType == VK_IMAGE_VIEW_TYPE_CUBE) ? VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT : 0); vkDefaultImageView = getImageView(imageViewType, mipLevels, arrayLayers); auto &copyCommandBuffer = ctx->vkCopyCommandBuffer; std::unique_ptr<VKBuffer> stagingBuffer; if (data) { stagingBuffer.reset(new VKBuffer()); stagingBuffer->create(ctx, data, size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT); } copyCommandBuffer.begin(); uploadFn(copyCommandBuffer.v, data, size, stagingBuffer.get()); if (imageUsageFlags & IMAGE_USAGE_SAMPLED_BIT) { if (genMipmaps) samplerCreateInfo->maxLod = mipLevels; if (!sampler) initSampler(); if (!samplerDescriptorSet) initSamplerDescriptorSet(copyCommandBuffer.v); } if (imageUsageFlags & IMAGE_USAGE_STORAGE_BIT) { if (!storageImageDescriptorSet) initStorageImageDescriptorSet(copyCommandBuffer.v); } if (imageUsageFlags & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) { vkImage.changeLayout( copyCommandBuffer.v, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT, VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, aspectFlags); } else if (imageUsageFlags & VK_IMAGE_USAGE_STORAGE_BIT) { vkImage.changeLayout(copyCommandBuffer.v, VK_IMAGE_LAYOUT_GENERAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); } else if (imageUsageFlags & VK_IMAGE_USAGE_SAMPLED_BIT) { vkImage.changeLayout( copyCommandBuffer.v, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); } copyCommandBuffer.end(); vk(ctx->queue)->submit(&copyCommandBuffer, 0, {}, {}, nullptr); ctx->queue->waitIdle(); } void VKTexture::generateMipmaps(CommandBuffer *commandBuffer) { generateMipmapsFn(vk(commandBuffer)->v); } void VKTexture::generateMipmapsFn(VkCommandBuffer cmdBuffer) { vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_ACCESS_TRANSFER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, aspectFlags, 0, 1, 0, arrayLayers); for (uint32_t j = 1; j < mipLevels; j++) { vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, aspectFlags, j, 1, 0, arrayLayers); VKBlit::blitImage( cmdBuffer, vkImage.v, j - 1, vkImage.v, j, {{0, 0, 0}, {int32_t(glm::max(w >> (j - 1), 1u)), int32_t(glm::max(h >> (j - 1), 1u)), 1}}, {{0, 0, 0}, {int32_t(glm::max(w >> j, 1u)), int32_t(glm::max(h >> j, 1u)), 1}}, 0, arrayLayers, 0, arrayLayers); vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_ACCESS_TRANSFER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, aspectFlags, j, 1, 0, arrayLayers); } } void VKTexture::upload(void *data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { auto &copyCommandBuffer = ctx->vkCopyCommandBuffer; std::unique_ptr<VKBuffer> stagingBuffer; if (data) { stagingBuffer.reset(new VKBuffer()); stagingBuffer->create(ctx, data, size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT); } copyCommandBuffer.begin(); uploadFn(copyCommandBuffer.v, data, size, stagingBuffer.get(), x, y, z, w, h, d, arrayLayers); if (imageUsageFlags & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) { vkImage.changeLayout( copyCommandBuffer.v, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT, VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, aspectFlags); } else if (imageUsageFlags & VK_IMAGE_USAGE_STORAGE_BIT) { vkImage.changeLayout(copyCommandBuffer.v, VK_IMAGE_LAYOUT_GENERAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); } else if (imageUsageFlags & VK_IMAGE_USAGE_SAMPLED_BIT) { vkImage.changeLayout( copyCommandBuffer.v, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); } copyCommandBuffer.end(); vk(ctx->queue)->submit(&copyCommandBuffer, 0, {}, {}, nullptr); ctx->queue->waitIdle(); } void VKTexture::uploadFn(VkCommandBuffer cmdBuffer, void *data, uint32_t size, VKBuffer *stagingBuffer, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { if (data) { if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; if (arrayLayers == -1) arrayLayers = this->arrayLayers; vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, aspectFlags, 0, 1, 0, arrayLayers); std::vector<VkBufferImageCopy> bufferCopyRegions = { {0, 0, 0, {aspectFlags, 0, 0, uint32_t(arrayLayers)}, {int32_t(x), int32_t(y), int32_t(z)}, {uint32_t(w), uint32_t(h), uint32_t(d)}}}; VK_TRACE(vkCmdCopyBufferToImage( cmdBuffer, stagingBuffer->v, vkImage.v, vkImage.imageLayout[0], uint32_t(bufferCopyRegions.size()), bufferCopyRegions.data())); } if (data && mipLevels != 1) generateMipmapsFn(cmdBuffer); } void VKTexture::download(void *data, uint32_t size, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { auto &copyCommandBuffer = ctx->vkCopyCommandBuffer; std::unique_ptr<VKBuffer> stagingBuffer; stagingBuffer.reset(new VKBuffer()); stagingBuffer->create(ctx, nullptr, size, VK_BUFFER_USAGE_TRANSFER_DST_BIT); copyCommandBuffer.begin(); downloadFn(copyCommandBuffer.v, data, size, stagingBuffer.get(), x, y, z, w, h, d, arrayLayers); copyCommandBuffer.end(); vk(ctx->queue)->submit(&copyCommandBuffer, 0, {}, {}, nullptr); ctx->queue->waitIdle(); stagingBuffer->download(data, size); } void VKTexture::downloadFn(VkCommandBuffer cmdBuffer, void *data, uint32_t size, VKBuffer *stagingBuffer, uint32_t x, uint32_t y, uint32_t z, int32_t w, int32_t h, int32_t d, int32_t arrayLayers) { if (w == -1) w = this->w; if (h == -1) h = this->h; if (d == -1) d = this->d; if (arrayLayers == -1) arrayLayers = this->arrayLayers; vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_ACCESS_TRANSFER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT); std::vector<VkBufferImageCopy> bufferCopyRegions = { {0, 0, 0, {aspectFlags, 0, 0, 1}, {int32_t(x), int32_t(y), int32_t(z)}, {uint32_t(w), uint32_t(h), uint32_t(d)}}}; VK_TRACE(vkCmdCopyImageToBuffer( cmdBuffer, vkImage.v, vkImage.imageLayout[0], stagingBuffer->v, uint32_t(bufferCopyRegions.size()), bufferCopyRegions.data())); } VKTexture::~VKTexture() { if (sampler) VK_TRACE(vkDestroySampler(ctx->vkDevice.v, sampler, nullptr)); } void VKTexture::initSampler() { VkResult vkResult; V(vkCreateSampler(ctx->vkDevice.v, samplerCreateInfo.get(), nullptr, &sampler)); } void VKTexture::initSamplerDescriptorSet(VkCommandBuffer cmdBuffer) { VkResult vkResult; vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); VkDescriptorPool descriptorPool = ctx->vkDescriptorPool; VkDescriptorSetLayout descriptorSetLayout = ctx->vkDescriptorSetLayoutCache.get( VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER); VkDescriptorSetAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, nullptr, descriptorPool, 1, &descriptorSetLayout}; V(vkAllocateDescriptorSets(ctx->vkDevice.v, &allocInfo, &samplerDescriptorSet)); VkDescriptorImageInfo descriptorImageInfo = {sampler, vkDefaultImageView->v, vkImage.imageLayout[0]}; VkWriteDescriptorSet writeDescriptorSet = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, nullptr, samplerDescriptorSet, 0, 0, 1, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, &descriptorImageInfo, nullptr, nullptr}; VK_TRACE(vkUpdateDescriptorSets(ctx->vkDevice.v, 1, &writeDescriptorSet, 0, nullptr)); } void VKTexture::initStorageImageDescriptorSet(VkCommandBuffer cmdBuffer) { VkResult vkResult; vkImage.changeLayout(cmdBuffer, VK_IMAGE_LAYOUT_GENERAL, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, aspectFlags, 0, mipLevels, 0, this->arrayLayers); VkDescriptorPool descriptorPool = ctx->vkDescriptorPool; VkDescriptorSetLayout descriptorSetLayout = ctx->vkDescriptorSetLayoutCache.get(VK_DESCRIPTOR_TYPE_STORAGE_IMAGE); VkDescriptorSetAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, nullptr, descriptorPool, 1, &descriptorSetLayout}; V(vkAllocateDescriptorSets(ctx->vkDevice.v, &allocInfo, &storageImageDescriptorSet)); VkDescriptorImageInfo descriptorImageInfo = {sampler, vkDefaultImageView->v, vkImage.imageLayout[0]}; VkWriteDescriptorSet writeDescriptorSet = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, nullptr, storageImageDescriptorSet, 0, 0, 1, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, &descriptorImageInfo, nullptr, nullptr}; VK_TRACE(vkUpdateDescriptorSets(ctx->vkDevice.v, 1, &writeDescriptorSet, 0, nullptr)); } void VKTexture::changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) { if (imageLayout == IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL) { vkImage.changeLayout(vk(commandBuffer)->v, VkImageLayout(imageLayout), VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, aspectFlags, 0, mipLevels, 0, arrayLayers); } else if (imageLayout == IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) { vkImage.changeLayout(vk(commandBuffer)->v, VkImageLayout(imageLayout), VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, aspectFlags, 0, mipLevels, 0, arrayLayers); } else if (imageLayout == IMAGE_LAYOUT_GENERAL) { vkImage.changeLayout(vk(commandBuffer)->v, VkImageLayout(imageLayout), VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, aspectFlags, 0, mipLevels, 0, arrayLayers); } else if (imageLayout == IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) { vkImage.changeLayout(vk(commandBuffer)->v, VkImageLayout(imageLayout), VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT, aspectFlags, 0, mipLevels, 0, arrayLayers); } } VKImageView *VKTexture::getImageView(VkImageViewType imageViewType, uint32_t mipLevels, uint32_t arrayLayers, uint32_t baseMipLevel, uint32_t baseArrayLayer) { VKImageViewCreateInfo imageViewCreateInfo(vkImage.v, imageViewType, vkFormat, aspectFlags, mipLevels, arrayLayers, baseMipLevel, baseArrayLayer); for (auto &imageView : vkImageViewCache) { if (imageView->createInfo == imageViewCreateInfo) { return imageView.get(); } } auto vkImageView = std::make_unique<VKImageView>(); vkImageView->create(ctx->vkDevice.v, imageViewCreateInfo); auto result = vkImageView.get(); vkImageViewCache.push_back(std::move(vkImageView)); return result; } Texture *Texture::create(GraphicsContext *ctx, Graphics *graphics, void *data, PixelFormat format, uint32_t size, uint32_t w, uint32_t h, uint32_t d, uint32_t arrayLayers, ImageUsageFlags imageUsageFlags, TextureType textureType, bool genMipmaps, FilterMode minFilter, FilterMode magFilter, FilterMode mipFilter, uint32_t numSamples) { VKTexture *vkTexture = new VKTexture(); VKSamplerCreateInfo *samplerCreateInfo = nullptr; if (imageUsageFlags & IMAGE_USAGE_SAMPLED_BIT) { samplerCreateInfo = new VKSamplerCreateInfo; samplerCreateInfo->minFilter = VkFilter(minFilter); samplerCreateInfo->magFilter = VkFilter(magFilter); samplerCreateInfo->mipmapMode = (mipFilter == FILTER_LINEAR) ? VK_SAMPLER_MIPMAP_MODE_LINEAR : VK_SAMPLER_MIPMAP_MODE_NEAREST; } vkTexture->create(vk(ctx), data, size, {w, h, d}, arrayLayers, VkFormat(format), imageUsageFlags, VkImageViewType(textureType), genMipmaps, samplerCreateInfo, numSamples); vkTexture->format = format; return vkTexture; } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKTexture_8h/","text":"src/ngfx/porting/vulkan/VKTexture.h Namespaces Name ngfx Classes Name class ngfx::VKTexture Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Texture.h\" #include \"ngfx/porting/vulkan/VKBuffer.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKImage.h\" #include \"ngfx/porting/vulkan/VKImageView.h\" #include \"ngfx/porting/vulkan/VKSamplerCreateInfo.h\" namespace ngfx { class VKTexture : public Texture { public: void create(VKGraphicsContext *ctx, void *data, uint32_t size, VkExtent3D extent, uint32_t arrayLayers, VkFormat format, VkImageUsageFlags imageUsageFlags, VkImageViewType imageViewType, bool genMipmaps, VKSamplerCreateInfo *pSamplerCreateInfo, uint32_t numSamples = 1); virtual ~VKTexture(); void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) override; void generateMipmaps(CommandBuffer *commandBuffer) override; VKImageView *getImageView(VkImageViewType imageViewType, uint32_t mipLevels, uint32_t arrayLayers, uint32_t baseMipLevel = 0, uint32_t baseArrayLayer = 0); VkFormat vkFormat; VKImage vkImage; std::vector<std::unique_ptr<VKImageView>> vkImageViewCache; VKImageView *vkDefaultImageView = nullptr; VkDescriptorSet samplerDescriptorSet = 0, storageImageDescriptorSet = 0; VkSampler sampler = 0; VkImageAspectFlags aspectFlags; bool depthTexture = false; bool genMipmaps = false; std::unique_ptr<VKSamplerCreateInfo> samplerCreateInfo; private: void initSamplerDescriptorSet(VkCommandBuffer cmdBuffer); void initStorageImageDescriptorSet(VkCommandBuffer cmdBuffer); void initSampler(); void uploadFn(VkCommandBuffer cmdBuffer, void *data, uint32_t size, VKBuffer *stagingBuffer, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1); void downloadFn(VkCommandBuffer cmdBuffer, void *data, uint32_t size, VKBuffer *stagingBuffer, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1); void generateMipmapsFn(VkCommandBuffer cmdBuffer); VKGraphicsContext *ctx; }; VK_CAST(Texture); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKTexture.h"},{"location":"api/Files/VKTexture_8h/#srcngfxportingvulkanvktextureh","text":"","title":"src/ngfx/porting/vulkan/VKTexture.h"},{"location":"api/Files/VKTexture_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKTexture_8h/#classes","text":"Name class ngfx::VKTexture","title":"Classes"},{"location":"api/Files/VKTexture_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Texture.h\" #include \"ngfx/porting/vulkan/VKBuffer.h\" #include \"ngfx/porting/vulkan/VKGraphicsContext.h\" #include \"ngfx/porting/vulkan/VKImage.h\" #include \"ngfx/porting/vulkan/VKImageView.h\" #include \"ngfx/porting/vulkan/VKSamplerCreateInfo.h\" namespace ngfx { class VKTexture : public Texture { public: void create(VKGraphicsContext *ctx, void *data, uint32_t size, VkExtent3D extent, uint32_t arrayLayers, VkFormat format, VkImageUsageFlags imageUsageFlags, VkImageViewType imageViewType, bool genMipmaps, VKSamplerCreateInfo *pSamplerCreateInfo, uint32_t numSamples = 1); virtual ~VKTexture(); void upload(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void download(void *data, uint32_t size, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1) override; void changeLayout(CommandBuffer *commandBuffer, ImageLayout imageLayout) override; void generateMipmaps(CommandBuffer *commandBuffer) override; VKImageView *getImageView(VkImageViewType imageViewType, uint32_t mipLevels, uint32_t arrayLayers, uint32_t baseMipLevel = 0, uint32_t baseArrayLayer = 0); VkFormat vkFormat; VKImage vkImage; std::vector<std::unique_ptr<VKImageView>> vkImageViewCache; VKImageView *vkDefaultImageView = nullptr; VkDescriptorSet samplerDescriptorSet = 0, storageImageDescriptorSet = 0; VkSampler sampler = 0; VkImageAspectFlags aspectFlags; bool depthTexture = false; bool genMipmaps = false; std::unique_ptr<VKSamplerCreateInfo> samplerCreateInfo; private: void initSamplerDescriptorSet(VkCommandBuffer cmdBuffer); void initStorageImageDescriptorSet(VkCommandBuffer cmdBuffer); void initSampler(); void uploadFn(VkCommandBuffer cmdBuffer, void *data, uint32_t size, VKBuffer *stagingBuffer, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1); void downloadFn(VkCommandBuffer cmdBuffer, void *data, uint32_t size, VKBuffer *stagingBuffer, uint32_t x = 0, uint32_t y = 0, uint32_t z = 0, int32_t w = -1, int32_t h = -1, int32_t d = -1, int32_t arrayLayers = -1); void generateMipmapsFn(VkCommandBuffer cmdBuffer); VKGraphicsContext *ctx; }; VK_CAST(Texture); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKUtil_8h/","text":"src/ngfx/porting/vulkan/VKUtil.h Defines Name VK_CAST (name) Macro Documentation define VK_CAST #define VK_CAST( name ) inline VK##name *vk(name *g) { return (VK##name *)g; } Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #define VK_CAST(name) \\ inline VK##name *vk(name *g) { return (VK##name *)g; } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKUtil.h"},{"location":"api/Files/VKUtil_8h/#srcngfxportingvulkanvkutilh","text":"","title":"src/ngfx/porting/vulkan/VKUtil.h"},{"location":"api/Files/VKUtil_8h/#defines","text":"Name VK_CAST (name)","title":"Defines"},{"location":"api/Files/VKUtil_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/VKUtil_8h/#define-vk_cast","text":"#define VK_CAST( name ) inline VK##name *vk(name *g) { return (VK##name *)g; }","title":"define VK_CAST"},{"location":"api/Files/VKUtil_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #define VK_CAST(name) \\ inline VK##name *vk(name *g) { return (VK##name *)g; } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/VKWindow_8h/","text":"src/ngfx/porting/vulkan/VKWindow.h Namespaces Name ngfx Classes Name class ngfx::VKWindow Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Window.h\" #include \"ngfx/porting/vulkan/VKSurface.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" namespace ngfx { class VKWindow : public Window { public: virtual ~VKWindow() {} VKSurface vkSurface; protected: VkInstance instance; }; VK_CAST(Window); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/vulkan/VKWindow.h"},{"location":"api/Files/VKWindow_8h/#srcngfxportingvulkanvkwindowh","text":"","title":"src/ngfx/porting/vulkan/VKWindow.h"},{"location":"api/Files/VKWindow_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/VKWindow_8h/#classes","text":"Name class ngfx::VKWindow","title":"Classes"},{"location":"api/Files/VKWindow_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Window.h\" #include \"ngfx/porting/vulkan/VKSurface.h\" #include \"ngfx/porting/vulkan/VKUtil.h\" namespace ngfx { class VKWindow : public Window { public: virtual ~VKWindow() {} VKSurface vkSurface; protected: VkInstance instance; }; VK_CAST(Window); } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/ViewController_8h/","text":"src/ngfx/porting/appkit/ViewController.h Classes Name class ViewController Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <Cocoa/Cocoa.h> @interface ViewController : NSViewController @end Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/appkit/ViewController.h"},{"location":"api/Files/ViewController_8h/#srcngfxportingappkitviewcontrollerh","text":"","title":"src/ngfx/porting/appkit/ViewController.h"},{"location":"api/Files/ViewController_8h/#classes","text":"Name class ViewController","title":"Classes"},{"location":"api/Files/ViewController_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <Cocoa/Cocoa.h> @interface ViewController : NSViewController @end Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/ViewController_8mm/","text":"src/ngfx/porting/appkit/ViewController.mm Attributes Name MTLViewDelegate * mtkViewDelegate Attributes Documentation variable mtkViewDelegate MTLViewDelegate * mtkViewDelegate { MTKView *mtkView; Source code #include \"porting/appkit/ViewController.h\" #include <MetalKit/MetalKit.h> #include \"porting/metal/MTLViewDelegate.h\" @implementation ViewController { MTKView *mtkView; MTLViewDelegate *mtkViewDelegate; } - (void)viewDidLoad { [super viewDidLoad]; mtkView = (MTKView *)self.view; mtkViewDelegate = [[MTLViewDelegate alloc] create:mtkView]; NSAssert(mtkViewDelegate, @\"Cannot create view MetalKit view delegate\"); [mtkViewDelegate mtkView:mtkView drawableSizeWillChange:mtkView.drawableSize]; mtkView.delegate = mtkViewDelegate; } @end Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/appkit/ViewController.mm"},{"location":"api/Files/ViewController_8mm/#srcngfxportingappkitviewcontrollermm","text":"","title":"src/ngfx/porting/appkit/ViewController.mm"},{"location":"api/Files/ViewController_8mm/#attributes","text":"Name MTLViewDelegate * mtkViewDelegate","title":"Attributes"},{"location":"api/Files/ViewController_8mm/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"api/Files/ViewController_8mm/#variable-mtkviewdelegate","text":"MTLViewDelegate * mtkViewDelegate { MTKView *mtkView;","title":"variable mtkViewDelegate"},{"location":"api/Files/ViewController_8mm/#source-code","text":"#include \"porting/appkit/ViewController.h\" #include <MetalKit/MetalKit.h> #include \"porting/metal/MTLViewDelegate.h\" @implementation ViewController { MTKView *mtkView; MTLViewDelegate *mtkViewDelegate; } - (void)viewDidLoad { [super viewDidLoad]; mtkView = (MTKView *)self.view; mtkViewDelegate = [[MTLViewDelegate alloc] create:mtkView]; NSAssert(mtkViewDelegate, @\"Cannot create view MetalKit view delegate\"); [mtkViewDelegate mtkView:mtkView drawableSizeWillChange:mtkView.drawableSize]; mtkView.delegate = mtkViewDelegate; } @end Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/WInputMap_8h/","text":"src/ngfx/porting/windows/WInputMap.h Namespaces Name ngfx Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <Windows.h> namespace ngfx { enum KeyCode { KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT }; enum InputAction { RELEASE, PRESS }; enum MouseButton { MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/windows/WInputMap.h"},{"location":"api/Files/WInputMap_8h/#srcngfxportingwindowswinputmaph","text":"","title":"src/ngfx/porting/windows/WInputMap.h"},{"location":"api/Files/WInputMap_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/WInputMap_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include <Windows.h> namespace ngfx { enum KeyCode { KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT }; enum InputAction { RELEASE, PRESS }; enum MouseButton { MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT }; } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/WWindow_8cpp/","text":"src/ngfx/porting/windows/WWindow.cpp Functions Name LRESULT windowProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) Defines Name WINDOW_CLASS_NAME Functions Documentation function windowProc LRESULT windowProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam ) Macro Documentation define WINDOW_CLASS_NAME #define WINDOW_CLASS_NAME L\"WWindow\" Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/windows/WWindow.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/StringUtil.h\" #include <windowsx.h> using namespace ngfx; #define WINDOW_CLASS_NAME L\"WWindow\" WWindow::Monitor WWindow::getPrimaryMonitor() { DWORD adapterIndex, displayIndex; DISPLAY_DEVICEW adapter, display; // get primary adapter for (adapterIndex = 0;; adapterIndex++) { ZeroMemory(&adapter, sizeof(adapter)); adapter.cb = sizeof(adapter); if (!EnumDisplayDevicesW(NULL, adapterIndex, &adapter, 0)) break; if (!(adapter.StateFlags & DISPLAY_DEVICE_ACTIVE)) continue; if (adapter.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) break; } // get primary display for (displayIndex = 0;; displayIndex++) { ZeroMemory(&display, sizeof(display)); display.cb = sizeof(display); if (!EnumDisplayDevicesW(adapter.DeviceName, displayIndex, &display, 0)) break; if (display.StateFlags & DISPLAY_DEVICE_ACTIVE) break; } return {adapter, display}; } WWindow::VideoMode WWindow::getVideoMode(const Monitor &monitor) { DEVMODEW dm; ZeroMemory(&dm, sizeof(dm)); dm.dmSize = sizeof(dm); EnumDisplaySettingsW(monitor.adapter.DeviceName, ENUM_CURRENT_SETTINGS, &dm); return {int(dm.dmPelsWidth), int(dm.dmPelsHeight)}; } LRESULT windowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) { WWindow *thiz = reinterpret_cast<WWindow *>(GetWindowLongPtr(hWnd, GWLP_USERDATA)); switch (message) { case WM_CREATE: { LPCREATESTRUCT pCreateStruct = reinterpret_cast<LPCREATESTRUCT>(lParam); SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pCreateStruct->lpCreateParams)); return 0; } case WM_KEYDOWN: { if (thiz->onKey) thiz->onKey(KeyCode(wParam), PRESS); return 0; } case WM_KEYUP: { if (thiz->onKey) thiz->onKey(KeyCode(wParam), RELEASE); return 0; } case WM_MOUSEWHEEL: { if (thiz->onScroll) thiz->onScroll(0.0, GET_WHEEL_DELTA_WPARAM(wParam) / double(WHEEL_DELTA)); return 0; } case WM_LBUTTONDOWN: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_LEFT, InputAction(PRESS)); return 0; } case WM_MBUTTONDOWN: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_MIDDLE, InputAction(PRESS)); return 0; } case WM_RBUTTONDOWN: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_RIGHT, InputAction(PRESS)); return 0; } case WM_LBUTTONUP: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_LEFT, InputAction(RELEASE)); return 0; } case WM_MBUTTONUP: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_MIDDLE, InputAction(RELEASE)); return 0; } case WM_RBUTTONUP: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_RIGHT, InputAction(RELEASE)); return 0; } case WM_MOUSEMOVE: { if (thiz->onCursorPos) thiz->onCursorPos(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)); return 0; } case WM_PAINT: { thiz->onUpdate(); thiz->onPaint(); return 0; } case WM_DESTROY: PostQuitMessage(0); return 0; } return DefWindowProc(hWnd, message, wParam, lParam); } void WWindow::registerWindowClass() { WNDCLASSEXW wc = {}; wc.cbSize = sizeof(wc); wc.style = CS_HREDRAW | CS_VREDRAW; wc.lpfnWndProc = (WNDPROC)windowProc; wc.hInstance = GetModuleHandleW(NULL); wc.hCursor = LoadCursorW(NULL, IDC_ARROW); wc.lpszClassName = WINDOW_CLASS_NAME; wc.hIcon = HICON(LoadImageW(NULL, IDI_APPLICATION, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_SHARED)); if (!RegisterClassExW(&wc)) NGFX_ERR(\"\"); } void WWindow::createWindow(int w, int h, const char *title) { const wchar_t *wTitle = StringUtil::toWString(title).c_str(); auto &hWnd = d3dSurface.v; RECT rect = {0, 0, w, h}; DWORD style = WS_POPUP; // WS_OVERLAPPED_WINDOW; AdjustWindowRect(&rect, style, FALSE); hWnd = CreateWindow(WINDOW_CLASS_NAME, wTitle, style, 0, 0, rect.right - rect.left, rect.bottom - rect.top, nullptr, nullptr, GetModuleHandleW(NULL), this); assert(hWnd); ShowWindow(hWnd, SW_SHOWNA); } void WWindow::getFramebufferSize(int *w, int *h) { RECT area; auto &hWnd = d3dSurface.v; GetClientRect(hWnd, &area); if (w) *w = area.right; if (h) *h = area.bottom; } void WWindow::create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w, int h) { this->w = w; this->h = h; auto monitor = getPrimaryMonitor(); auto videoMode = getVideoMode(monitor); if (w == Window::DISPLAY_WIDTH) w = videoMode.width; if (h == Window::DISPLAY_HEIGHT) h = videoMode.height; registerWindowClass(); createWindow(w, h, title); getFramebufferSize(&w, &h); this->w = w; this->h = h; d3dSurface.w = w; d3dSurface.h = h; surface = &d3dSurface; onWindowCreated(this); } bool WWindow::shouldClose() { return (msg.message == WM_QUIT); } void WWindow::pollEvents() { if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) { TranslateMessage(&msg); DispatchMessage(&msg); } } WWindow::~WWindow() {} void WWindow::destroySurface() {} Window *Window::create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w, int h) { auto window = new WWindow(); window->create(graphicsContext, title, onWindowCreated, w, h); return window; } Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/windows/WWindow.cpp"},{"location":"api/Files/WWindow_8cpp/#srcngfxportingwindowswwindowcpp","text":"","title":"src/ngfx/porting/windows/WWindow.cpp"},{"location":"api/Files/WWindow_8cpp/#functions","text":"Name LRESULT windowProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)","title":"Functions"},{"location":"api/Files/WWindow_8cpp/#defines","text":"Name WINDOW_CLASS_NAME","title":"Defines"},{"location":"api/Files/WWindow_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/WWindow_8cpp/#function-windowproc","text":"LRESULT windowProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )","title":"function windowProc"},{"location":"api/Files/WWindow_8cpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"api/Files/WWindow_8cpp/#define-window_class_name","text":"#define WINDOW_CLASS_NAME L\"WWindow\"","title":"define WINDOW_CLASS_NAME"},{"location":"api/Files/WWindow_8cpp/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #include \"ngfx/porting/windows/WWindow.h\" #include \"ngfx/core/DebugUtil.h\" #include \"ngfx/core/StringUtil.h\" #include <windowsx.h> using namespace ngfx; #define WINDOW_CLASS_NAME L\"WWindow\" WWindow::Monitor WWindow::getPrimaryMonitor() { DWORD adapterIndex, displayIndex; DISPLAY_DEVICEW adapter, display; // get primary adapter for (adapterIndex = 0;; adapterIndex++) { ZeroMemory(&adapter, sizeof(adapter)); adapter.cb = sizeof(adapter); if (!EnumDisplayDevicesW(NULL, adapterIndex, &adapter, 0)) break; if (!(adapter.StateFlags & DISPLAY_DEVICE_ACTIVE)) continue; if (adapter.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) break; } // get primary display for (displayIndex = 0;; displayIndex++) { ZeroMemory(&display, sizeof(display)); display.cb = sizeof(display); if (!EnumDisplayDevicesW(adapter.DeviceName, displayIndex, &display, 0)) break; if (display.StateFlags & DISPLAY_DEVICE_ACTIVE) break; } return {adapter, display}; } WWindow::VideoMode WWindow::getVideoMode(const Monitor &monitor) { DEVMODEW dm; ZeroMemory(&dm, sizeof(dm)); dm.dmSize = sizeof(dm); EnumDisplaySettingsW(monitor.adapter.DeviceName, ENUM_CURRENT_SETTINGS, &dm); return {int(dm.dmPelsWidth), int(dm.dmPelsHeight)}; } LRESULT windowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) { WWindow *thiz = reinterpret_cast<WWindow *>(GetWindowLongPtr(hWnd, GWLP_USERDATA)); switch (message) { case WM_CREATE: { LPCREATESTRUCT pCreateStruct = reinterpret_cast<LPCREATESTRUCT>(lParam); SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pCreateStruct->lpCreateParams)); return 0; } case WM_KEYDOWN: { if (thiz->onKey) thiz->onKey(KeyCode(wParam), PRESS); return 0; } case WM_KEYUP: { if (thiz->onKey) thiz->onKey(KeyCode(wParam), RELEASE); return 0; } case WM_MOUSEWHEEL: { if (thiz->onScroll) thiz->onScroll(0.0, GET_WHEEL_DELTA_WPARAM(wParam) / double(WHEEL_DELTA)); return 0; } case WM_LBUTTONDOWN: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_LEFT, InputAction(PRESS)); return 0; } case WM_MBUTTONDOWN: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_MIDDLE, InputAction(PRESS)); return 0; } case WM_RBUTTONDOWN: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_RIGHT, InputAction(PRESS)); return 0; } case WM_LBUTTONUP: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_LEFT, InputAction(RELEASE)); return 0; } case WM_MBUTTONUP: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_MIDDLE, InputAction(RELEASE)); return 0; } case WM_RBUTTONUP: { if (thiz->onMouseButton) thiz->onMouseButton(MOUSE_BUTTON_RIGHT, InputAction(RELEASE)); return 0; } case WM_MOUSEMOVE: { if (thiz->onCursorPos) thiz->onCursorPos(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)); return 0; } case WM_PAINT: { thiz->onUpdate(); thiz->onPaint(); return 0; } case WM_DESTROY: PostQuitMessage(0); return 0; } return DefWindowProc(hWnd, message, wParam, lParam); } void WWindow::registerWindowClass() { WNDCLASSEXW wc = {}; wc.cbSize = sizeof(wc); wc.style = CS_HREDRAW | CS_VREDRAW; wc.lpfnWndProc = (WNDPROC)windowProc; wc.hInstance = GetModuleHandleW(NULL); wc.hCursor = LoadCursorW(NULL, IDC_ARROW); wc.lpszClassName = WINDOW_CLASS_NAME; wc.hIcon = HICON(LoadImageW(NULL, IDI_APPLICATION, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_SHARED)); if (!RegisterClassExW(&wc)) NGFX_ERR(\"\"); } void WWindow::createWindow(int w, int h, const char *title) { const wchar_t *wTitle = StringUtil::toWString(title).c_str(); auto &hWnd = d3dSurface.v; RECT rect = {0, 0, w, h}; DWORD style = WS_POPUP; // WS_OVERLAPPED_WINDOW; AdjustWindowRect(&rect, style, FALSE); hWnd = CreateWindow(WINDOW_CLASS_NAME, wTitle, style, 0, 0, rect.right - rect.left, rect.bottom - rect.top, nullptr, nullptr, GetModuleHandleW(NULL), this); assert(hWnd); ShowWindow(hWnd, SW_SHOWNA); } void WWindow::getFramebufferSize(int *w, int *h) { RECT area; auto &hWnd = d3dSurface.v; GetClientRect(hWnd, &area); if (w) *w = area.right; if (h) *h = area.bottom; } void WWindow::create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w, int h) { this->w = w; this->h = h; auto monitor = getPrimaryMonitor(); auto videoMode = getVideoMode(monitor); if (w == Window::DISPLAY_WIDTH) w = videoMode.width; if (h == Window::DISPLAY_HEIGHT) h = videoMode.height; registerWindowClass(); createWindow(w, h, title); getFramebufferSize(&w, &h); this->w = w; this->h = h; d3dSurface.w = w; d3dSurface.h = h; surface = &d3dSurface; onWindowCreated(this); } bool WWindow::shouldClose() { return (msg.message == WM_QUIT); } void WWindow::pollEvents() { if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) { TranslateMessage(&msg); DispatchMessage(&msg); } } WWindow::~WWindow() {} void WWindow::destroySurface() {} Window *Window::create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w, int h) { auto window = new WWindow(); window->create(graphicsContext, title, onWindowCreated, w, h); return window; } Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/WWindow_8h/","text":"src/ngfx/porting/windows/WWindow.h Namespaces Name ngfx Classes Name class ngfx::WWindow Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/porting/d3d/D3DWindow.h\" #include <windows.h> namespace ngfx { class WWindow : public D3DWindow { public: void create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w, int h); virtual bool shouldClose(); virtual void pollEvents(); virtual ~WWindow(); virtual void destroySurface(); private: MSG msg{}; void createWindow(int w, int h, const char *title); void getFramebufferSize(int *w, int *h); struct Monitor { DISPLAY_DEVICEW adapter, display; }; Monitor getPrimaryMonitor(); struct VideoMode { int width, height; }; VideoMode getVideoMode(const Monitor &monitor); void registerWindowClass(); }; inline WWindow *w(Window *window) { return (WWindow *)window; } } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/windows/WWindow.h"},{"location":"api/Files/WWindow_8h/#srcngfxportingwindowswwindowh","text":"","title":"src/ngfx/porting/windows/WWindow.h"},{"location":"api/Files/WWindow_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/WWindow_8h/#classes","text":"Name class ngfx::WWindow","title":"Classes"},{"location":"api/Files/WWindow_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/GraphicsContext.h\" #include \"ngfx/porting/d3d/D3DWindow.h\" #include <windows.h> namespace ngfx { class WWindow : public D3DWindow { public: void create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w, int h); virtual bool shouldClose(); virtual void pollEvents(); virtual ~WWindow(); virtual void destroySurface(); private: MSG msg{}; void createWindow(int w, int h, const char *title); void getFramebufferSize(int *w, int *h); struct Monitor { DISPLAY_DEVICEW adapter, display; }; Monitor getPrimaryMonitor(); struct VideoMode { int width, height; }; VideoMode getVideoMode(const Monitor &monitor); void registerWindowClass(); }; inline WWindow *w(Window *window) { return (WWindow *)window; } } // namespace ngfx Updated on 3 April 2021 at 20:21:52 PDT","title":"Source code"},{"location":"api/Files/Window_8h/","text":"src/ngfx/graphics/Window.h Namespaces Name ngfx Classes Name class ngfx::Window Source code /* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/input/InputMap.h\" #include <functional> namespace ngfx { class GraphicsContext; class Window { public: static Window *create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w = DISPLAY_WIDTH, int h = DISPLAY_HEIGHT); virtual ~Window() {} virtual bool shouldClose() = 0; virtual void pollEvents() = 0; enum { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1 }; int w, h; Surface *surface = nullptr; std::function<void()> onUpdate = nullptr, onPaint = nullptr; std::function<void(KeyCode code, InputAction action)> onKey = nullptr; std::function<void(double xoffset, double yoffset)> onScroll = nullptr; std::function<void(double x, double y)> onCursorPos = nullptr; std::function<void(MouseButton button, InputAction action)> onMouseButton = nullptr; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics/Window.h"},{"location":"api/Files/Window_8h/#srcngfxgraphicswindowh","text":"","title":"src/ngfx/graphics/Window.h"},{"location":"api/Files/Window_8h/#namespaces","text":"Name ngfx","title":"Namespaces"},{"location":"api/Files/Window_8h/#classes","text":"Name class ngfx::Window","title":"Classes"},{"location":"api/Files/Window_8h/#source-code","text":"/* * Copyright 2020 GoPro Inc. * * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ #pragma once #include \"ngfx/graphics/Surface.h\" #include \"ngfx/input/InputMap.h\" #include <functional> namespace ngfx { class GraphicsContext; class Window { public: static Window *create(GraphicsContext *graphicsContext, const char *title, std::function<void(Window *thiz)> onWindowCreated, int w = DISPLAY_WIDTH, int h = DISPLAY_HEIGHT); virtual ~Window() {} virtual bool shouldClose() = 0; virtual void pollEvents() = 0; enum { DISPLAY_WIDTH = -1, DISPLAY_HEIGHT = -1 }; int w, h; Surface *surface = nullptr; std::function<void()> onUpdate = nullptr, onPaint = nullptr; std::function<void(KeyCode code, InputAction action)> onKey = nullptr; std::function<void(double xoffset, double yoffset)> onScroll = nullptr; std::function<void(double x, double y)> onCursorPos = nullptr; std::function<void(MouseButton button, InputAction action)> onMouseButton = nullptr; }; }; // namespace ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Source code"},{"location":"api/Files/dir_0c54d2fb62f31c7d2d5bff67601a6b9d/","text":"src/ngfx/porting/vulkan Files Name src/ngfx/porting/vulkan/VKBlit.cpp src/ngfx/porting/vulkan/VKBlit.h src/ngfx/porting/vulkan/VKBuffer.cpp src/ngfx/porting/vulkan/VKBuffer.h src/ngfx/porting/vulkan/VKCommandBuffer.cpp src/ngfx/porting/vulkan/VKCommandBuffer.h src/ngfx/porting/vulkan/VKCommandPool.cpp src/ngfx/porting/vulkan/VKCommandPool.h src/ngfx/porting/vulkan/VKComputePipeline.cpp src/ngfx/porting/vulkan/VKComputePipeline.h src/ngfx/porting/vulkan/VKConfig.h src/ngfx/porting/vulkan/VKDebugUtil.cpp src/ngfx/porting/vulkan/VKDebugUtil.h src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.cpp src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h src/ngfx/porting/vulkan/VKDevice.cpp src/ngfx/porting/vulkan/VKDevice.h src/ngfx/porting/vulkan/VKFence.cpp src/ngfx/porting/vulkan/VKFence.h src/ngfx/porting/vulkan/VKFramebuffer.cpp src/ngfx/porting/vulkan/VKFramebuffer.h src/ngfx/porting/vulkan/VKGraphics.cpp src/ngfx/porting/vulkan/VKGraphics.h src/ngfx/porting/vulkan/VKGraphicsContext.cpp src/ngfx/porting/vulkan/VKGraphicsContext.h src/ngfx/porting/vulkan/VKGraphicsCore.h src/ngfx/porting/vulkan/VKGraphicsPipeline.cpp src/ngfx/porting/vulkan/VKGraphicsPipeline.h src/ngfx/porting/vulkan/VKImage.cpp src/ngfx/porting/vulkan/VKImage.h src/ngfx/porting/vulkan/VKImageCreateInfo.h src/ngfx/porting/vulkan/VKImageView.cpp src/ngfx/porting/vulkan/VKImageView.h src/ngfx/porting/vulkan/VKImageViewCreateInfo.h src/ngfx/porting/vulkan/VKInstance.cpp src/ngfx/porting/vulkan/VKInstance.h src/ngfx/porting/vulkan/VKPhysicalDevice.cpp src/ngfx/porting/vulkan/VKPhysicalDevice.h src/ngfx/porting/vulkan/VKPipeline.cpp src/ngfx/porting/vulkan/VKPipeline.h src/ngfx/porting/vulkan/VKPipelineCache.cpp src/ngfx/porting/vulkan/VKPipelineCache.h src/ngfx/porting/vulkan/VKQueue.cpp src/ngfx/porting/vulkan/VKQueue.h src/ngfx/porting/vulkan/VKRenderPass.cpp src/ngfx/porting/vulkan/VKRenderPass.h src/ngfx/porting/vulkan/VKSamplerCreateInfo.h src/ngfx/porting/vulkan/VKSemaphore.cpp src/ngfx/porting/vulkan/VKSemaphore.h src/ngfx/porting/vulkan/VKShaderModule.cpp src/ngfx/porting/vulkan/VKShaderModule.h src/ngfx/porting/vulkan/VKSurface.cpp src/ngfx/porting/vulkan/VKSurface.h src/ngfx/porting/vulkan/VKSwapchain.cpp src/ngfx/porting/vulkan/VKSwapchain.h src/ngfx/porting/vulkan/VKTexture.cpp src/ngfx/porting/vulkan/VKTexture.h src/ngfx/porting/vulkan/VKUtil.h src/ngfx/porting/vulkan/VKWindow.h Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/vulkan"},{"location":"api/Files/dir_0c54d2fb62f31c7d2d5bff67601a6b9d/#srcngfxportingvulkan","text":"","title":"src/ngfx/porting/vulkan"},{"location":"api/Files/dir_0c54d2fb62f31c7d2d5bff67601a6b9d/#files","text":"Name src/ngfx/porting/vulkan/VKBlit.cpp src/ngfx/porting/vulkan/VKBlit.h src/ngfx/porting/vulkan/VKBuffer.cpp src/ngfx/porting/vulkan/VKBuffer.h src/ngfx/porting/vulkan/VKCommandBuffer.cpp src/ngfx/porting/vulkan/VKCommandBuffer.h src/ngfx/porting/vulkan/VKCommandPool.cpp src/ngfx/porting/vulkan/VKCommandPool.h src/ngfx/porting/vulkan/VKComputePipeline.cpp src/ngfx/porting/vulkan/VKComputePipeline.h src/ngfx/porting/vulkan/VKConfig.h src/ngfx/porting/vulkan/VKDebugUtil.cpp src/ngfx/porting/vulkan/VKDebugUtil.h src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.cpp src/ngfx/porting/vulkan/VKDescriptorSetLayoutCache.h src/ngfx/porting/vulkan/VKDevice.cpp src/ngfx/porting/vulkan/VKDevice.h src/ngfx/porting/vulkan/VKFence.cpp src/ngfx/porting/vulkan/VKFence.h src/ngfx/porting/vulkan/VKFramebuffer.cpp src/ngfx/porting/vulkan/VKFramebuffer.h src/ngfx/porting/vulkan/VKGraphics.cpp src/ngfx/porting/vulkan/VKGraphics.h src/ngfx/porting/vulkan/VKGraphicsContext.cpp src/ngfx/porting/vulkan/VKGraphicsContext.h src/ngfx/porting/vulkan/VKGraphicsCore.h src/ngfx/porting/vulkan/VKGraphicsPipeline.cpp src/ngfx/porting/vulkan/VKGraphicsPipeline.h src/ngfx/porting/vulkan/VKImage.cpp src/ngfx/porting/vulkan/VKImage.h src/ngfx/porting/vulkan/VKImageCreateInfo.h src/ngfx/porting/vulkan/VKImageView.cpp src/ngfx/porting/vulkan/VKImageView.h src/ngfx/porting/vulkan/VKImageViewCreateInfo.h src/ngfx/porting/vulkan/VKInstance.cpp src/ngfx/porting/vulkan/VKInstance.h src/ngfx/porting/vulkan/VKPhysicalDevice.cpp src/ngfx/porting/vulkan/VKPhysicalDevice.h src/ngfx/porting/vulkan/VKPipeline.cpp src/ngfx/porting/vulkan/VKPipeline.h src/ngfx/porting/vulkan/VKPipelineCache.cpp src/ngfx/porting/vulkan/VKPipelineCache.h src/ngfx/porting/vulkan/VKQueue.cpp src/ngfx/porting/vulkan/VKQueue.h src/ngfx/porting/vulkan/VKRenderPass.cpp src/ngfx/porting/vulkan/VKRenderPass.h src/ngfx/porting/vulkan/VKSamplerCreateInfo.h src/ngfx/porting/vulkan/VKSemaphore.cpp src/ngfx/porting/vulkan/VKSemaphore.h src/ngfx/porting/vulkan/VKShaderModule.cpp src/ngfx/porting/vulkan/VKShaderModule.h src/ngfx/porting/vulkan/VKSurface.cpp src/ngfx/porting/vulkan/VKSurface.h src/ngfx/porting/vulkan/VKSwapchain.cpp src/ngfx/porting/vulkan/VKSwapchain.h src/ngfx/porting/vulkan/VKTexture.cpp src/ngfx/porting/vulkan/VKTexture.h src/ngfx/porting/vulkan/VKUtil.h src/ngfx/porting/vulkan/VKWindow.h Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Files/dir_30faf12615bf536facf6068fc9db1a7e/","text":"src/ngfx/computeOps Files Name src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp src/ngfx/computeOps/MatrixMultiplyCPUOp.h src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp src/ngfx/computeOps/MatrixMultiplyGPUOp.h src/ngfx/computeOps/MatrixMultiplyOp.h Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/computeOps"},{"location":"api/Files/dir_30faf12615bf536facf6068fc9db1a7e/#srcngfxcomputeops","text":"","title":"src/ngfx/computeOps"},{"location":"api/Files/dir_30faf12615bf536facf6068fc9db1a7e/#files","text":"Name src/ngfx/computeOps/MatrixMultiplyCPUOp.cpp src/ngfx/computeOps/MatrixMultiplyCPUOp.h src/ngfx/computeOps/MatrixMultiplyGPUOp.cpp src/ngfx/computeOps/MatrixMultiplyGPUOp.h src/ngfx/computeOps/MatrixMultiplyOp.h Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Files/dir_40c68d60cc133af9f739e75dd73e0e82/","text":"src/ngfx/porting/d3d Files Name src/ngfx/porting/d3d/D3DBlitOp.cpp src/ngfx/porting/d3d/D3DBlitOp.h src/ngfx/porting/d3d/D3DBuffer.cpp src/ngfx/porting/d3d/D3DBuffer.h src/ngfx/porting/d3d/D3DCommandList.cpp src/ngfx/porting/d3d/D3DCommandList.h src/ngfx/porting/d3d/D3DCommandQueue.cpp src/ngfx/porting/d3d/D3DCommandQueue.h src/ngfx/porting/d3d/D3DComputePass.h src/ngfx/porting/d3d/D3DComputePipeline.cpp src/ngfx/porting/d3d/D3DComputePipeline.h src/ngfx/porting/d3d/D3DDebugUtil.h src/ngfx/porting/d3d/D3DDescriptorHandle.cpp src/ngfx/porting/d3d/D3DDescriptorHandle.h src/ngfx/porting/d3d/D3DDescriptorHeap.cpp src/ngfx/porting/d3d/D3DDescriptorHeap.h src/ngfx/porting/d3d/D3DDevice.cpp src/ngfx/porting/d3d/D3DDevice.h src/ngfx/porting/d3d/D3DFence.cpp src/ngfx/porting/d3d/D3DFence.h src/ngfx/porting/d3d/D3DFramebuffer.cpp src/ngfx/porting/d3d/D3DFramebuffer.h src/ngfx/porting/d3d/D3DGraphics.cpp src/ngfx/porting/d3d/D3DGraphics.h src/ngfx/porting/d3d/D3DGraphicsContext.cpp src/ngfx/porting/d3d/D3DGraphicsContext.h src/ngfx/porting/d3d/D3DGraphicsCore.h src/ngfx/porting/d3d/D3DGraphicsPipeline.cpp src/ngfx/porting/d3d/D3DGraphicsPipeline.h src/ngfx/porting/d3d/D3DPipeline.cpp src/ngfx/porting/d3d/D3DPipeline.h src/ngfx/porting/d3d/D3DPipelineCache.h src/ngfx/porting/d3d/D3DReadbackBuffer.cpp src/ngfx/porting/d3d/D3DReadbackBuffer.h src/ngfx/porting/d3d/D3DRenderPass.cpp src/ngfx/porting/d3d/D3DRenderPass.h src/ngfx/porting/d3d/D3DSamplerDesc.h src/ngfx/porting/d3d/D3DShaderModule.cpp src/ngfx/porting/d3d/D3DShaderModule.h src/ngfx/porting/d3d/D3DSurface.h src/ngfx/porting/d3d/D3DSwapchain.cpp src/ngfx/porting/d3d/D3DSwapchain.h src/ngfx/porting/d3d/D3DTexture.cpp src/ngfx/porting/d3d/D3DTexture.h src/ngfx/porting/d3d/D3DUtil.h src/ngfx/porting/d3d/D3DWindow.h Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/d3d"},{"location":"api/Files/dir_40c68d60cc133af9f739e75dd73e0e82/#srcngfxportingd3d","text":"","title":"src/ngfx/porting/d3d"},{"location":"api/Files/dir_40c68d60cc133af9f739e75dd73e0e82/#files","text":"Name src/ngfx/porting/d3d/D3DBlitOp.cpp src/ngfx/porting/d3d/D3DBlitOp.h src/ngfx/porting/d3d/D3DBuffer.cpp src/ngfx/porting/d3d/D3DBuffer.h src/ngfx/porting/d3d/D3DCommandList.cpp src/ngfx/porting/d3d/D3DCommandList.h src/ngfx/porting/d3d/D3DCommandQueue.cpp src/ngfx/porting/d3d/D3DCommandQueue.h src/ngfx/porting/d3d/D3DComputePass.h src/ngfx/porting/d3d/D3DComputePipeline.cpp src/ngfx/porting/d3d/D3DComputePipeline.h src/ngfx/porting/d3d/D3DDebugUtil.h src/ngfx/porting/d3d/D3DDescriptorHandle.cpp src/ngfx/porting/d3d/D3DDescriptorHandle.h src/ngfx/porting/d3d/D3DDescriptorHeap.cpp src/ngfx/porting/d3d/D3DDescriptorHeap.h src/ngfx/porting/d3d/D3DDevice.cpp src/ngfx/porting/d3d/D3DDevice.h src/ngfx/porting/d3d/D3DFence.cpp src/ngfx/porting/d3d/D3DFence.h src/ngfx/porting/d3d/D3DFramebuffer.cpp src/ngfx/porting/d3d/D3DFramebuffer.h src/ngfx/porting/d3d/D3DGraphics.cpp src/ngfx/porting/d3d/D3DGraphics.h src/ngfx/porting/d3d/D3DGraphicsContext.cpp src/ngfx/porting/d3d/D3DGraphicsContext.h src/ngfx/porting/d3d/D3DGraphicsCore.h src/ngfx/porting/d3d/D3DGraphicsPipeline.cpp src/ngfx/porting/d3d/D3DGraphicsPipeline.h src/ngfx/porting/d3d/D3DPipeline.cpp src/ngfx/porting/d3d/D3DPipeline.h src/ngfx/porting/d3d/D3DPipelineCache.h src/ngfx/porting/d3d/D3DReadbackBuffer.cpp src/ngfx/porting/d3d/D3DReadbackBuffer.h src/ngfx/porting/d3d/D3DRenderPass.cpp src/ngfx/porting/d3d/D3DRenderPass.h src/ngfx/porting/d3d/D3DSamplerDesc.h src/ngfx/porting/d3d/D3DShaderModule.cpp src/ngfx/porting/d3d/D3DShaderModule.h src/ngfx/porting/d3d/D3DSurface.h src/ngfx/porting/d3d/D3DSwapchain.cpp src/ngfx/porting/d3d/D3DSwapchain.h src/ngfx/porting/d3d/D3DTexture.cpp src/ngfx/porting/d3d/D3DTexture.h src/ngfx/porting/d3d/D3DUtil.h src/ngfx/porting/d3d/D3DWindow.h Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Files/dir_4e1573efe795f44b9b1a6fe4d85753ca/","text":"src/ngfx/porting/glfw Files Name src/ngfx/porting/glfw/GLFWInputMap.h src/ngfx/porting/glfw/GLFWWindow.cpp src/ngfx/porting/glfw/GLFWWindow.h Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/glfw"},{"location":"api/Files/dir_4e1573efe795f44b9b1a6fe4d85753ca/#srcngfxportingglfw","text":"","title":"src/ngfx/porting/glfw"},{"location":"api/Files/dir_4e1573efe795f44b9b1a6fe4d85753ca/#files","text":"Name src/ngfx/porting/glfw/GLFWInputMap.h src/ngfx/porting/glfw/GLFWWindow.cpp src/ngfx/porting/glfw/GLFWWindow.h Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Files/dir_59d6d67be47e2ccbf97815c0cb34958e/","text":"src/ngfx/porting/windows Files Name src/ngfx/porting/windows/WInputMap.h src/ngfx/porting/windows/WWindow.cpp src/ngfx/porting/windows/WWindow.h Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/porting/windows"},{"location":"api/Files/dir_59d6d67be47e2ccbf97815c0cb34958e/#srcngfxportingwindows","text":"","title":"src/ngfx/porting/windows"},{"location":"api/Files/dir_59d6d67be47e2ccbf97815c0cb34958e/#files","text":"Name src/ngfx/porting/windows/WInputMap.h src/ngfx/porting/windows/WWindow.cpp src/ngfx/porting/windows/WWindow.h Updated on 3 April 2021 at 20:21:52 PDT","title":"Files"},{"location":"api/Files/dir_61819f5050c989815f217f007bce688d/","text":"src/ngfx/graphics Files Name src/ngfx/graphics/Buffer.h src/ngfx/graphics/BufferUtil.h src/ngfx/graphics/Camera.cpp src/ngfx/graphics/Camera.h src/ngfx/graphics/CommandBuffer.h src/ngfx/graphics/Config.h src/ngfx/graphics/Device.h src/ngfx/graphics/DrawOp.h src/ngfx/graphics/Fence.h src/ngfx/graphics/FilterOp.cpp src/ngfx/graphics/FilterOp.h src/ngfx/graphics/Framebuffer.h src/ngfx/graphics/Graphics.h src/ngfx/graphics/GraphicsContext.h src/ngfx/graphics/GraphicsCore.h src/ngfx/graphics/GraphicsPipeline.cpp src/ngfx/graphics/GraphicsPipeline.h src/ngfx/graphics/MeshData.h src/ngfx/graphics/MeshUtil.cpp src/ngfx/graphics/MeshUtil.h src/ngfx/graphics/Pipeline.h src/ngfx/graphics/PipelineCache.cpp src/ngfx/graphics/PipelineCache.h src/ngfx/graphics/Queue.h src/ngfx/graphics/RenderPass.h src/ngfx/graphics/Semaphore.h src/ngfx/graphics/ShaderModule.cpp src/ngfx/graphics/ShaderModule.h src/ngfx/graphics/ShaderTools.cpp src/ngfx/graphics/ShaderTools.h src/ngfx/graphics/Surface.h src/ngfx/graphics/Swapchain.h src/ngfx/graphics/Texture.cpp src/ngfx/graphics/Texture.h src/ngfx/graphics/Window.h Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/graphics"},{"location":"api/Files/dir_61819f5050c989815f217f007bce688d/#srcngfxgraphics","text":"","title":"src/ngfx/graphics"},{"location":"api/Files/dir_61819f5050c989815f217f007bce688d/#files","text":"Name src/ngfx/graphics/Buffer.h src/ngfx/graphics/BufferUtil.h src/ngfx/graphics/Camera.cpp src/ngfx/graphics/Camera.h src/ngfx/graphics/CommandBuffer.h src/ngfx/graphics/Config.h src/ngfx/graphics/Device.h src/ngfx/graphics/DrawOp.h src/ngfx/graphics/Fence.h src/ngfx/graphics/FilterOp.cpp src/ngfx/graphics/FilterOp.h src/ngfx/graphics/Framebuffer.h src/ngfx/graphics/Graphics.h src/ngfx/graphics/GraphicsContext.h src/ngfx/graphics/GraphicsCore.h src/ngfx/graphics/GraphicsPipeline.cpp src/ngfx/graphics/GraphicsPipeline.h src/ngfx/graphics/MeshData.h src/ngfx/graphics/MeshUtil.cpp src/ngfx/graphics/MeshUtil.h src/ngfx/graphics/Pipeline.h src/ngfx/graphics/PipelineCache.cpp src/ngfx/graphics/PipelineCache.h src/ngfx/graphics/Queue.h src/ngfx/graphics/RenderPass.h src/ngfx/graphics/Semaphore.h src/ngfx/graphics/ShaderModule.cpp src/ngfx/graphics/ShaderModule.h src/ngfx/graphics/ShaderTools.cpp src/ngfx/graphics/ShaderTools.h src/ngfx/graphics/Surface.h src/ngfx/graphics/Swapchain.h src/ngfx/graphics/Texture.cpp src/ngfx/graphics/Texture.h src/ngfx/graphics/Window.h Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Files/dir_63a95ed4093c85063905e55b50c4c57a/","text":"src/ngfx/compute Files Name src/ngfx/compute/ComputeApplication.cpp src/ngfx/compute/ComputeApplication.h src/ngfx/compute/ComputeOp.h src/ngfx/compute/ComputePass.h src/ngfx/compute/ComputePipeline.h Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/compute"},{"location":"api/Files/dir_63a95ed4093c85063905e55b50c4c57a/#srcngfxcompute","text":"","title":"src/ngfx/compute"},{"location":"api/Files/dir_63a95ed4093c85063905e55b50c4c57a/#files","text":"Name src/ngfx/compute/ComputeApplication.cpp src/ngfx/compute/ComputeApplication.h src/ngfx/compute/ComputeOp.h src/ngfx/compute/ComputePass.h src/ngfx/compute/ComputePipeline.h Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"src Directories Name src/ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"src"},{"location":"api/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#src","text":"","title":"src"},{"location":"api/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","text":"Name src/ngfx Updated on 3 April 2021 at 20:21:51 PDT","title":"Directories"},{"location":"api/Files/dir_6a2981783036dd447c2e297205838fbc/","text":"src/ngfx/input Files Name src/ngfx/input/InputListener.h src/ngfx/input/InputMap.h Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/input"},{"location":"api/Files/dir_6a2981783036dd447c2e297205838fbc/#srcngfxinput","text":"","title":"src/ngfx/input"},{"location":"api/Files/dir_6a2981783036dd447c2e297205838fbc/#files","text":"Name src/ngfx/input/InputListener.h src/ngfx/input/InputMap.h Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Files/dir_7b3ee6f3d70af721796ac60009550648/","text":"src/ngfx/porting/metal Files Name src/ngfx/porting/metal/MTLApplication.h src/ngfx/porting/metal/MTLApplication.mm src/ngfx/porting/metal/MTLBuffer.h src/ngfx/porting/metal/MTLBuffer.mm src/ngfx/porting/metal/MTLCommandBuffer.h src/ngfx/porting/metal/MTLCommandBuffer.mm src/ngfx/porting/metal/MTLCommandEncoder.h src/ngfx/porting/metal/MTLComputeCommandEncoder.h src/ngfx/porting/metal/MTLComputePipeline.h src/ngfx/porting/metal/MTLComputePipeline.mm src/ngfx/porting/metal/MTLDepthStencilTexture.h src/ngfx/porting/metal/MTLDepthStencilTexture.mm src/ngfx/porting/metal/MTLDevice.h src/ngfx/porting/metal/MTLDevice.mm src/ngfx/porting/metal/MTLFramebuffer.h src/ngfx/porting/metal/MTLFramebuffer.mm src/ngfx/porting/metal/MTLGraphics.h src/ngfx/porting/metal/MTLGraphics.mm src/ngfx/porting/metal/MTLGraphicsContext.h src/ngfx/porting/metal/MTLGraphicsContext.mm src/ngfx/porting/metal/MTLGraphicsCore.h src/ngfx/porting/metal/MTLGraphicsCoreDefines.h src/ngfx/porting/metal/MTLGraphicsPipeline.h src/ngfx/porting/metal/MTLGraphicsPipeline.mm src/ngfx/porting/metal/MTLPipelineCache.h src/ngfx/porting/metal/MTLPipelineUtil.h src/ngfx/porting/metal/MTLPipelineUtil.mm src/ngfx/porting/metal/MTLRenderCommandEncoder.h src/ngfx/porting/metal/MTLRenderPass.h src/ngfx/porting/metal/MTLRenderPass.mm src/ngfx/porting/metal/MTLShaderModule.h src/ngfx/porting/metal/MTLShaderModule.mm src/ngfx/porting/metal/MTLSurface.h src/ngfx/porting/metal/MTLTexture.h src/ngfx/porting/metal/MTLTexture.mm src/ngfx/porting/metal/MTLUtil.h src/ngfx/porting/metal/MTLViewDelegate.h src/ngfx/porting/metal/MTLViewDelegate.mm src/ngfx/porting/metal/MTLWindow.h src/ngfx/porting/metal/MTLWindow.mm Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/metal"},{"location":"api/Files/dir_7b3ee6f3d70af721796ac60009550648/#srcngfxportingmetal","text":"","title":"src/ngfx/porting/metal"},{"location":"api/Files/dir_7b3ee6f3d70af721796ac60009550648/#files","text":"Name src/ngfx/porting/metal/MTLApplication.h src/ngfx/porting/metal/MTLApplication.mm src/ngfx/porting/metal/MTLBuffer.h src/ngfx/porting/metal/MTLBuffer.mm src/ngfx/porting/metal/MTLCommandBuffer.h src/ngfx/porting/metal/MTLCommandBuffer.mm src/ngfx/porting/metal/MTLCommandEncoder.h src/ngfx/porting/metal/MTLComputeCommandEncoder.h src/ngfx/porting/metal/MTLComputePipeline.h src/ngfx/porting/metal/MTLComputePipeline.mm src/ngfx/porting/metal/MTLDepthStencilTexture.h src/ngfx/porting/metal/MTLDepthStencilTexture.mm src/ngfx/porting/metal/MTLDevice.h src/ngfx/porting/metal/MTLDevice.mm src/ngfx/porting/metal/MTLFramebuffer.h src/ngfx/porting/metal/MTLFramebuffer.mm src/ngfx/porting/metal/MTLGraphics.h src/ngfx/porting/metal/MTLGraphics.mm src/ngfx/porting/metal/MTLGraphicsContext.h src/ngfx/porting/metal/MTLGraphicsContext.mm src/ngfx/porting/metal/MTLGraphicsCore.h src/ngfx/porting/metal/MTLGraphicsCoreDefines.h src/ngfx/porting/metal/MTLGraphicsPipeline.h src/ngfx/porting/metal/MTLGraphicsPipeline.mm src/ngfx/porting/metal/MTLPipelineCache.h src/ngfx/porting/metal/MTLPipelineUtil.h src/ngfx/porting/metal/MTLPipelineUtil.mm src/ngfx/porting/metal/MTLRenderCommandEncoder.h src/ngfx/porting/metal/MTLRenderPass.h src/ngfx/porting/metal/MTLRenderPass.mm src/ngfx/porting/metal/MTLShaderModule.h src/ngfx/porting/metal/MTLShaderModule.mm src/ngfx/porting/metal/MTLSurface.h src/ngfx/porting/metal/MTLTexture.h src/ngfx/porting/metal/MTLTexture.mm src/ngfx/porting/metal/MTLUtil.h src/ngfx/porting/metal/MTLViewDelegate.h src/ngfx/porting/metal/MTLViewDelegate.mm src/ngfx/porting/metal/MTLWindow.h src/ngfx/porting/metal/MTLWindow.mm Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Files/dir_836d6044c9b9d906d07510ab7de02523/","text":"src/ngfx/drawOps Files Name src/ngfx/drawOps/DrawColorOp.cpp src/ngfx/drawOps/DrawColorOp.h src/ngfx/drawOps/DrawMeshOp.cpp src/ngfx/drawOps/DrawMeshOp.h src/ngfx/drawOps/DrawTextureOp.cpp src/ngfx/drawOps/DrawTextureOp.h Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/drawOps"},{"location":"api/Files/dir_836d6044c9b9d906d07510ab7de02523/#srcngfxdrawops","text":"","title":"src/ngfx/drawOps"},{"location":"api/Files/dir_836d6044c9b9d906d07510ab7de02523/#files","text":"Name src/ngfx/drawOps/DrawColorOp.cpp src/ngfx/drawOps/DrawColorOp.h src/ngfx/drawOps/DrawMeshOp.cpp src/ngfx/drawOps/DrawMeshOp.h src/ngfx/drawOps/DrawTextureOp.cpp src/ngfx/drawOps/DrawTextureOp.h Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Files/dir_ba89cfdb2985c20790f90acbff1b244e/","text":"src/ngfx/regex Files Name src/ngfx/regex/RegexUtil.cpp src/ngfx/regex/RegexUtil.h Updated on 3 April 2021 at 20:21:52 PDT","title":"src/ngfx/regex"},{"location":"api/Files/dir_ba89cfdb2985c20790f90acbff1b244e/#srcngfxregex","text":"","title":"src/ngfx/regex"},{"location":"api/Files/dir_ba89cfdb2985c20790f90acbff1b244e/#files","text":"Name src/ngfx/regex/RegexUtil.cpp src/ngfx/regex/RegexUtil.h Updated on 3 April 2021 at 20:21:52 PDT","title":"Files"},{"location":"api/Files/dir_bf4520687725fcb8943bc560a06cbd17/","text":"src/ngfx Directories Name src/ngfx/compute src/ngfx/computeOps src/ngfx/core src/ngfx/drawOps src/ngfx/graphics src/ngfx/input src/ngfx/porting src/ngfx/regex Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx"},{"location":"api/Files/dir_bf4520687725fcb8943bc560a06cbd17/#srcngfx","text":"","title":"src/ngfx"},{"location":"api/Files/dir_bf4520687725fcb8943bc560a06cbd17/#directories","text":"Name src/ngfx/compute src/ngfx/computeOps src/ngfx/core src/ngfx/drawOps src/ngfx/graphics src/ngfx/input src/ngfx/porting src/ngfx/regex Updated on 3 April 2021 at 20:21:51 PDT","title":"Directories"},{"location":"api/Files/dir_d6ebad042f9e66e97e57125cd12423b2/","text":"src/ngfx/porting Directories Name src/ngfx/porting/appkit src/ngfx/porting/d3d src/ngfx/porting/glfw src/ngfx/porting/metal src/ngfx/porting/vulkan src/ngfx/porting/windows Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting"},{"location":"api/Files/dir_d6ebad042f9e66e97e57125cd12423b2/#srcngfxporting","text":"","title":"src/ngfx/porting"},{"location":"api/Files/dir_d6ebad042f9e66e97e57125cd12423b2/#directories","text":"Name src/ngfx/porting/appkit src/ngfx/porting/d3d src/ngfx/porting/glfw src/ngfx/porting/metal src/ngfx/porting/vulkan src/ngfx/porting/windows Updated on 3 April 2021 at 20:21:51 PDT","title":"Directories"},{"location":"api/Files/dir_f0cfb9d6257f0cbc5e7e8cb8f2cdcbe0/","text":"src/ngfx/core Files Name src/ngfx/core/Application.h src/ngfx/core/BaseApplication.cpp src/ngfx/core/BaseApplication.h src/ngfx/core/DebugUtil.h src/ngfx/core/File.cpp src/ngfx/core/File.h src/ngfx/core/FileUtil.cpp src/ngfx/core/FileUtil.h src/ngfx/core/FPSCounter.cpp src/ngfx/core/FPSCounter.h src/ngfx/core/ProcessUtil.cpp src/ngfx/core/ProcessUtil.h src/ngfx/core/StringUtil.cpp src/ngfx/core/StringUtil.h src/ngfx/core/Timer.cpp src/ngfx/core/Timer.h src/ngfx/core/Util.cpp src/ngfx/core/Util.h Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/core"},{"location":"api/Files/dir_f0cfb9d6257f0cbc5e7e8cb8f2cdcbe0/#srcngfxcore","text":"","title":"src/ngfx/core"},{"location":"api/Files/dir_f0cfb9d6257f0cbc5e7e8cb8f2cdcbe0/#files","text":"Name src/ngfx/core/Application.h src/ngfx/core/BaseApplication.cpp src/ngfx/core/BaseApplication.h src/ngfx/core/DebugUtil.h src/ngfx/core/File.cpp src/ngfx/core/File.h src/ngfx/core/FileUtil.cpp src/ngfx/core/FileUtil.h src/ngfx/core/FPSCounter.cpp src/ngfx/core/FPSCounter.h src/ngfx/core/ProcessUtil.cpp src/ngfx/core/ProcessUtil.h src/ngfx/core/StringUtil.cpp src/ngfx/core/StringUtil.h src/ngfx/core/Timer.cpp src/ngfx/core/Timer.h src/ngfx/core/Util.cpp src/ngfx/core/Util.h Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Files/dir_f1d8ce7061f0d76f7632440a95bdaa58/","text":"src/ngfx/porting/appkit Files Name src/ngfx/porting/appkit/AppDelegate.h src/ngfx/porting/appkit/AppDelegate.mm src/ngfx/porting/appkit/AppKitInputMap.h src/ngfx/porting/appkit/ViewController.h src/ngfx/porting/appkit/ViewController.mm Updated on 3 April 2021 at 20:21:51 PDT","title":"src/ngfx/porting/appkit"},{"location":"api/Files/dir_f1d8ce7061f0d76f7632440a95bdaa58/#srcngfxportingappkit","text":"","title":"src/ngfx/porting/appkit"},{"location":"api/Files/dir_f1d8ce7061f0d76f7632440a95bdaa58/#files","text":"Name src/ngfx/porting/appkit/AppDelegate.h src/ngfx/porting/appkit/AppDelegate.mm src/ngfx/porting/appkit/AppKitInputMap.h src/ngfx/porting/appkit/ViewController.h src/ngfx/porting/appkit/ViewController.mm Updated on 3 April 2021 at 20:21:51 PDT","title":"Files"},{"location":"api/Modules/","text":"Modules Updated on 3 April 2021 at 20:21:52 PDT","title":"Modules"},{"location":"api/Modules/#modules","text":"Updated on 3 April 2021 at 20:21:52 PDT","title":"Modules"},{"location":"api/Namespaces/","text":"Namespaces namespace glm namespace ngfx namespace std namespace std::chrono namespace std::placeholders Updated on 3 April 2021 at 20:21:52 PDT","title":"Namespaces"},{"location":"api/Namespaces/#namespaces","text":"namespace glm namespace ngfx namespace std namespace std::chrono namespace std::placeholders Updated on 3 April 2021 at 20:21:52 PDT","title":"Namespaces"},{"location":"api/Namespaces/namespaceglm/","text":"glm Updated on 3 April 2021 at 20:21:51 PDT","title":"glm"},{"location":"api/Namespaces/namespaceglm/#glm","text":"Updated on 3 April 2021 at 20:21:51 PDT","title":"glm"},{"location":"api/Namespaces/namespacengfx/","text":"ngfx Classes Name class ngfx::BaseApplication class ngfx::Buffer class ngfx::Camera class ngfx::CommandBuffer class ngfx::ComputeApplication class ngfx::ComputeOp class ngfx::ComputePass class ngfx::ComputePipeline class ngfx::ComputeShaderModule class ngfx::D3DBlitOp class ngfx::D3DBuffer class ngfx::D3DCommandList class ngfx::D3DCommandQueue class ngfx::D3DComputePass class ngfx::D3DComputePipeline class ngfx::D3DComputeShaderModule class ngfx::D3DDescriptorHandle class ngfx::D3DDescriptorHeap class ngfx::D3DDevice class ngfx::D3DFence class ngfx::D3DFragmentShaderModule class ngfx::D3DFramebuffer class ngfx::D3DGraphics class ngfx::D3DGraphicsContext class ngfx::D3DGraphicsPipeline class ngfx::D3DPipeline class ngfx::D3DPipelineCache struct ngfx::D3DPipelineUtil class ngfx::D3DReadbackBuffer class ngfx::D3DRenderPass struct ngfx::D3DSamplerDesc class ngfx::D3DShaderModule class ngfx::D3DSurface class ngfx::D3DSwapchain class ngfx::D3DTexture class ngfx::D3DVertexShaderModule class ngfx::D3DWindow class ngfx::Device class ngfx::DrawColorOp class ngfx::DrawMeshOp class ngfx::DrawOp class ngfx::DrawTextureOp class ngfx::Fence class ngfx::File class ngfx::FileUtil class ngfx::FilterOp class ngfx::FPSCounter class ngfx::FragmentShaderModule class ngfx::Framebuffer class ngfx::GLFWWindow class ngfx::Graphics class ngfx::GraphicsContext class ngfx::GraphicsPipeline class ngfx::InputListener class ngfx::MatrixMultiplyCPUOp class ngfx::MatrixMultiplyGPUOp class ngfx::MatrixMultiplyOp struct ngfx::MeshData struct ngfx::MeshUtil class ngfx::MTLApplication class ngfx::MTLBuffer class ngfx::MTLCommandBuffer class ngfx::MTLCommandEncoder class ngfx::MTLComputeCommandEncoder class ngfx::MTLComputePipeline class ngfx::MTLComputeShaderModule class ngfx::MTLDepthStencilTexture class ngfx::MTLDevice class ngfx::MTLFragmentShaderModule class ngfx::MTLFramebuffer class ngfx::MTLGraphics class ngfx::MTLGraphicsContext class ngfx::MTLGraphicsPipeline class ngfx::MTLPipelineCache struct ngfx::MTLPipelineUtil class ngfx::MTLRenderCommandEncoder class ngfx::MTLRenderPass class ngfx::MTLShaderModule class ngfx::MTLSurface class ngfx::MTLTexture class ngfx::MTLVertexShaderModule class ngfx::MTLWindow class ngfx::Pipeline class ngfx::PipelineCache class ngfx::ProcessUtil class ngfx::Queue struct ngfx::Rect2D class ngfx::RegexUtil struct ngfx::Region class ngfx::RenderPass class ngfx::Semaphore class ngfx::ShaderModule class ngfx::ShaderTools class ngfx::StringUtil class ngfx::Surface class ngfx::Swapchain class ngfx::Texture class ngfx::Timer class ngfx::Util class ngfx::VertexShaderModule struct ngfx::VKBlit class ngfx::VKBuffer class ngfx::VKCommandBuffer class ngfx::VKCommandPool class ngfx::VKComputePipeline class ngfx::VKComputeShaderModule class ngfx::VKDebugMessenger class ngfx::VKDescriptorSetLayoutCache class ngfx::VKDevice class ngfx::VKFence class ngfx::VKFragmentShaderModule class ngfx::VKFramebuffer class ngfx::VKGraphics class ngfx::VKGraphicsContext class ngfx::VKGraphicsPipeline class ngfx::VKImage struct ngfx::VKImageCreateInfo class ngfx::VKImageView struct ngfx::VKImageViewCreateInfo class ngfx::VKInstance class ngfx::VKPhysicalDevice class ngfx::VKPipeline class ngfx::VKPipelineCache struct ngfx::VKPipelineUtil class ngfx::VKQueue class ngfx::VKRenderPass struct ngfx::VKSamplerCreateInfo class ngfx::VKSemaphore class ngfx::VKShaderModule class ngfx::VKSurface class ngfx::VKSwapchain class ngfx::VKTexture class ngfx::VKVertexShaderModule class ngfx::VKWindow class ngfx::Window class ngfx::WWindow Types Name enum KeyCode { KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT} enum InputAction { RELEASE, PRESS, GLFW =(KEY_UP), GLFW =(KEY_UP), RELEASE, PRESS} enum MouseButton { MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT} enum PrimitiveTopology { PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PolygonMode { POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendFactor { BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_CONSTANT_ALPHA = MTLBlendFactorBlendAlpha, BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = MTLBlendFactorOneMinusBlendAlpha, BLEND_FACTOR_SRC_ALPHA_SATURATE = MTLBlendFactorSourceAlphaSaturated, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BufferUsageFlagBits { BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendOp { BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ColorComponentFlagBits { COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CommandBufferLevel { COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CullModeFlags { CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FrontFace { FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum TextureType { TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY} enum ImageUsageFlagBits { IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PipelineStageFlagBits { PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ShaderStageFlagBits { SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PixelFormat { PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT} enum IndexFormat { INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT} enum VertexFormat { DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT)} enum DescriptorType { DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum VertexInputRate { VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FilterMode { FILTER_NEAREST, FILTER_LINEAR, FILTER_NEAREST, FILTER_LINEAR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ImageLayout { IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR} enum KeyCode { KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT} enum InputAction { RELEASE, PRESS, GLFW =(KEY_UP), GLFW =(KEY_UP), RELEASE, PRESS} enum MouseButton { MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT} enum PrimitiveTopology { PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PolygonMode { POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendFactor { BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_CONSTANT_ALPHA = MTLBlendFactorBlendAlpha, BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = MTLBlendFactorOneMinusBlendAlpha, BLEND_FACTOR_SRC_ALPHA_SATURATE = MTLBlendFactorSourceAlphaSaturated, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendOp { BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BufferUsageFlagBits { BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ColorComponentFlagBits { COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CommandBufferLevel { COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CullModeFlags { CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FenceCreateFlagBits { FENCE_CREATE_SIGNALED_BIT, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FrontFace { FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ImageUsageFlagBits { IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PipelineStageFlagBits { PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ShaderStageFlagBits { SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum TextureType { TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY} enum PixelFormat { PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT} enum IndexFormat { INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT} enum VertexFormat { DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT)} enum DescriptorType { DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum VertexInputRate { VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FilterMode { FILTER_NEAREST, FILTER_LINEAR, FILTER_NEAREST, FILTER_LINEAR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ImageLayout { IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR} enum MTLPrimitiveType { MTLPrimitiveTypePoint = 0, MTLPrimitiveTypeLine = 1, MTLPrimitiveTypeLineStrip = 2, MTLPrimitiveTypeTriangle = 3, MTLPrimitiveTypeTriangleStrip = 4} enum MTLTriangleFillMode { MTLTriangleFillModeFill = 0, MTLTriangleFillModeLines = 1} enum MTLBlendFactor { MTLBlendFactorZero = 0, MTLBlendFactorOne = 1, MTLBlendFactorSourceColor = 2, MTLBlendFactorOneMinusSourceColor = 3, MTLBlendFactorSourceAlpha = 4, MTLBlendFactorOneMinusSourceAlpha = 5, MTLBlendFactorDestinationColor = 6, MTLBlendFactorOneMinusDestinationColor = 7, MTLBlendFactorDestinationAlpha = 8, MTLBlendFactorOneMinusDestinationAlpha = 9, MTLBlendFactorSourceAlphaSaturated = 10, MTLBlendFactorBlendColor = 11, MTLBlendFactorOneMinusBlendColor = 12, MTLBlendFactorBlendAlpha = 13, MTLBlendFactorOneMinusBlendAlpha = 14} enum MTLBlendOperation { MTLBlendOperationAdd = 0, MTLBlendOperationSubtract = 1, MTLBlendOperationReverseSubtract = 2, MTLBlendOperationMin = 3, MTLBlendOperationMax = 4} enum MTLColorWriteMask { MTLColorWriteMaskNone = 0, MTLColorWriteMaskRed = 0x1 << 3, MTLColorWriteMaskGreen = 0x1 << 2, MTLColorWriteMaskBlue = 0x1 << 1, MTLColorWriteMaskAlpha = 0x1 << 0, MTLColorWriteMaskAll = 0xf} enum MTLCullMode { MTLCullModeNone = 0, MTLCullModeFront = 1, MTLCullModeBack = 2} enum MTLWinding { MTLWindingClockwise = 0, MTLWindingCounterClockwise = 1} enum MTLPixelFormat { MTLPixelFormatInvalid = 0, MTLPixelFormatA8Unorm = 1, MTLPixelFormatR8Unorm = 10, MTLPixelFormatR8Unorm_sRGB = 11, MTLPixelFormatR8Snorm = 12, MTLPixelFormatR8Uint = 13, MTLPixelFormatR8Sint = 14, MTLPixelFormatR16Unorm = 20, MTLPixelFormatR16Snorm = 22, MTLPixelFormatR16Uint = 23, MTLPixelFormatR16Sint = 24, MTLPixelFormatR16Float = 25, MTLPixelFormatRG8Unorm = 30, MTLPixelFormatRG8Unorm_sRGB = 31, MTLPixelFormatRG8Snorm = 32, MTLPixelFormatRG8Uint = 33, MTLPixelFormatRG8Sint = 34, MTLPixelFormatB5G6R5Unorm = 40, MTLPixelFormatA1BGR5Unorm = 41, MTLPixelFormatABGR4Unorm = 42, MTLPixelFormatBGR5A1Unorm = 43, MTLPixelFormatR32Uint = 53, MTLPixelFormatR32Sint = 54, MTLPixelFormatR32Float = 55, MTLPixelFormatRG16Unorm = 60, MTLPixelFormatRG16Snorm = 62, MTLPixelFormatRG16Uint = 63, MTLPixelFormatRG16Sint = 64, MTLPixelFormatRG16Float = 65, MTLPixelFormatRGBA8Unorm = 70, MTLPixelFormatRGBA8Unorm_sRGB = 71, MTLPixelFormatRGBA8Snorm = 72, MTLPixelFormatRGBA8Uint = 73, MTLPixelFormatRGBA8Sint = 74, MTLPixelFormatBGRA8Unorm = 80, MTLPixelFormatBGRA8Unorm_sRGB = 81, MTLPixelFormatRGB10A2Unorm = 90, MTLPixelFormatRGB10A2Uint = 91, MTLPixelFormatRG11B10Float = 92, MTLPixelFormatRGB9E5Float = 93, MTLPixelFormatBGR10A2Unorm = 94, MTLPixelFormatBGR10_XR = 554, MTLPixelFormatBGR10_XR_sRGB = 555, MTLPixelFormatRG32Uint = 103, MTLPixelFormatRG32Sint = 104, MTLPixelFormatRG32Float = 105, MTLPixelFormatRGBA16Unorm = 110, MTLPixelFormatRGBA16Snorm = 112, MTLPixelFormatRGBA16Uint = 113, MTLPixelFormatRGBA16Sint = 114, MTLPixelFormatRGBA16Float = 115, MTLPixelFormatBGRA10_XR = 552, MTLPixelFormatBGRA10_XR_sRGB = 553, MTLPixelFormatRGBA32Uint = 123, MTLPixelFormatRGBA32Sint = 124, MTLPixelFormatRGBA32Float = 125, MTLPixelFormatBC1_RGBA = 130, MTLPixelFormatBC1_RGBA_sRGB = 131, MTLPixelFormatBC2_RGBA = 132, MTLPixelFormatBC2_RGBA_sRGB = 133, MTLPixelFormatBC3_RGBA = 134, MTLPixelFormatBC3_RGBA_sRGB = 135, MTLPixelFormatBC4_RUnorm = 140, MTLPixelFormatBC4_RSnorm = 141, MTLPixelFormatBC5_RGUnorm = 142, MTLPixelFormatBC5_RGSnorm = 143, MTLPixelFormatBC6H_RGBFloat = 150, MTLPixelFormatBC6H_RGBUfloat = 151, MTLPixelFormatBC7_RGBAUnorm = 152, MTLPixelFormatBC7_RGBAUnorm_sRGB = 153, MTLPixelFormatPVRTC_RGB_2BPP = 160, MTLPixelFormatPVRTC_RGB_2BPP_sRGB = 161, MTLPixelFormatPVRTC_RGB_4BPP = 162, MTLPixelFormatPVRTC_RGB_4BPP_sRGB = 163, MTLPixelFormatPVRTC_RGBA_2BPP = 164, MTLPixelFormatPVRTC_RGBA_2BPP_sRGB = 165, MTLPixelFormatPVRTC_RGBA_4BPP = 166, MTLPixelFormatPVRTC_RGBA_4BPP_sRGB = 167, MTLPixelFormatEAC_R11Unorm = 170, MTLPixelFormatEAC_R11Snorm = 172, MTLPixelFormatEAC_RG11Unorm = 174, MTLPixelFormatEAC_RG11Snorm = 176, MTLPixelFormatEAC_RGBA8 = 178, MTLPixelFormatEAC_RGBA8_sRGB = 179, MTLPixelFormatETC2_RGB8 = 180, MTLPixelFormatETC2_RGB8_sRGB = 181, MTLPixelFormatETC2_RGB8A1 = 182, MTLPixelFormatETC2_RGB8A1_sRGB = 183, MTLPixelFormatASTC_4x4_sRGB = 186, MTLPixelFormatASTC_5x4_sRGB = 187, MTLPixelFormatASTC_5x5_sRGB = 188, MTLPixelFormatASTC_6x5_sRGB = 189, MTLPixelFormatASTC_6x6_sRGB = 190, MTLPixelFormatASTC_8x5_sRGB = 192, MTLPixelFormatASTC_8x6_sRGB = 193, MTLPixelFormatASTC_8x8_sRGB = 194, MTLPixelFormatASTC_10x5_sRGB = 195, MTLPixelFormatASTC_10x6_sRGB = 196, MTLPixelFormatASTC_10x8_sRGB = 197, MTLPixelFormatASTC_10x10_sRGB = 198, MTLPixelFormatASTC_12x10_sRGB = 199, MTLPixelFormatASTC_12x12_sRGB = 200, MTLPixelFormatASTC_4x4_LDR = 204, MTLPixelFormatASTC_5x4_LDR = 205, MTLPixelFormatASTC_5x5_LDR = 206, MTLPixelFormatASTC_6x5_LDR = 207, MTLPixelFormatASTC_6x6_LDR = 208, MTLPixelFormatASTC_8x5_LDR = 210, MTLPixelFormatASTC_8x6_LDR = 211, MTLPixelFormatASTC_8x8_LDR = 212, MTLPixelFormatASTC_10x5_LDR = 213, MTLPixelFormatASTC_10x6_LDR = 214, MTLPixelFormatASTC_10x8_LDR = 215, MTLPixelFormatASTC_10x10_LDR = 216, MTLPixelFormatASTC_12x10_LDR = 217, MTLPixelFormatASTC_12x12_LDR = 218, MTLPixelFormatGBGR422 = 240, MTLPixelFormatBGRG422 = 241, MTLPixelFormatDepth16Unorm = 250, MTLPixelFormatDepth32Float = 252, MTLPixelFormatStencil8 = 253, MTLPixelFormatDepth24Unorm_Stencil8 = 255, MTLPixelFormatDepth32Float_Stencil8 = 260, MTLPixelFormatX32_Stencil8 = 261, MTLPixelFormatX24_Stencil8 = 262} enum MTLIndexType { MTLIndexTypeUInt16 = 0, MTLIndexTypeUInt32 = 1} enum MTLTextureType { MTLTextureType1D = 0, MTLTextureType1DArray = 1, MTLTextureType2D = 2, MTLTextureType2DArray = 3, MTLTextureType2DMultisample = 4, MTLTextureTypeCube = 5, MTLTextureTypeCubeArray = 6, MTLTextureType3D = 7, MTLTextureType2DMultisampleArray = 8, MTLTextureTypeTextureBuffer = 9} enum MTLVertexFormat { MTLVertexFormatInvalid = 0, MTLVertexFormatUChar2 = 1, MTLVertexFormatUChar3 = 2, MTLVertexFormatUChar4 = 3, MTLVertexFormatChar2 = 4, MTLVertexFormatChar3 = 5, MTLVertexFormatChar4 = 6, MTLVertexFormatUChar2Normalized = 7, MTLVertexFormatUChar3Normalized = 8, MTLVertexFormatUChar4Normalized = 9, MTLVertexFormatChar2Normalized = 10, MTLVertexFormatChar3Normalized = 11, MTLVertexFormatChar4Normalized = 12, MTLVertexFormatUShort2 = 13, MTLVertexFormatUShort3 = 14, MTLVertexFormatUShort4 = 15, MTLVertexFormatShort2 = 16, MTLVertexFormatShort3 = 17, MTLVertexFormatShort4 = 18, MTLVertexFormatUShort2Normalized = 19, MTLVertexFormatUShort3Normalized = 20, MTLVertexFormatUShort4Normalized = 21, MTLVertexFormatShort2Normalized = 22, MTLVertexFormatShort3Normalized = 23, MTLVertexFormatShort4Normalized = 24, MTLVertexFormatHalf2 = 25, MTLVertexFormatHalf3 = 26, MTLVertexFormatHalf4 = 27, MTLVertexFormatFloat = 28, MTLVertexFormatFloat2 = 29, MTLVertexFormatFloat3 = 30, MTLVertexFormatFloat4 = 31, MTLVertexFormatInt = 32, MTLVertexFormatInt2 = 33, MTLVertexFormatInt3 = 34, MTLVertexFormatInt4 = 35, MTLVertexFormatUInt = 36, MTLVertexFormatUInt2 = 37, MTLVertexFormatUInt3 = 38, MTLVertexFormatUInt4 = 39, MTLVertexFormatInt1010102Normalized = 40, MTLVertexFormatUInt1010102Normalized = 41} enum PrimitiveTopology { PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PolygonMode { POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendFactor { BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_CONSTANT_ALPHA = MTLBlendFactorBlendAlpha, BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = MTLBlendFactorOneMinusBlendAlpha, BLEND_FACTOR_SRC_ALPHA_SATURATE = MTLBlendFactorSourceAlphaSaturated, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendOp { BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BufferUsageFlagBits { BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ColorComponentFlagBits { COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CommandBufferLevel { COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CullModeFlags { CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FenceCreateFlagBits { FENCE_CREATE_SIGNALED_BIT, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FrontFace { FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum TextureType { TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY} enum ImageUsageFlagBits { IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PipelineStageFlagBits { PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ShaderStageFlagBits { SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PixelFormat { PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT} enum IndexFormat { INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT} enum VertexFormat { DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT)} enum DescriptorType { DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum VertexInputRate { VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FilterMode { FILTER_NEAREST, FILTER_LINEAR, FILTER_NEAREST, FILTER_LINEAR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ImageLayout { IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR} enum KeyCode { KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT} enum InputAction { RELEASE, PRESS, GLFW =(KEY_UP), GLFW =(KEY_UP), RELEASE, PRESS} enum MouseButton { MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT} typedef uint32_t Flags typedef Flags PipelineStageFlags typedef Flags ShaderStageFlags typedef Flags FenceCreateFlags typedef Flags ImageUsageFlags typedef Flags ColorComponentFlags typedef Flags BufferUsageFlags Functions Name Buffer * createVertexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) template <typename T > Buffer * createVertexBuffer ( GraphicsContext * ctx, const std::vector< T > & v) Buffer * createIndexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t)) template <typename T > Buffer * createIndexBuffer ( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t)) Buffer * createUniformBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) Buffer * createStorageBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) D3D_CAST ( Buffer ) D3DCommandList * d3d ( CommandBuffer * g) D3D_CAST ( ComputePipeline ) D3D_CAST ( Device ) D3D_CAST ( Fence ) D3D_CAST ( Framebuffer ) D3D_CAST ( Graphics ) D3D_CAST ( GraphicsContext ) D3D_CAST ( GraphicsPipeline ) D3D_CAST ( RenderPass ) D3D_CAST ( ShaderModule ) D3D_CAST ( VertexShaderModule ) D3D_CAST ( FragmentShaderModule ) D3D_CAST ( ComputeShaderModule ) D3D_CAST ( Surface ) D3D_CAST ( Texture ) D3D_CAST ( Window ) GLFWWindow * glfw ( Window * window) MTL_CAST ( Buffer ) MTL_CAST ( CommandBuffer ) MTL_CAST ( ComputePipeline ) MTL_CAST ( Device ) MTL_CAST ( Framebuffer ) MTL_CAST ( Graphics ) MTL_CAST ( GraphicsContext ) MTL_CAST ( GraphicsPipeline ) MTL_CAST ( RenderPass ) MTL_CAST ( ShaderModule ) MTL_CAST ( VertexShaderModule ) MTL_CAST ( FragmentShaderModule ) MTL_CAST ( ComputeShaderModule ) MTL_CAST ( Surface ) MTL_CAST ( Texture ) MTL_CAST ( Window ) VK_CAST ( Buffer ) VK_CAST ( CommandBuffer ) VK_CAST ( ComputePipeline ) VK_CAST ( Device ) VK_CAST ( Fence ) VK_CAST ( Framebuffer ) VK_CAST ( Graphics ) VKGraphicsContext * vk ( GraphicsContext * g) VK_CAST ( GraphicsPipeline ) bool operator== (const VKImageViewCreateInfo & lhs, const VKImageViewCreateInfo & rhs) VK_CAST ( Queue ) VK_CAST ( RenderPass ) VK_CAST ( Semaphore ) VK_CAST ( ShaderModule ) VK_CAST ( VertexShaderModule ) VK_CAST ( FragmentShaderModule ) VK_CAST ( ComputeShaderModule ) VK_CAST ( Surface ) VK_CAST ( Swapchain ) VK_CAST ( Texture ) VK_CAST ( Window ) WWindow * w ( Window * window) Types Documentation enum KeyCode Enumerator Value Description KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT enum InputAction Enumerator Value Description RELEASE PRESS GLFW =(KEY_UP) GLFW =(KEY_UP) RELEASE PRESS enum MouseButton Enumerator Value Description MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT enum PrimitiveTopology Enumerator Value Description PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum PolygonMode Enumerator Value Description POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum BlendFactor Enumerator Value Description BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_CONSTANT_ALPHA MTLBlendFactorBlendAlpha BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA MTLBlendFactorOneMinusBlendAlpha BLEND_FACTOR_SRC_ALPHA_SATURATE MTLBlendFactorSourceAlphaSaturated VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum BufferUsageFlagBits Enumerator Value Description BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum BlendOp Enumerator Value Description BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum ColorComponentFlagBits Enumerator Value Description COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum CommandBufferLevel Enumerator Value Description COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum CullModeFlags Enumerator Value Description CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum FrontFace Enumerator Value Description FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum TextureType Enumerator Value Description TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY enum ImageUsageFlagBits Enumerator Value Description IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum PipelineStageFlagBits Enumerator Value Description PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum ShaderStageFlagBits Enumerator Value Description SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum PixelFormat Enumerator Value Description PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT enum IndexFormat Enumerator Value Description INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT enum VertexFormat Enumerator Value Description DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) enum DescriptorType Enumerator Value Description DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum VertexInputRate Enumerator Value Description VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum FilterMode Enumerator Value Description FILTER_NEAREST FILTER_LINEAR FILTER_NEAREST FILTER_LINEAR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum ImageLayout Enumerator Value Description IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR enum KeyCode Enumerator Value Description KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT enum InputAction Enumerator Value Description RELEASE PRESS GLFW =(KEY_UP) GLFW =(KEY_UP) RELEASE PRESS enum MouseButton Enumerator Value Description MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT enum PrimitiveTopology Enumerator Value Description PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum PolygonMode Enumerator Value Description POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum BlendFactor Enumerator Value Description BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_CONSTANT_ALPHA MTLBlendFactorBlendAlpha BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA MTLBlendFactorOneMinusBlendAlpha BLEND_FACTOR_SRC_ALPHA_SATURATE MTLBlendFactorSourceAlphaSaturated VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum BlendOp Enumerator Value Description BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum BufferUsageFlagBits Enumerator Value Description BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum ColorComponentFlagBits Enumerator Value Description COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum CommandBufferLevel Enumerator Value Description COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum CullModeFlags Enumerator Value Description CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum FenceCreateFlagBits Enumerator Value Description FENCE_CREATE_SIGNALED_BIT VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum FrontFace Enumerator Value Description FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum ImageUsageFlagBits Enumerator Value Description IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum PipelineStageFlagBits Enumerator Value Description PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum ShaderStageFlagBits Enumerator Value Description SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum TextureType Enumerator Value Description TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY enum PixelFormat Enumerator Value Description PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT enum IndexFormat Enumerator Value Description INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT enum VertexFormat Enumerator Value Description DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) enum DescriptorType Enumerator Value Description DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum VertexInputRate Enumerator Value Description VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum FilterMode Enumerator Value Description FILTER_NEAREST FILTER_LINEAR FILTER_NEAREST FILTER_LINEAR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum ImageLayout Enumerator Value Description IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR enum MTLPrimitiveType Enumerator Value Description MTLPrimitiveTypePoint 0 MTLPrimitiveTypeLine 1 MTLPrimitiveTypeLineStrip 2 MTLPrimitiveTypeTriangle 3 MTLPrimitiveTypeTriangleStrip 4 enum MTLTriangleFillMode Enumerator Value Description MTLTriangleFillModeFill 0 MTLTriangleFillModeLines 1 enum MTLBlendFactor Enumerator Value Description MTLBlendFactorZero 0 MTLBlendFactorOne 1 MTLBlendFactorSourceColor 2 MTLBlendFactorOneMinusSourceColor 3 MTLBlendFactorSourceAlpha 4 MTLBlendFactorOneMinusSourceAlpha 5 MTLBlendFactorDestinationColor 6 MTLBlendFactorOneMinusDestinationColor 7 MTLBlendFactorDestinationAlpha 8 MTLBlendFactorOneMinusDestinationAlpha 9 MTLBlendFactorSourceAlphaSaturated 10 MTLBlendFactorBlendColor 11 MTLBlendFactorOneMinusBlendColor 12 MTLBlendFactorBlendAlpha 13 MTLBlendFactorOneMinusBlendAlpha 14 enum MTLBlendOperation Enumerator Value Description MTLBlendOperationAdd 0 MTLBlendOperationSubtract 1 MTLBlendOperationReverseSubtract 2 MTLBlendOperationMin 3 MTLBlendOperationMax 4 enum MTLColorWriteMask Enumerator Value Description MTLColorWriteMaskNone 0 MTLColorWriteMaskRed 0x1 << 3 MTLColorWriteMaskGreen 0x1 << 2 MTLColorWriteMaskBlue 0x1 << 1 MTLColorWriteMaskAlpha 0x1 << 0 MTLColorWriteMaskAll 0xf enum MTLCullMode Enumerator Value Description MTLCullModeNone 0 MTLCullModeFront 1 MTLCullModeBack 2 enum MTLWinding Enumerator Value Description MTLWindingClockwise 0 MTLWindingCounterClockwise 1 enum MTLPixelFormat Enumerator Value Description MTLPixelFormatInvalid 0 MTLPixelFormatA8Unorm 1 MTLPixelFormatR8Unorm 10 MTLPixelFormatR8Unorm_sRGB 11 MTLPixelFormatR8Snorm 12 MTLPixelFormatR8Uint 13 MTLPixelFormatR8Sint 14 MTLPixelFormatR16Unorm 20 MTLPixelFormatR16Snorm 22 MTLPixelFormatR16Uint 23 MTLPixelFormatR16Sint 24 MTLPixelFormatR16Float 25 MTLPixelFormatRG8Unorm 30 MTLPixelFormatRG8Unorm_sRGB 31 MTLPixelFormatRG8Snorm 32 MTLPixelFormatRG8Uint 33 MTLPixelFormatRG8Sint 34 MTLPixelFormatB5G6R5Unorm 40 MTLPixelFormatA1BGR5Unorm 41 MTLPixelFormatABGR4Unorm 42 MTLPixelFormatBGR5A1Unorm 43 MTLPixelFormatR32Uint 53 MTLPixelFormatR32Sint 54 MTLPixelFormatR32Float 55 MTLPixelFormatRG16Unorm 60 MTLPixelFormatRG16Snorm 62 MTLPixelFormatRG16Uint 63 MTLPixelFormatRG16Sint 64 MTLPixelFormatRG16Float 65 MTLPixelFormatRGBA8Unorm 70 MTLPixelFormatRGBA8Unorm_sRGB 71 MTLPixelFormatRGBA8Snorm 72 MTLPixelFormatRGBA8Uint 73 MTLPixelFormatRGBA8Sint 74 MTLPixelFormatBGRA8Unorm 80 MTLPixelFormatBGRA8Unorm_sRGB 81 MTLPixelFormatRGB10A2Unorm 90 MTLPixelFormatRGB10A2Uint 91 MTLPixelFormatRG11B10Float 92 MTLPixelFormatRGB9E5Float 93 MTLPixelFormatBGR10A2Unorm 94 MTLPixelFormatBGR10_XR 554 MTLPixelFormatBGR10_XR_sRGB 555 MTLPixelFormatRG32Uint 103 MTLPixelFormatRG32Sint 104 MTLPixelFormatRG32Float 105 MTLPixelFormatRGBA16Unorm 110 MTLPixelFormatRGBA16Snorm 112 MTLPixelFormatRGBA16Uint 113 MTLPixelFormatRGBA16Sint 114 MTLPixelFormatRGBA16Float 115 MTLPixelFormatBGRA10_XR 552 MTLPixelFormatBGRA10_XR_sRGB 553 MTLPixelFormatRGBA32Uint 123 MTLPixelFormatRGBA32Sint 124 MTLPixelFormatRGBA32Float 125 MTLPixelFormatBC1_RGBA 130 MTLPixelFormatBC1_RGBA_sRGB 131 MTLPixelFormatBC2_RGBA 132 MTLPixelFormatBC2_RGBA_sRGB 133 MTLPixelFormatBC3_RGBA 134 MTLPixelFormatBC3_RGBA_sRGB 135 MTLPixelFormatBC4_RUnorm 140 MTLPixelFormatBC4_RSnorm 141 MTLPixelFormatBC5_RGUnorm 142 MTLPixelFormatBC5_RGSnorm 143 MTLPixelFormatBC6H_RGBFloat 150 MTLPixelFormatBC6H_RGBUfloat 151 MTLPixelFormatBC7_RGBAUnorm 152 MTLPixelFormatBC7_RGBAUnorm_sRGB 153 MTLPixelFormatPVRTC_RGB_2BPP 160 MTLPixelFormatPVRTC_RGB_2BPP_sRGB 161 MTLPixelFormatPVRTC_RGB_4BPP 162 MTLPixelFormatPVRTC_RGB_4BPP_sRGB 163 MTLPixelFormatPVRTC_RGBA_2BPP 164 MTLPixelFormatPVRTC_RGBA_2BPP_sRGB 165 MTLPixelFormatPVRTC_RGBA_4BPP 166 MTLPixelFormatPVRTC_RGBA_4BPP_sRGB 167 MTLPixelFormatEAC_R11Unorm 170 MTLPixelFormatEAC_R11Snorm 172 MTLPixelFormatEAC_RG11Unorm 174 MTLPixelFormatEAC_RG11Snorm 176 MTLPixelFormatEAC_RGBA8 178 MTLPixelFormatEAC_RGBA8_sRGB 179 MTLPixelFormatETC2_RGB8 180 MTLPixelFormatETC2_RGB8_sRGB 181 MTLPixelFormatETC2_RGB8A1 182 MTLPixelFormatETC2_RGB8A1_sRGB 183 MTLPixelFormatASTC_4x4_sRGB 186 MTLPixelFormatASTC_5x4_sRGB 187 MTLPixelFormatASTC_5x5_sRGB 188 MTLPixelFormatASTC_6x5_sRGB 189 MTLPixelFormatASTC_6x6_sRGB 190 MTLPixelFormatASTC_8x5_sRGB 192 MTLPixelFormatASTC_8x6_sRGB 193 MTLPixelFormatASTC_8x8_sRGB 194 MTLPixelFormatASTC_10x5_sRGB 195 MTLPixelFormatASTC_10x6_sRGB 196 MTLPixelFormatASTC_10x8_sRGB 197 MTLPixelFormatASTC_10x10_sRGB 198 MTLPixelFormatASTC_12x10_sRGB 199 MTLPixelFormatASTC_12x12_sRGB 200 MTLPixelFormatASTC_4x4_LDR 204 MTLPixelFormatASTC_5x4_LDR 205 MTLPixelFormatASTC_5x5_LDR 206 MTLPixelFormatASTC_6x5_LDR 207 MTLPixelFormatASTC_6x6_LDR 208 MTLPixelFormatASTC_8x5_LDR 210 MTLPixelFormatASTC_8x6_LDR 211 MTLPixelFormatASTC_8x8_LDR 212 MTLPixelFormatASTC_10x5_LDR 213 MTLPixelFormatASTC_10x6_LDR 214 MTLPixelFormatASTC_10x8_LDR 215 MTLPixelFormatASTC_10x10_LDR 216 MTLPixelFormatASTC_12x10_LDR 217 MTLPixelFormatASTC_12x12_LDR 218 MTLPixelFormatGBGR422 240 MTLPixelFormatBGRG422 241 MTLPixelFormatDepth16Unorm 250 MTLPixelFormatDepth32Float 252 MTLPixelFormatStencil8 253 MTLPixelFormatDepth24Unorm_Stencil8 255 MTLPixelFormatDepth32Float_Stencil8 260 MTLPixelFormatX32_Stencil8 261 MTLPixelFormatX24_Stencil8 262 enum MTLIndexType Enumerator Value Description MTLIndexTypeUInt16 0 MTLIndexTypeUInt32 1 enum MTLTextureType Enumerator Value Description MTLTextureType1D 0 MTLTextureType1DArray 1 MTLTextureType2D 2 MTLTextureType2DArray 3 MTLTextureType2DMultisample 4 MTLTextureTypeCube 5 MTLTextureTypeCubeArray 6 MTLTextureType3D 7 MTLTextureType2DMultisampleArray 8 MTLTextureTypeTextureBuffer 9 enum MTLVertexFormat Enumerator Value Description MTLVertexFormatInvalid 0 MTLVertexFormatUChar2 1 MTLVertexFormatUChar3 2 MTLVertexFormatUChar4 3 MTLVertexFormatChar2 4 MTLVertexFormatChar3 5 MTLVertexFormatChar4 6 MTLVertexFormatUChar2Normalized 7 MTLVertexFormatUChar3Normalized 8 MTLVertexFormatUChar4Normalized 9 MTLVertexFormatChar2Normalized 10 MTLVertexFormatChar3Normalized 11 MTLVertexFormatChar4Normalized 12 MTLVertexFormatUShort2 13 MTLVertexFormatUShort3 14 MTLVertexFormatUShort4 15 MTLVertexFormatShort2 16 MTLVertexFormatShort3 17 MTLVertexFormatShort4 18 MTLVertexFormatUShort2Normalized 19 MTLVertexFormatUShort3Normalized 20 MTLVertexFormatUShort4Normalized 21 MTLVertexFormatShort2Normalized 22 MTLVertexFormatShort3Normalized 23 MTLVertexFormatShort4Normalized 24 MTLVertexFormatHalf2 25 MTLVertexFormatHalf3 26 MTLVertexFormatHalf4 27 MTLVertexFormatFloat 28 MTLVertexFormatFloat2 29 MTLVertexFormatFloat3 30 MTLVertexFormatFloat4 31 MTLVertexFormatInt 32 MTLVertexFormatInt2 33 MTLVertexFormatInt3 34 MTLVertexFormatInt4 35 MTLVertexFormatUInt 36 MTLVertexFormatUInt2 37 MTLVertexFormatUInt3 38 MTLVertexFormatUInt4 39 MTLVertexFormatInt1010102Normalized 40 MTLVertexFormatUInt1010102Normalized 41 enum PrimitiveTopology Enumerator Value Description PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum PolygonMode Enumerator Value Description POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum BlendFactor Enumerator Value Description BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_CONSTANT_ALPHA MTLBlendFactorBlendAlpha BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA MTLBlendFactorOneMinusBlendAlpha BLEND_FACTOR_SRC_ALPHA_SATURATE MTLBlendFactorSourceAlphaSaturated VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum BlendOp Enumerator Value Description BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum BufferUsageFlagBits Enumerator Value Description BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum ColorComponentFlagBits Enumerator Value Description COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum CommandBufferLevel Enumerator Value Description COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum CullModeFlags Enumerator Value Description CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum FenceCreateFlagBits Enumerator Value Description FENCE_CREATE_SIGNALED_BIT VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum FrontFace Enumerator Value Description FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum TextureType Enumerator Value Description TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY enum ImageUsageFlagBits Enumerator Value Description IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum PipelineStageFlagBits Enumerator Value Description PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum ShaderStageFlagBits Enumerator Value Description SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum PixelFormat Enumerator Value Description PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT enum IndexFormat Enumerator Value Description INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT enum VertexFormat Enumerator Value Description DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) enum DescriptorType Enumerator Value Description DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum VertexInputRate Enumerator Value Description VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum FilterMode Enumerator Value Description FILTER_NEAREST FILTER_LINEAR FILTER_NEAREST FILTER_LINEAR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) enum ImageLayout Enumerator Value Description IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR enum KeyCode Enumerator Value Description KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT enum InputAction Enumerator Value Description RELEASE PRESS GLFW =(KEY_UP) GLFW =(KEY_UP) RELEASE PRESS enum MouseButton Enumerator Value Description MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT typedef Flags typedef uint32_t ngfx::Flags; typedef PipelineStageFlags typedef Flags ngfx::PipelineStageFlags; typedef ShaderStageFlags typedef Flags ngfx::ShaderStageFlags; typedef FenceCreateFlags typedef Flags ngfx::FenceCreateFlags; typedef ImageUsageFlags typedef Flags ngfx::ImageUsageFlags; typedef ColorComponentFlags typedef Flags ngfx::ColorComponentFlags; typedef BufferUsageFlags typedef Flags ngfx::BufferUsageFlags; Functions Documentation function createVertexBuffer static Buffer * createVertexBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) Create a vertex buffer function createVertexBuffer template <typename T > static inline Buffer * createVertexBuffer( GraphicsContext * ctx, const std::vector< T > & v ) Parameters : ctx The graphics context v The buffer data Create a vertex buffer function createIndexBuffer static Buffer * createIndexBuffer( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) stride The stride of the input data (in bytes) Create an index buffer function createIndexBuffer template <typename T > static inline Buffer * createIndexBuffer( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context v The buffer data stride The stride of the input data (in bytes) Create an index buffer function createUniformBuffer static Buffer * createUniformBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a uniform buffer function createStorageBuffer static Buffer * createStorageBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a storage buffer function D3D_CAST D3D_CAST( Buffer ) function d3d inline D3DCommandList * d3d( CommandBuffer * g ) function D3D_CAST D3D_CAST( ComputePipeline ) function D3D_CAST D3D_CAST( Device ) function D3D_CAST D3D_CAST( Fence ) function D3D_CAST D3D_CAST( Framebuffer ) function D3D_CAST D3D_CAST( Graphics ) function D3D_CAST D3D_CAST( GraphicsContext ) function D3D_CAST D3D_CAST( GraphicsPipeline ) function D3D_CAST D3D_CAST( RenderPass ) function D3D_CAST D3D_CAST( ShaderModule ) function D3D_CAST D3D_CAST( VertexShaderModule ) function D3D_CAST D3D_CAST( FragmentShaderModule ) function D3D_CAST D3D_CAST( ComputeShaderModule ) function D3D_CAST D3D_CAST( Surface ) function D3D_CAST D3D_CAST( Texture ) function D3D_CAST D3D_CAST( Window ) function glfw inline GLFWWindow * glfw( Window * window ) function MTL_CAST MTL_CAST( Buffer ) function MTL_CAST MTL_CAST( CommandBuffer ) function MTL_CAST MTL_CAST( ComputePipeline ) function MTL_CAST MTL_CAST( Device ) function MTL_CAST MTL_CAST( Framebuffer ) function MTL_CAST MTL_CAST( Graphics ) function MTL_CAST MTL_CAST( GraphicsContext ) function MTL_CAST MTL_CAST( GraphicsPipeline ) function MTL_CAST MTL_CAST( RenderPass ) function MTL_CAST MTL_CAST( ShaderModule ) function MTL_CAST MTL_CAST( VertexShaderModule ) function MTL_CAST MTL_CAST( FragmentShaderModule ) function MTL_CAST MTL_CAST( ComputeShaderModule ) function MTL_CAST MTL_CAST( Surface ) function MTL_CAST MTL_CAST( Texture ) function MTL_CAST MTL_CAST( Window ) function VK_CAST VK_CAST( Buffer ) function VK_CAST VK_CAST( CommandBuffer ) function VK_CAST VK_CAST( ComputePipeline ) function VK_CAST VK_CAST( Device ) function VK_CAST VK_CAST( Fence ) function VK_CAST VK_CAST( Framebuffer ) function VK_CAST VK_CAST( Graphics ) function vk inline VKGraphicsContext * vk( GraphicsContext * g ) function VK_CAST VK_CAST( GraphicsPipeline ) function operator== static bool operator==( const VKImageViewCreateInfo & lhs, const VKImageViewCreateInfo & rhs ) function VK_CAST VK_CAST( Queue ) function VK_CAST VK_CAST( RenderPass ) function VK_CAST VK_CAST( Semaphore ) function VK_CAST VK_CAST( ShaderModule ) function VK_CAST VK_CAST( VertexShaderModule ) function VK_CAST VK_CAST( FragmentShaderModule ) function VK_CAST VK_CAST( ComputeShaderModule ) function VK_CAST VK_CAST( Surface ) function VK_CAST VK_CAST( Swapchain ) function VK_CAST VK_CAST( Texture ) function VK_CAST VK_CAST( Window ) function w inline WWindow * w( Window * window ) Updated on 3 April 2021 at 20:21:51 PDT","title":"ngfx"},{"location":"api/Namespaces/namespacengfx/#ngfx","text":"","title":"ngfx"},{"location":"api/Namespaces/namespacengfx/#classes","text":"Name class ngfx::BaseApplication class ngfx::Buffer class ngfx::Camera class ngfx::CommandBuffer class ngfx::ComputeApplication class ngfx::ComputeOp class ngfx::ComputePass class ngfx::ComputePipeline class ngfx::ComputeShaderModule class ngfx::D3DBlitOp class ngfx::D3DBuffer class ngfx::D3DCommandList class ngfx::D3DCommandQueue class ngfx::D3DComputePass class ngfx::D3DComputePipeline class ngfx::D3DComputeShaderModule class ngfx::D3DDescriptorHandle class ngfx::D3DDescriptorHeap class ngfx::D3DDevice class ngfx::D3DFence class ngfx::D3DFragmentShaderModule class ngfx::D3DFramebuffer class ngfx::D3DGraphics class ngfx::D3DGraphicsContext class ngfx::D3DGraphicsPipeline class ngfx::D3DPipeline class ngfx::D3DPipelineCache struct ngfx::D3DPipelineUtil class ngfx::D3DReadbackBuffer class ngfx::D3DRenderPass struct ngfx::D3DSamplerDesc class ngfx::D3DShaderModule class ngfx::D3DSurface class ngfx::D3DSwapchain class ngfx::D3DTexture class ngfx::D3DVertexShaderModule class ngfx::D3DWindow class ngfx::Device class ngfx::DrawColorOp class ngfx::DrawMeshOp class ngfx::DrawOp class ngfx::DrawTextureOp class ngfx::Fence class ngfx::File class ngfx::FileUtil class ngfx::FilterOp class ngfx::FPSCounter class ngfx::FragmentShaderModule class ngfx::Framebuffer class ngfx::GLFWWindow class ngfx::Graphics class ngfx::GraphicsContext class ngfx::GraphicsPipeline class ngfx::InputListener class ngfx::MatrixMultiplyCPUOp class ngfx::MatrixMultiplyGPUOp class ngfx::MatrixMultiplyOp struct ngfx::MeshData struct ngfx::MeshUtil class ngfx::MTLApplication class ngfx::MTLBuffer class ngfx::MTLCommandBuffer class ngfx::MTLCommandEncoder class ngfx::MTLComputeCommandEncoder class ngfx::MTLComputePipeline class ngfx::MTLComputeShaderModule class ngfx::MTLDepthStencilTexture class ngfx::MTLDevice class ngfx::MTLFragmentShaderModule class ngfx::MTLFramebuffer class ngfx::MTLGraphics class ngfx::MTLGraphicsContext class ngfx::MTLGraphicsPipeline class ngfx::MTLPipelineCache struct ngfx::MTLPipelineUtil class ngfx::MTLRenderCommandEncoder class ngfx::MTLRenderPass class ngfx::MTLShaderModule class ngfx::MTLSurface class ngfx::MTLTexture class ngfx::MTLVertexShaderModule class ngfx::MTLWindow class ngfx::Pipeline class ngfx::PipelineCache class ngfx::ProcessUtil class ngfx::Queue struct ngfx::Rect2D class ngfx::RegexUtil struct ngfx::Region class ngfx::RenderPass class ngfx::Semaphore class ngfx::ShaderModule class ngfx::ShaderTools class ngfx::StringUtil class ngfx::Surface class ngfx::Swapchain class ngfx::Texture class ngfx::Timer class ngfx::Util class ngfx::VertexShaderModule struct ngfx::VKBlit class ngfx::VKBuffer class ngfx::VKCommandBuffer class ngfx::VKCommandPool class ngfx::VKComputePipeline class ngfx::VKComputeShaderModule class ngfx::VKDebugMessenger class ngfx::VKDescriptorSetLayoutCache class ngfx::VKDevice class ngfx::VKFence class ngfx::VKFragmentShaderModule class ngfx::VKFramebuffer class ngfx::VKGraphics class ngfx::VKGraphicsContext class ngfx::VKGraphicsPipeline class ngfx::VKImage struct ngfx::VKImageCreateInfo class ngfx::VKImageView struct ngfx::VKImageViewCreateInfo class ngfx::VKInstance class ngfx::VKPhysicalDevice class ngfx::VKPipeline class ngfx::VKPipelineCache struct ngfx::VKPipelineUtil class ngfx::VKQueue class ngfx::VKRenderPass struct ngfx::VKSamplerCreateInfo class ngfx::VKSemaphore class ngfx::VKShaderModule class ngfx::VKSurface class ngfx::VKSwapchain class ngfx::VKTexture class ngfx::VKVertexShaderModule class ngfx::VKWindow class ngfx::Window class ngfx::WWindow","title":"Classes"},{"location":"api/Namespaces/namespacengfx/#types","text":"Name enum KeyCode { KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT} enum InputAction { RELEASE, PRESS, GLFW =(KEY_UP), GLFW =(KEY_UP), RELEASE, PRESS} enum MouseButton { MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT} enum PrimitiveTopology { PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PolygonMode { POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendFactor { BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_CONSTANT_ALPHA = MTLBlendFactorBlendAlpha, BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = MTLBlendFactorOneMinusBlendAlpha, BLEND_FACTOR_SRC_ALPHA_SATURATE = MTLBlendFactorSourceAlphaSaturated, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BufferUsageFlagBits { BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendOp { BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ColorComponentFlagBits { COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CommandBufferLevel { COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CullModeFlags { CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FrontFace { FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum TextureType { TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY} enum ImageUsageFlagBits { IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PipelineStageFlagBits { PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ShaderStageFlagBits { SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PixelFormat { PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT} enum IndexFormat { INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT} enum VertexFormat { DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT)} enum DescriptorType { DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum VertexInputRate { VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FilterMode { FILTER_NEAREST, FILTER_LINEAR, FILTER_NEAREST, FILTER_LINEAR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ImageLayout { IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR} enum KeyCode { KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT} enum InputAction { RELEASE, PRESS, GLFW =(KEY_UP), GLFW =(KEY_UP), RELEASE, PRESS} enum MouseButton { MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT} enum PrimitiveTopology { PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PolygonMode { POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendFactor { BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_CONSTANT_ALPHA = MTLBlendFactorBlendAlpha, BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = MTLBlendFactorOneMinusBlendAlpha, BLEND_FACTOR_SRC_ALPHA_SATURATE = MTLBlendFactorSourceAlphaSaturated, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendOp { BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BufferUsageFlagBits { BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ColorComponentFlagBits { COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CommandBufferLevel { COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CullModeFlags { CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FenceCreateFlagBits { FENCE_CREATE_SIGNALED_BIT, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FrontFace { FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ImageUsageFlagBits { IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PipelineStageFlagBits { PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ShaderStageFlagBits { SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum TextureType { TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY} enum PixelFormat { PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT} enum IndexFormat { INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT} enum VertexFormat { DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT)} enum DescriptorType { DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum VertexInputRate { VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FilterMode { FILTER_NEAREST, FILTER_LINEAR, FILTER_NEAREST, FILTER_LINEAR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ImageLayout { IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR} enum MTLPrimitiveType { MTLPrimitiveTypePoint = 0, MTLPrimitiveTypeLine = 1, MTLPrimitiveTypeLineStrip = 2, MTLPrimitiveTypeTriangle = 3, MTLPrimitiveTypeTriangleStrip = 4} enum MTLTriangleFillMode { MTLTriangleFillModeFill = 0, MTLTriangleFillModeLines = 1} enum MTLBlendFactor { MTLBlendFactorZero = 0, MTLBlendFactorOne = 1, MTLBlendFactorSourceColor = 2, MTLBlendFactorOneMinusSourceColor = 3, MTLBlendFactorSourceAlpha = 4, MTLBlendFactorOneMinusSourceAlpha = 5, MTLBlendFactorDestinationColor = 6, MTLBlendFactorOneMinusDestinationColor = 7, MTLBlendFactorDestinationAlpha = 8, MTLBlendFactorOneMinusDestinationAlpha = 9, MTLBlendFactorSourceAlphaSaturated = 10, MTLBlendFactorBlendColor = 11, MTLBlendFactorOneMinusBlendColor = 12, MTLBlendFactorBlendAlpha = 13, MTLBlendFactorOneMinusBlendAlpha = 14} enum MTLBlendOperation { MTLBlendOperationAdd = 0, MTLBlendOperationSubtract = 1, MTLBlendOperationReverseSubtract = 2, MTLBlendOperationMin = 3, MTLBlendOperationMax = 4} enum MTLColorWriteMask { MTLColorWriteMaskNone = 0, MTLColorWriteMaskRed = 0x1 << 3, MTLColorWriteMaskGreen = 0x1 << 2, MTLColorWriteMaskBlue = 0x1 << 1, MTLColorWriteMaskAlpha = 0x1 << 0, MTLColorWriteMaskAll = 0xf} enum MTLCullMode { MTLCullModeNone = 0, MTLCullModeFront = 1, MTLCullModeBack = 2} enum MTLWinding { MTLWindingClockwise = 0, MTLWindingCounterClockwise = 1} enum MTLPixelFormat { MTLPixelFormatInvalid = 0, MTLPixelFormatA8Unorm = 1, MTLPixelFormatR8Unorm = 10, MTLPixelFormatR8Unorm_sRGB = 11, MTLPixelFormatR8Snorm = 12, MTLPixelFormatR8Uint = 13, MTLPixelFormatR8Sint = 14, MTLPixelFormatR16Unorm = 20, MTLPixelFormatR16Snorm = 22, MTLPixelFormatR16Uint = 23, MTLPixelFormatR16Sint = 24, MTLPixelFormatR16Float = 25, MTLPixelFormatRG8Unorm = 30, MTLPixelFormatRG8Unorm_sRGB = 31, MTLPixelFormatRG8Snorm = 32, MTLPixelFormatRG8Uint = 33, MTLPixelFormatRG8Sint = 34, MTLPixelFormatB5G6R5Unorm = 40, MTLPixelFormatA1BGR5Unorm = 41, MTLPixelFormatABGR4Unorm = 42, MTLPixelFormatBGR5A1Unorm = 43, MTLPixelFormatR32Uint = 53, MTLPixelFormatR32Sint = 54, MTLPixelFormatR32Float = 55, MTLPixelFormatRG16Unorm = 60, MTLPixelFormatRG16Snorm = 62, MTLPixelFormatRG16Uint = 63, MTLPixelFormatRG16Sint = 64, MTLPixelFormatRG16Float = 65, MTLPixelFormatRGBA8Unorm = 70, MTLPixelFormatRGBA8Unorm_sRGB = 71, MTLPixelFormatRGBA8Snorm = 72, MTLPixelFormatRGBA8Uint = 73, MTLPixelFormatRGBA8Sint = 74, MTLPixelFormatBGRA8Unorm = 80, MTLPixelFormatBGRA8Unorm_sRGB = 81, MTLPixelFormatRGB10A2Unorm = 90, MTLPixelFormatRGB10A2Uint = 91, MTLPixelFormatRG11B10Float = 92, MTLPixelFormatRGB9E5Float = 93, MTLPixelFormatBGR10A2Unorm = 94, MTLPixelFormatBGR10_XR = 554, MTLPixelFormatBGR10_XR_sRGB = 555, MTLPixelFormatRG32Uint = 103, MTLPixelFormatRG32Sint = 104, MTLPixelFormatRG32Float = 105, MTLPixelFormatRGBA16Unorm = 110, MTLPixelFormatRGBA16Snorm = 112, MTLPixelFormatRGBA16Uint = 113, MTLPixelFormatRGBA16Sint = 114, MTLPixelFormatRGBA16Float = 115, MTLPixelFormatBGRA10_XR = 552, MTLPixelFormatBGRA10_XR_sRGB = 553, MTLPixelFormatRGBA32Uint = 123, MTLPixelFormatRGBA32Sint = 124, MTLPixelFormatRGBA32Float = 125, MTLPixelFormatBC1_RGBA = 130, MTLPixelFormatBC1_RGBA_sRGB = 131, MTLPixelFormatBC2_RGBA = 132, MTLPixelFormatBC2_RGBA_sRGB = 133, MTLPixelFormatBC3_RGBA = 134, MTLPixelFormatBC3_RGBA_sRGB = 135, MTLPixelFormatBC4_RUnorm = 140, MTLPixelFormatBC4_RSnorm = 141, MTLPixelFormatBC5_RGUnorm = 142, MTLPixelFormatBC5_RGSnorm = 143, MTLPixelFormatBC6H_RGBFloat = 150, MTLPixelFormatBC6H_RGBUfloat = 151, MTLPixelFormatBC7_RGBAUnorm = 152, MTLPixelFormatBC7_RGBAUnorm_sRGB = 153, MTLPixelFormatPVRTC_RGB_2BPP = 160, MTLPixelFormatPVRTC_RGB_2BPP_sRGB = 161, MTLPixelFormatPVRTC_RGB_4BPP = 162, MTLPixelFormatPVRTC_RGB_4BPP_sRGB = 163, MTLPixelFormatPVRTC_RGBA_2BPP = 164, MTLPixelFormatPVRTC_RGBA_2BPP_sRGB = 165, MTLPixelFormatPVRTC_RGBA_4BPP = 166, MTLPixelFormatPVRTC_RGBA_4BPP_sRGB = 167, MTLPixelFormatEAC_R11Unorm = 170, MTLPixelFormatEAC_R11Snorm = 172, MTLPixelFormatEAC_RG11Unorm = 174, MTLPixelFormatEAC_RG11Snorm = 176, MTLPixelFormatEAC_RGBA8 = 178, MTLPixelFormatEAC_RGBA8_sRGB = 179, MTLPixelFormatETC2_RGB8 = 180, MTLPixelFormatETC2_RGB8_sRGB = 181, MTLPixelFormatETC2_RGB8A1 = 182, MTLPixelFormatETC2_RGB8A1_sRGB = 183, MTLPixelFormatASTC_4x4_sRGB = 186, MTLPixelFormatASTC_5x4_sRGB = 187, MTLPixelFormatASTC_5x5_sRGB = 188, MTLPixelFormatASTC_6x5_sRGB = 189, MTLPixelFormatASTC_6x6_sRGB = 190, MTLPixelFormatASTC_8x5_sRGB = 192, MTLPixelFormatASTC_8x6_sRGB = 193, MTLPixelFormatASTC_8x8_sRGB = 194, MTLPixelFormatASTC_10x5_sRGB = 195, MTLPixelFormatASTC_10x6_sRGB = 196, MTLPixelFormatASTC_10x8_sRGB = 197, MTLPixelFormatASTC_10x10_sRGB = 198, MTLPixelFormatASTC_12x10_sRGB = 199, MTLPixelFormatASTC_12x12_sRGB = 200, MTLPixelFormatASTC_4x4_LDR = 204, MTLPixelFormatASTC_5x4_LDR = 205, MTLPixelFormatASTC_5x5_LDR = 206, MTLPixelFormatASTC_6x5_LDR = 207, MTLPixelFormatASTC_6x6_LDR = 208, MTLPixelFormatASTC_8x5_LDR = 210, MTLPixelFormatASTC_8x6_LDR = 211, MTLPixelFormatASTC_8x8_LDR = 212, MTLPixelFormatASTC_10x5_LDR = 213, MTLPixelFormatASTC_10x6_LDR = 214, MTLPixelFormatASTC_10x8_LDR = 215, MTLPixelFormatASTC_10x10_LDR = 216, MTLPixelFormatASTC_12x10_LDR = 217, MTLPixelFormatASTC_12x12_LDR = 218, MTLPixelFormatGBGR422 = 240, MTLPixelFormatBGRG422 = 241, MTLPixelFormatDepth16Unorm = 250, MTLPixelFormatDepth32Float = 252, MTLPixelFormatStencil8 = 253, MTLPixelFormatDepth24Unorm_Stencil8 = 255, MTLPixelFormatDepth32Float_Stencil8 = 260, MTLPixelFormatX32_Stencil8 = 261, MTLPixelFormatX24_Stencil8 = 262} enum MTLIndexType { MTLIndexTypeUInt16 = 0, MTLIndexTypeUInt32 = 1} enum MTLTextureType { MTLTextureType1D = 0, MTLTextureType1DArray = 1, MTLTextureType2D = 2, MTLTextureType2DArray = 3, MTLTextureType2DMultisample = 4, MTLTextureTypeCube = 5, MTLTextureTypeCubeArray = 6, MTLTextureType3D = 7, MTLTextureType2DMultisampleArray = 8, MTLTextureTypeTextureBuffer = 9} enum MTLVertexFormat { MTLVertexFormatInvalid = 0, MTLVertexFormatUChar2 = 1, MTLVertexFormatUChar3 = 2, MTLVertexFormatUChar4 = 3, MTLVertexFormatChar2 = 4, MTLVertexFormatChar3 = 5, MTLVertexFormatChar4 = 6, MTLVertexFormatUChar2Normalized = 7, MTLVertexFormatUChar3Normalized = 8, MTLVertexFormatUChar4Normalized = 9, MTLVertexFormatChar2Normalized = 10, MTLVertexFormatChar3Normalized = 11, MTLVertexFormatChar4Normalized = 12, MTLVertexFormatUShort2 = 13, MTLVertexFormatUShort3 = 14, MTLVertexFormatUShort4 = 15, MTLVertexFormatShort2 = 16, MTLVertexFormatShort3 = 17, MTLVertexFormatShort4 = 18, MTLVertexFormatUShort2Normalized = 19, MTLVertexFormatUShort3Normalized = 20, MTLVertexFormatUShort4Normalized = 21, MTLVertexFormatShort2Normalized = 22, MTLVertexFormatShort3Normalized = 23, MTLVertexFormatShort4Normalized = 24, MTLVertexFormatHalf2 = 25, MTLVertexFormatHalf3 = 26, MTLVertexFormatHalf4 = 27, MTLVertexFormatFloat = 28, MTLVertexFormatFloat2 = 29, MTLVertexFormatFloat3 = 30, MTLVertexFormatFloat4 = 31, MTLVertexFormatInt = 32, MTLVertexFormatInt2 = 33, MTLVertexFormatInt3 = 34, MTLVertexFormatInt4 = 35, MTLVertexFormatUInt = 36, MTLVertexFormatUInt2 = 37, MTLVertexFormatUInt3 = 38, MTLVertexFormatUInt4 = 39, MTLVertexFormatInt1010102Normalized = 40, MTLVertexFormatUInt1010102Normalized = 41} enum PrimitiveTopology { PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, PRIMITIVE_TOPOLOGY_POINT_LIST = D3D_PRIMITIVE_TOPOLOGY_POINTLIST, PRIMITIVE_TOPOLOGY_LINE_LIST = D3D_PRIMITIVE_TOPOLOGY_LINELIST, PRIMITIVE_TOPOLOGY_LINE_STRIP = D3D_PRIMITIVE_TOPOLOGY_LINESTRIP, PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST, PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PolygonMode { POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, POLYGON_MODE_FILL = D3D12_FILL_MODE_SOLID, POLYGON_MODE_LINE = D3D12_FILL_MODE_WIREFRAME, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendFactor { BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_ZERO = D3D12_BLEND_ZERO, BLEND_FACTOR_ONE = D3D12_BLEND_ONE, BLEND_FACTOR_SRC_COLOR = D3D12_BLEND_SRC_COLOR, BLEND_FACTOR_ONE_MINUS_SRC_COLOR = D3D12_BLEND_INV_SRC_COLOR, BLEND_FACTOR_DST_COLOR = D3D12_BLEND_DEST_COLOR, BLEND_FACTOR_ONE_MINUS_DST_COLOR = D3D12_BLEND_INV_DEST_COLOR, BLEND_FACTOR_SRC_ALPHA = D3D12_BLEND_SRC_ALPHA, BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = D3D12_BLEND_INV_SRC_ALPHA, BLEND_FACTOR_DST_ALPHA = D3D12_BLEND_DEST_ALPHA, BLEND_FACTOR_ONE_MINUS_DST_ALPHA = D3D12_BLEND_INV_DEST_ALPHA, BLEND_FACTOR_CONSTANT_COLOR = D3D12_BLEND_BLEND_FACTOR, BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = D3D12_BLEND_INV_BLEND_FACTOR, BLEND_FACTOR_CONSTANT_ALPHA = MTLBlendFactorBlendAlpha, BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = MTLBlendFactorOneMinusBlendAlpha, BLEND_FACTOR_SRC_ALPHA_SATURATE = MTLBlendFactorSourceAlphaSaturated, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BlendOp { BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, BLEND_OP_ADD = D3D12_BLEND_OP_ADD, BLEND_OP_SUBTRACT = D3D12_BLEND_OP_SUBTRACT, BLEND_OP_REVERSE_SUBTRACT = D3D12_BLEND_OP_REV_SUBTRACT, BLEND_OP_MIN = D3D12_BLEND_OP_MIN, BLEND_OP_MAX = D3D12_BLEND_OP_MAX, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum BufferUsageFlagBits { BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, BUFFER_USAGE_TRANSFER_SRC_BIT = 1, BUFFER_USAGE_TRANSFER_DST_BIT = 2, BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4, BUFFER_USAGE_STORAGE_BUFFER_BIT = 8, BUFFER_USAGE_VERTEX_BUFFER_BIT = 16, BUFFER_USAGE_INDEX_BUFFER_BIT = 32, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ColorComponentFlagBits { COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, COLOR_COMPONENT_R_BIT = D3D12_COLOR_WRITE_ENABLE_RED, COLOR_COMPONENT_G_BIT = D3D12_COLOR_WRITE_ENABLE_GREEN, COLOR_COMPONENT_B_BIT = D3D12_COLOR_WRITE_ENABLE_BLUE, COLOR_COMPONENT_A_BIT = D3D12_COLOR_WRITE_ENABLE_ALPHA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CommandBufferLevel { COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, COMMAND_BUFFER_LEVEL_PRIMARY = D3D12_COMMAND_LIST_TYPE_DIRECT, COMMAND_BUFFER_LEVEL_SECONDARY = D3D12_COMMAND_LIST_TYPE_BUNDLE, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum CullModeFlags { CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, CULL_MODE_NONE = D3D12_CULL_MODE_NONE, CULL_MODE_FRONT_BIT = D3D12_CULL_MODE_FRONT, CULL_MODE_BACK_BIT = D3D12_CULL_MODE_BACK, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FenceCreateFlagBits { FENCE_CREATE_SIGNALED_BIT, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FrontFace { FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, FRONT_FACE_COUNTER_CLOCKWISE = MTLWindingCounterClockwise, FRONT_FACE_CLOCKWISE = MTLWindingClockwise, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum TextureType { TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY, TEXTURE_TYPE_2D = D3D12_SRV_DIMENSION_TEXTURE2D, TEXTURE_TYPE_3D = D3D12_SRV_DIMENSION_TEXTURE3D, TEXTURE_TYPE_CUBE = D3D12_SRV_DIMENSION_TEXTURECUBE, TEXTURE_TYPE_2D_ARRAY = D3D12_SRV_DIMENSION_TEXTURE2DARRAY} enum ImageUsageFlagBits { IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, IMAGE_USAGE_TRANSFER_SRC_BIT = 1, IMAGE_USAGE_TRANSFER_DST_BIT = 2, IMAGE_USAGE_SAMPLED_BIT = 4, IMAGE_USAGE_STORAGE_BIT = 8, IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16, IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32, IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64, IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PipelineStageFlagBits { PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ShaderStageFlagBits { SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, SHADER_STAGE_VERTEX_BIT = 1, SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2, SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4, SHADER_STAGE_GEOMETRY_BIT = 8, SHADER_STAGE_FRAGMENT_BIT = 16, SHADER_STAGE_COMPUTE_BIT = 32, SHADER_STAGE_ALL_GRAPHICS = 64, SHADER_STAGE_ALL = 0xFF, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum PixelFormat { PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_UNDEFINED = DXGI_FORMAT_UNKNOWN, DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), DEFINE_PIXELFORMATS =(8, UNORM, UNORM), PIXELFORMAT_BGRA8_UNORM = DXGI_FORMAT_B8G8R8A8_UNORM, PIXELFORMAT_D16_UNORM = DXGI_FORMAT_D16_UNORM, PIXELFORMAT_D24_UNORM = DXGI_FORMAT_D24_UNORM_S8_UINT, PIXELFORMAT_D24_UNORM_S8 = DXGI_FORMAT_D24_UNORM_S8_UINT} enum IndexFormat { INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT, INDEXFORMAT_UINT16 = DXGI_FORMAT_R16_UINT, INDEXFORMAT_UINT32 = DXGI_FORMAT_R32_UINT} enum VertexFormat { DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT), DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT)} enum DescriptorType { DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, DESCRIPTOR_TYPE_STORAGE_IMAGE, DESCRIPTOR_TYPE_UNIFORM_BUFFER, DESCRIPTOR_TYPE_STORAGE_BUFFER, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum VertexInputRate { VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VERTEX_INPUT_RATE_VERTEX = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, VERTEX_INPUT_RATE_INSTANCE = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum FilterMode { FILTER_NEAREST, FILTER_LINEAR, FILTER_NEAREST, FILTER_LINEAR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)} enum ImageLayout { IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, IMAGE_LAYOUT_UNDEFINED, IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, IMAGE_LAYOUT_GENERAL, IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), VK =(PRIMITIVE_TOPOLOGY_POINT_LIST), IMAGE_LAYOUT_PRESENT_SRC = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR} enum KeyCode { KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), GLFW =(KEY_UP), KEY_UP = VK_UP, KEY_DOWN = VK_DOWN, KEY_LEFT = VK_LEFT, KEY_RIGHT = VK_RIGHT} enum InputAction { RELEASE, PRESS, GLFW =(KEY_UP), GLFW =(KEY_UP), RELEASE, PRESS} enum MouseButton { MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT, GLFW =(KEY_UP), GLFW =(KEY_UP), MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE, MOUSE_BUTTON_RIGHT} typedef uint32_t Flags typedef Flags PipelineStageFlags typedef Flags ShaderStageFlags typedef Flags FenceCreateFlags typedef Flags ImageUsageFlags typedef Flags ColorComponentFlags typedef Flags BufferUsageFlags","title":"Types"},{"location":"api/Namespaces/namespacengfx/#functions","text":"Name Buffer * createVertexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) template <typename T > Buffer * createVertexBuffer ( GraphicsContext * ctx, const std::vector< T > & v) Buffer * createIndexBuffer ( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t)) template <typename T > Buffer * createIndexBuffer ( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t)) Buffer * createUniformBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) Buffer * createStorageBuffer ( GraphicsContext * ctx, const void * data, uint32_t size) D3D_CAST ( Buffer ) D3DCommandList * d3d ( CommandBuffer * g) D3D_CAST ( ComputePipeline ) D3D_CAST ( Device ) D3D_CAST ( Fence ) D3D_CAST ( Framebuffer ) D3D_CAST ( Graphics ) D3D_CAST ( GraphicsContext ) D3D_CAST ( GraphicsPipeline ) D3D_CAST ( RenderPass ) D3D_CAST ( ShaderModule ) D3D_CAST ( VertexShaderModule ) D3D_CAST ( FragmentShaderModule ) D3D_CAST ( ComputeShaderModule ) D3D_CAST ( Surface ) D3D_CAST ( Texture ) D3D_CAST ( Window ) GLFWWindow * glfw ( Window * window) MTL_CAST ( Buffer ) MTL_CAST ( CommandBuffer ) MTL_CAST ( ComputePipeline ) MTL_CAST ( Device ) MTL_CAST ( Framebuffer ) MTL_CAST ( Graphics ) MTL_CAST ( GraphicsContext ) MTL_CAST ( GraphicsPipeline ) MTL_CAST ( RenderPass ) MTL_CAST ( ShaderModule ) MTL_CAST ( VertexShaderModule ) MTL_CAST ( FragmentShaderModule ) MTL_CAST ( ComputeShaderModule ) MTL_CAST ( Surface ) MTL_CAST ( Texture ) MTL_CAST ( Window ) VK_CAST ( Buffer ) VK_CAST ( CommandBuffer ) VK_CAST ( ComputePipeline ) VK_CAST ( Device ) VK_CAST ( Fence ) VK_CAST ( Framebuffer ) VK_CAST ( Graphics ) VKGraphicsContext * vk ( GraphicsContext * g) VK_CAST ( GraphicsPipeline ) bool operator== (const VKImageViewCreateInfo & lhs, const VKImageViewCreateInfo & rhs) VK_CAST ( Queue ) VK_CAST ( RenderPass ) VK_CAST ( Semaphore ) VK_CAST ( ShaderModule ) VK_CAST ( VertexShaderModule ) VK_CAST ( FragmentShaderModule ) VK_CAST ( ComputeShaderModule ) VK_CAST ( Surface ) VK_CAST ( Swapchain ) VK_CAST ( Texture ) VK_CAST ( Window ) WWindow * w ( Window * window)","title":"Functions"},{"location":"api/Namespaces/namespacengfx/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Namespaces/namespacengfx/#enum-keycode","text":"Enumerator Value Description KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT","title":"enum KeyCode"},{"location":"api/Namespaces/namespacengfx/#enum-inputaction","text":"Enumerator Value Description RELEASE PRESS GLFW =(KEY_UP) GLFW =(KEY_UP) RELEASE PRESS","title":"enum InputAction"},{"location":"api/Namespaces/namespacengfx/#enum-mousebutton","text":"Enumerator Value Description MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT","title":"enum MouseButton"},{"location":"api/Namespaces/namespacengfx/#enum-primitivetopology","text":"Enumerator Value Description PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum PrimitiveTopology"},{"location":"api/Namespaces/namespacengfx/#enum-polygonmode","text":"Enumerator Value Description POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum PolygonMode"},{"location":"api/Namespaces/namespacengfx/#enum-blendfactor","text":"Enumerator Value Description BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_CONSTANT_ALPHA MTLBlendFactorBlendAlpha BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA MTLBlendFactorOneMinusBlendAlpha BLEND_FACTOR_SRC_ALPHA_SATURATE MTLBlendFactorSourceAlphaSaturated VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum BlendFactor"},{"location":"api/Namespaces/namespacengfx/#enum-bufferusageflagbits","text":"Enumerator Value Description BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum BufferUsageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-blendop","text":"Enumerator Value Description BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum BlendOp"},{"location":"api/Namespaces/namespacengfx/#enum-colorcomponentflagbits","text":"Enumerator Value Description COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum ColorComponentFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-commandbufferlevel","text":"Enumerator Value Description COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum CommandBufferLevel"},{"location":"api/Namespaces/namespacengfx/#enum-cullmodeflags","text":"Enumerator Value Description CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum CullModeFlags"},{"location":"api/Namespaces/namespacengfx/#enum-frontface","text":"Enumerator Value Description FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum FrontFace"},{"location":"api/Namespaces/namespacengfx/#enum-texturetype","text":"Enumerator Value Description TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY","title":"enum TextureType"},{"location":"api/Namespaces/namespacengfx/#enum-imageusageflagbits","text":"Enumerator Value Description IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum ImageUsageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-pipelinestageflagbits","text":"Enumerator Value Description PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum PipelineStageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-shaderstageflagbits","text":"Enumerator Value Description SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum ShaderStageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-pixelformat","text":"Enumerator Value Description PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT","title":"enum PixelFormat"},{"location":"api/Namespaces/namespacengfx/#enum-indexformat","text":"Enumerator Value Description INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT","title":"enum IndexFormat"},{"location":"api/Namespaces/namespacengfx/#enum-vertexformat","text":"Enumerator Value Description DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT)","title":"enum VertexFormat"},{"location":"api/Namespaces/namespacengfx/#enum-descriptortype","text":"Enumerator Value Description DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum DescriptorType"},{"location":"api/Namespaces/namespacengfx/#enum-vertexinputrate","text":"Enumerator Value Description VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum VertexInputRate"},{"location":"api/Namespaces/namespacengfx/#enum-filtermode","text":"Enumerator Value Description FILTER_NEAREST FILTER_LINEAR FILTER_NEAREST FILTER_LINEAR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum FilterMode"},{"location":"api/Namespaces/namespacengfx/#enum-imagelayout","text":"Enumerator Value Description IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR","title":"enum ImageLayout"},{"location":"api/Namespaces/namespacengfx/#enum-keycode_1","text":"Enumerator Value Description KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT","title":"enum KeyCode"},{"location":"api/Namespaces/namespacengfx/#enum-inputaction_1","text":"Enumerator Value Description RELEASE PRESS GLFW =(KEY_UP) GLFW =(KEY_UP) RELEASE PRESS","title":"enum InputAction"},{"location":"api/Namespaces/namespacengfx/#enum-mousebutton_1","text":"Enumerator Value Description MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT","title":"enum MouseButton"},{"location":"api/Namespaces/namespacengfx/#enum-primitivetopology_1","text":"Enumerator Value Description PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum PrimitiveTopology"},{"location":"api/Namespaces/namespacengfx/#enum-polygonmode_1","text":"Enumerator Value Description POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum PolygonMode"},{"location":"api/Namespaces/namespacengfx/#enum-blendfactor_1","text":"Enumerator Value Description BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_CONSTANT_ALPHA MTLBlendFactorBlendAlpha BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA MTLBlendFactorOneMinusBlendAlpha BLEND_FACTOR_SRC_ALPHA_SATURATE MTLBlendFactorSourceAlphaSaturated VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum BlendFactor"},{"location":"api/Namespaces/namespacengfx/#enum-blendop_1","text":"Enumerator Value Description BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum BlendOp"},{"location":"api/Namespaces/namespacengfx/#enum-bufferusageflagbits_1","text":"Enumerator Value Description BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum BufferUsageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-colorcomponentflagbits_1","text":"Enumerator Value Description COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum ColorComponentFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-commandbufferlevel_1","text":"Enumerator Value Description COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum CommandBufferLevel"},{"location":"api/Namespaces/namespacengfx/#enum-cullmodeflags_1","text":"Enumerator Value Description CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum CullModeFlags"},{"location":"api/Namespaces/namespacengfx/#enum-fencecreateflagbits","text":"Enumerator Value Description FENCE_CREATE_SIGNALED_BIT VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum FenceCreateFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-frontface_1","text":"Enumerator Value Description FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum FrontFace"},{"location":"api/Namespaces/namespacengfx/#enum-imageusageflagbits_1","text":"Enumerator Value Description IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum ImageUsageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-pipelinestageflagbits_1","text":"Enumerator Value Description PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum PipelineStageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-shaderstageflagbits_1","text":"Enumerator Value Description SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum ShaderStageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-texturetype_1","text":"Enumerator Value Description TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY","title":"enum TextureType"},{"location":"api/Namespaces/namespacengfx/#enum-pixelformat_1","text":"Enumerator Value Description PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT","title":"enum PixelFormat"},{"location":"api/Namespaces/namespacengfx/#enum-indexformat_1","text":"Enumerator Value Description INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT","title":"enum IndexFormat"},{"location":"api/Namespaces/namespacengfx/#enum-vertexformat_1","text":"Enumerator Value Description DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT)","title":"enum VertexFormat"},{"location":"api/Namespaces/namespacengfx/#enum-descriptortype_1","text":"Enumerator Value Description DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum DescriptorType"},{"location":"api/Namespaces/namespacengfx/#enum-vertexinputrate_1","text":"Enumerator Value Description VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum VertexInputRate"},{"location":"api/Namespaces/namespacengfx/#enum-filtermode_1","text":"Enumerator Value Description FILTER_NEAREST FILTER_LINEAR FILTER_NEAREST FILTER_LINEAR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum FilterMode"},{"location":"api/Namespaces/namespacengfx/#enum-imagelayout_1","text":"Enumerator Value Description IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR","title":"enum ImageLayout"},{"location":"api/Namespaces/namespacengfx/#enum-mtlprimitivetype","text":"Enumerator Value Description MTLPrimitiveTypePoint 0 MTLPrimitiveTypeLine 1 MTLPrimitiveTypeLineStrip 2 MTLPrimitiveTypeTriangle 3 MTLPrimitiveTypeTriangleStrip 4","title":"enum MTLPrimitiveType"},{"location":"api/Namespaces/namespacengfx/#enum-mtltrianglefillmode","text":"Enumerator Value Description MTLTriangleFillModeFill 0 MTLTriangleFillModeLines 1","title":"enum MTLTriangleFillMode"},{"location":"api/Namespaces/namespacengfx/#enum-mtlblendfactor","text":"Enumerator Value Description MTLBlendFactorZero 0 MTLBlendFactorOne 1 MTLBlendFactorSourceColor 2 MTLBlendFactorOneMinusSourceColor 3 MTLBlendFactorSourceAlpha 4 MTLBlendFactorOneMinusSourceAlpha 5 MTLBlendFactorDestinationColor 6 MTLBlendFactorOneMinusDestinationColor 7 MTLBlendFactorDestinationAlpha 8 MTLBlendFactorOneMinusDestinationAlpha 9 MTLBlendFactorSourceAlphaSaturated 10 MTLBlendFactorBlendColor 11 MTLBlendFactorOneMinusBlendColor 12 MTLBlendFactorBlendAlpha 13 MTLBlendFactorOneMinusBlendAlpha 14","title":"enum MTLBlendFactor"},{"location":"api/Namespaces/namespacengfx/#enum-mtlblendoperation","text":"Enumerator Value Description MTLBlendOperationAdd 0 MTLBlendOperationSubtract 1 MTLBlendOperationReverseSubtract 2 MTLBlendOperationMin 3 MTLBlendOperationMax 4","title":"enum MTLBlendOperation"},{"location":"api/Namespaces/namespacengfx/#enum-mtlcolorwritemask","text":"Enumerator Value Description MTLColorWriteMaskNone 0 MTLColorWriteMaskRed 0x1 << 3 MTLColorWriteMaskGreen 0x1 << 2 MTLColorWriteMaskBlue 0x1 << 1 MTLColorWriteMaskAlpha 0x1 << 0 MTLColorWriteMaskAll 0xf","title":"enum MTLColorWriteMask"},{"location":"api/Namespaces/namespacengfx/#enum-mtlcullmode","text":"Enumerator Value Description MTLCullModeNone 0 MTLCullModeFront 1 MTLCullModeBack 2","title":"enum MTLCullMode"},{"location":"api/Namespaces/namespacengfx/#enum-mtlwinding","text":"Enumerator Value Description MTLWindingClockwise 0 MTLWindingCounterClockwise 1","title":"enum MTLWinding"},{"location":"api/Namespaces/namespacengfx/#enum-mtlpixelformat","text":"Enumerator Value Description MTLPixelFormatInvalid 0 MTLPixelFormatA8Unorm 1 MTLPixelFormatR8Unorm 10 MTLPixelFormatR8Unorm_sRGB 11 MTLPixelFormatR8Snorm 12 MTLPixelFormatR8Uint 13 MTLPixelFormatR8Sint 14 MTLPixelFormatR16Unorm 20 MTLPixelFormatR16Snorm 22 MTLPixelFormatR16Uint 23 MTLPixelFormatR16Sint 24 MTLPixelFormatR16Float 25 MTLPixelFormatRG8Unorm 30 MTLPixelFormatRG8Unorm_sRGB 31 MTLPixelFormatRG8Snorm 32 MTLPixelFormatRG8Uint 33 MTLPixelFormatRG8Sint 34 MTLPixelFormatB5G6R5Unorm 40 MTLPixelFormatA1BGR5Unorm 41 MTLPixelFormatABGR4Unorm 42 MTLPixelFormatBGR5A1Unorm 43 MTLPixelFormatR32Uint 53 MTLPixelFormatR32Sint 54 MTLPixelFormatR32Float 55 MTLPixelFormatRG16Unorm 60 MTLPixelFormatRG16Snorm 62 MTLPixelFormatRG16Uint 63 MTLPixelFormatRG16Sint 64 MTLPixelFormatRG16Float 65 MTLPixelFormatRGBA8Unorm 70 MTLPixelFormatRGBA8Unorm_sRGB 71 MTLPixelFormatRGBA8Snorm 72 MTLPixelFormatRGBA8Uint 73 MTLPixelFormatRGBA8Sint 74 MTLPixelFormatBGRA8Unorm 80 MTLPixelFormatBGRA8Unorm_sRGB 81 MTLPixelFormatRGB10A2Unorm 90 MTLPixelFormatRGB10A2Uint 91 MTLPixelFormatRG11B10Float 92 MTLPixelFormatRGB9E5Float 93 MTLPixelFormatBGR10A2Unorm 94 MTLPixelFormatBGR10_XR 554 MTLPixelFormatBGR10_XR_sRGB 555 MTLPixelFormatRG32Uint 103 MTLPixelFormatRG32Sint 104 MTLPixelFormatRG32Float 105 MTLPixelFormatRGBA16Unorm 110 MTLPixelFormatRGBA16Snorm 112 MTLPixelFormatRGBA16Uint 113 MTLPixelFormatRGBA16Sint 114 MTLPixelFormatRGBA16Float 115 MTLPixelFormatBGRA10_XR 552 MTLPixelFormatBGRA10_XR_sRGB 553 MTLPixelFormatRGBA32Uint 123 MTLPixelFormatRGBA32Sint 124 MTLPixelFormatRGBA32Float 125 MTLPixelFormatBC1_RGBA 130 MTLPixelFormatBC1_RGBA_sRGB 131 MTLPixelFormatBC2_RGBA 132 MTLPixelFormatBC2_RGBA_sRGB 133 MTLPixelFormatBC3_RGBA 134 MTLPixelFormatBC3_RGBA_sRGB 135 MTLPixelFormatBC4_RUnorm 140 MTLPixelFormatBC4_RSnorm 141 MTLPixelFormatBC5_RGUnorm 142 MTLPixelFormatBC5_RGSnorm 143 MTLPixelFormatBC6H_RGBFloat 150 MTLPixelFormatBC6H_RGBUfloat 151 MTLPixelFormatBC7_RGBAUnorm 152 MTLPixelFormatBC7_RGBAUnorm_sRGB 153 MTLPixelFormatPVRTC_RGB_2BPP 160 MTLPixelFormatPVRTC_RGB_2BPP_sRGB 161 MTLPixelFormatPVRTC_RGB_4BPP 162 MTLPixelFormatPVRTC_RGB_4BPP_sRGB 163 MTLPixelFormatPVRTC_RGBA_2BPP 164 MTLPixelFormatPVRTC_RGBA_2BPP_sRGB 165 MTLPixelFormatPVRTC_RGBA_4BPP 166 MTLPixelFormatPVRTC_RGBA_4BPP_sRGB 167 MTLPixelFormatEAC_R11Unorm 170 MTLPixelFormatEAC_R11Snorm 172 MTLPixelFormatEAC_RG11Unorm 174 MTLPixelFormatEAC_RG11Snorm 176 MTLPixelFormatEAC_RGBA8 178 MTLPixelFormatEAC_RGBA8_sRGB 179 MTLPixelFormatETC2_RGB8 180 MTLPixelFormatETC2_RGB8_sRGB 181 MTLPixelFormatETC2_RGB8A1 182 MTLPixelFormatETC2_RGB8A1_sRGB 183 MTLPixelFormatASTC_4x4_sRGB 186 MTLPixelFormatASTC_5x4_sRGB 187 MTLPixelFormatASTC_5x5_sRGB 188 MTLPixelFormatASTC_6x5_sRGB 189 MTLPixelFormatASTC_6x6_sRGB 190 MTLPixelFormatASTC_8x5_sRGB 192 MTLPixelFormatASTC_8x6_sRGB 193 MTLPixelFormatASTC_8x8_sRGB 194 MTLPixelFormatASTC_10x5_sRGB 195 MTLPixelFormatASTC_10x6_sRGB 196 MTLPixelFormatASTC_10x8_sRGB 197 MTLPixelFormatASTC_10x10_sRGB 198 MTLPixelFormatASTC_12x10_sRGB 199 MTLPixelFormatASTC_12x12_sRGB 200 MTLPixelFormatASTC_4x4_LDR 204 MTLPixelFormatASTC_5x4_LDR 205 MTLPixelFormatASTC_5x5_LDR 206 MTLPixelFormatASTC_6x5_LDR 207 MTLPixelFormatASTC_6x6_LDR 208 MTLPixelFormatASTC_8x5_LDR 210 MTLPixelFormatASTC_8x6_LDR 211 MTLPixelFormatASTC_8x8_LDR 212 MTLPixelFormatASTC_10x5_LDR 213 MTLPixelFormatASTC_10x6_LDR 214 MTLPixelFormatASTC_10x8_LDR 215 MTLPixelFormatASTC_10x10_LDR 216 MTLPixelFormatASTC_12x10_LDR 217 MTLPixelFormatASTC_12x12_LDR 218 MTLPixelFormatGBGR422 240 MTLPixelFormatBGRG422 241 MTLPixelFormatDepth16Unorm 250 MTLPixelFormatDepth32Float 252 MTLPixelFormatStencil8 253 MTLPixelFormatDepth24Unorm_Stencil8 255 MTLPixelFormatDepth32Float_Stencil8 260 MTLPixelFormatX32_Stencil8 261 MTLPixelFormatX24_Stencil8 262","title":"enum MTLPixelFormat"},{"location":"api/Namespaces/namespacengfx/#enum-mtlindextype","text":"Enumerator Value Description MTLIndexTypeUInt16 0 MTLIndexTypeUInt32 1","title":"enum MTLIndexType"},{"location":"api/Namespaces/namespacengfx/#enum-mtltexturetype","text":"Enumerator Value Description MTLTextureType1D 0 MTLTextureType1DArray 1 MTLTextureType2D 2 MTLTextureType2DArray 3 MTLTextureType2DMultisample 4 MTLTextureTypeCube 5 MTLTextureTypeCubeArray 6 MTLTextureType3D 7 MTLTextureType2DMultisampleArray 8 MTLTextureTypeTextureBuffer 9","title":"enum MTLTextureType"},{"location":"api/Namespaces/namespacengfx/#enum-mtlvertexformat","text":"Enumerator Value Description MTLVertexFormatInvalid 0 MTLVertexFormatUChar2 1 MTLVertexFormatUChar3 2 MTLVertexFormatUChar4 3 MTLVertexFormatChar2 4 MTLVertexFormatChar3 5 MTLVertexFormatChar4 6 MTLVertexFormatUChar2Normalized 7 MTLVertexFormatUChar3Normalized 8 MTLVertexFormatUChar4Normalized 9 MTLVertexFormatChar2Normalized 10 MTLVertexFormatChar3Normalized 11 MTLVertexFormatChar4Normalized 12 MTLVertexFormatUShort2 13 MTLVertexFormatUShort3 14 MTLVertexFormatUShort4 15 MTLVertexFormatShort2 16 MTLVertexFormatShort3 17 MTLVertexFormatShort4 18 MTLVertexFormatUShort2Normalized 19 MTLVertexFormatUShort3Normalized 20 MTLVertexFormatUShort4Normalized 21 MTLVertexFormatShort2Normalized 22 MTLVertexFormatShort3Normalized 23 MTLVertexFormatShort4Normalized 24 MTLVertexFormatHalf2 25 MTLVertexFormatHalf3 26 MTLVertexFormatHalf4 27 MTLVertexFormatFloat 28 MTLVertexFormatFloat2 29 MTLVertexFormatFloat3 30 MTLVertexFormatFloat4 31 MTLVertexFormatInt 32 MTLVertexFormatInt2 33 MTLVertexFormatInt3 34 MTLVertexFormatInt4 35 MTLVertexFormatUInt 36 MTLVertexFormatUInt2 37 MTLVertexFormatUInt3 38 MTLVertexFormatUInt4 39 MTLVertexFormatInt1010102Normalized 40 MTLVertexFormatUInt1010102Normalized 41","title":"enum MTLVertexFormat"},{"location":"api/Namespaces/namespacengfx/#enum-primitivetopology_2","text":"Enumerator Value Description PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP PRIMITIVE_TOPOLOGY_POINT_LIST D3D_PRIMITIVE_TOPOLOGY_POINTLIST PRIMITIVE_TOPOLOGY_LINE_LIST D3D_PRIMITIVE_TOPOLOGY_LINELIST PRIMITIVE_TOPOLOGY_LINE_STRIP D3D_PRIMITIVE_TOPOLOGY_LINESTRIP PRIMITIVE_TOPOLOGY_TRIANGLE_LIST D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum PrimitiveTopology"},{"location":"api/Namespaces/namespacengfx/#enum-polygonmode_2","text":"Enumerator Value Description POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME POLYGON_MODE_FILL D3D12_FILL_MODE_SOLID POLYGON_MODE_LINE D3D12_FILL_MODE_WIREFRAME VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum PolygonMode"},{"location":"api/Namespaces/namespacengfx/#enum-blendfactor_2","text":"Enumerator Value Description BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_ZERO D3D12_BLEND_ZERO BLEND_FACTOR_ONE D3D12_BLEND_ONE BLEND_FACTOR_SRC_COLOR D3D12_BLEND_SRC_COLOR BLEND_FACTOR_ONE_MINUS_SRC_COLOR D3D12_BLEND_INV_SRC_COLOR BLEND_FACTOR_DST_COLOR D3D12_BLEND_DEST_COLOR BLEND_FACTOR_ONE_MINUS_DST_COLOR D3D12_BLEND_INV_DEST_COLOR BLEND_FACTOR_SRC_ALPHA D3D12_BLEND_SRC_ALPHA BLEND_FACTOR_ONE_MINUS_SRC_ALPHA D3D12_BLEND_INV_SRC_ALPHA BLEND_FACTOR_DST_ALPHA D3D12_BLEND_DEST_ALPHA BLEND_FACTOR_ONE_MINUS_DST_ALPHA D3D12_BLEND_INV_DEST_ALPHA BLEND_FACTOR_CONSTANT_COLOR D3D12_BLEND_BLEND_FACTOR BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR D3D12_BLEND_INV_BLEND_FACTOR BLEND_FACTOR_CONSTANT_ALPHA MTLBlendFactorBlendAlpha BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA MTLBlendFactorOneMinusBlendAlpha BLEND_FACTOR_SRC_ALPHA_SATURATE MTLBlendFactorSourceAlphaSaturated VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum BlendFactor"},{"location":"api/Namespaces/namespacengfx/#enum-blendop_2","text":"Enumerator Value Description BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX BLEND_OP_ADD D3D12_BLEND_OP_ADD BLEND_OP_SUBTRACT D3D12_BLEND_OP_SUBTRACT BLEND_OP_REVERSE_SUBTRACT D3D12_BLEND_OP_REV_SUBTRACT BLEND_OP_MIN D3D12_BLEND_OP_MIN BLEND_OP_MAX D3D12_BLEND_OP_MAX VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum BlendOp"},{"location":"api/Namespaces/namespacengfx/#enum-bufferusageflagbits_2","text":"Enumerator Value Description BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 BUFFER_USAGE_TRANSFER_SRC_BIT 1 BUFFER_USAGE_TRANSFER_DST_BIT 2 BUFFER_USAGE_UNIFORM_BUFFER_BIT 4 BUFFER_USAGE_STORAGE_BUFFER_BIT 8 BUFFER_USAGE_VERTEX_BUFFER_BIT 16 BUFFER_USAGE_INDEX_BUFFER_BIT 32 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum BufferUsageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-colorcomponentflagbits_2","text":"Enumerator Value Description COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA COLOR_COMPONENT_R_BIT D3D12_COLOR_WRITE_ENABLE_RED COLOR_COMPONENT_G_BIT D3D12_COLOR_WRITE_ENABLE_GREEN COLOR_COMPONENT_B_BIT D3D12_COLOR_WRITE_ENABLE_BLUE COLOR_COMPONENT_A_BIT D3D12_COLOR_WRITE_ENABLE_ALPHA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum ColorComponentFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-commandbufferlevel_2","text":"Enumerator Value Description COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE COMMAND_BUFFER_LEVEL_PRIMARY D3D12_COMMAND_LIST_TYPE_DIRECT COMMAND_BUFFER_LEVEL_SECONDARY D3D12_COMMAND_LIST_TYPE_BUNDLE VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum CommandBufferLevel"},{"location":"api/Namespaces/namespacengfx/#enum-cullmodeflags_2","text":"Enumerator Value Description CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK CULL_MODE_NONE D3D12_CULL_MODE_NONE CULL_MODE_FRONT_BIT D3D12_CULL_MODE_FRONT CULL_MODE_BACK_BIT D3D12_CULL_MODE_BACK VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum CullModeFlags"},{"location":"api/Namespaces/namespacengfx/#enum-fencecreateflagbits_1","text":"Enumerator Value Description FENCE_CREATE_SIGNALED_BIT VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum FenceCreateFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-frontface_2","text":"Enumerator Value Description FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise FRONT_FACE_COUNTER_CLOCKWISE MTLWindingCounterClockwise FRONT_FACE_CLOCKWISE MTLWindingClockwise VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum FrontFace"},{"location":"api/Namespaces/namespacengfx/#enum-texturetype_2","text":"Enumerator Value Description TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY TEXTURE_TYPE_2D D3D12_SRV_DIMENSION_TEXTURE2D TEXTURE_TYPE_3D D3D12_SRV_DIMENSION_TEXTURE3D TEXTURE_TYPE_CUBE D3D12_SRV_DIMENSION_TEXTURECUBE TEXTURE_TYPE_2D_ARRAY D3D12_SRV_DIMENSION_TEXTURE2DARRAY","title":"enum TextureType"},{"location":"api/Namespaces/namespacengfx/#enum-imageusageflagbits_2","text":"Enumerator Value Description IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 IMAGE_USAGE_TRANSFER_SRC_BIT 1 IMAGE_USAGE_TRANSFER_DST_BIT 2 IMAGE_USAGE_SAMPLED_BIT 4 IMAGE_USAGE_STORAGE_BIT 8 IMAGE_USAGE_COLOR_ATTACHMENT_BIT 16 IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT 32 IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 64 IMAGE_USAGE_INPUT_ATTACHMENT_BIT 128 VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum ImageUsageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-pipelinestageflagbits_2","text":"Enumerator Value Description PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum PipelineStageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-shaderstageflagbits_2","text":"Enumerator Value Description SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF SHADER_STAGE_VERTEX_BIT 1 SHADER_STAGE_TESSELLATION_CONTROL_BIT 2 SHADER_STAGE_TESSELLATION_EVALUATION_BIT 4 SHADER_STAGE_GEOMETRY_BIT 8 SHADER_STAGE_FRAGMENT_BIT 16 SHADER_STAGE_COMPUTE_BIT 32 SHADER_STAGE_ALL_GRAPHICS 64 SHADER_STAGE_ALL 0xFF VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum ShaderStageFlagBits"},{"location":"api/Namespaces/namespacengfx/#enum-pixelformat_2","text":"Enumerator Value Description PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_UNDEFINED DXGI_FORMAT_UNKNOWN DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) DEFINE_PIXELFORMATS =(8, UNORM, UNORM) PIXELFORMAT_BGRA8_UNORM DXGI_FORMAT_B8G8R8A8_UNORM PIXELFORMAT_D16_UNORM DXGI_FORMAT_D16_UNORM PIXELFORMAT_D24_UNORM DXGI_FORMAT_D24_UNORM_S8_UINT PIXELFORMAT_D24_UNORM_S8 DXGI_FORMAT_D24_UNORM_S8_UINT","title":"enum PixelFormat"},{"location":"api/Namespaces/namespacengfx/#enum-indexformat_2","text":"Enumerator Value Description INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT INDEXFORMAT_UINT16 DXGI_FORMAT_R16_UINT INDEXFORMAT_UINT32 DXGI_FORMAT_R32_UINT","title":"enum IndexFormat"},{"location":"api/Namespaces/namespacengfx/#enum-vertexformat_2","text":"Enumerator Value Description DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT) DEFINE_VERTEXFORMATS =(32, FLOAT, FLOAT)","title":"enum VertexFormat"},{"location":"api/Namespaces/namespacengfx/#enum-descriptortype_2","text":"Enumerator Value Description DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER DESCRIPTOR_TYPE_STORAGE_IMAGE DESCRIPTOR_TYPE_UNIFORM_BUFFER DESCRIPTOR_TYPE_STORAGE_BUFFER VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum DescriptorType"},{"location":"api/Namespaces/namespacengfx/#enum-vertexinputrate_2","text":"Enumerator Value Description VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VERTEX_INPUT_RATE_VERTEX D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA VERTEX_INPUT_RATE_INSTANCE D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum VertexInputRate"},{"location":"api/Namespaces/namespacengfx/#enum-filtermode_2","text":"Enumerator Value Description FILTER_NEAREST FILTER_LINEAR FILTER_NEAREST FILTER_LINEAR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST)","title":"enum FilterMode"},{"location":"api/Namespaces/namespacengfx/#enum-imagelayout_2","text":"Enumerator Value Description IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR IMAGE_LAYOUT_UNDEFINED IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL IMAGE_LAYOUT_GENERAL IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) VK =(PRIMITIVE_TOPOLOGY_POINT_LIST) IMAGE_LAYOUT_PRESENT_SRC VK_IMAGE_LAYOUT_PRESENT_SRC_KHR","title":"enum ImageLayout"},{"location":"api/Namespaces/namespacengfx/#enum-keycode_2","text":"Enumerator Value Description KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) GLFW =(KEY_UP) KEY_UP VK_UP KEY_DOWN VK_DOWN KEY_LEFT VK_LEFT KEY_RIGHT VK_RIGHT","title":"enum KeyCode"},{"location":"api/Namespaces/namespacengfx/#enum-inputaction_2","text":"Enumerator Value Description RELEASE PRESS GLFW =(KEY_UP) GLFW =(KEY_UP) RELEASE PRESS","title":"enum InputAction"},{"location":"api/Namespaces/namespacengfx/#enum-mousebutton_2","text":"Enumerator Value Description MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT GLFW =(KEY_UP) GLFW =(KEY_UP) MOUSE_BUTTON_LEFT MOUSE_BUTTON_MIDDLE MOUSE_BUTTON_RIGHT","title":"enum MouseButton"},{"location":"api/Namespaces/namespacengfx/#typedef-flags","text":"typedef uint32_t ngfx::Flags;","title":"typedef Flags"},{"location":"api/Namespaces/namespacengfx/#typedef-pipelinestageflags","text":"typedef Flags ngfx::PipelineStageFlags;","title":"typedef PipelineStageFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-shaderstageflags","text":"typedef Flags ngfx::ShaderStageFlags;","title":"typedef ShaderStageFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-fencecreateflags","text":"typedef Flags ngfx::FenceCreateFlags;","title":"typedef FenceCreateFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-imageusageflags","text":"typedef Flags ngfx::ImageUsageFlags;","title":"typedef ImageUsageFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-colorcomponentflags","text":"typedef Flags ngfx::ColorComponentFlags;","title":"typedef ColorComponentFlags"},{"location":"api/Namespaces/namespacengfx/#typedef-bufferusageflags","text":"typedef Flags ngfx::BufferUsageFlags;","title":"typedef BufferUsageFlags"},{"location":"api/Namespaces/namespacengfx/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Namespaces/namespacengfx/#function-createvertexbuffer","text":"static Buffer * createVertexBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The size of input data (in bytes) Create a vertex buffer","title":"function createVertexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createvertexbuffer_1","text":"template <typename T > static inline Buffer * createVertexBuffer( GraphicsContext * ctx, const std::vector< T > & v ) Parameters : ctx The graphics context v The buffer data Create a vertex buffer","title":"function createVertexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createindexbuffer","text":"static Buffer * createIndexBuffer( GraphicsContext * ctx, const void * data, uint32_t size, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) stride The stride of the input data (in bytes) Create an index buffer","title":"function createIndexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createindexbuffer_1","text":"template <typename T > static inline Buffer * createIndexBuffer( GraphicsContext * ctx, const std::vector< T > & v, uint32_t stride =sizeof(uint32_t) ) Parameters : ctx The graphics context v The buffer data stride The stride of the input data (in bytes) Create an index buffer","title":"function createIndexBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createuniformbuffer","text":"static Buffer * createUniformBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a uniform buffer","title":"function createUniformBuffer"},{"location":"api/Namespaces/namespacengfx/#function-createstoragebuffer","text":"static Buffer * createStorageBuffer( GraphicsContext * ctx, const void * data, uint32_t size ) Parameters : ctx The graphics context data The buffer data size The buffer size (in bytes) Create a storage buffer","title":"function createStorageBuffer"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast","text":"D3D_CAST( Buffer )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d","text":"inline D3DCommandList * d3d( CommandBuffer * g )","title":"function d3d"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_1","text":"D3D_CAST( ComputePipeline )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_2","text":"D3D_CAST( Device )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_3","text":"D3D_CAST( Fence )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_4","text":"D3D_CAST( Framebuffer )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_5","text":"D3D_CAST( Graphics )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_6","text":"D3D_CAST( GraphicsContext )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_7","text":"D3D_CAST( GraphicsPipeline )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_8","text":"D3D_CAST( RenderPass )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_9","text":"D3D_CAST( ShaderModule )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_10","text":"D3D_CAST( VertexShaderModule )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_11","text":"D3D_CAST( FragmentShaderModule )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_12","text":"D3D_CAST( ComputeShaderModule )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_13","text":"D3D_CAST( Surface )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_14","text":"D3D_CAST( Texture )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-d3d_cast_15","text":"D3D_CAST( Window )","title":"function D3D_CAST"},{"location":"api/Namespaces/namespacengfx/#function-glfw","text":"inline GLFWWindow * glfw( Window * window )","title":"function glfw"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast","text":"MTL_CAST( Buffer )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_1","text":"MTL_CAST( CommandBuffer )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_2","text":"MTL_CAST( ComputePipeline )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_3","text":"MTL_CAST( Device )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_4","text":"MTL_CAST( Framebuffer )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_5","text":"MTL_CAST( Graphics )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_6","text":"MTL_CAST( GraphicsContext )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_7","text":"MTL_CAST( GraphicsPipeline )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_8","text":"MTL_CAST( RenderPass )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_9","text":"MTL_CAST( ShaderModule )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_10","text":"MTL_CAST( VertexShaderModule )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_11","text":"MTL_CAST( FragmentShaderModule )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_12","text":"MTL_CAST( ComputeShaderModule )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_13","text":"MTL_CAST( Surface )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_14","text":"MTL_CAST( Texture )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-mtl_cast_15","text":"MTL_CAST( Window )","title":"function MTL_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast","text":"VK_CAST( Buffer )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_1","text":"VK_CAST( CommandBuffer )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_2","text":"VK_CAST( ComputePipeline )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_3","text":"VK_CAST( Device )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_4","text":"VK_CAST( Fence )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_5","text":"VK_CAST( Framebuffer )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_6","text":"VK_CAST( Graphics )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk","text":"inline VKGraphicsContext * vk( GraphicsContext * g )","title":"function vk"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_7","text":"VK_CAST( GraphicsPipeline )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-operator","text":"static bool operator==( const VKImageViewCreateInfo & lhs, const VKImageViewCreateInfo & rhs )","title":"function operator=="},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_8","text":"VK_CAST( Queue )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_9","text":"VK_CAST( RenderPass )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_10","text":"VK_CAST( Semaphore )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_11","text":"VK_CAST( ShaderModule )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_12","text":"VK_CAST( VertexShaderModule )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_13","text":"VK_CAST( FragmentShaderModule )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_14","text":"VK_CAST( ComputeShaderModule )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_15","text":"VK_CAST( Surface )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_16","text":"VK_CAST( Swapchain )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_17","text":"VK_CAST( Texture )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-vk_cast_18","text":"VK_CAST( Window )","title":"function VK_CAST"},{"location":"api/Namespaces/namespacengfx/#function-w","text":"inline WWindow * w( Window * window ) Updated on 3 April 2021 at 20:21:51 PDT","title":"function w"},{"location":"api/Namespaces/namespacestd/","text":"std Updated on 3 April 2021 at 20:21:51 PDT","title":"std"},{"location":"api/Namespaces/namespacestd/#std","text":"Updated on 3 April 2021 at 20:21:51 PDT","title":"std"},{"location":"api/Namespaces/namespacestd_1_1chrono/","text":"std::chrono Updated on 3 April 2021 at 20:21:51 PDT","title":"std::chrono"},{"location":"api/Namespaces/namespacestd_1_1chrono/#stdchrono","text":"Updated on 3 April 2021 at 20:21:51 PDT","title":"std::chrono"},{"location":"api/Namespaces/namespacestd_1_1placeholders/","text":"std::placeholders Updated on 3 April 2021 at 20:21:51 PDT","title":"std::placeholders"},{"location":"api/Namespaces/namespacestd_1_1placeholders/#stdplaceholders","text":"Updated on 3 April 2021 at 20:21:51 PDT","title":"std::placeholders"},{"location":"api/Pages/","text":"Pages Updated on 3 April 2021 at 20:21:52 PDT","title":"Pages"},{"location":"api/Pages/#pages","text":"Updated on 3 April 2021 at 20:21:52 PDT","title":"Pages"}]}