
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.0.6">
    
    
      
        <title>src/ngfx/graphics/ShaderTools.cpp - NGFX API Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.2c0c5eaf.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.7fa14f5b.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#srcngfxgraphicsshadertoolscpp" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="NGFX API Documentation" class="md-header__button md-logo" aria-label="NGFX API Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            NGFX API Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              src/ngfx/graphics/ShaderTools.cpp
            
          </span>
        </div>
      </div>
    </div>
    <div class="md-header__options">
      
    </div>
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="NGFX API Documentation" class="md-nav__button md-logo" aria-label="NGFX API Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    NGFX API Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="/docs" class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="/api/Classes" class="md-nav__link">
        Classes
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="/api/Namespaces" class="md-nav__link">
        Namespaces
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="/api/Modules" class="md-nav__link">
        Modules
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="/api/Files" class="md-nav__link">
        Files
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="/api/Pages" class="md-nav__link">
        Related Pages
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="/api/Examples" class="md-nav__link">
        Examples
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#attributes" class="md-nav__link">
    Attributes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#defines" class="md-nav__link">
    Defines
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions-documentation" class="md-nav__link">
    Functions Documentation
  </a>
  
    <nav class="md-nav" aria-label="Functions Documentation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#function-getenv" class="md-nav__link">
    function getEnv
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function-getentry" class="md-nav__link">
    function getEntry
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function-toshaderkind" class="md-nav__link">
    function toShaderKind
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#attributes-documentation" class="md-nav__link">
    Attributes Documentation
  </a>
  
    <nav class="md-nav" aria-label="Attributes Documentation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#variable-readfile" class="md-nav__link">
    variable readFile
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#variable-writefile" class="md-nav__link">
    variable writeFile
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#variable-tolower" class="md-nav__link">
    variable toLower
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#macro-documentation" class="md-nav__link">
    Macro Documentation
  </a>
  
    <nav class="md-nav" aria-label="Macro Documentation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#define-v" class="md-nav__link">
    define V
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#define-patch" class="md-nav__link">
    define PATCH
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#source-code" class="md-nav__link">
    Source code
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="srcngfxgraphicsshadertoolscpp">src/ngfx/graphics/ShaderTools.cpp</h1>
<h2 id="functions">Functions</h2>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td><strong><a href="/api/Files/ShaderTools_8cpp/#function-getenv">getEnv</a></strong>(const string &amp; name)</td>
</tr>
<tr>
<td>json *</td>
<td><strong><a href="/api/Files/ShaderTools_8cpp/#function-getentry">getEntry</a></strong>(const json &amp; data, const string &amp; key)</td>
</tr>
<tr>
<td>shaderc_shader_kind</td>
<td><strong><a href="/api/Files/ShaderTools_8cpp/#function-toshaderkind">toShaderKind</a></strong>(const string &amp; ext)</td>
</tr>
</tbody>
</table>
<h2 id="attributes">Attributes</h2>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td><strong><a href="/api/Files/ShaderTools_8cpp/#variable-readfile">readFile</a></strong></td>
</tr>
<tr>
<td>auto</td>
<td><strong><a href="/api/Files/ShaderTools_8cpp/#variable-writefile">writeFile</a></strong></td>
</tr>
<tr>
<td>auto</td>
<td><strong><a href="/api/Files/ShaderTools_8cpp/#variable-tolower">toLower</a></strong></td>
</tr>
</tbody>
</table>
<h2 id="defines">Defines</h2>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong><a href="/api/Files/ShaderTools_8cpp/#define-v">V</a></strong>(func)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="/api/Files/ShaderTools_8cpp/#define-patch">PATCH</a></strong></td>
</tr>
</tbody>
</table>
<h2 id="functions-documentation">Functions Documentation</h2>
<h3 id="function-getenv">function getEnv</h3>
<pre><code class="language-cpp">static string getEnv(
    const string &amp; name
)
</code></pre>
<h3 id="function-getentry">function getEntry</h3>
<pre><code class="language-cpp">static json * getEntry(
    const json &amp; data,
    const string &amp; key
)
</code></pre>
<h3 id="function-toshaderkind">function toShaderKind</h3>
<pre><code class="language-cpp">static shaderc_shader_kind toShaderKind(
    const string &amp; ext
)
</code></pre>
<h2 id="attributes-documentation">Attributes Documentation</h2>
<h3 id="variable-readfile">variable readFile</h3>
<pre><code class="language-cpp">auto readFile = FileUtil::readFile;
</code></pre>
<h3 id="variable-writefile">variable writeFile</h3>
<pre><code class="language-cpp">auto writeFile = FileUtil::writeFile;
</code></pre>
<h3 id="variable-tolower">variable toLower</h3>
<pre><code class="language-cpp">auto toLower = StringUtil::toLower;
</code></pre>
<h2 id="macro-documentation">Macro Documentation</h2>
<h3 id="define-v">define V</h3>
<pre><code class="language-cpp">#define V(
    func
)
  {                                                                            \
    ret = func;                                                                \
    if (ret != 0)                                                              \
      return ret;                                                              \
  }
</code></pre>
<h3 id="define-patch">define PATCH</h3>
<pre><code class="language-cpp">#define PATCH string(&quot;patch&quot;)
</code></pre>
<h2 id="source-code">Source code</h2>
<pre><code class="language-cpp">/*
 * Copyright 2020 GoPro Inc.
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include &quot;ShaderTools.h&quot;
#include &quot;ngfx/core/DebugUtil.h&quot;
#include &quot;ngfx/core/FileUtil.h&quot;
#include &quot;ngfx/core/StringUtil.h&quot;
#include &lt;cctype&gt;
#include &lt;filesystem&gt;
#include &lt;fstream&gt;
#include &lt;regex&gt;
#include &lt;set&gt;
#include &lt;spirv_cross/spirv_glsl.hpp&gt;
#include &lt;spirv_cross/spirv_hlsl.hpp&gt;
#include &lt;spirv_cross/spirv_msl.hpp&gt;
#include &lt;spirv_cross/spirv_reflect.hpp&gt;
#include &lt;sstream&gt;
using namespace std;
using namespace ngfx;
auto readFile = FileUtil::readFile;
auto writeFile = FileUtil::writeFile;
auto toLower = StringUtil::toLower;
namespace fs = std::filesystem;
#define V(func)                                                                \
  {                                                                            \
    ret = func;                                                                \
    if (ret != 0)                                                              \
      return ret;                                                              \
  }

#ifdef _WIN32
#define PATCH string(&quot;patch.exe&quot;)
#else
#define PATCH string(&quot;patch&quot;)
#endif

static string getEnv(const string &amp;name) {
  char *value = getenv(name.c_str());
  return (value ? value : &quot;&quot;);
}
static json *getEntry(const json &amp;data, const string &amp;key) {
  auto it = data.find(key);
  if (it == data.end())
    return nullptr;
  return (json *)&amp;it.value();
}
ShaderTools::ShaderTools(bool verbose) : verbose(verbose) {
  defaultIncludePaths = {&quot;ngfx/data/shaders&quot;, &quot;nodegl/data/shaders&quot;};
}

int ShaderTools::cmd(string str) {
  if (verbose) {
    NGFX_LOG(&quot;&gt;&gt; %s&quot;, str.c_str());
  } else
    str += &quot; &gt;&gt; /dev/null 2&gt;&amp;1&quot;;
  return system(str.c_str());
}

bool ShaderTools::findIncludeFile(const string &amp;includeFilename,
                                  const vector&lt;string&gt; &amp;includePaths,
                                  string &amp;includeFile) {
  for (const string &amp;includePath : includePaths) {
    fs::path filename = includePath / fs::path(includeFilename);
    if (fs::exists(filename)) {
      includeFile = filename.string();
      return true;
    }
  }
  return false;
}

int ShaderTools::preprocess(const string &amp;src, const string &amp;dataPath,
                            string &amp;dst) {
  dst = &quot;&quot;;
  vector&lt;string&gt; includePaths = defaultIncludePaths;
  includePaths.push_back(dataPath);
  istringstream sstream(src);
  string line;
  while (std::getline(sstream, line)) {
    smatch matchIncludeGroups;
    bool matchInclude =
        regex_search(line, matchIncludeGroups, regex(&quot;#include \&quot;([^\&quot;]*)&quot;));
    if (matchInclude) {
      string includeFilename = matchIncludeGroups[1];
      string includeFilePath;
      findIncludeFile(includeFilename, includePaths, includeFilePath);
      dst += readFile(includeFilePath);
    } else {
      dst += line + &quot;\n&quot;;
    }
  }
  return 0;
}

int ShaderTools::compileShaderGLSL(
    const string &amp;src, shaderc_shader_kind shaderKind,
    const MacroDefinitions &amp;defines, string &amp;spv, bool verbose,
    shaderc_optimization_level optimizationLevel) {
  shaderc::Compiler compiler;
  shaderc::CompileOptions compileOptions;
  for (const MacroDefinition &amp;define : defines) {
    compileOptions.AddMacroDefinition(define.name, define.value);
  }
  compileOptions.SetOptimizationLevel(optimizationLevel);
  compileOptions.SetGenerateDebugInfo();

  auto result = compiler.CompileGlslToSpv(src, shaderKind, &quot;&quot;, compileOptions);
  if (result.GetCompilationStatus() != shaderc_compilation_status_success) {
    NGFX_ERR(&quot;cannot compile file: %s&quot;, result.GetErrorMessage().c_str());
    return 1;
  }
  spv = string((const char *)result.cbegin(),
               sizeof(uint32_t) * (result.cend() - result.cbegin()));
  return 0;
}

int ShaderTools::removeUnusedVariablesGLSL(const std::string &amp;src,
                                           shaderc_shader_kind shaderKind,
                                           const MacroDefinitions &amp;defines,
                                           std::string &amp;dst) {
  int ret = 0;
  string spv;
  V(compileShaderGLSL(src, shaderKind, defines, spv, false));
  spirv_cross::CompilerGLSL compilerGLSL((const uint32_t *)spv.data(),
                                         spv.size() / sizeof(uint32_t));
  auto activeVariables = compilerGLSL.get_active_interface_variables();
  compilerGLSL.get_shader_resources(activeVariables);
  compilerGLSL.set_enabled_interface_variables(move(activeVariables));
  spirv_cross::CompilerGLSL::Options opts;
  opts.vulkan_semantics = true;
  compilerGLSL.set_common_options(opts);
  dst = compilerGLSL.compile();
  return 0;
}

int ShaderTools::patchShaderLayoutsGLSL(const string &amp;src, string &amp;dst) {
  dst = &quot;&quot;;
  istringstream sstream(src);
  string line;
  while (std::getline(sstream, line)) {
    // Patch GLSL shader layouts
    smatch g;

    bool matchLayout = regex_search(line, g,
                                    regex(&quot;^(.*)&quot;
                                          &quot;layout\\s*\\(&quot;
                                          &quot;([^)]*)&quot;
                                          &quot;binding[\\s]*=[\\s]*&quot;
                                          &quot;([\\d]+)&quot;
                                          &quot;([^)]*)&quot;
                                          &quot;\\)&quot;
                                          &quot;(.*)\r*$&quot;));
    if (matchLayout) {
      dst += g[1].str() + &quot;layout(&quot; + g[2].str() + &quot;set = &quot; + g[3].str() +
             &quot;, binding = 0&quot; + g[4].str() + &quot;)&quot; + g[5].str() + &quot;\n&quot;;
    } else {
      dst += line + &quot;\n&quot;;
    }
  }
  return 0;
}

static shaderc_shader_kind toShaderKind(const string &amp;ext) {
  static const map&lt;string, shaderc_shader_kind&gt; shaderKindMap = {
      {&quot;.vert&quot;, shaderc_vertex_shader},
      {&quot;.frag&quot;, shaderc_fragment_shader},
      {&quot;.comp&quot;, shaderc_compute_shader}};
  return shaderKindMap.at(ext);
}
int ShaderTools::compileShaderGLSL(string filename,
                                   const MacroDefinitions &amp;defines,
                                   const string &amp;outDir,
                                   vector&lt;string&gt; &amp;outFiles, int flags) {
  string parentPath = fs::path(filename).parent_path().string();
  filename = fs::path(filename).filename().string();
  string inFileName =
      fs::path(parentPath + &quot;/&quot; + filename).make_preferred().string();
  string outFileName =
      fs::path(outDir + &quot;/&quot; + filename + &quot;.spv&quot;).make_preferred().string();
  if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) {
    outFiles.push_back(outFileName);
    return 0;
  }
  string src, dst;
  int ret = 0;

  src = FileUtil::readFile(inFileName);
  string ext = FileUtil::splitExt(inFileName)[1];
  shaderc_shader_kind shaderKind = toShaderKind(ext);
  if (flags &amp; REMOVE_UNUSED_VARIABLES) {
    V(removeUnusedVariablesGLSL(src, shaderKind, defines, dst));
    src = move(dst);
  }
  if (flags &amp; PATCH_SHADER_LAYOUTS_GLSL) {
    V(patchShaderLayoutsGLSL(src, dst));
    src = move(dst);
  }
  V(compileShaderGLSL(src, shaderKind, defines, dst));
  writeFile(outFileName, dst);
  outFiles.push_back(outFileName);
  return 0;
}

int ShaderTools::compileShaderMSL(const string &amp;file,
                                  const MacroDefinitions &amp;defines,
                                  string outDir, vector&lt;string&gt; &amp;outFiles) {
  string strippedFilename =
      FileUtil::splitExt(fs::path(file).filename().string())[0];
  string inFileName = fs::path(outDir + &quot;/&quot; + strippedFilename + &quot;.metal&quot;)
                          .make_preferred()
                          .string();
  string outFileName = fs::path(outDir + &quot;/&quot; + strippedFilename + &quot;.metallib&quot;)
                           .make_preferred()
                           .string();
  if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) {
    outFiles.push_back(outFileName);
    return 0;
  }

  string debugFlags = &quot;-gline-tables-only -MO&quot;;
  int result = cmd(&quot;xcrun -sdk macosx metal &quot; + debugFlags + &quot; -c &quot; +
                   inFileName + &quot; -o &quot; + outDir + &quot;/&quot; + strippedFilename +
                   &quot;.air &amp;&amp; &quot;
                   &quot;xcrun -sdk macosx metallib &quot; +
                   outDir + &quot;/&quot; + strippedFilename + &quot;.air -o &quot; + outFileName);
  if (result == 0)
    NGFX_LOG(&quot;compiled file: %s&quot;, file.c_str());
  else
    NGFX_ERR(&quot;cannot compile file: %s&quot;, file.c_str());
  outFiles.push_back(outFileName);
  return result;
}

int ShaderTools::compileShaderHLSL(const string &amp;file,
                                   const MacroDefinitions &amp;defines,
                                   string outDir, vector&lt;string&gt; &amp;outFiles) {
  string strippedFilename =
      FileUtil::splitExt(fs::path(file).filename().string())[0];
  string inFileName = fs::path(outDir + &quot;/&quot; + strippedFilename + &quot;.hlsl&quot;)
                          .make_preferred()
                          .string();
  string outFileName = fs::path(outDir + &quot;/&quot; + strippedFilename + &quot;.dxc&quot;)
                           .make_preferred()
                           .string();
  if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) {
    outFiles.push_back(outFileName);
    return 0;
  }

  string shaderModel = &quot;&quot;;
  if (strstr(inFileName.c_str(), &quot;.vert&quot;))
    shaderModel = &quot;vs_5_0&quot;;
  else if (strstr(inFileName.c_str(), &quot;.frag&quot;))
    shaderModel = &quot;ps_5_0&quot;;
  else if (strstr(inFileName.c_str(), &quot;.comp&quot;))
    shaderModel = &quot;cs_5_0&quot;;
  int result = cmd(&quot;dxc.exe /T &quot; + shaderModel + &quot; /Fo &quot; + outFileName + &quot; &quot; +
                   inFileName);
  if (result == 0)
    NGFX_LOG(&quot;compiled file: %s&quot;, file.c_str());
  else
    NGFX_ERR(&quot;cannot compile file: %s&quot;, file.c_str());
  outFiles.push_back(outFileName);
  return result;
}

int ShaderTools::convertSPVToMSL(const string &amp;spv,
                                 shaderc_shader_kind shaderKind, string &amp;msl) {
  spirv_cross::CompilerMSL compilerMSL((const uint32_t *)spv.data(),
                                       spv.size() / sizeof(uint32_t));
  msl = compilerMSL.compile();
  return 0;
}

int ShaderTools::convertSPVToHLSL(const string &amp;spv,
                                  shaderc_shader_kind shaderKind, string &amp;hlsl,
                                  uint32_t shaderModel) {
  spirv_cross::CompilerHLSL compilerHLSL((const uint32_t *)spv.data(),
                                         spv.size() / sizeof(uint32_t));
  auto options = compilerHLSL.get_hlsl_options();
  options.shader_model = shaderModel;
  compilerHLSL.set_hlsl_options(options);
  hlsl = compilerHLSL.compile();
  return 0;
}

int ShaderTools::convertShader(const string &amp;file, const string &amp;extraArgs,
                               string outDir, Format fmt,
                               vector&lt;string&gt; &amp;outFiles) {
  auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string());
  string strippedFilename = splitFilename[0];
  string ext = FileUtil::splitExt(strippedFilename)[1];
  string inFileName = fs::path(outDir + &quot;/&quot; + strippedFilename + &quot;.spv&quot;)
                          .make_preferred()
                          .string();
  string outFileName = fs::path(outDir + &quot;/&quot; + strippedFilename +
                                (fmt == FORMAT_MSL ? &quot;.metal&quot; : &quot;.hlsl&quot;))
                           .make_preferred()
                           .string();
  if (!FileUtil::srcFileNewerThanOutFile(inFileName, outFileName)) {
    outFiles.push_back(outFileName);
    return 0;
  }
  string spv = FileUtil::readFile(inFileName), dst;
  int result;
  if (fmt == FORMAT_MSL) {
    result = convertSPVToMSL(spv, toShaderKind(ext), dst);
  } else {
    result = convertSPVToHLSL(spv, toShaderKind(ext), dst);
  }
  FileUtil::writeFile(outFileName, dst);
  string args =
      (fmt == FORMAT_MSL ? &quot;--msl&quot; : &quot;--hlsl --shader-model 60&quot;) + extraArgs;
  if (result == 0)
    NGFX_LOG(&quot;converted file: %s to %s&quot;, inFileName.c_str(),
             outFileName.c_str());
  else
    NGFX_ERR(&quot;cannot convert file: %s&quot;, file.c_str());
  outFiles.push_back(outFileName);
  return result;
}

bool ShaderTools::findMetalReflectData(
    const vector&lt;RegexUtil::Match&gt; &amp;metalReflectData, const string &amp;name,
    RegexUtil::Match &amp;match) {
  for (const RegexUtil::Match &amp;data : metalReflectData) {
    if (data.s[2] == name) {
      match = data;
      return true;
    } else if (strstr(data.s[1].c_str(), name.c_str())) {
      match = data;
      return true;
    }
  }
  return false;
}

int ShaderTools::patchShaderReflectionDataMSL(const std::string &amp;glslReflect,
                                              const std::string &amp;ext,
                                              const std::string &amp;msl,
                                              std::string &amp;mslReflect) {
  auto glslReflectJson = json::parse(glslReflect);
  MetalReflectData metalReflectData;
  if (ext == &quot;.vert&quot;) {
    metalReflectData.attributes =
        RegexUtil::findAll(regex(&quot;([^\\s]*)[\\s]*([^\\s]*)[\\s]*\\[\\[&quot;
                                 &quot;attribute\\(([0-9]+)\\)\\]\\]&quot;),
                           msl);
  }
  metalReflectData.buffers = RegexUtil::findAll(
      regex(&quot;([^\\s]*)[\\s]*([^\\s]*)[\\s]*\\[\\[buffer\\(([0-9]+)\\)\\]\\]&quot;),
      msl);
  metalReflectData.textures = RegexUtil::findAll(
      regex(&quot;([^\\s]*)[\\s]*([^\\s]*)[\\s]*\\[\\[texture\\(([0-9]+)\\)\\]\\]&quot;),
      msl);

  json *textures = getEntry(glslReflectJson, &quot;textures&quot;),
       *ubos = getEntry(glslReflectJson, &quot;ubos&quot;),
       *ssbos = getEntry(glslReflectJson, &quot;ssbos&quot;),
       *images = getEntry(glslReflectJson, &quot;images&quot;);
  uint32_t numDescriptors =
      (textures ? textures-&gt;size() : 0) + (images ? images-&gt;size() : 0) +
      (ubos ? ubos-&gt;size() : 0) + (ssbos ? ssbos-&gt;size() : 0);

  // update input bindings
  if (ext == &quot;.vert&quot;) {
    json *inputs = getEntry(glslReflectJson, &quot;inputs&quot;);
    for (json &amp;input : *inputs) {
      RegexUtil::Match metalInputReflectData;
      bool foundMatch = findMetalReflectData(
          metalReflectData.attributes, input[&quot;name&quot;], metalInputReflectData);
      if (!foundMatch) {
        return 1;
      }
      input[&quot;location&quot;] = stoi(metalInputReflectData.s[3]) + numDescriptors;
    }
  }

  // update descriptor bindings
  if (textures)
    for (json &amp;descriptor : *textures) {
      RegexUtil::Match metalTextureReflectData;
      bool foundMatch =
          findMetalReflectData(metalReflectData.textures, descriptor[&quot;name&quot;],
                               metalTextureReflectData);
      assert(foundMatch);
      descriptor[&quot;set&quot;] = stoi(metalTextureReflectData.s[3]);
    }
  if (ubos)
    for (json &amp;descriptor : *ubos) {
      RegexUtil::Match metalBufferReflectData;
      bool foundMatch = findMetalReflectData(
          metalReflectData.buffers, descriptor[&quot;name&quot;], metalBufferReflectData);
      assert(foundMatch);
      descriptor[&quot;set&quot;] = stoi(metalBufferReflectData.s[3]);
    }
  if (ssbos)
    for (json &amp;descriptor : *ssbos) {
      RegexUtil::Match metalBufferReflectData;
      bool foundMatch = findMetalReflectData(
          metalReflectData.buffers, descriptor[&quot;name&quot;], metalBufferReflectData);
      assert(foundMatch);
      descriptor[&quot;set&quot;] = stoi(metalBufferReflectData.s[3]);
    }
  if (images)
    for (json &amp;descriptor : *images) {
      RegexUtil::Match metalTextureReflectData;
      bool foundMatch =
          findMetalReflectData(metalReflectData.textures, descriptor[&quot;name&quot;],
                               metalTextureReflectData);
      assert(foundMatch);
      descriptor[&quot;set&quot;] = stoi(metalTextureReflectData.s[3]);
    }

  mslReflect = glslReflectJson.dump(4);
  return 0;
}

int ShaderTools::patchShaderReflectionDataHLSL(const std::string &amp;glslReflect,
                                               const std::string &amp;ext,
                                               const std::string &amp;hlsl,
                                               std::string &amp;hlslReflect) {
  auto glslReflectJson = json::parse(glslReflect);
  HLSLReflectData hlslReflectData;

  // parse semantics
  if (ext == &quot;.vert&quot;) {
    json *inputs = getEntry(glslReflectJson, &quot;inputs&quot;);
    for (json &amp;input : *inputs) {
      regex p(input[&quot;name&quot;].get&lt;string&gt;() + &quot;\\s*:\\s*([^;]*);&quot;);
      vector&lt;RegexUtil::Match&gt; hlslReflectData = RegexUtil::findAll(p, hlsl);
      input[&quot;semantic&quot;] = hlslReflectData[0].s[1];
    }
  }

  // get descriptors
  json *textures = getEntry(glslReflectJson, &quot;textures&quot;),
       *ubos = getEntry(glslReflectJson, &quot;ubos&quot;),
       *ssbos = getEntry(glslReflectJson, &quot;ssbos&quot;),
       *images = getEntry(glslReflectJson, &quot;images&quot;);
  map&lt;int, json *&gt; descriptors;
  if (textures)
    for (auto &amp;desc : *textures)
      descriptors[desc[&quot;set&quot;].get&lt;int&gt;()] = &amp;desc;
  if (ubos)
    for (auto &amp;desc : *ubos)
      descriptors[desc[&quot;set&quot;].get&lt;int&gt;()] = &amp;desc;
  if (ssbos)
    for (auto &amp;desc : *ssbos)
      descriptors[desc[&quot;set&quot;].get&lt;int&gt;()] = &amp;desc;
  if (images)
    for (auto &amp;desc : *images)
      descriptors[desc[&quot;set&quot;].get&lt;int&gt;()] = &amp;desc;

  // patch descriptor bindings
  set&lt;int&gt; sets;
  set&lt;string&gt; samplerTypes = {&quot;sampler2D&quot;, &quot;sampler3D&quot;, &quot;samplerCube&quot;};
  for (const auto &amp;kv : descriptors) {
    uint32_t set = kv.first;
    json &amp;desc = *kv.second;
    while (sets.find(set) != sets.end())
      set += 1;
    desc[&quot;set&quot;] = set;
    sets.insert(set);
    if (samplerTypes.find(desc[&quot;type&quot;]) != samplerTypes.end())
      sets.insert(set + 1);
  }
  hlslReflect = glslReflectJson.dump(4);
  return 0;
}

int ShaderTools::genShaderReflectionGLSL(const string &amp;, const string &amp;ext,
                                         const string &amp;spv, string &amp;glslMap) {
  spirv_cross::CompilerReflection compilerReflection(
      (const uint32_t *)spv.data(), spv.size() / sizeof(uint32_t));
  auto reflectOutput = compilerReflection.compile();
  glslMap = json::parse(reflectOutput).dump(4);
  return 0;
}

int ShaderTools::genShaderReflectionMSL(const string &amp;msl, const string &amp;ext,
                                        const string &amp;spv, string &amp;mslMap) {
  string glslReflect;
  genShaderReflectionGLSL(&quot;&quot;, ext, spv, glslReflect);
  return patchShaderReflectionDataMSL(glslReflect, ext, msl, mslMap);
}

int ShaderTools::genShaderReflectionHLSL(const string &amp;hlsl, const string &amp;ext,
                                         const string &amp;spv, string &amp;hlslMap) {
  string glslReflect;
  genShaderReflectionGLSL(&quot;&quot;, ext, spv, glslReflect);
  return patchShaderReflectionDataHLSL(glslReflect, ext, hlsl, hlslMap);
}

string ShaderTools::parseReflectionData(const json &amp;reflectData, string ext) {
  string contents = &quot;&quot;;
  if (ext == &quot;.vert&quot;) {
    json *inputs = getEntry(reflectData, &quot;inputs&quot;);
    contents += &quot;INPUT_ATTRIBUTES &quot; + to_string(inputs-&gt;size()) + &quot;\n&quot;;
    for (const json &amp;input : *inputs) {
      string inputName = input[&quot;name&quot;];
      string inputSemantic = &quot;&quot;;
      string inputNameLower = toLower(inputName);
      inputSemantic = &quot;UNDEFINED&quot;;
      if (input.find(&quot;semantic&quot;) != input.end())
        inputSemantic = input[&quot;semantic&quot;];
      map&lt;string, string&gt; inputTypeMap = {
          {&quot;float&quot;, &quot;VERTEXFORMAT_FLOAT&quot;}, {&quot;vec2&quot;, &quot;VERTEXFORMAT_FLOAT2&quot;},
          {&quot;vec3&quot;, &quot;VERTEXFORMAT_FLOAT3&quot;}, {&quot;vec4&quot;, &quot;VERTEXFORMAT_FLOAT4&quot;},
          {&quot;ivec2&quot;, &quot;VERTEXFORMAT_INT2&quot;},  {&quot;ivec3&quot;, &quot;VERTEXFORMAT_INT3&quot;},
          {&quot;ivec4&quot;, &quot;VERTEXFORMAT_INT4&quot;},  {&quot;mat2&quot;, &quot;VERTEXFORMAT_MAT2&quot;},
          {&quot;mat3&quot;, &quot;VERTEXFORMAT_MAT3&quot;},   {&quot;mat4&quot;, &quot;VERTEXFORMAT_MAT4&quot;}};
      string inputType = inputTypeMap[input[&quot;type&quot;]];
      contents += &quot;\t&quot; + inputName + &quot; &quot; + inputSemantic + &quot; &quot; +
                  to_string(input[&quot;location&quot;].get&lt;int&gt;()) + &quot; &quot; + inputType +
                  &quot;\n&quot;;
    }
  }
  json *textures = getEntry(reflectData, &quot;textures&quot;),
       *ubos = getEntry(reflectData, &quot;ubos&quot;),
       *ssbos = getEntry(reflectData, &quot;ssbos&quot;),
       *images = getEntry(reflectData, &quot;images&quot;),
       *types = getEntry(reflectData, &quot;types&quot;);
  json uniformBufferInfos;
  json shaderStorageBufferInfos;

  std::function&lt;void(const json &amp;, json &amp;, uint32_t, string)&gt; parseMembers =
      [&amp;](const json &amp;membersData, json &amp;members, uint32_t baseOffset = 0,
          string baseName = &quot;&quot;) {
        for (const json &amp;memberData : membersData) {
          const map&lt;string, int&gt; typeSizeMap = {
              {&quot;int&quot;, 4},    {&quot;uint&quot;, 4},  {&quot;float&quot;, 4},  {&quot;vec2&quot;, 8},
              {&quot;vec3&quot;, 12},  {&quot;vec4&quot;, 16}, {&quot;ivec2&quot;, 8},  {&quot;ivec3&quot;, 12},
              {&quot;ivec4&quot;, 16}, {&quot;uvec2&quot;, 8}, {&quot;uvec3&quot;, 12}, {&quot;uvec4&quot;, 16},
              {&quot;mat2&quot;, 16},  {&quot;mat3&quot;, 36}, {&quot;mat4&quot;, 64}};
          string memberType = memberData[&quot;type&quot;];
          if (typeSizeMap.find(memberType) != typeSizeMap.end()) {
            json member = memberData;
            member[&quot;name&quot;] = baseName + member[&quot;name&quot;].get&lt;string&gt;();
            member[&quot;size&quot;] = typeSizeMap.at(memberType);
            member[&quot;offset&quot;] = member[&quot;offset&quot;].get&lt;int&gt;() + baseOffset;
            member[&quot;array_count&quot;] = (member.find(&quot;array&quot;) != member.end())
                                        ? member[&quot;array&quot;][0].get&lt;int&gt;()
                                        : 0;
            member[&quot;array_stride&quot;] =
                (member.find(&quot;array_stride&quot;) != member.end())
                    ? member[&quot;array_stride&quot;].get&lt;int&gt;()
                    : 0;
            members.push_back(member);
          } else if (types-&gt;find(memberType) != types-&gt;end()) {
            const json &amp;type = (*types)[memberType];
            parseMembers(type[&quot;members&quot;], members,
                         baseOffset + memberData[&quot;offset&quot;].get&lt;int&gt;(),
                         baseName + memberData[&quot;name&quot;].get&lt;string&gt;() + &quot;.&quot;);
          } else
            NGFX_ERR(&quot;unrecognized type: {memberType}&quot;);
        }
      };

  auto parseBuffers = [&amp;](const json &amp;buffers, json &amp;bufferInfos) {
    for (const json &amp;buffer : buffers) {
      const json &amp;bufferType = (*types)[buffer[&quot;type&quot;].get&lt;string&gt;()];
      json bufferMembers = {};
      parseMembers(bufferType[&quot;members&quot;], bufferMembers, 0, &quot;&quot;);
      json bufferInfo = {{&quot;name&quot;, buffer[&quot;name&quot;].get&lt;string&gt;()},
                         {&quot;set&quot;, buffer[&quot;set&quot;].get&lt;int&gt;()},
                         {&quot;binding&quot;, buffer[&quot;binding&quot;].get&lt;int&gt;()},
                         {&quot;members&quot;, bufferMembers}};
      bufferInfos.push_back(bufferInfo);
    }
  };
  if (ubos)
    parseBuffers(*ubos, uniformBufferInfos);
  if (ssbos)
    parseBuffers(*ssbos, shaderStorageBufferInfos);

  json textureDescriptors = {};
  json bufferDescriptors = {};
  if (textures)
    for (const json &amp;texture : *textures) {
      textureDescriptors[to_string(texture[&quot;set&quot;].get&lt;int&gt;())] = {
          {&quot;type&quot;, texture[&quot;type&quot;]},
          {&quot;name&quot;, texture[&quot;name&quot;]},
          {&quot;set&quot;, texture[&quot;set&quot;]},
          {&quot;binding&quot;, texture[&quot;binding&quot;]}};
    }
  if (images)
    for (const json &amp;image : *images) {
      textureDescriptors[to_string(image[&quot;set&quot;].get&lt;int&gt;())] = {
          {&quot;type&quot;, image[&quot;type&quot;]},
          {&quot;name&quot;, image[&quot;name&quot;]},
          {&quot;set&quot;, image[&quot;set&quot;]},
          {&quot;binding&quot;, image[&quot;binding&quot;]}};
    }
  if (ubos)
    for (const json &amp;ubo : *ubos) {
      bufferDescriptors[to_string(ubo[&quot;set&quot;].get&lt;int&gt;())] = {
          {&quot;type&quot;, &quot;uniformBuffer&quot;},
          {&quot;name&quot;, ubo[&quot;name&quot;]},
          {&quot;set&quot;, ubo[&quot;set&quot;]},
          {&quot;binding&quot;, ubo[&quot;binding&quot;]}};
    }
  if (ssbos)
    for (const json &amp;ssbo : *ssbos) {
      bufferDescriptors[to_string(ssbo[&quot;set&quot;].get&lt;int&gt;())] = {
          {&quot;type&quot;, &quot;shaderStorageBuffer&quot;},
          {&quot;name&quot;, ssbo[&quot;name&quot;]},
          {&quot;set&quot;, ssbo[&quot;set&quot;]},
          {&quot;binding&quot;, ssbo[&quot;binding&quot;]}};
    }
  contents += &quot;DESCRIPTORS &quot; +
              to_string(textureDescriptors.size() + bufferDescriptors.size()) +
              &quot;\n&quot;;
  map&lt;string, string&gt; descriptorTypeMap = {
      {&quot;sampler2D&quot;, &quot;DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER&quot;},
      {&quot;sampler3D&quot;, &quot;DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER&quot;},
      {&quot;samplerCube&quot;, &quot;DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER&quot;},
      {&quot;image2D&quot;, &quot;DESCRIPTOR_TYPE_STORAGE_IMAGE&quot;},
      {&quot;uniformBuffer&quot;, &quot;DESCRIPTOR_TYPE_UNIFORM_BUFFER&quot;},
      {&quot;shaderStorageBuffer&quot;, &quot;DESCRIPTOR_TYPE_STORAGE_BUFFER&quot;}};
  for (auto &amp;[key, val] : textureDescriptors.items()) {
    string descriptorType = descriptorTypeMap[val[&quot;type&quot;]];
    contents += &quot;\t&quot; + val[&quot;name&quot;].get&lt;string&gt;() + &quot; &quot; + descriptorType + &quot; &quot; +
                to_string(val[&quot;set&quot;].get&lt;int&gt;()) + &quot;\n&quot;;
  }
  for (auto &amp;[key, val] : bufferDescriptors.items()) {
    string descriptorType = descriptorTypeMap[val[&quot;type&quot;]];
    contents += &quot;\t&quot; + val[&quot;name&quot;].get&lt;string&gt;() + &quot; &quot; + descriptorType + &quot; &quot; +
                to_string(val[&quot;set&quot;].get&lt;int&gt;()) + &quot;\n&quot;;
  }
  auto processBufferInfos = [&amp;](const json &amp;bufferInfo) -&gt; string {
    string contents = &quot;&quot;;
    const json &amp;memberInfos = bufferInfo[&quot;members&quot;];
    contents += bufferInfo[&quot;name&quot;].get&lt;string&gt;() + &quot; &quot; +
                to_string(bufferInfo[&quot;set&quot;].get&lt;int&gt;()) + &quot; &quot; +
                to_string(memberInfos.size()) + &quot;\n&quot;;
    for (const json &amp;m : memberInfos) {
      contents += m[&quot;name&quot;].get&lt;string&gt;() + &quot; &quot; +
                  to_string(m[&quot;offset&quot;].get&lt;int&gt;()) + &quot; &quot; +
                  to_string(m[&quot;size&quot;].get&lt;int&gt;()) + &quot; &quot; +
                  to_string(m[&quot;array_count&quot;].get&lt;int&gt;()) + &quot; &quot; +
                  to_string(m[&quot;array_stride&quot;].get&lt;int&gt;()) + &quot;\n&quot;;
    }
    return contents;
  };
  contents +=
      &quot;UNIFORM_BUFFER_INFOS &quot; + to_string(uniformBufferInfos.size()) + &quot;\n&quot;;
  for (const json &amp;bufferInfo : uniformBufferInfos) {
    contents += processBufferInfos(bufferInfo);
  }

  contents += &quot;SHADER_STORAGE_BUFFER_INFOS &quot; +
              to_string(shaderStorageBufferInfos.size()) + &quot;\n&quot;;
  for (const json &amp;bufferInfo : shaderStorageBufferInfos) {
    contents += processBufferInfos(bufferInfo);
  }
  return contents;
}

int ShaderTools::generateShaderMapGLSL(const string &amp;file, string outDir,
                                       vector&lt;string&gt; &amp;outFiles) {
  string filename = fs::path(file).filename().string();
  string ext = FileUtil::splitExt(filename)[1];

  string glslFileName =
      fs::path(outDir + &quot;/&quot; + filename).make_preferred().string();
  string spvFileName =
      fs::path(outDir + &quot;/&quot; + filename + &quot;.spv&quot;).make_preferred().string();
  string glslMapFileName =
      fs::path(outDir + &quot;/&quot; + filename + &quot;.map&quot;).make_preferred().string();
  if (!FileUtil::srcFileNewerThanOutFile(glslFileName, glslMapFileName)) {
    outFiles.push_back(glslMapFileName);
    return 0;
  }

  string glsl = &quot;&quot;, spv = readFile(spvFileName), glslReflect;
  genShaderReflectionGLSL(glsl, ext, spv, glslReflect);
  auto glslReflectJson = json::parse(glslReflect);
  string glslMap = parseReflectionData(glslReflectJson, ext);

  writeFile(glslMapFileName, glslMap);
  outFiles.push_back(glslMapFileName);
  return 0;
}

int ShaderTools::generateShaderMapMSL(const string &amp;file, string outDir,
                                      vector&lt;string&gt; &amp;outFiles) {
  auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string());
  string glslFilename = splitFilename[0];
  string ext = FileUtil::splitExt(splitFilename[0])[1];

  string mslFileName = fs::path(outDir + &quot;/&quot; + glslFilename + &quot;.metal&quot;)
                           .make_preferred()
                           .string();
  string spvFileName =
      fs::path(outDir + &quot;/&quot; + glslFilename + &quot;.spv&quot;).make_preferred().string();
  string mslMapFileName = fs::path(outDir + &quot;/&quot; + glslFilename + &quot;.metal.map&quot;)
                              .make_preferred()
                              .string();
  if (!FileUtil::srcFileNewerThanOutFile(mslFileName, mslMapFileName)) {
    outFiles.push_back(mslMapFileName);
    return 0;
  }

  string msl = readFile(mslFileName), spv = readFile(spvFileName), mslReflect;
  genShaderReflectionMSL(msl, ext, spv, mslReflect);
  auto mslReflectJson = json::parse(mslReflect);
  string mslMap = parseReflectionData(mslReflectJson, ext);

  writeFile(mslMapFileName, mslMap);
  outFiles.push_back(mslMapFileName);
  return 0;
}

int ShaderTools::generateShaderMapHLSL(const string &amp;file, string outDir,
                                       vector&lt;string&gt; &amp;outFiles) {
  auto splitFilename = FileUtil::splitExt(fs::path(file).filename().string());
  string glslFilename = splitFilename[0];
  string ext = FileUtil::splitExt(splitFilename[0])[1];

  string hlslFileName =
      fs::path(outDir + &quot;/&quot; + glslFilename + &quot;.hlsl&quot;).make_preferred().string();
  string spvFileName =
      fs::path(outDir + &quot;/&quot; + glslFilename + &quot;.spv&quot;).make_preferred().string();
  string hlslMapFileName = fs::path(outDir + &quot;/&quot; + glslFilename + &quot;.hlsl.map&quot;)
                               .make_preferred()
                               .string();
  if (!FileUtil::srcFileNewerThanOutFile(hlslFileName, hlslMapFileName)) {
    outFiles.push_back(hlslMapFileName);
    return 0;
  }

  string hlsl = readFile(hlslFileName), spv = readFile(spvFileName),
         hlslReflect;
  genShaderReflectionHLSL(hlsl, ext, spv, hlslReflect);
  auto hlslReflectJson = json::parse(hlslReflect);
  string hlslMap = parseReflectionData(hlslReflectJson, ext);

  writeFile(hlslMapFileName, hlslMap);
  outFiles.push_back(hlslMapFileName);
  return 0;
}

vector&lt;string&gt; ShaderTools::convertShaders(const vector&lt;string&gt; &amp;files,
                                           string outDir, Format fmt) {
  vector&lt;string&gt; outFiles;
  for (const string &amp;file : files)
    convertShader(file, &quot;&quot;, outDir, fmt, outFiles);
  return outFiles;
}

vector&lt;string&gt; ShaderTools::compileShaders(const vector&lt;string&gt; &amp;files,
                                           string outDir, Format fmt,
                                           const MacroDefinitions &amp;defines,
                                           int flags) {
#ifdef GRAPHICS_BACKEND_VULKAN
  defines += &quot; -DGRAPHICS_BACKEND_VULKAN=1&quot;;
#endif
  vector&lt;string&gt; outFiles;
  for (const string &amp;file : files) {
    if (fmt == FORMAT_GLSL)
      compileShaderGLSL(file, defines, outDir, outFiles, flags);
    else if (fmt == FORMAT_MSL)
      compileShaderMSL(file, defines, outDir, outFiles);
    else if (fmt == FORMAT_HLSL)
      compileShaderHLSL(file, defines, outDir, outFiles);
  }
  return outFiles;
}

void ShaderTools::applyPatches(const vector&lt;string&gt; &amp;patchFiles,
                               string outDir) {
  for (const string &amp;patchFile : patchFiles) {
    string filename = FileUtil::splitExt(fs::path(patchFile).string())[0];
    NGFX_LOG(&quot;filename: %s&quot;, filename.c_str());
    string outFile =
        fs::path(outDir + &quot;/&quot; + filename).make_preferred().string();
    if (fs::exists(outFile)) {
      NGFX_LOG(&quot;applying patch: {patchFile}&quot;);
      string cmdStr = PATCH + &quot; -N -u &quot; + outFile + &quot; -i &quot; + patchFile;
      cmd(cmdStr);
    }
  }
}

vector&lt;string&gt; ShaderTools::generateShaderMaps(const vector&lt;string&gt; &amp;files,
                                               string outDir, Format fmt) {
  vector&lt;string&gt; outFiles;
  for (const string &amp;file : files) {
    if (fmt == FORMAT_GLSL)
      generateShaderMapGLSL(file, outDir, outFiles);
    else if (fmt == FORMAT_MSL)
      generateShaderMapMSL(file, outDir, outFiles);
    else if (fmt == FORMAT_HLSL)
      generateShaderMapHLSL(file, outDir, outFiles);
  }
  return outFiles;
}
</code></pre>
<hr />
<p>Updated on 14 March 2021 at 09:47:42 Pacific Daylight Time</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../../../assets/javascripts/workers/search.fb4a9340.min.js", "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.a1c7c35e.min.js"></script>
      
    
  </body>
</html>